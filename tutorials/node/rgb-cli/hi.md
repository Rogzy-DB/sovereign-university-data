---
name: आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
description: RGB पर Exchange स्मार्ट कॉन्ट्रैक्ट्स बनाने के लिए, आपको कुछ स्टेप्स फॉलो करने होंगे। सबसे पहले, आपको RGB प्लेटफॉर्म पर एक अकाउंट बनाना होगा। इसके बाद, आपको Exchange स्मार्ट कॉन्ट्रैक्ट्स की कोडिंग समझनी होगी। आप इसके लिए ऑनलाइन ट्यूटोरियल्स या गाइड्स का सहारा ले सकते हैं। 

फिर, RGB के डेवलपमेंट टूल्स का उपयोग करके, आप अपने स्मार्ट कॉन्ट्रैक्ट्स को कोड कर सकते हैं। एक बार कोडिंग पूरी हो जाने के बाद, आपको इसे टेस्टनेट पर टेस्ट करना होगा ताकि यह सुनिश्चित हो सके कि सब कुछ सही तरीके से काम कर रहा है। 

टेस्टिंग के बाद, आप अपने स्मार्ट कॉन्ट्रैक्ट्स को RGB के मेननेट पर डिप्लॉय कर सकते हैं। इस प्रक्रिया के दौरान, आपको कुछ गैस फीस का भुगतान करना पड़ सकता है। 

अगर आपको किसी भी स्टेप में दिक्कत आती है, तो आप RGB के सपोर्ट फोरम्स या कम्युनिटी से मदद ले सकते हैं।
---
![cover](assets/cover.webp)

इस ट्यूटोरियल में, हम LNP/BP एसोसिएशन द्वारा बनाए गए कमांड-लाइन टूल `RGB` का उपयोग करके Contract लिखने की चरण-दर-चरण प्रक्रिया का पालन करेंगे। इसका उद्देश्य यह दिखाना है कि CLI को कैसे इंस्टॉल और मैनेज किया जाए, Schema को कैसे संकलित किया जाए, Interface और Interface Implementation को कैसे आयात किया जाए, और फिर RGB एसेट कैसे जारी किया जाए। हम इसके अंतर्निहित तर्क को भी देखेंगे, जिसमें संकलन और स्थिति सत्यापन शामिल हैं। इस ट्यूटोरियल के अंत में, आपको इस प्रक्रिया को दोहराने और अपने खुद के RGB कॉन्ट्रैक्ट्स बनाने में सक्षम होना चाहिए।

## RGB प्रोटोकॉल की याद दिलाना

RGB एक प्रोटोकॉल है जो Bitcoin के ऊपर चलता है और Smart contract की कार्यक्षमता और डिजिटल संपत्ति प्रबंधन का अनुकरण करता है, बिना उस Blockchain को ओवरलोड किए जिस पर यह आधारित है। पारंपरिक On-Chain स्मार्ट कॉन्ट्रैक्ट्स (जैसे कि एथेरियम पर) के विपरीत, RGB "*Client-side Validation*" प्रणाली पर निर्भर करता है: अधिकांश डेटा और स्थिति इतिहास केवल शामिल प्रतिभागियों द्वारा ही आदान-प्रदान और संग्रहीत किए जाते हैं, जबकि Bitcoin Blockchain केवल छोटे क्रिप्टोग्राफिक कमिटमेंट्स की मेजबानी करता है (जैसे *Tapret* या *Opret* जैसी प्रणालियों के माध्यम से)। RGB प्रोटोकॉल में, Bitcoin Blockchain इसलिए केवल एक समय-स्टैम्पिंग सर्वर और Double-spending सुरक्षा प्रणाली के रूप में कार्य करता है।

RGB Contract एक विकासशील राज्य मशीन की तरह संरचित है। यह एक Genesis के साथ शुरू होता है जो प्रारंभिक स्थिति को परिभाषित करता है (उदाहरण के लिए, Supply, टिकर या अन्य मेटाडेटा का वर्णन करते हुए) जो एक सख्ती से टाइप और संकलित Schema के अनुसार होता है। इसके बाद, राज्य संक्रमण और यदि आवश्यक हो तो राज्य विस्तार लागू किए जाते हैं ताकि इस स्थिति को संशोधित या विस्तारित किया जा सके। प्रत्येक ऑपरेशन, चाहे वह फंगिबल संपत्तियों (RGB20) का स्थानांतरण हो या अद्वितीय संपत्तियों (RGB21) का निर्माण हो, *सिंगल-यूज़ सील्स* शामिल करता है। ये Bitcoin UTXOs को off-chain राज्यों से जोड़ते हैं और डबल स्पेंडिंग को रोकते हैं, जबकि गोपनीयता और स्केलेबिलिटी सुनिश्चित करते हैं।

RGB प्रोटोकॉल कैसे काम करता है, इसके बारे में अधिक जानने के लिए, मैं आपको यह व्यापक प्रशिक्षण कोर्स करने की सलाह देता हूँ:

https://planb.network/courses/3ce1d37c-05ba-4f54-aa15-7586d37b2bb7
RGB की आंतरिक लॉजिक Rust लाइब्रेरीज़ पर आधारित है, जिन्हें आप डेवलपर्स के रूप में अपने प्रोजेक्ट्स में इम्पोर्ट कर सकते हैं ताकि *Client-side Validation* हिस्से को मैनेज किया जा सके। इसके अलावा, LNP/BP टीम अन्य भाषाओं के लिए बाइंडिंग्स पर काम कर रही है, लेकिन यह अभी तक पूरा नहीं हुआ है। इसके साथ ही, Bitfinex जैसी अन्य संस्थाएं अपनी खुद की इंटीग्रेशन स्टैक्स विकसित कर रही हैं, लेकिन इनके बारे में हम किसी और ट्यूटोरियल में बात करेंगे। फिलहाल, `RGB` CLI आधिकारिक संदर्भ है, भले ही यह अभी पूरी तरह से परिष्कृत नहीं है।

## RGB और CLI उपकरण की स्थापना और प्रस्तुति

मुख्य कमांड को `RGB` कहा जाता है। इसे `git` की तरह बनाया गया है, जिसमें अनुबंधों को प्रबंधित करने, उन्हें लागू करने, संपत्तियों को जारी करने आदि के लिए उप-कमांड्स का सेट होता है। Bitcoin और Wallet फिलहाल एकीकृत नहीं हैं, लेकिन जल्द ही आने वाले संस्करण (0.11) में होंगे। इस अगले संस्करण से उपयोगकर्ता सीधे `RGB` से अपने वॉलेट्स (डिस्क्रिप्टर्स के माध्यम से) बना और प्रबंधित कर सकेंगे, जिसमें PSBT जनरेशन, साइनिंग के लिए बाहरी हार्डवेयर (जैसे Hardware Wallet) के साथ संगतता, और Sparrow जैसे सॉफ़्टवेयर के साथ इंटरऑपरेबिलिटी शामिल होगी। इससे पूरी संपत्ति जारी करने और स्थानांतरण की प्रक्रिया सरल हो जाएगी।

### कार्गो के माध्यम से इंस्टॉलेशन

हम Rust में उपकरण को इस तरह से स्थापित करते हैं:

```bash
cargo install rgb-contracts --all-features
```

(नोट: इस क्रेट का नाम `RGB-contracts` है, और इंस्टॉल किया गया कमांड `RGB` कहलाएगा। अगर पहले से कोई क्रेट `RGB` नाम का मौजूद होता, तो टकराव हो सकता था, इसलिए यह नाम रखा गया है।)

इंस्टॉलेशन में कई सारी निर्भरताएँ शामिल होती हैं, जैसे कि कमांड पार्सिंग, इलेक्ट्रम इंटीग्रेशन, ज़ीरो-नॉलेज प्रूफ्स मैनेजमेंट आदि।

इंस्टॉलेशन पूरा होने के बाद, :

```bash
rgb
```

जब आप `RGB` को बिना किसी तर्क के चलाते हैं, तो यह उपलब्ध सब-कमांड्स की एक सूची दिखाता है, जैसे कि `interfaces`, `Schema`, `import`, `export`, `issue`, `Invoice`, `transfer`, आदि। आप स्थानीय स्टोरेज डायरेक्टरी (एक Stash जो सभी लॉग्स, योजनाएँ और कार्यान्वयन रखता है) को बदल सकते हैं, नेटवर्क चुन सकते हैं (Testnet, Mainnet) या अपने Electrum सर्वर को कॉन्फ़िगर कर सकते हैं।

![RGB-CLI](assets/fr/01.webp)

### नियंत्रणों का पहला अवलोकन

जब आप निम्नलिखित कमांड चलाते हैं, तो आप देखेंगे कि एक `RGB20` Interface पहले से ही डिफ़ॉल्ट रूप से एकीकृत है।

```bash
rgb interfaces
```

अगर यह Interface एकीकृत नहीं है, तो इसे क्लोन करें:

```bash
git clone https://github.com/RGB-WG/rgb-interfaces
```

इसे संकलित करें:

```bash
cargo run
```

फिर अपनी पसंद का Interface आयात करें:

```bash
rgb import interfaces/RGB20.rgb
```

![RGB-CLI](assets/fr/02.webp)

हमें बताया गया है कि अभी तक कोई Schema सॉफ़्टवेयर में इम्पोर्ट नहीं किया गया है। और न ही Stash में कोई Contract है। इसे देखने के लिए, यह कमांड चलाएँ:

```bash
rgb schemata
```

आप फिर उस रिपॉजिटरी को क्लोन कर सकते हैं ताकि कुछ विशेष योजनाएँ प्राप्त कर सकें।

```bash
git clone https://github.com/RGB-WG/rgb-schemata
```

![RGB-CLI](assets/fr/03.webp)

इस संग्रह में `src/` डायरेक्टरी के अंदर कई Rust फाइलें हैं (जैसे `nia.rs`) जो स्कीमाओं को परिभाषित करती हैं (NIA का मतलब "*गैर-फुलाने योग्य संपत्ति*", UDA का मतलब "*अद्वितीय डिजिटल संपत्ति*", आदि)। इन्हें संकलित करने के लिए, आप फिर चला सकते हैं:

```bash
cd rgb-schemata
cargo run
```

यह कई `.RGB` और `.rgba` फाइलें उत्पन्न करता है जो संकलित योजनाओं से संबंधित होती हैं। उदाहरण के लिए, आपको `NonInflatableAsset.RGB` फाइल मिलेगी।

### Schema और Interface Implementation का आयात करना

अब आप स्कीमैटिक को `RGB` में इम्पोर्ट कर सकते हैं।

```bash
rgb import schemata/NonInflatableAssets.rgb
```

![RGB-CLI](assets/fr/04.webp)

यह इसे स्थानीय Stash में जोड़ता है। अगर हम निम्नलिखित कमांड चलाते हैं, तो हम देखेंगे कि अब Schema दिखाई दे रहा है।

```bash
rgb schemata
```

## Contract का निर्माण (जारी करना)

एक नया संपत्ति बनाने के दो तरीके होते हैं:


- हम या तो Rust में एक स्क्रिप्ट या कोड का उपयोग करते हैं जो Schema के फील्ड्स (जैसे Global State, ओन्ड स्टेट्स आदि) को भरकर एक Contract बनाता है और फिर एक `.RGB` या `.rgba` फाइल तैयार करता है।
- या सीधे `issue` सब-कमांड का उपयोग करें, जिसमें एक YAML (या TOML) फ़ाइल हो जो टोकन की विशेषताओं का वर्णन करती हो।

आप `examples` फोल्डर में Rust के उदाहरण पा सकते हैं, जो यह दिखाते हैं कि आप `ContractBuilder` कैसे बनाते हैं, `Global State` (संपत्ति का नाम, टिकर, Supply, तारीख, आदि) कैसे भरते हैं, Owned State को कैसे परिभाषित करते हैं (जिसे UTXO में असाइन किया गया है), और फिर इन सबको एक *Contract Consignment* में कैसे संकलित करते हैं जिसे आप Stash में निर्यात, सत्यापित और आयात कर सकते हैं।

दूसरा तरीका यह है कि आप एक YAML फाइल को मैन्युअली एडिट करके `ticker`, `name`, `Supply`, आदि को कस्टमाइज़ करें। मान लीजिए कि फाइल का नाम `RGB20-demo.yaml` है। आप इसमें निम्नलिखित चीजें निर्दिष्ट कर सकते हैं:


- `spec`: टिकर, नाम, प्रिसिजन ;
- `शर्तें`: कानूनी सूचनाओं के लिए एक क्षेत्र;
- `issuedSupply`: जारी किए गए टोकन की मात्रा;
- `असाइनमेंट्स`: यह Single-Use Seal (*Seal Definition*) और अनलॉक की गई मात्रा को दर्शाता है।

यहाँ एक YAML फ़ाइल का उदाहरण दिया गया है जिसे बनाना है:

```yaml
interface: RGB20Fixed
globals:
spec:
ticker: PBN
name: Plan B Network
details: "Pay attention: the asset has no value"
precision: 2
terms:
text: >
SUBJECT TO, AND WITHOUT IN ANY WAY LIMITING, THE REPRESENTATIONS AND WARRANTIES OF ANY SELLER. PROPERTY IS BEING SOLD “AS IS”...
media: ~
issuedSupply: 100000000
assignments:
assetOwner:
seal: tapret1st:b449f7eaa3f98c145b27ad0eeb7b5679ceb567faef7a52479bc995792b65f804:1
amount: 100000000 # this is 1 million (we have two digits for cents)
```

![RGB-CLI](assets/fr/05.webp)

फिर बस यह कमांड चलाएँ:

```bash
rgb issue '<SchemaID>' ssi:<Issuer> rgb20-demo.yaml
```

![RGB-CLI](assets/fr/06.webp)

मेरे मामले में, अनोखा Schema पहचानकर्ता (जिसे एकल उद्धरणों में बंद किया जाना चाहिए) है `RDYhMTR!9gv8Y2GLv9UNBEK1hcrCmdLDFk9Qd5fnO8k` और मैंने कोई जारीकर्ता नहीं डाला है। इसलिए मेरा आदेश है :

```txt
rgb issue 'RDYhMTR!9gv8Y2GLv9UNBEK1hcrCmdLDFk9Qd5fnO8k' ssi:anonymous rgb20-demo.yaml
```

अगर आपको Schema ID नहीं पता है, तो यह कमांड चलाएं:

```bash
rgb schemata
```

CLI जवाब देता है कि एक नया Contract जारी किया गया है और इसे Stash में जोड़ा गया है। अगर हम निम्नलिखित कमांड टाइप करते हैं, तो हम देखते हैं कि अब एक अतिरिक्त Contract है, जो अभी-अभी जारी किए गए से मेल खाता है।

```bash
rgb contracts
```

![RGB-CLI](assets/fr/07.webp)

फिर, अगला कमांड वैश्विक राज्यों (जैसे नाम, टिकर, Supply...) और स्वामित्व वाले राज्यों की सूची दिखाता है, यानी आवंटन (उदाहरण के लिए, 1 मिलियन `PBN` टोकन जो UTXO `b449f7eaa3f98c145b27ad0eeb7b5679ceb567faef7a52479bc995792b65f804:1` में परिभाषित हैं)।

```bash
rgb state '<ContractId>'
```

![RGB-CLI](assets/fr/08.webp)

## निर्यात, आयात और सत्यापन

इस Contract को अन्य उपयोगकर्ताओं के साथ साझा करने के लिए, इसे Stash से एक : में निर्यात किया जा सकता है।

```bash
rgb export '<ContractId>' myContractPBN.rgb
```

![RGB-CLI](assets/fr/09.webp)

`myContractPBN.RGB` फाइल को किसी दूसरे उपयोगकर्ता को दिया जा सकता है, जो इसे अपने Stash में इस कमांड के साथ जोड़ सकता है:

```bash
rgb import myContractPBN.rgb
```

जब आप आयात करते हैं, अगर यह एक साधारण *Contract Consignment* है, तो हमें "`Importing Consignment RGB`" संदेश मिलेगा। अगर यह एक बड़ा *State Transition Consignment* है, तो कमांड अलग होगा (`RGB accept`)।

वैधता सुनिश्चित करने के लिए, आप स्थानीय सत्यापन फ़ंक्शन का भी उपयोग कर सकते हैं। उदाहरण के लिए, आप चला सकते हैं:

```bash
rgb validate myContract.rgb
```

### Stash का उपयोग, सत्यापन और प्रदर्शन

याद दिलाने के लिए, Stash एक स्थानीय सूची है जिसमें स्कीमास, इंटरफेसेस, इम्प्लीमेंटेशन्स और कॉन्ट्रैक्ट्स (Genesis + ट्रांज़िशन्स) शामिल हैं। हर बार जब आप "इम्पोर्ट" चलाते हैं, तो आप Stash में एक तत्व जोड़ते हैं। इस Stash को विस्तार से देखने के लिए आप इस कमांड का उपयोग कर सकते हैं:

```bash
rgb dump
```

![RGB-CLI](assets/fr/10.webp)

यह generate एक फोल्डर होगा जिसमें पूरे Stash के विवरण होंगे।

## आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

स्थानांतरण करने के लिए, आपको `Tapret` या `Opret` प्रतिबद्धताओं को प्रबंधित करने के लिए एक स्थानीय Bitcoin Wallet को संचालित करना होगा।

### generate और Invoice

अधिकतर मामलों में, Contract में भाग लेने वालों (जैसे कि एलिस और बॉब) के बीच बातचीत Invoice के निर्माण के माध्यम से होती है। अगर एलिस चाहती है कि बॉब कुछ कार्य करे (जैसे कि टोकन ट्रांसफर, पुनः जारी करना, DAO में कोई कार्रवाई, आदि), तो एलिस एक Invoice बनाती है जिसमें बॉब के लिए उसके निर्देश होते हैं। तो हमारे पास यह है:


- एलिस** (Invoice की जारीकर्ता);
- बॉब** (जो Invoice प्राप्त करता है और उसे पूरा करता है)।

अन्य पारिस्थितिकी प्रणालियों के विपरीत, RGB Invoice केवल भुगतान की धारणा तक सीमित नहीं है। यह Contract से जुड़े किसी भी अनुरोध को शामिल कर सकता है: जैसे कि एक कुंजी को रद्द करना, मतदान करना, एक NFT पर उत्कीर्णन (*engraving*) बनाना, आदि। संबंधित प्रक्रिया को Contract Interface में वर्णित किया जा सकता है। संबंधित प्रक्रिया को Contract Interface में वर्णित किया जा सकता है।

निम्नलिखित कमांड RGB Invoice उत्पन्न करता है:

```bash
$ rgb invoice $CONTRACT -i $INTERFACE $ACTION $STATE $SEAL
```

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।


- `$Contract`: Contract पहचानकर्ता (*ContractId*) ;
- `$Interface`: Interface का उपयोग किया जाना है (जैसे `RGB20`);
- `$ACTION`: Interface में निर्दिष्ट ऑपरेशन का नाम (एक साधारण फंजिबल टोकन ट्रांसफर के लिए, यह "ट्रांसफर" हो सकता है)। अगर Interface पहले से ही एक डिफ़ॉल्ट एक्शन प्रदान करता है, तो आपको इसे यहां फिर से दर्ज करने की आवश्यकता नहीं है।
- `$STATE`: वह स्थिति डेटा जिसे स्थानांतरित किया जाना है (उदाहरण के लिए, अगर कोई फंजिबल टोकन स्थानांतरित किया जा रहा है तो टोकन की मात्रा);
- `$Seal`: लाभार्थी (एलिस) का Single-Use Seal, यानी UTXO का एक स्पष्ट संदर्भ। बॉब इस जानकारी का उपयोग Witness Transaction बनाने के लिए करेगा, और फिर संबंधित आउटपुट एलिस का होगा (या तो *blinded UTXO* या बिना एन्क्रिप्ट किए हुए रूप में)।

उदाहरण के लिए, निम्नलिखित आदेशों के साथ

```bash
alice$ CONTRACT='iZgIN9EL-2H21UgQ-x!A3uJc-WwXhCSm-$9Lwcc1-v!mUkKY'
alice$ MY_UTXO=4960acc21c175c551af84114541eace09c14d3a1bb184809f7b80916f57f9ef8:1
alice$ rgb invoice $CONTRACT -i RGB20 --amount 100 $MY_UTXO
```

CLI, generate और Invoice की तरह होगा:

```bash
rgb:iZgIN9EL-2H21UgQ-x!A3uJc-WwXhCSm-$9Lwcc1-v!mUkKY/RGB20/100+utxob:zlVS28Rb-...
```

इसे किसी भी माध्यम से बॉब को भेजा जा सकता है (जैसे टेक्स्ट, क्यूआर कोड आदि)।

### स्थानांतरण करना

इस Invoice से स्थानांतरित करने के लिए:


- बॉब (जिसके पास उसके Stash में टोकन हैं) के पास एक Bitcoin और Wallet है। उसे एक Bitcoin लेन-देन तैयार करना है (PSBT के रूप में, जैसे `tx.PSBT`) जो उन UTXOs को खर्च करता है जहाँ आवश्यक RGB टोकन स्थित हैं, साथ ही एक UTXO मुद्रा (Exchange) के लिए;
- बॉब निम्नलिखित कमांड चलाता है:

```bash
bob$ rgb transfer tx.psbt $INVOICE consignment.rgb
```


- यह एक `Consignment.RGB` फाइल बनाता है जिसमें शामिल होता है:
 - टोकन असली हैं, यह साबित करने के लिए एलिस को संक्रमण इतिहास दिखाना।
 - नया परिवर्तन जो टोकन को एलिस के Single-Use Seal में स्थानांतरित करता है;
 - Witness Transaction (हस्ताक्षरित नहीं)।
- बॉब इस `Consignment.RGB` फाइल को ऐलिस को भेजता है (ई-मेल, किसी शेयरिंग सर्वर या RGB-RPC प्रोटोकॉल, स्टॉर्म आदि के माध्यम से);
- एलिस को `Consignment.RGB` प्राप्त होता है और वह इसे अपने Stash में स्वीकार कर लेती है।

```bash
alice$ rgb accept consignment.rgb
```


- CLI यह सुनिश्चित करता है कि ट्रांज़िशन सही है और इसे एलिस के Stash में जोड़ देता है। अगर यह गलत होता है, तो कमांड विफल हो जाता है और विस्तृत त्रुटि संदेश दिखाता है। अगर सही होता है, तो यह सफल होता है और बताता है कि नमूना लेन-देन अभी तक Bitcoin नेटवर्क पर प्रसारित नहीं हुआ है (बॉब एलिस के Green लाइट का इंतजार कर रहा है)।
- पुष्टि के रूप में, `accept` कमांड एक हस्ताक्षर (*पेस्लिप*) लौटाता है जिसे एलिस बॉब को भेज सकती है ताकि वह उसे दिखा सके कि उसने *Consignment* को मान्य कर दिया है।
- बॉब अब अपने Bitcoin लेन-देन पर हस्ताक्षर कर सकता है और उसे प्रकाशित (`--publish`) कर सकता है।

```bash
bob$ rgb check <sig> && wallet sign --publish tx.psbt
```


- जैसे ही यह लेन-देन On-Chain की पुष्टि हो जाती है, संपत्ति का Ownership एलिस को स्थानांतरित माना जाता है। एलिस का Wallet, जो लेन-देन के Mining की निगरानी कर रहा है, अपने Stash में नया Owned State देखता है।

अब आप RGB और Contract को जारी और ट्रांसफर करना सीख चुके हैं। अगर आपको यह ट्यूटोरियल उपयोगी लगा, तो मैं आभारी रहूँगा अगर आप नीचे एक Green अंगूठा दें। कृपया इस लेख को अपने सोशल नेटवर्क्स पर साझा करने के लिए स्वतंत्र महसूस करें। बहुत-बहुत धन्यवाद!

मैं आपको एक और ट्यूटोरियल की सिफारिश करता हूँ जिसमें मैं समझाता हूँ कि कैसे RGB संगत लाइटनिंग नोड को Exchange टोकन के लिए लगभग तुरंत लॉन्च किया जा सकता है।

https://planb.network/tutorials/node/others/rln-ffc02528-329b-4e16-bd83-873d0299feea