---
name: औपचारिक क्रिप्टोग्राफी का परिचय
goal: क्रिप्टोग्राफी के विज्ञान और अभ्यास की गहराई से परिचय।
objectives: 

  - बील सिफर और आधुनिक क्रिप्टोग्राफिक विधियों का अन्वेषण करें ताकि आप क्रिप्टोग्राफी की बुनियादी और ऐतिहासिक अवधारणाओं को समझ सकें।
  - संख्या सिद्धांत, समूह और क्षेत्र का गहराई से अध्ययन करें ताकि आप क्रिप्टोग्राफी के मूलभूत गणितीय सिद्धांतों में महारत हासिल कर सकें।
  - RC4 स्ट्रीम सिफर और AES (एडवांस्ड एन्क्रिप्शन स्टैंडर्ड) को 128-बिट कुंजी के साथ अध्ययन करें ताकि आप सममित क्रिप्टोग्राफिक एल्गोरिदम के बारे में जान सकें।
  - RSA क्रिप्टोसिस्टम, कुंजी वितरण और Hash फंक्शन्स की जांच करें ताकि आप असममित क्रिप्टोग्राफी को समझ सकें।

---
# क्रिप्टोग्राफी में गहराई से जानें

क्रिप्टोग्राफी शिक्षा में एक अच्छा संतुलन प्रदान करने वाली सामग्री ढूंढना मुश्किल होता है।

एक तरफ, लंबे और औपचारिक लेख होते हैं, जो वास्तव में केवल उन्हीं लोगों के लिए सुलभ होते हैं जिनकी गणित, तर्कशास्त्र या किसी अन्य औपचारिक विषय में मजबूत पृष्ठभूमि होती है। दूसरी तरफ, बहुत ऊपरी स्तर की परिचयात्मक सामग्री होती है, जो वास्तव में बहुत सारे विवरण छुपा लेती है, जिससे कोई भी जिज्ञासु व्यक्ति संतुष्ट नहीं हो पाता।

यह क्रिप्टोग्राफी का परिचय मध्य मार्ग को पकड़ने की कोशिश करता है। यह उन लोगों के लिए थोड़ा चुनौतीपूर्ण और विस्तृत होना चाहिए जो क्रिप्टोग्राफी में नए हैं, लेकिन यह किसी सामान्य बुनियादी ग्रंथ की तरह गहराई में नहीं जाता।

+++
# परिचय

<partId>bbed2f46-d64c-5fb5-b892-d726032f2494</partId>

## आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

<chapterId>bb8a8b73-7fb2-50da-bf4e-98996d79887b</chapterId>

यह किताब क्रिप्टोग्राफी के विज्ञान और अभ्यास की गहराई से जानकारी देती है। जहां संभव हो, यह औपचारिक व्याख्या के बजाय सामग्री की अवधारणा पर ध्यान केंद्रित करती है।

> यह कोर्स [JWBurgers के रिपॉजिटरी](https://github.com/JWBurgers/An_Introduction_to_Cryptography) पर आधारित है। सभी अधिकार उनके पास हैं। सामग्री अभी पूरी नहीं हुई है और यहाँ केवल यह दिखाने के लिए है कि अगर JWburger सहमत होते हैं तो हम इसे कैसे शामिल कर सकते हैं।
### प्रेरणा और उद्देश्य

क्रिप्टोग्राफी की शिक्षा में एक अच्छा संतुलन प्रदान करने वाली सामग्री ढूंढना मुश्किल होता है।

एक तरफ, लंबे और औपचारिक लेख होते हैं, जो वास्तव में केवल उन्हीं लोगों के लिए समझने योग्य होते हैं जिनकी गणित, तर्कशास्त्र या किसी अन्य औपचारिक विषय में मजबूत पृष्ठभूमि होती है। दूसरी तरफ, बहुत ऊपरी स्तर की परिचयात्मक सामग्री होती है, जो इतनी अधिक जानकारी छुपा लेती है कि कोई भी थोड़ा जिज्ञासु व्यक्ति भी उसे पूरी तरह से नहीं समझ पाता।

यह क्रिप्टोग्राफी का परिचय मध्य मार्ग को पकड़ने की कोशिश करता है। यह उन लोगों के लिए थोड़ा चुनौतीपूर्ण और विस्तृत होना चाहिए जो क्रिप्टोग्राफी में नए हैं, लेकिन यह किसी सामान्य बुनियादी ग्रंथ की तरह गहराई में नहीं जाता।

### लक्षित दर्शक

चाहे आप डेवलपर हों या ज्ञान के प्रति जिज्ञासु, यह किताब उन सभी के लिए उपयोगी है जो क्रिप्टोग्राफी को सतही तौर पर नहीं बल्कि गहराई से समझना चाहते हैं। अगर आपका लक्ष्य क्रिप्टोग्राफी के क्षेत्र में महारत हासिल करना है, तो यह किताब एक अच्छा शुरुआती बिंदु भी है।

### पढ़ने के दिशा-निर्देश

इस किताब में फिलहाल सात अध्याय शामिल हैं: "क्रिप्टोग्राफी क्या है?" (अध्याय 1), "क्रिप्टोग्राफी के गणितीय आधार I" (अध्याय 2), "क्रिप्टोग्राफी के गणितीय आधार II" (अध्याय 3), "सिमेट्रिक क्रिप्टोग्राफी" (अध्याय 4), "RC4 और AES" (अध्याय 5), "असिमेट्रिक क्रिप्टोग्राफी" (अध्याय 6), और "RSA क्रिप्टोसिस्टम" (अध्याय 7)। एक अंतिम अध्याय, "व्यवहार में क्रिप्टोग्राफी," अभी जोड़ा जाएगा। यह विभिन्न क्रिप्टोग्राफिक अनुप्रयोगों पर केंद्रित होगा, जिसमें ट्रांसपोर्ट Layer सुरक्षा, ओनियन रूटिंग, और Bitcoin के मूल्य Exchange प्रणाली शामिल हैं।

यदि आपके पास गणित में मजबूत पृष्ठभूमि नहीं है, तो संख्या सिद्धांत शायद इस किताब का सबसे कठिन विषय है। मैं इसका एक संक्षिप्त परिचय अध्याय 3 में देता हूँ, और यह AES के विवरण में अध्याय 5 में और RSA क्रिप्टोसिस्टम में अध्याय 7 में भी आता है।

अगर आप इस किताब के इन हिस्सों के औपचारिक विवरणों को लेकर सच में जूझ रहे हैं, तो मैं सलाह दूंगा कि पहली बार में इन्हें ऊपरी तौर पर पढ़ लें।

### आभार प्रकट करना

इस किताब को आकार देने में सबसे प्रभावशाली किताब रही है जोनाथन कैट्ज़ और यहूदा लिंडेल की _Introduction to Modern Cryptography_, जिसे CRC प्रेस (बोका रैटन, FL) ने 2015 में प्रकाशित किया था। इसके साथ एक कोर्स भी उपलब्ध है जिसका नाम "क्रिप्टोग्राफी" है और यह कोर्सेरा पर उपलब्ध है।

इस पुस्तक के अवलोकन को तैयार करने में जिन मुख्य अतिरिक्त स्रोतों ने मदद की है, वे हैं: साइमन सिंह की _द कोड बुक_, फोर्थ एस्टेट (लंदन, 1999); क्रिस्टोफ पायर और जान पेल्ज़ की _अंडरस्टैंडिंग क्रिप्टोग्राफी_, स्प्रिंगर (हाइडलबर्ग, 2010) और पायर की पुस्तक पर आधारित [“इंट्रोडक्शन टू क्रिप्टोग्राफी” नामक कोर्स](https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg); और ब्रूस श्नाइयर की _एप्लाइड क्रिप्टोग्राफी_, दूसरा संस्करण, 2015 (इंडियानापोलिस, IN: जॉन वाइली एंड संस)।

मैं इन स्रोतों से ली गई बहुत ही विशिष्ट जानकारी और परिणामों का ही उल्लेख करूंगा, लेकिन मैं यहां पर अपनी सामान्य कृतज्ञता व्यक्त करना चाहता हूं।

यदि इस परिचय के बाद कुछ पाठक क्रिप्टोग्राफी पर और गहरी जानकारी प्राप्त करना चाहते हैं, तो मैं Katz और Lindell की किताब की सिफारिश करता हूँ। Katz का कोर्स Coursera पर किताब की तुलना में थोड़ा अधिक सुलभ है।

### योगदान

कृपया [रिपॉजिटरी में योगदान फ़ाइल](https://github.com/JWBurgers/An_Introduction_to_Cryptography/blob/master/Contributions.md) पर एक नज़र डालें, जहाँ आपको प्रोजेक्ट का समर्थन करने के लिए कुछ दिशानिर्देश मिलेंगे।

### संकेत प्रणाली

**मुख्य शब्द:**

प्राइमर में मुख्य शब्दों को बोल्ड करके प्रस्तुत किया जाता है। उदाहरण के लिए, यदि हम Rijndael सिफर को एक मुख्य शब्द के रूप में प्रस्तुत करें, तो यह इस प्रकार दिखेगा: **Rijndael सिफर**।

मुख्य शब्दों को स्पष्ट रूप से परिभाषित किया गया है, जब तक कि वे सही नाम न हों या उनका अर्थ चर्चा से स्पष्ट न हो।

किसी भी महत्वपूर्ण शब्द की परिभाषा आमतौर पर उसके परिचय के समय दी जाती है, हालांकि कभी-कभी इसे बाद में समझाना अधिक सुविधाजनक होता है।

**जोर दिए गए शब्द और वाक्यांश:**

शब्दों और वाक्यांशों को इटैलिक्स के माध्यम से जोर दिया जाता है। उदाहरण के लिए, वाक्यांश "अपना पासवर्ड याद रखें" इस तरह दिखेगा: *अपना पासवर्ड याद रखें*।

**औपचारिक संकेत:**

औपचारिक संकेत मुख्य रूप से चर, यादृच्छिक चर, और सेट से संबंधित होता है।


- वेरिएबल्स: ये आमतौर पर छोटे अक्षरों से दर्शाए जाते हैं (जैसे, "x" या "y")। कभी-कभी स्पष्टता के लिए इन्हें बड़े अक्षरों में भी लिखा जाता है (जैसे, "M" या "K")।
- रैंडम वेरिएबल्स: इन्हें हमेशा बड़े अक्षर (जैसे, "X" या "Y") से दर्शाया जाता है।
- सेट: इन्हें हमेशा मोटे, बड़े अक्षरों (जैसे, **S**) से दर्शाया जाता है।

# क्रिप्टोग्राफी क्या है?

क्रिप्टोग्राफी एक तकनीक है जिसका उपयोग जानकारी को सुरक्षित और गोपनीय रखने के लिए किया जाता है। इसमें डेटा को इस तरह से बदलना शामिल होता है कि केवल वही लोग इसे समझ सकें जिनके पास इसे समझने की अनुमति है। इसे आमतौर पर संदेशों को एन्क्रिप्ट और डिक्रिप्ट करने के लिए उपयोग किया जाता है ताकि अनधिकृत लोग इसे न पढ़ सकें। यह तकनीक ऑनलाइन लेन-देन, ईमेल, और अन्य डिजिटल संचार को सुरक्षित रखने में मदद करती है।

<partId>48e4d6d5-cd00-5c00-8adb-ae8477ff47c4</partId>

## बील सिफर

<chapterId>ae674346-4789-5ab1-9b6f-c8989d83be89</chapterId>

आइए, हम क्रिप्टोग्राफी के क्षेत्र में अपनी खोज की शुरुआत इसके इतिहास की एक सबसे आकर्षक और मनोरंजक घटना से करते हैं: बील सिफर की कहानी।

मेरे विचार में, बील सिफर्स की कहानी हकीकत से ज्यादा कल्पना लगती है। लेकिन कहा जाता है कि यह कुछ इस तरह से हुई थी।

सर्दियों के मौसम में, 1820 और 1822 दोनों में, थॉमस जे. बील नाम का एक व्यक्ति वर्जीनिया के लिंचबर्ग में रॉबर्ट मॉरिस के स्वामित्व वाले एक सराय में ठहरा। बील की दूसरी यात्रा के अंत में, उसने मॉरिस को एक लोहे का डिब्बा सौंपा जिसमें कुछ महत्वपूर्ण कागजात थे, और उनसे इसे सुरक्षित रखने के लिए कहा।

कुछ महीनों बाद, मॉरिस को बील का एक पत्र मिला जो 9 मई, 1822 को लिखा गया था। इसमें लोहे के बॉक्स की सामग्री की बड़ी कीमत पर जोर दिया गया और मॉरिस को कुछ निर्देश दिए गए: अगर बील या उसके साथी कभी बॉक्स लेने नहीं आए, तो उसे पत्र की तारीख से ठीक दस साल बाद (यानी 9 मई, 1832) बॉक्स खोलना चाहिए। अंदर के कुछ कागज सामान्य पाठ में लिखे होंगे। हालांकि, कई अन्य "एक कुंजी की सहायता के बिना समझ में नहीं आएंगे।" यह "कुंजी" फिर जून 1832 में बील के एक अनाम मित्र द्वारा मॉरिस को दी जाएगी।

स्पष्ट निर्देशों के बावजूद, मॉरिस ने मई 1832 में बॉक्स नहीं खोला और बील का रहस्यमय दोस्त उस साल जून में कभी नहीं आया। आखिरकार 1845 में, सराय के मालिक ने बॉक्स खोलने का फैसला किया। उसमें मॉरिस को एक नोट मिला जिसमें बताया गया था कि बील और उसके साथी पश्चिम में सोना और चांदी खोजकर उसे कुछ गहनों के साथ सुरक्षित रखने के लिए दफना चुके थे। इसके अलावा, बॉक्स में तीन **साइफरटेक्स्ट** थे: यानी, ऐसे पाठ जो कोड में लिखे गए थे और जिन्हें खोलने के लिए एक **क्रिप्टोग्राफिक कुंजी**, या एक रहस्य, और एक संबंधित एल्गोरिदम की आवश्यकता होती है। इस प्रक्रिया को **डिक्रिप्शन** कहा जाता है, जबकि लॉक करने की प्रक्रिया को **एन्क्रिप्शन** कहा जाता है। (जैसा कि अध्याय 3 में समझाया गया है, साइफर शब्द के कई अर्थ हो सकते हैं। "बील साइफर्स" नाम में, यह साइफरटेक्स्ट्स के लिए संक्षिप्त है।)

मॉरिस को लोहे के बक्से में जो तीन गुप्त संदेश मिले, वे सभी संख्याओं की श्रृंखला के रूप में हैं, जो कॉमा से अलग की गई हैं। बील के नोट के अनुसार, ये गुप्त संदेश अलग-अलग रूप से खजाने की जगह, खजाने की सामग्री, और उन नामों की सूची प्रदान करते हैं जिनके पास खजाने का हक है और उनके हिस्से (यह जानकारी तब काम आएगी जब बील और उनके साथी कभी बक्से को लेने नहीं आए)।

मॉरिस ने बीस साल तक तीन गुप्त संदेशों को डिक्रिप्ट करने की कोशिश की। अगर उसके पास कुंजी होती, तो यह काम आसान होता। लेकिन मॉरिस के पास कुंजी नहीं थी और वह मूल पाठ, जिसे क्रिप्टोग्राफी में आमतौर पर **प्लेनटेक्स्ट** कहा जाता है, को पुनः प्राप्त करने में असफल रहा।

अपनी जिंदगी के आखिरी दिनों में, मोरिस ने 1862 में एक दोस्त को वह बॉक्स सौंप दिया। इस दोस्त ने बाद में 1885 में जे.बी. वार्ड के छद्म नाम से एक पैम्फलेट प्रकाशित किया। इसमें बॉक्स के (कथित) इतिहास का वर्णन, तीन गुप्त संदेश और दूसरे गुप्त संदेश के लिए एक समाधान शामिल था जो उसने खोजा था। (ऐसा लगता है कि प्रत्येक गुप्त संदेश के लिए एक अलग कुंजी है, और एक ही कुंजी सभी तीन गुप्त संदेशों पर काम नहीं करती जैसा कि बील ने मूल रूप से मोरिस को अपने पत्र में सुझाव दिया था।)

आप नीचे *चित्र 2* में दूसरा गुप्त संदेश देख सकते हैं। [2] इस गुप्त संदेश की कुंजी संयुक्त राज्य अमेरिका की स्वतंत्रता की घोषणा है। इसे डिक्रिप्ट करने की प्रक्रिया दो नियमों को लागू करने पर आधारित है:


- संदेश में दिए गए किसी भी संख्या n के लिए, संयुक्त राज्य अमेरिका के स्वतंत्रता घोषणा पत्र में nवें शब्द को खोजें।
- आपको जो शब्द मिला है, उसकी पहली अक्षर को संख्या n से बदलें।

*चित्र 1: बील सिफर नंबर 2*

![Figure 1: Beale cipher no 2.](assets/Figure1-1.webp "Figure 1: Beale cipher no. 2")

उदाहरण के लिए, दूसरे सिफरटेक्स्ट की पहली संख्या 115 है। स्वतंत्रता की घोषणा का 115वां शब्द "instituted" है, इसलिए प्लेनटेक्स्ट का पहला अक्षर "i" है। सिफरटेक्स्ट सीधे शब्दों के बीच की दूरी और बड़े अक्षरों का संकेत नहीं देता। लेकिन जब आप पहले कुछ शब्दों को डिक्रिप्ट कर लेते हैं, तो आप तार्किक रूप से यह निष्कर्ष निकाल सकते हैं कि प्लेनटेक्स्ट का पहला शब्द बस "I" था। (प्लेनटेक्स्ट "I have deposited in the county of Bedford." वाक्यांश से शुरू होता है।)

डिक्रिप्शन के बाद, दूसरा संदेश खजाने की विस्तृत सामग्री (सोना, चांदी, और जवाहरात) बताता है, और सुझाव देता है कि इसे लोहे के बर्तनों में दफनाया गया था और चट्टानों से ढका गया था, बेडफोर्ड काउंटी (वर्जीनिया) में। लोगों को एक अच्छी रहस्य कहानी पसंद होती है, इसलिए अन्य दो बील सिफर्स को डिक्रिप्ट करने के लिए बहुत प्रयास किए गए हैं, खासकर उस सिफर को जो खजाने के स्थान का वर्णन करता है। यहां तक कि कई प्रमुख क्रिप्टोग्राफर्स ने भी इन्हें हल करने की कोशिश की है। हालांकि, अब तक कोई भी अन्य दो सिफरटेक्स्ट्स को डिक्रिप्ट नहीं कर पाया है।

**नोट्स:**

[1] कहानी का अच्छा सारांश देखने के लिए, साइमन सिंह की किताब *द कोड बुक*, फोर्थ एस्टेट (लंदन, 1999), पृष्ठ 82-99 देखें। इस कहानी पर एक छोटी फिल्म एंड्रयू एलेन ने 2010 में बनाई थी। आप यह फिल्म, "द थॉमस बील सिफर," [इसकी वेबसाइट पर](http://www.thomasbealecipher.com/) देख सकते हैं।

[2] यह छवि बील सिफर्स के विकिपीडिया पृष्ठ पर उपलब्ध है।

## आधुनिक क्रिप्टोग्राफी

<chapterId>d07d576f-8a4b-5890-b182-2e5763f550f4</chapterId>

रंगीन कहानियाँ, जैसे कि बील सिफर्स की कहानी, वही हैं जिन्हें हम में से अधिकांश लोग क्रिप्टोग्राफी के साथ जोड़ते हैं। फिर भी, आधुनिक क्रिप्टोग्राफी इन ऐतिहासिक उदाहरणों से कम से कम चार महत्वपूर्ण तरीकों से भिन्न होती है।

पहले, ऐतिहासिक रूप से क्रिप्टोग्राफी केवल **गोपनीयता** (या निजता) से संबंधित रही है। [3] सिफरटेक्स्ट्स बनाए जाते थे ताकि केवल कुछ विशेष पक्ष ही प्लेनटेक्स्ट्स में मौजूद जानकारी को जान सकें, जैसे कि बील सिफर के मामले में। किसी एन्क्रिप्शन योजना को इस उद्देश्य को अच्छी तरह से पूरा करने के लिए, सिफरटेक्स्ट को डिक्रिप्ट करना तभी संभव होना चाहिए जब आपके पास सही कुंजी हो।

आधुनिक क्रिप्टोग्राफी केवल गोपनीयता तक सीमित नहीं है, बल्कि यह कई अन्य विषयों पर भी ध्यान देती है। इनमें मुख्य रूप से शामिल हैं (1) **संदेश की अखंडता**—यानी यह सुनिश्चित करना कि संदेश में कोई बदलाव नहीं हुआ है; (2) **संदेश की प्रामाणिकता**—यानी यह सुनिश्चित करना कि संदेश वास्तव में किसी विशेष प्रेषक से आया है; और (3) **अस्वीकृति से बचाव**—यानी यह सुनिश्चित करना कि प्रेषक बाद में झूठा दावा नहीं कर सके कि उसने संदेश नहीं भेजा।

एक महत्वपूर्ण अंतर जो ध्यान में रखना चाहिए, वह है **एन्क्रिप्शन योजना** और **क्रिप्टोग्राफिक योजना** के बीच। एन्क्रिप्शन योजना केवल गोपनीयता से संबंधित होती है। जबकि एक एन्क्रिप्शन योजना एक क्रिप्टोग्राफिक योजना होती है, इसका उल्टा सही नहीं है। एक क्रिप्टोग्राफिक योजना क्रिप्टोग्राफी के अन्य मुख्य विषयों की सेवा भी कर सकती है, जिनमें अखंडता, प्रामाणिकता और अस्वीकृति शामिल हैं।

ईमानदारी और प्रामाणिकता के विषय गोपनीयता जितने ही महत्वपूर्ण हैं। हमारे आधुनिक संचार प्रणालियाँ बिना संचार की ईमानदारी और प्रामाणिकता की गारंटी के काम नहीं कर सकतीं। गैर-प्रतिस्वीकृति भी एक महत्वपूर्ण चिंता है, जैसे कि डिजिटल अनुबंधों के लिए, लेकिन क्रिप्टोग्राफिक अनुप्रयोगों में यह गोपनीयता, ईमानदारी और प्रामाणिकता जितनी व्यापक रूप से आवश्यक नहीं होती।

दूसरा, पारंपरिक एन्क्रिप्शन योजनाएं जैसे कि बील सिफर हमेशा एक कुंजी का उपयोग करती थीं जो सभी संबंधित पक्षों के बीच साझा की जाती थी। हालांकि, कई आधुनिक क्रिप्टोग्राफिक योजनाओं में सिर्फ एक नहीं, बल्कि दो कुंजियों का उपयोग होता है: एक **निजी कुंजी** और एक **सार्वजनिक कुंजी**। जहां निजी कुंजी को किसी भी अनुप्रयोग में निजी रहना चाहिए, वहीं सार्वजनिक कुंजी आमतौर पर सार्वजनिक जानकारी होती है (इसलिए उनके नाम)। एन्क्रिप्शन के क्षेत्र में, सार्वजनिक कुंजी का उपयोग संदेश को एन्क्रिप्ट करने के लिए किया जा सकता है, जबकि निजी कुंजी का उपयोग डिक्रिप्शन के लिए किया जा सकता है।

क्रिप्टोग्राफी की वह शाखा जिसमें सभी पक्ष एक ही कुंजी साझा करते हैं, उसे **सिमेट्रिक क्रिप्टोग्राफी** कहा जाता है। इस प्रकार की योजना में एकल कुंजी को आमतौर पर **प्राइवेट की** (या सीक्रेट की) कहा जाता है। क्रिप्टोग्राफी की वह शाखा जो योजनाओं से संबंधित है जिसमें एक प्राइवेट-पब्लिक की जोड़ी की आवश्यकता होती है, उसे **असिमेट्रिक क्रिप्टोग्राफी** कहा जाता है। इन शाखाओं को कभी-कभी क्रमशः **प्राइवेट की क्रिप्टोग्राफी** और **पब्लिक की क्रिप्टोग्राफी** भी कहा जाता है (हालांकि यह भ्रम पैदा कर सकता है, क्योंकि पब्लिक की क्रिप्टोग्राफिक योजनाओं में भी प्राइवेट की होती है)।

1970 के दशक के अंत में असममित क्रिप्टोग्राफी का आगमन क्रिप्टोग्राफी के इतिहास की सबसे महत्वपूर्ण घटनाओं में से एक रहा है। इसके बिना, हमारे अधिकांश आधुनिक संचार प्रणालियाँ, जिनमें Bitcoin भी शामिल है, संभव नहीं होतीं, या कम से कम बहुत ही अव्यवहारिक होतीं।

महत्वपूर्ण बात यह है कि आधुनिक क्रिप्टोग्राफी केवल सममित और असममित कुंजी क्रिप्टोग्राफिक योजनाओं का अध्ययन नहीं है (हालांकि यह क्षेत्र का बड़ा हिस्सा कवर करता है)। उदाहरण के लिए, क्रिप्टोग्राफी Hash फंक्शन्स और छद्म-यादृच्छिक संख्या जनरेटर से भी संबंधित है, और आप इन मूलभूत तत्वों पर ऐसे अनुप्रयोग बना सकते हैं जो सममित या असममित कुंजी क्रिप्टोग्राफी से संबंधित नहीं होते।

तीसरा, पारंपरिक एन्क्रिप्शन योजनाएँ, जैसे कि बील सिफर में उपयोग की जाती थीं, विज्ञान से अधिक कला थीं। उनकी सुरक्षा का आकलन मुख्य रूप से उनकी जटिलता के बारे में धारणाओं पर आधारित था। जब उन पर कोई नया हमला होता था, तो उन्हें आमतौर पर सुधार दिया जाता था, या अगर हमला बहुत गंभीर होता था, तो उन्हें पूरी तरह से छोड़ दिया जाता था। हालांकि, आधुनिक क्रिप्टोग्राफी एक सख्त विज्ञान है, जिसमें क्रिप्टोग्राफिक योजनाओं को विकसित और विश्लेषण करने के लिए औपचारिक, गणितीय दृष्टिकोण अपनाया जाता है।

विशेष रूप से, आधुनिक क्रिप्टोग्राफी का केंद्र बिंदु सुरक्षा के औपचारिक **प्रमाण** होते हैं। किसी भी क्रिप्टोग्राफिक योजना के लिए सुरक्षा का प्रमाण तीन चरणों में आगे बढ़ता है:

1. **सुरक्षा की क्रिप्टोग्राफिक परिभाषा** का बयान, यानी सुरक्षा के लक्ष्यों का एक सेट और हमलावर द्वारा उत्पन्न खतरा।

किसी भी गणितीय मान्यताओं का विवरण जो योजना की गणनात्मक जटिलता से संबंधित हो। उदाहरण के लिए, एक क्रिप्टोग्राफिक योजना में एक छद्म-यादृच्छिक संख्या जनरेटर हो सकता है। हालांकि हम यह साबित नहीं कर सकते कि ये मौजूद हैं, हम मान सकते हैं कि ये होते हैं।

3. इस योजना की सुरक्षा के गणितीय **प्रमाण** का विवरण, सुरक्षा की औपचारिक धारणा और किसी भी गणितीय धारणाओं के आधार पर।

चौथा, जहाँ पहले के समय में क्रिप्टोग्राफी का मुख्य रूप से सैन्य क्षेत्रों में उपयोग होता था, वहीं अब यह हमारे डिजिटल युग की रोजमर्रा की गतिविधियों में घुलमिल गई है। चाहे आप ऑनलाइन बैंकिंग कर रहे हों, सोशल मीडिया पर पोस्ट कर रहे हों, अपने क्रेडिट कार्ड से अमेज़न से कोई उत्पाद खरीद रहे हों, या अपने दोस्त को Bitcoin दे रहे हों, क्रिप्टोग्राफी हमारे डिजिटल युग की अनिवार्य आवश्यकता बन गई है।

आधुनिक क्रिप्टोग्राफी के इन चार पहलुओं को देखते हुए, हम आधुनिक **क्रिप्टोग्राफी** को उस विज्ञान के रूप में परिभाषित कर सकते हैं जो क्रिप्टोग्राफिक योजनाओं के औपचारिक विकास और विश्लेषण से संबंधित है, ताकि डिजिटल जानकारी को विरोधी हमलों से सुरक्षित किया जा सके। [6] यहाँ सुरक्षा का अर्थ व्यापक रूप से समझा जाना चाहिए, जिसमें ऐसे हमलों को रोकना शामिल है जो संचार में गोपनीयता, अखंडता, प्रमाणीकरण, और/या गैर-प्रतिस्वीकृति को नुकसान पहुंचाते हैं।

क्रिप्टोग्राफी को **साइबर सुरक्षा** की एक उपशाखा के रूप में सबसे अच्छा समझा जा सकता है, जो कंप्यूटर सिस्टम की चोरी, नुकसान और दुरुपयोग को रोकने से संबंधित है। ध्यान दें कि कई साइबर सुरक्षा चिंताओं का क्रिप्टोग्राफी से बहुत कम या केवल आंशिक संबंध होता है।

उदाहरण के लिए, अगर कोई कंपनी महंगे सर्वर को स्थानीय रूप से रखती है, तो उन्हें इस हार्डवेयर को चोरी और नुकसान से बचाने की चिंता हो सकती है। हालांकि यह एक साइबर सुरक्षा की चिंता है, लेकिन इसका क्रिप्टोग्राफी से ज्यादा लेना-देना नहीं है।

एक और उदाहरण के लिए, **फिशिंग हमले** हमारे आधुनिक युग में एक आम समस्या हैं। ये हमले ई-मेल या किसी अन्य संदेश माध्यम के जरिए लोगों को धोखा देने की कोशिश करते हैं ताकि वे अपने संवेदनशील जानकारी जैसे पासवर्ड या क्रेडिट कार्ड नंबर साझा कर दें। हालांकि क्रिप्टोग्राफी कुछ हद तक Address फिशिंग हमलों में मदद कर सकती है, लेकिन एक व्यापक दृष्टिकोण के लिए केवल क्रिप्टोग्राफी का उपयोग करना पर्याप्त नहीं है।

**नोट्स:**

[3] अगर सही-सही कहें, तो क्रिप्टोग्राफिक योजनाओं का मुख्य उपयोग गोपनीयता से जुड़ा होता है। उदाहरण के लिए, बच्चे अक्सर "मज़े" के लिए साधारण क्रिप्टोग्राफिक योजनाओं का उपयोग करते हैं। उन मामलों में गोपनीयता वास्तव में कोई चिंता का विषय नहीं होती।

[4] ब्रूस श्नाइयर, *एप्लाइड क्रिप्टोग्राफी*, दूसरा संस्करण, 2015 (इंडियानापोलिस, आईएन: जॉन वाइली एंड सन्स), पृष्ठ 2।

अच्छे विवरण के लिए जोनाथन कैट्ज़ और यहूदा लिंडेल की किताब *इंट्रोडक्शन टू मॉडर्न क्रिप्टोग्राफी* देखें, जो सीआरसी प्रेस द्वारा 2015 में प्रकाशित की गई है, विशेष रूप से पृष्ठ 16-23।

[6] देखें Katz और Lindell, वही, पृष्ठ 3। मुझे लगता है कि उनके वर्णन में कुछ समस्याएँ हैं, इसलिए मैं यहाँ उनके बयान का थोड़ा अलग संस्करण प्रस्तुत कर रहा हूँ।

## खुली बातचीत

<chapterId>cb23d0a6-ba9a-5dc6-a55a-258405ae4117</chapterId>

आधुनिक क्रिप्टोग्राफी को इस तरह से डिज़ाइन किया गया है कि यह **खुले संचार** के माहौल में सुरक्षा की गारंटी दे सके। अगर हमारा संचार चैनल इतना सुरक्षित है कि जासूसों के पास हमारे संदेशों को देखने या उनमें छेड़छाड़ करने का कोई मौका नहीं है, तो क्रिप्टोग्राफी की ज़रूरत नहीं होती। लेकिन हमारी ज्यादातर संचार चैनल इतने अच्छे से सुरक्षित नहीं होते।

आधुनिक दुनिया में संचार की रीढ़ एक विशाल नेटवर्क है जो फाइबर ऑप्टिक केबल्स से बना है। फोन कॉल करना, टेलीविजन देखना, और वेब ब्राउज़ करना आमतौर पर इस फाइबर ऑप्टिक केबल्स के नेटवर्क पर निर्भर करता है (हालांकि एक छोटा प्रतिशत केवल सैटेलाइट्स पर निर्भर हो सकता है)। यह सच है कि आपके घर में विभिन्न प्रकार के डेटा कनेक्शन हो सकते हैं, जैसे कि कोएक्सियल केबल, (असिमेट्रिक) डिजिटल सब्सक्राइबर लाइन, और फाइबर ऑप्टिक केबल। लेकिन, कम से कम विकसित देशों में, ये विभिन्न डेटा माध्यम जल्दी से आपके घर के बाहर एक नोड में मिल जाते हैं जो एक विशाल फाइबर ऑप्टिक केबल्स के नेटवर्क से जुड़ा होता है, जो पूरे विश्व को जोड़ता है। कुछ दूरस्थ क्षेत्रों में, जैसे कि संयुक्त राज्य अमेरिका और ऑस्ट्रेलिया में, डेटा ट्रैफिक अभी भी पारंपरिक तांबे की टेलीफोन तारों के माध्यम से लंबी दूरी तय कर सकता है।

इन केबलों के नेटवर्क और इसके सहायक ढांचे तक संभावित हमलावरों को शारीरिक रूप से पहुँचने से रोकना असंभव होगा। वास्तव में, हम पहले से ही जानते हैं कि हमारे अधिकांश डेटा को विभिन्न राष्ट्रीय खुफिया एजेंसियों द्वारा इंटरनेट के महत्वपूर्ण चौराहों पर रोका जाता है। इसमें फेसबुक संदेशों से लेकर उन वेबसाइटों के पते तक सब कुछ शामिल है, जिन्हें आप देखते हैं।

बड़े पैमाने पर डेटा की निगरानी के लिए एक शक्तिशाली विरोधी, जैसे कि एक राष्ट्रीय खुफिया एजेंसी की आवश्यकता होती है, लेकिन कम संसाधनों वाले हमलावर भी आसानी से स्थानीय स्तर पर जासूसी करने की कोशिश कर सकते हैं। हालांकि यह तारों को टैप करने के स्तर पर हो सकता है, लेकिन वायरलेस संचार को इंटरसेप्ट करना कहीं अधिक आसान है।

हमारे घरों में, दफ्तरों में या कैफे में, अधिकतर स्थानीय नेटवर्क डेटा अब भौतिक केबलों के बजाय रेडियो तरंगों के माध्यम से वायरलेस एक्सेस पॉइंट्स पर ऑल-इन-वन राउटर्स तक पहुंचता है। इसलिए, किसी हमलावर को आपके स्थानीय ट्रैफिक को इंटरसेप्ट करने के लिए बहुत कम संसाधनों की आवश्यकता होती है। यह विशेष रूप से चिंताजनक है क्योंकि ज्यादातर लोग अपने स्थानीय नेटवर्क के माध्यम से यात्रा करने वाले डेटा की सुरक्षा के लिए बहुत कम करते हैं। इसके अलावा, संभावित हमलावर हमारे मोबाइल ब्रॉडबैंड कनेक्शनों, जैसे 3G, 4G, और 5G को भी निशाना बना सकते हैं। ये सभी वायरलेस संचार हमलावरों के लिए आसान लक्ष्य हैं।

इसलिए, संचार चैनल को सुरक्षित करके बातचीत को गुप्त रखने का विचार आज की आधुनिक दुनिया में एक निराशाजनक भ्रम है। हमारे पास जो भी जानकारी है, वह गंभीर चिंता का कारण है: आपको हमेशा यह मानकर चलना चाहिए कि कोई आपकी बात सुन रहा है। और इस आधुनिक माहौल में किसी भी तरह की सुरक्षा पाने के लिए हमारे पास मुख्य उपकरण क्रिप्टोग्राफी ही है।

**नोट्स:**

देखें, उदाहरण के लिए, ओल्गा खज़ान का लेख "समुद्र के नीचे केबल टैपिंग की डरावनी और पुरानी प्रथा", *द अटलांटिक*, 16 जुलाई, 2013 (उपलब्ध [द अटलांटिक](https://www.theatlantic.com/international/archive/2013/07/the-creepy-long-standing-practice-of-undersea-cable-tapping/277855/) पर)।

# क्रिप्टोग्राफी की गणितीय नींव 1

<partId>1bf9f0aa-0f68-5493-83fb-2167238ff9de</partId>

## यादृच्छिक चर (रैंडम वेरिएबल्स)

<chapterId>b623a7d0-3dff-5803-bd4e-8257ff73dd69</chapterId>

क्रिप्टोग्राफी गणित पर निर्भर करती है। और अगर आप क्रिप्टोग्राफी को गहराई से समझना चाहते हैं, तो आपको उस गणित में सहज होना पड़ेगा।

यह अध्याय उन बुनियादी गणितीय अवधारणाओं का परिचय देता है जिनसे आप क्रिप्टोग्राफी सीखते समय सामना करेंगे। इनमें यादृच्छिक चर, माड्यूलो ऑपरेशन्स, XOR ऑपरेशन्स, और छद्म-यादृच्छिकता शामिल हैं। क्रिप्टोग्राफी को गहराई से समझने के लिए आपको इन विषयों में महारत हासिल करनी चाहिए।

अगला भाग संख्या सिद्धांत से संबंधित है, जो काफी अधिक चुनौतीपूर्ण है।

### यादृच्छिक चर (रैंडम वेरिएबल्स)

एक यादृच्छिक चर को आमतौर पर एक साधारण, बड़े अक्षर से दर्शाया जाता है। उदाहरण के लिए, हम एक यादृच्छिक चर $X$, एक यादृच्छिक चर $Y$, या एक यादृच्छिक चर $Z$ के बारे में बात कर सकते हैं। यही संकेत मैं आगे भी उपयोग करूंगा।

एक **यादृच्छिक चर** दो या अधिक संभावित मान ले सकता है, जिनमें से प्रत्येक के साथ एक निश्चित सकारात्मक संभावना होती है। संभावित मानों को **परिणाम सेट** में सूचीबद्ध किया जाता है।

हर बार जब आप किसी यादृच्छिक चर का **नमूना** लेते हैं, तो आप उसकी संभावनाओं के अनुसार उसके परिणाम सेट से एक विशेष मान चुनते हैं।

चलो एक सरल उदाहरण की ओर बढ़ते हैं। मान लो एक चर X है जिसे इस प्रकार परिभाषित किया गया है:


- X के परिणाम सेट में $\{1,2\}$ शामिल हैं।

$$
Pr[X = 1] = 0.5
$$

$$
Pr[X = 2] = 0.5
$$

यह देखना आसान है कि $X$ एक यादृच्छिक चर है। सबसे पहले, $X$ के लिए दो या अधिक संभावित मान हैं, जैसे $1$ और $2$। दूसरा, प्रत्येक संभावित मान के होने की एक सकारात्मक संभावना है जब भी आप $X$ का नमूना लेते हैं, जैसे $0.5$।

एक यादृच्छिक चर के लिए बस एक परिणाम सेट की आवश्यकता होती है जिसमें दो या अधिक संभावनाएँ होती हैं, जहाँ प्रत्येक संभावना के होने की एक सकारात्मक संभावना होती है जब हम नमूना लेते हैं। सिद्धांत रूप में, एक यादृच्छिक चर को बिना किसी संदर्भ के, अमूर्त रूप से परिभाषित किया जा सकता है। इस स्थिति में, आप "नमूना लेने" को एक प्राकृतिक प्रयोग चलाने के रूप में सोच सकते हैं ताकि यादृच्छिक चर का मान निर्धारित किया जा सके।

ऊपर दिए गए $X$ वेरिएबल को एक अमूर्त तरीके से परिभाषित किया गया था। इसलिए, आप $X$ वेरिएबल के सैंपलिंग को एक निष्पक्ष सिक्का उछालने के रूप में सोच सकते हैं, जहां हेड्स आने पर "2" और टेल्स आने पर "1" असाइन किया जाता है। $X$ के प्रत्येक सैंपल के लिए, आप सिक्का फिर से उछालते हैं।

आप इसे इस तरह भी सोच सकते हैं कि $X$ का नमूना लेना ऐसा है जैसे एक निष्पक्ष पासा फेंकना। अगर पासा $1$, $3$, या $4$ पर आता है, तो आप "2" मान देते हैं, और अगर पासा $2$, $5$, या $6$ पर आता है, तो आप "1" मान देते हैं। हर बार जब आप $X$ का नमूना लेते हैं, तो आप पासा फिर से फेंकते हैं।

वास्तव में, कोई भी प्राकृतिक प्रयोग जो आपको ऊपर दिए गए $X$ के संभावित मानों की संभावनाओं को परिभाषित करने की अनुमति देता है, उसे ड्राइंग के संदर्भ में कल्पना की जा सकती है।

अक्सर, हालांकि, रैंडम वेरिएबल्स को केवल सैद्धांतिक रूप से नहीं पेश किया जाता है। इसके बजाय, संभावित परिणामों के सेट का स्पष्ट वास्तविक दुनिया में अर्थ होता है (सिर्फ संख्याओं के रूप में नहीं)। इसके अलावा, ये परिणाम किसी विशेष प्रकार के प्रयोग के संदर्भ में परिभाषित किए जा सकते हैं (सिर्फ उन मूल्यों के साथ किसी भी प्राकृतिक प्रयोग के रूप में नहीं)।

अब चलिए एक उदाहरण पर विचार करते हैं जहाँ चर $X$ को अमूर्त रूप से परिभाषित नहीं किया गया है। $X$ को इस प्रकार परिभाषित किया गया है ताकि यह निर्धारित किया जा सके कि दो टीमों में से कौन सी टीम फुटबॉल खेल की शुरुआत करेगी:


- $X$ के परिणाम सेट में {लाल किक ऑफ करता है, नीला किक ऑफ करता है} शामिल हैं।
- एक विशेष सिक्का $C$ उछालें: चित = "लाल टीम की शुरुआत"; पट = "नीली टीम की शुरुआत"

$$
Pr [X = \text{red kicks off}] = 0.5
$$

$$
Pr [X = \text{blue kicks off}] = 0.5
$$

इस मामले में, X के परिणाम सेट को एक ठोस अर्थ दिया गया है, यानी कि फुटबॉल खेल में कौन सी टीम शुरुआत करती है। इसके अलावा, संभावित परिणाम और उनसे जुड़ी संभावनाएँ एक ठोस प्रयोग द्वारा निर्धारित की जाती हैं, यानी कि एक विशेष सिक्का $C$ उछालना।

क्रिप्टोग्राफी की चर्चाओं में, अक्सर रैंडम वेरिएबल्स को एक ऐसे परिणाम सेट के संदर्भ में पेश किया जाता है जिसका वास्तविक दुनिया में कुछ मतलब होता है। यह वह सेट हो सकता है जिसमें सभी संदेश शामिल होते हैं जिन्हें एन्क्रिप्ट किया जा सकता है, जिसे संदेश स्थान कहा जाता है, या वह सेट जिसमें सभी कुंजियाँ शामिल होती हैं जिन्हें एन्क्रिप्शन का उपयोग करने वाले पक्ष चुन सकते हैं, जिसे कुंजी स्थान कहा जाता है।

क्रिप्टोग्राफी पर चर्चाओं में रैंडम वेरिएबल्स को आमतौर पर किसी विशेष प्राकृतिक प्रयोग के संदर्भ में परिभाषित नहीं किया जाता है, बल्कि किसी भी ऐसे प्रयोग के संदर्भ में परिभाषित किया जाता है जो सही प्रायिकता वितरण दे सके।

रैंडम वेरिएबल्स के पास या तो डिस्क्रीट या कंटीन्यूअस प्रायिकता वितरण हो सकता है। जिन रैंडम वेरिएबल्स का **डिस्क्रीट प्रायिकता वितरण** होता है, उन्हें डिस्क्रीट रैंडम वेरिएबल्स कहते हैं, और इनके संभावित परिणामों की संख्या सीमित होती है। अब तक दिए गए दोनों उदाहरणों में रैंडम वेरिएबल $X$ डिस्क्रीट था।

**सतत यादृच्छिक चर** एक या अधिक अंतरालों में मान ले सकते हैं। उदाहरण के लिए, आप कह सकते हैं कि एक यादृच्छिक चर, जब नमूना लिया जाता है, तो 0 और 1 के बीच कोई भी वास्तविक मान ले सकता है, और इस अंतराल में प्रत्येक वास्तविक संख्या के आने की संभावना समान होती है। इस अंतराल के भीतर, अनंत संभावित मान होते हैं।

क्रिप्टोग्राफिक चर्चाओं के लिए, आपको केवल विविक्त यादृच्छिक चर (discrete random variables) को समझने की आवश्यकता होगी। इसलिए, आगे की किसी भी चर्चा में जब भी यादृच्छिक चर का उल्लेख होगा, तो उसे विविक्त यादृच्छिक चर के संदर्भ में ही समझा जाना चाहिए, जब तक कि विशेष रूप से कुछ और न कहा गया हो।

### यादृच्छिक चर का ग्राफ बनाना

एक यादृच्छिक चर के संभावित मान और उनसे जुड़ी संभावनाओं को एक ग्राफ के माध्यम से आसानी से देखा जा सकता है। उदाहरण के लिए, पिछले भाग में दिए गए यादृच्छिक चर $X$ को लें, जिसका परिणाम सेट $\{1, 2\}$ है, और $Pr [X = 1] = 0.5$ तथा $Pr [X = 2] = 0.5$ है। आमतौर पर, हम ऐसे यादृच्छिक चर को *चित्र 1* में बार ग्राफ के रूप में प्रदर्शित करते हैं।

*चित्र 1: यादृच्छिक चर X*

![Figure 1: Random variable X.](assets/Figure2-1.webp)

*चित्र 1* में चौड़ी पट्टियाँ यह संकेत नहीं देतीं कि यादृच्छिक चर $X$ वास्तव में सतत है। इसके बजाय, पट्टियाँ चौड़ी इसलिए बनाई गई हैं ताकि वे देखने में अधिक आकर्षक लगें (सिर्फ एक सीधी रेखा ऊपर की ओर कम सहज दृश्य प्रदान करती है)।

### समान चर

"रैंडम वेरिएबल" के अभिव्यक्ति में "रैंडम" का मतलब बस "संभाव्य" होता है। दूसरे शब्दों में, इसका मतलब है कि वेरिएबल के दो या अधिक संभावित परिणाम कुछ निश्चित संभावनाओं के साथ होते हैं। हालांकि, ये परिणाम *जरूरी नहीं* कि समान रूप से संभावित हों (हालांकि अन्य संदर्भों में "रैंडम" का यह मतलब हो सकता है)।

**समान चर** एक विशेष प्रकार का यादृच्छिक चर होता है। यह दो या अधिक मान ले सकता है और सभी मानों की संभावना समान होती है। *चित्र 1* में दिखाया गया यादृच्छिक चर $X$ स्पष्ट रूप से एक समान चर है, क्योंकि दोनों संभावित परिणाम $0.5$ की संभावना के साथ होते हैं। हालांकि, कई यादृच्छिक चर ऐसे होते हैं जो समान चर के उदाहरण नहीं होते।

उदाहरण के लिए, यादृच्छिक चर $Y$ पर विचार करें। इसका परिणाम सेट $\{1, 2, 3, 8, 10\}$ है और इसकी निम्नलिखित प्रायिकता वितरण है:

$$
\Pr[Y = 1] = 0.25
$$

$$
\Pr[Y = 2] = 0.35
$$

$$
\Pr[Y = 3] = 0.1
$$

$$
\Pr[Y = 8] = 0.25
$$

$$
\Pr[Y = 10] = 0.05
$$

हालांकि दो संभावित परिणामों, यानी $1$ और $8$, के होने की संभावना वास्तव में समान है, $Y$ कुछ अन्य मान भी ले सकता है जिनकी संभावनाएं $0.25$ से अलग हो सकती हैं जब नमूना लिया जाता है। इसलिए, जबकि $Y$ वास्तव में एक यादृच्छिक चर है, यह एक समान चर नहीं है।

*चित्र 2* में $Y$ का एक ग्राफिकल चित्रण दिया गया है।

*चित्र 2: यादृच्छिक चर Y*

![Figure 2: Random variable Y.](assets/Figure2-2.webp "Figure 2: Random variable Y")

अंतिम उदाहरण के लिए, यादृच्छिक चर Z पर विचार करें। इसके परिणाम सेट {1,3,7,11,12} हैं और इसकी संभाव्यता वितरण इस प्रकार है:

$$
\Pr[Z = 2] = 0.2
$$

$$
\Pr[Z = 3] = 0.2
$$

$$
\Pr[Z = 9] = 0.2
$$

$$
\Pr[Z = 11] = 0.2
$$

$$
\Pr[Z = 12] = 0.2
$$

आप इसे *चित्र 3* में देख सकते हैं। यादृच्छिक चर Z, Y के विपरीत, एक समान चर है, क्योंकि नमूना लेने पर सभी संभावित मानों के लिए संभावनाएँ समान होती हैं।

*चित्र 3: यादृच्छिक चर Z*

![Figure 3: Random variable Z.](assets/Figure2-3.webp "Figure 3: Random variable Z")

### सशर्त प्रायिकता

मान लीजिए कि बॉब पिछले कैलेंडर वर्ष से किसी एक दिन को समान रूप से चुनने का इरादा रखता है। हमें यह निष्कर्ष निकालना चाहिए कि चुने गए दिन के गर्मी के मौसम में होने की संभावना क्या है?

अगर हम उत्तरी गोलार्ध की बात करें, तो गर्मी का मौसम आमतौर पर जून, जुलाई और अगस्त के महीनों में होता है। इन तीन महीनों में कुल मिलाकर 92 दिन होते हैं (जून में 30 दिन, जुलाई में 31 दिन, और अगस्त में 31 दिन)।

एक साल में कुल 365 दिन होते हैं। इसलिए, गर्मी के मौसम में किसी दिन के चुने जाने की संभावना होगी:

गर्मी के दिनों की संख्या / कुल दिनों की संख्या = 92/365

तो, बॉब के द्वारा चुने गए दिन के गर्मी के मौसम में होने की संभावना लगभग 0.252 या 25.2% है।

जब तक हमें लगता है कि बॉब की प्रक्रिया वास्तव में समान रूप से होगी, हमें यह निष्कर्ष निकालना चाहिए कि बॉब के द्वारा चुने गए दिन के ग्रीष्म ऋतु में होने की संभावना 1/4 है। यह उस दिन के ग्रीष्म ऋतु में होने की **निर्वैयक्तिक संभावना** है जिसे यादृच्छिक रूप से चुना गया है।

मान लीजिए कि अब बॉब एक कैलेंडर दिन को समान रूप से चुनने के बजाय केवल उन दिनों में से चुनता है जिन दिनों क्रिस्टल लेक (न्यू जर्सी) में दोपहर का तापमान 21 डिग्री सेल्सियस या उससे अधिक था। इस अतिरिक्त जानकारी के आधार पर, हम यह निष्कर्ष निकाल सकते हैं कि बॉब के ग्रीष्म ऋतु में एक दिन चुनने की संभावना बढ़ जाती है। ऐसा इसलिए है क्योंकि गर्मियों में तापमान आमतौर पर अधिक होता है, इसलिए 21 डिग्री सेल्सियस या उससे अधिक तापमान वाले दिन अधिकतर गर्मियों में ही होते हैं।

हमें पहले से अलग निष्कर्ष निकालना चाहिए, भले ही हमारे पास कोई और विशेष जानकारी न हो (जैसे, पिछले साल के हर दिन दोपहर का तापमान)।

यह जानते हुए कि क्रिस्टल लेक न्यू जर्सी में है, हम निश्चित रूप से उम्मीद नहीं करेंगे कि सर्दियों में दोपहर का तापमान 21 डिग्री सेल्सियस या उससे अधिक होगा। इसके बजाय, यह अधिक संभावना है कि यह वसंत या पतझड़ में एक गर्म दिन हो, या फिर गर्मियों के किसी दिन का हो। इसलिए, यह जानते हुए कि क्रिस्टल लेक में चुने गए दिन का दोपहर का तापमान 21 डिग्री सेल्सियस या उससे अधिक था, इस बात की संभावना बहुत अधिक हो जाती है कि बॉब द्वारा चुना गया दिन गर्मियों में है। यह **शर्तीय संभावना** है कि यादृच्छिक रूप से चुना गया दिन गर्मियों में है, यह जानते हुए कि क्रिस्टल लेक में दोपहर का तापमान 21 डिग्री सेल्सियस या उससे अधिक था।

पिछले उदाहरण के विपरीत, दो घटनाओं की संभावनाएँ पूरी तरह से असंबंधित भी हो सकती हैं। ऐसे में हम कहते हैं कि वे **स्वतंत्र** हैं।

मान लीजिए कि एक निष्पक्ष सिक्का उछाला गया और वह हेड्स आया। इस तथ्य को ध्यान में रखते हुए, कल बारिश होने की संभावना क्या होगी? इस स्थिति में सशर्त संभावना वही होनी चाहिए जो बिना शर्त संभावना होती है कि कल बारिश होगी, क्योंकि सिक्का उछालने का मौसम पर आमतौर पर कोई प्रभाव नहीं पड़ता।

हम शर्तीय प्रायिकता कथनों को लिखने के लिए "|" प्रतीक का उपयोग करते हैं। उदाहरण के लिए, घटना $A$ की प्रायिकता, यह जानते हुए कि घटना $B$ घटित हो चुकी है, को इस प्रकार लिखा जा सकता है:

$$
Pr[A|B]
$$

जब दो घटनाएँ, $A$ और $B$, स्वतंत्र होती हैं, तो:

$$
Pr[A|B] = Pr[A] \text{ and } Pr[B|A] = Pr[B]
$$

स्वतंत्रता की शर्त को इस प्रकार सरल बनाया जा सकता है:

$$
Pr[A, B] = Pr[A] \cdot Pr[B]
$$

प्रायिकता सिद्धांत में एक महत्वपूर्ण परिणाम **बेयस प्रमेय** के नाम से जाना जाता है। यह मूल रूप से कहता है कि $Pr[A|B]$ को निम्नलिखित रूप में फिर से लिखा जा सकता है:

$$
Pr[A|B] = \frac{Pr[B|A] \cdot Pr[A]}{Pr[B]}
$$

विशिष्ट घटनाओं के साथ सशर्त संभावनाओं का उपयोग करने के बजाय, हम संभावित घटनाओं के सेट पर दो या अधिक यादृच्छिक चर के साथ शामिल सशर्त संभावनाओं को भी देख सकते हैं। मान लीजिए दो यादृच्छिक चर हैं, $X$ और $Y$। हम $X$ के लिए किसी भी संभावित मान को $x$ द्वारा और $Y$ के लिए किसी भी संभावित मान को $y$ द्वारा दर्शा सकते हैं। तब हम कह सकते हैं कि दो यादृच्छिक चर स्वतंत्र होते हैं यदि निम्नलिखित कथन सही होता है:

$$
Pr[X = x, Y = y] = Pr[X = x] \cdot Pr[Y = y]
$$

सभी $x$ और $y$ के लिए।

आइए इस कथन का मतलब थोड़ा और स्पष्ट रूप से समझते हैं।

मान लीजिए कि $X$ और $Y$ के लिए परिणाम सेट इस प्रकार परिभाषित किए गए हैं: **X** = $\{x_1, x_2, \ldots, x_i, \ldots, x_n\}$ और **Y** = $\{y_1, y_2, \ldots, y_i, \ldots, y_m\}$। (आमतौर पर, मानों के सेट को मोटे अक्षरों और बड़े अक्षरों में दर्शाया जाता है।)

मान लीजिए कि आपने $Y$ का नमूना लिया और $y_1$ देखा। ऊपर दिए गए कथन के अनुसार, अब $X$ का नमूना लेते समय $x_1$ प्राप्त करने की संभावना बिल्कुल वैसी ही है जैसे कि आपने कभी $y_1$ देखा ही नहीं था। यह बात किसी भी $y_i$ के लिए सही है जिसे हमने $Y$ के प्रारंभिक नमूने से खींचा हो। अंत में, यह केवल $x_1$ के लिए ही नहीं, बल्कि किसी भी $x_i$ के लिए सही है। $Y$ के नमूने के परिणाम का $x_i$ की संभावना पर कोई प्रभाव नहीं पड़ता। यह सब उस स्थिति में भी लागू होता है जब पहले $X$ का नमूना लिया जाता है।

चलो, हमारी चर्चा को एक थोड़े दार्शनिक बिंदु पर समाप्त करते हैं। किसी भी वास्तविक स्थिति में, किसी घटना की संभावना हमेशा एक विशेष जानकारी के सेट के आधार पर आंकी जाती है। बहुत सख्त अर्थों में कोई "बिना शर्त संभावना" नहीं होती।

मान लीजिए कि मैंने आपसे पूछा कि 2030 तक सूअर उड़ने की कितनी संभावना है। भले ही मैं आपको कोई और जानकारी न दूं, लेकिन आप दुनिया के बारे में बहुत कुछ जानते हैं जो आपके निर्णय को प्रभावित कर सकता है। आपने कभी सूअरों को उड़ते हुए नहीं देखा है। आप जानते हैं कि ज्यादातर लोग उनसे उड़ने की उम्मीद नहीं करेंगे। आप जानते हैं कि वे वास्तव में उड़ने के लिए बने नहीं हैं। और इसी तरह।

इसलिए, जब हम वास्तविक दुनिया के संदर्भ में किसी घटना की "बिना शर्त संभावना" की बात करते हैं, तो इस शब्द का वास्तव में मतलब तभी हो सकता है जब हम इसे "बिना किसी अतिरिक्त स्पष्ट जानकारी के संभावना" के रूप में लें। इसी तरह, "शर्तीय संभावना" को हमेशा किसी विशेष जानकारी के संदर्भ में समझा जाना चाहिए।

मान लीजिए, मैं आपसे पूछता हूँ कि 2030 तक सूअर उड़ने लगेंगे, इस संभावना के बारे में आपकी क्या राय है, और इसके पहले मैं आपको यह जानकारी देता हूँ कि न्यूज़ीलैंड में कुछ बकरियों ने कुछ साल की ट्रेनिंग के बाद उड़ना सीख लिया है। इस स्थिति में, आप शायद 2030 तक सूअरों के उड़ने की संभावना के बारे में अपनी राय बदल देंगे। तो, 2030 तक सूअरों के उड़ने की संभावना इस बात पर निर्भर करती है कि न्यूज़ीलैंड की बकरियों के उड़ने की जानकारी क्या है।

## मॉड्यूलो ऑपरेशन

<chapterId>709b34e5-b155-53d2-abbd-97d67e56db00</chapterId>

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

**मॉड्यूलो ऑपरेशन** के साथ सबसे बुनियादी अभिव्यक्ति इस प्रकार होती है: $x \mod y$।

चर $x$ को भाज्य (dividend) कहा जाता है और चर $y$ को भाजक (divisor) कहा जाता है। जब आप एक सकारात्मक भाज्य और एक सकारात्मक भाजक के साथ मॉड्यूलो ऑपरेशन करते हैं, तो आपको बस विभाजन के बाद बचा हुआ शेष निकालना होता है।

उदाहरण के लिए, $25 \mod 4$ को देखें। संख्या 4, संख्या 25 में कुल 6 बार जाती है। उस भाग के बाद जो शेष बचता है, वह 1 है। इसलिए, $25 \mod 4$ का मान 1 होता है। इसी तरह, हम नीचे दिए गए अन्य अभिव्यक्तियों का मूल्यांकन कर सकते हैं:


- 29 को 30 से भाग देने पर शेषफल 29 होता है, क्योंकि 30, 29 में 0 बार पूरा जाता है और शेष 29 बचता है।
- 42 को 2 से भाग देने पर शेषफल 0 आता है (क्योंकि 2, 42 में कुल 21 बार जाता है और शेष 0 बचता है)।
- $12 \mod 5 = 2$ (क्योंकि 5, 12 में कुल 2 बार जाता है और बाकी बचता है 2)
- 20 को 8 से भाग देने पर 2 बार पूरा जाता है और शेष 4 बचता है। इसलिए, $20 \mod 8 = 4$।

जब डिविडेंड या डिवाइज़र नकारात्मक होता है, तो प्रोग्रामिंग भाषाएं मोड्यूलो ऑपरेशन्स को अलग-अलग तरीके से संभाल सकती हैं।

क्रिप्टोग्राफी में आपको निश्चित रूप से ऐसे मामले मिलेंगे जहां लाभांश नकारात्मक होता है। इन मामलों में, सामान्य तरीका कुछ इस प्रकार होता है:


- सबसे पहले उस सबसे नज़दीकी मान को निर्धारित करें जो लाभांश से कम या उसके बराबर हो और जिसमें भाजक को शून्य शेष के साथ विभाजित किया जा सके। उस मान को $p$ कहें।
- यदि डिविडेंड $x$ है, तो मॉड्यूलो ऑपरेशन का परिणाम $x – p$ का मान होता है।

उदाहरण के लिए, मान लीजिए कि डिविडेंड $–20$ है और डिवाइजर 3 है। $–20$ से कम या उसके बराबर सबसे नज़दीकी संख्या जिसमें 3 पूरी तरह से विभाजित हो सकता है, वह $–21$ है। इस स्थिति में $x – p$ का मान $–20 – (–21)$ है। यह 1 के बराबर होता है, इसलिए $–20 \mod 3$ का मान 1 होता है। इसी तरह, हम नीचे दिए गए अभिव्यक्तियों का मूल्यांकन कर सकते हैं:


- $–8 \mod 5 = 2$ का मतलब है कि जब आप -8 को 5 से विभाजित करते हैं, तो शेष 2 आता है। इसे ऐसे समझ सकते हैं कि -8 में 5 को जोड़ते हुए सबसे नज़दीकी बड़ा पूर्णांक प्राप्त करें जो 5 का गुणज हो। यहाँ, -8 में 10 जोड़ने पर 2 आता है, जो 5 का गुणज है। इसलिए शेषफल 2 है।
- $–19 \mod 16 = 13$ का मतलब है कि जब आप -19 को 16 से भाग देते हैं, तो शेष 13 आता है। इसे ऐसे समझ सकते हैं कि -19 में 16 को जोड़ते हुए सबसे नज़दीकी बड़ा पूर्णांक प्राप्त करें जो 16 से विभाज्य हो। यहाँ, -19 में 16 को दो बार जोड़ने पर हमें 13 मिलता है, जो 16 से विभाज्य है। इसलिए शेषफल 13 होता है।
- –14 को 6 से भाग देने पर शेषफल 4 आता है।

संकेतों के बारे में बात करें तो, आमतौर पर आप इस प्रकार के अभिव्यक्तियाँ देखेंगे: $x = [y \mod z]$। ब्रैकेट्स की वजह से, इस मामले में मॉड्यूलो ऑपरेशन केवल अभिव्यक्ति के दाईं ओर लागू होता है। उदाहरण के लिए, अगर $y$ की मान 25 है और $z$ की मान 4 है, तो $x$ की गणना 1 होगी।

बिना ब्रैकेट्स के, मोड्यूलो ऑपरेशन एक अभिव्यक्ति के *दोनों पक्षों* पर लागू होता है। मान लीजिए, उदाहरण के लिए, निम्नलिखित अभिव्यक्ति: $x = y \mod z$। यदि $y$ की मान 25 है और $z$ की मान 4 है, तो हमें केवल इतना पता है कि $x \mod 4$ का मान 1 होगा। यह $x$ के लिए किसी भी मान के साथ संगत है जो सेट $\{\ldots,–7, –3, 1, 5, 9,\ldots\}$ में आता है।

गणित की वह शाखा जिसमें संख्याओं और अभिव्यक्तियों पर मॉड्यूलो ऑपरेशन शामिल होते हैं, उसे **मॉड्यूलर अंकगणित** कहा जाता है। आप इस शाखा को ऐसे अंकगणित के रूप में सोच सकते हैं जहाँ संख्या रेखा अनंत लंबी नहीं होती। हालांकि हम आमतौर पर क्रिप्टोग्राफी में (धनात्मक) पूर्णांकों के लिए मॉड्यूलो ऑपरेशन का सामना करते हैं, आप किसी भी वास्तविक संख्याओं का उपयोग करके भी मॉड्यूलो ऑपरेशन कर सकते हैं।

### शिफ्ट सिफर

मॉड्यूलो ऑपरेशन अक्सर क्रिप्टोग्राफी में देखा जाता है। उदाहरण के लिए, आइए एक सबसे प्रसिद्ध ऐतिहासिक एन्क्रिप्शन योजना पर विचार करें: शिफ्ट सिफर।

चलो पहले इसे परिभाषित करते हैं। मान लो एक शब्दकोश *D* है जो अंग्रेज़ी वर्णमाला के सभी अक्षरों को क्रम में संख्याओं के सेट $\{0, 1, 2, \ldots, 25\}$ के साथ जोड़ता है। एक संदेश स्थान **M** मान लो। तब **शिफ्ट सिफर** एक एन्क्रिप्शन योजना है जो इस प्रकार परिभाषित की जाती है:


- आपको कुंजी स्थान **K** से एक कुंजी $k$ को समान रूप से चुनना है, जहाँ **K** = $\{0, 1, 2, \ldots, 25\}$ है।
- एक संदेश $m \in \mathbf{M}$ को निम्नलिखित तरीके से एन्क्रिप्ट करें:
    - $m$ को उसके व्यक्तिगत अक्षरों में अलग करें: $m_0, m_1, \ldots, m_i, \ldots, m_l$।
    - आपको प्रत्येक $m_i$ को *D* के अनुसार एक संख्या में बदलना है।
    - प्रत्येक $m_i$ के लिए, $c_i = [(m_i + k) \mod 26]$।
    - आपको प्रत्येक $c_i$ को *D* के अनुसार एक अक्षर में बदलना है।
    - फिर $c_0, c_1, \ldots, c_l$ को मिलाकर गुप्त संदेश $c$ प्राप्त करें।
- एक गुप्त संदेश $c$ को निम्नलिखित तरीके से डिक्रिप्ट करें:
    - प्रत्येक $c_i$ को *D* के अनुसार एक संख्या में बदलें।
    - प्रत्येक $c_i$ के लिए, $m_i = [(c_i – k) \mod 26]$
    - आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
    - फिर $m_0, m_1, \ldots, m_l$ को मिलाकर मूल संदेश $m$ प्राप्त करें।

शिफ्ट सिफर में मॉड्यूलो ऑपरेटर यह सुनिश्चित करता है कि अक्षर घुमकर वापस आ जाएं, ताकि सभी सिफरटेक्स्ट अक्षर परिभाषित रहें। उदाहरण के लिए, "DOG" शब्द पर शिफ्ट सिफर का उपयोग करने पर विचार करें।

मान लीजिए कि आपने एक कुंजी को 17 के मान के लिए चुना है। अक्षर "O" का मान 15 होता है। बिना मॉड्यूलो ऑपरेशन के, इस प्लेनटेक्स्ट संख्या में कुंजी जोड़ने पर यह 32 की सिफरटेक्स्ट संख्या बन जाएगी। हालांकि, यह सिफरटेक्स्ट संख्या किसी सिफरटेक्स्ट अक्षर में परिवर्तित नहीं की जा सकती, क्योंकि अंग्रेजी वर्णमाला में केवल 26 अक्षर होते हैं। मॉड्यूलो ऑपरेशन यह सुनिश्चित करता है कि सिफरटेक्स्ट संख्या वास्तव में 6 है (जो $32 \mod 26$ का परिणाम है), जो सिफरटेक्स्ट अक्षर "G" के बराबर है।

शब्द "DOG" का पूरा एन्क्रिप्शन 17 की कुंजी मान के साथ इस प्रकार है:


- संदेश = कुत्ता = क, उ, त, ता = 3, 15, 6
- $c_0$ की गणना इस प्रकार की गई है: पहले 3 और 17 को जोड़ा गया, जिससे 20 प्राप्त हुआ। फिर 20 को 26 से मॉड (mod) किया गया, जिसका परिणाम 20 आया। इस प्रकार $c_0$ का मान U है।
- $c_1 = [(15 + 17) \mod 26] = [(32) \mod 26] = 6 = G$

यह गणना एक प्रकार की गणितीय प्रक्रिया है जिसमें हम दो संख्याओं को जोड़ते हैं और फिर उनके योग को 26 से भाग देकर शेषफल निकालते हैं। यहाँ, 15 और 17 को जोड़ा गया, जिससे 32 प्राप्त हुआ। फिर 32 को 26 से भाग दिया गया, जिससे शेषफल 6 आया। इस शेषफल को अंग्रेजी वर्णमाला के अक्षर में बदलने पर 'G' प्राप्त होता है।
- $c_2 = [(6 + 17) \mod 26] = [(23) \mod 26] = 23 = X$

यह गणना एक मॉड्यूलो ऑपरेशन का उदाहरण है। यहाँ पर, 6 और 17 को जोड़ा गया है, जिससे 23 प्राप्त होता है। फिर 23 को 26 से मॉड्यूलो किया गया है, जिसका परिणाम 23 ही आता है। अंत में, 23 को अक्षर 'X' के रूप में दर्शाया गया है।
- $c = UGX$ का मतलब है कि $c$ की कीमत या मूल्य UGX (युगांडा शिलिंग) में है।

हर कोई सहज रूप से समझ सकता है कि शिफ्ट सिफर कैसे काम करता है और शायद खुद भी इसका उपयोग कर सकता है। लेकिन क्रिप्टोग्राफी के ज्ञान को आगे बढ़ाने के लिए, यह महत्वपूर्ण है कि आप औपचारिकता के साथ अधिक सहज होना शुरू करें, क्योंकि योजनाएँ और भी जटिल हो जाएंगी। इसलिए, शिफ्ट सिफर के लिए कदमों को औपचारिक रूप दिया गया है।

**नोट्स:**

[1] हम इस कथन को ठीक से परिभाषित कर सकते हैं, पिछले खंड की शब्दावली का उपयोग करते हुए। मान लीजिए कि एक समान चर $K$ है, जिसके संभावित परिणामों का सेट $K$ है। तो:

$$
Pr[K = 0] = \frac{1}{26}
$$

$$
Pr[K = 1] = \frac{1}{26}
$$

...और इसी तरह। एक बार समान वितरण वाले चर $K$ का नमूना लें ताकि एक विशेष कुंजी प्राप्त हो सके।

## XOR ऑपरेशन

<chapterId>22f185cc-c516-5b33-950b-0908f2f881fe</chapterId>

सभी कंप्यूटर डेटा को बिट्स के स्तर पर प्रोसेस, स्टोर और नेटवर्क के माध्यम से भेजा जाता है। कंप्यूटर डेटा पर लागू की जाने वाली कोई भी क्रिप्टोग्राफिक योजनाएँ भी बिट-स्तर पर काम करती हैं।

मान लीजिए कि आपने अपने ई-मेल एप्लिकेशन में एक ई-मेल टाइप किया है। जो भी एन्क्रिप्शन आप लागू करते हैं, वह आपके ई-मेल के ASCII अक्षरों पर सीधे नहीं होता। इसके बजाय, यह आपके ई-मेल में अक्षरों और अन्य प्रतीकों के बिट-प्रतिनिधित्व पर लागू होता है।

आधुनिक क्रिप्टोग्राफी के लिए एक महत्वपूर्ण गणितीय ऑपरेशन, मॉड्यूलो ऑपरेशन के अलावा, **XOR ऑपरेशन** या "एक्सक्लूसिव ऑर" ऑपरेशन है। यह ऑपरेशन दो बिट्स को इनपुट के रूप में लेता है और आउटपुट के रूप में एक और बिट देता है। XOR ऑपरेशन को "XOR" के रूप में दर्शाया जाएगा। यह 0 देता है यदि दोनों बिट्स समान हैं और 1 देता है यदि दोनों बिट्स अलग हैं। आप नीचे चार संभावनाएं देख सकते हैं। प्रतीक $\oplus$ "XOR" को दर्शाता है:


- $0 \oplus 0 = 0$ का मतलब है कि जब आप दो शून्य को XOR ऑपरेशन के साथ जोड़ते हैं, तो परिणाम शून्य होता है। XOR ऑपरेशन में, अगर दोनों इनपुट समान होते हैं, तो आउटपुट शून्य होता है।
- $0 \oplus 1 = 1$ का मतलब है कि जब हम 0 और 1 का XOR ऑपरेशन करते हैं, तो परिणाम 1 होता है। XOR ऑपरेशन में, अगर दोनों बिट्स अलग होते हैं, तो परिणाम 1 होता है।
- $1 \oplus 0 = 1$ का मतलब है कि जब आप बाइनरी ऑपरेशन XOR (एक्सक्लूसिव OR) का उपयोग करते हैं, तो 1 और 0 का परिणाम 1 होता है। XOR ऑपरेशन में, अगर दोनों बिट्स अलग होते हैं, तो परिणाम 1 होता है।
- $1 \oplus 1 = 0$ का मतलब है कि जब हम दो बाइनरी अंकों (1 और 1) को XOR ऑपरेशन के तहत जोड़ते हैं, तो परिणाम 0 होता है। XOR ऑपरेशन में, अगर दोनों इनपुट समान होते हैं, तो आउटपुट 0 होता है, और अगर अलग होते हैं, तो आउटपुट 1 होता है।

उदाहरण के लिए, मान लीजिए कि आपके पास एक संदेश $m_1$ (01111001) है और दूसरा संदेश $m_2$ (01011001) है। इन दोनों संदेशों के बीच XOR ऑपरेशन इस प्रकार किया जा सकता है।


- $m_1 \oplus m_2 = 01111001 \oplus 01011001 = 00100000$

यह गणितीय ऑपरेशन बाइनरी संख्या प्रणाली में XOR (एक्सक्लूसिव OR) ऑपरेशन को दर्शाता है। यहाँ पर $m_1$ और $m_2$ दो बाइनरी संख्याएँ हैं, जिनका XOR ऑपरेशन किया गया है। इसका परिणाम $00100000$ है। XOR ऑपरेशन में, जब दो बाइनरी अंकों में से कोई एक '1' होता है, तो परिणाम '1' होता है, अन्यथा '0' होता है।

यह प्रक्रिया सीधी-सादी है। सबसे पहले, आप $m_1$ और $m_2$ के बाएँ से पहले बिट्स को XOR करते हैं। इस मामले में, वह है $0 \oplus 0 = 0$। फिर आप बाएँ से दूसरे जोड़े के बिट्स को XOR करते हैं। इस मामले में, वह है $1 \oplus 1 = 0$। आप इस प्रक्रिया को तब तक जारी रखते हैं जब तक कि आप दाएँ से सबसे अंतिम बिट्स पर XOR ऑपरेशन नहीं कर लेते।

यह देखना आसान है कि XOR ऑपरेशन प्रत्यावर्ती है, यानी $m_1 \oplus m_2 = m_2 \oplus m_1$। इसके अलावा, XOR ऑपरेशन संघटित भी है। मतलब, $(m_1 \oplus m_2) \oplus m_3 = m_1 \oplus (m_2 \oplus m_3)$।

विभिन्न लंबाई की दो स्ट्रिंग्स पर XOR ऑपरेशन का अलग-अलग संदर्भों में अलग-अलग मतलब हो सकता है। यहाँ हम विभिन्न लंबाई की स्ट्रिंग्स पर किसी भी XOR ऑपरेशन की चिंता नहीं करेंगे।

XOR ऑपरेशन उस विशेष स्थिति के बराबर होता है जब बिट्स के जोड़ पर मॉड्यूलो ऑपरेशन किया जाता है और भाजक 2 होता है। आप निम्नलिखित परिणामों में इस समानता को देख सकते हैं:


- $(0 + 0) \mod 2 = 0 \oplus 0 = 0$ का मतलब है कि जब आप 0 और 0 को जोड़ते हैं और उसे 2 से भाग करते हैं, तो शेषफल 0 आता है। इसे XOR ऑपरेशन के रूप में भी लिखा जा सकता है, जहाँ 0 XOR 0 का परिणाम भी 0 होता है।
- $(1 + 0) \bmod 2 = 1 \oplus 0 = 1$ का मतलब है कि जब हम 1 और 0 को जोड़ते हैं और उसका परिणाम 2 से भाग देकर शेष निकालते हैं, तो हमें 1 मिलता है। यह भी दर्शाता है कि 1 और 0 का XOR ऑपरेशन करने पर भी परिणाम 1 होता है।
- $(0 + 1) \mod 2 = 0 \oplus 1 = 1$ का मतलब है कि जब आप 0 और 1 को जोड़ते हैं और उसे 2 से भाग देते हैं, तो शेषफल 1 आता है। इसे XOR ऑपरेशन के रूप में भी लिखा जा सकता है, जो 0 और 1 के लिए 1 होता है।
- $(1 + 1) \mod 2 = 1 \oplus 1 = 0$ का मतलब है कि जब हम 1 और 1 को जोड़ते हैं और उसे 2 से भाग देते हैं, तो बाकी 0 बचता है। इसे XOR ऑपरेशन के रूप में भी लिखा जा सकता है, जहाँ 1 XOR 1 का परिणाम 0 होता है।

## छद्म-यादृच्छिकता

<chapterId>20463fc5-3e92-581f-a1b7-3151279bd95e</chapterId>

हमारी चर्चा में जब हमने रैंडम और यूनिफॉर्म वेरिएबल्स की बात की, तो हमने "रैंडम" और "यूनिफॉर्म" के बीच एक खास अंतर किया। आमतौर पर, जब रैंडम वेरिएबल्स का वर्णन किया जाता है, तो इस अंतर को बनाए रखा जाता है। लेकिन, हमारे वर्तमान संदर्भ में, इस अंतर को छोड़ना जरूरी है और "रैंडम" और "यूनिफॉर्म" को समानार्थी के रूप में इस्तेमाल किया जाता है। मैं इस खंड के अंत में समझाऊंगा कि ऐसा क्यों किया गया है।

शुरुआत करने के लिए, हम एक लंबाई $n$ की बाइनरी स्ट्रिंग को **रैंडम** (या **समान**) कह सकते हैं, अगर यह एक समान वेरिएबल $S$ के नमूने का परिणाम है, जो ऐसी लंबाई $n$ की प्रत्येक बाइनरी स्ट्रिंग को चयन के लिए समान संभावना देता है।

मान लीजिए, उदाहरण के लिए, 8 लंबाई वाले सभी बाइनरी स्ट्रिंग्स का सेट: $\{0000\ 0000, 0000\ 0001, \ldots, 1111\ 1111\}$। (आमतौर पर 8-बिट स्ट्रिंग को दो हिस्सों में लिखा जाता है, जिन्हें **निबल** कहा जाता है।) इस स्ट्रिंग्स के सेट को **$S_8$** कहते हैं।

ऊपर दी गई परिभाषा के अनुसार, हम किसी विशेष 8 लंबाई के बाइनरी स्ट्रिंग को रैंडम (या समान) कह सकते हैं, यदि वह एक समान वेरिएबल $S$ के नमूने का परिणाम था, जो **$S_8$** में प्रत्येक स्ट्रिंग को चयन की समान संभावना देता है। चूंकि सेट **$S_8$** में $2^8$ Elements शामिल हैं, इसलिए नमूने के समय चयन की संभावना सेट में प्रत्येक स्ट्रिंग के लिए $1/2^8$ होनी चाहिए।

बाइनरी स्ट्रिंग की रैंडमनेस का एक मुख्य पहलू यह है कि इसे उस प्रक्रिया के संदर्भ में परिभाषित किया जाता है जिसके द्वारा इसे चुना गया था। इसलिए, किसी विशेष बाइनरी स्ट्रिंग का स्वरूप अपने आप में उसकी चयन में रैंडमनेस के बारे में कुछ भी नहीं बताता।

उदाहरण के लिए, बहुत से लोगों को सहज रूप से यह लगता है कि $1111\ 1111$ जैसी स्ट्रिंग को यादृच्छिक रूप से नहीं चुना जा सकता। लेकिन यह स्पष्ट रूप से गलत है।

एक समान चर $S$ को 8 लंबाई वाले सभी बाइनरी स्ट्रिंग्स पर परिभाषित करते हुए, सेट **$S_8$** से $1111\ 1111$ चुनने की संभावना उतनी ही है जितनी कि $0111\ 0100$ जैसे स्ट्रिंग की। इसलिए, आप केवल स्ट्रिंग का विश्लेषण करके उसकी रैंडमनेस के बारे में कुछ नहीं कह सकते।

हम बाइनरी स्ट्रिंग्स के अलावा भी रैंडम स्ट्रिंग्स की बात कर सकते हैं। उदाहरण के लिए, हम एक रैंडम हेक्स स्ट्रिंग $AF\ 02\ 82$ की बात कर सकते हैं। इस स्थिति में, यह स्ट्रिंग सभी 6 लंबाई वाली हेक्स स्ट्रिंग्स के सेट से रैंडम रूप से चुनी गई होगी। यह 24 लंबाई वाली बाइनरी स्ट्रिंग को रैंडम रूप से चुनने के बराबर है, क्योंकि हर हेक्स अंक 4 बिट्स का प्रतिनिधित्व करता है।

आमतौर पर "एक रैंडम स्ट्रिंग" का मतलब होता है बिना किसी विशेषता के, एक ऐसी स्ट्रिंग जो समान लंबाई वाली सभी स्ट्रिंग्स के सेट से रैंडम तरीके से चुनी गई हो। मैंने इसे ऊपर इसी तरह से वर्णित किया है। एक लंबाई $n$ की स्ट्रिंग को, निश्चित रूप से, किसी अन्य सेट से भी रैंडम तरीके से चुना जा सकता है। उदाहरण के लिए, ऐसा सेट जो केवल लंबाई $n$ की सभी स्ट्रिंग्स का एक उपसमुच्चय हो, या शायद ऐसा सेट जिसमें विभिन्न लंबाई की स्ट्रिंग्स शामिल हों। इन मामलों में, हालांकि, हम इसे "रैंडम स्ट्रिंग" नहीं कहेंगे, बल्कि "एक स्ट्रिंग जो किसी सेट **S** से रैंडम तरीके से चुनी गई है" कहेंगे।

क्रिप्टोग्राफी में एक महत्वपूर्ण अवधारणा है छद्म-यादृच्छिकता (pseudorandomness)। एक **छद्म-यादृच्छिक स्ट्रिंग** जिसकी लंबाई $n$ है, ऐसा प्रतीत होता है जैसे यह एक समान चर $S$ के नमूने का परिणाम है, जो **$S_n$** में प्रत्येक स्ट्रिंग को चयन के लिए समान संभावना देता है। लेकिन वास्तव में, यह स्ट्रिंग एक समान चर $S'$ के नमूने का परिणाम है, जो केवल एक संभाव्यता वितरण को परिभाषित करता है—जो जरूरी नहीं कि सभी संभावित परिणामों के लिए समान संभावनाएं हो—**$S_n$** के एक उपसमुच्चय पर। यहां महत्वपूर्ण बात यह है कि कोई भी वास्तव में $S$ और $S'$ के नमूनों के बीच अंतर नहीं कर सकता, भले ही आप उनमें से कई लें।

मान लीजिए, उदाहरण के लिए, एक यादृच्छिक चर $S$ है। इसका परिणाम सेट **$S_{256}$** है, जो 256 लंबाई के सभी बाइनरी स्ट्रिंग्स का सेट है। इस सेट में $2^{256}$ तत्व होते हैं। प्रत्येक तत्व के चुने जाने की संभावना समान होती है, जो कि $1/2^{256}$ होती है, जब हम नमूना लेते हैं।

इसके अलावा, मान लीजिए एक यादृच्छिक चर $S'$ है। इसका परिणाम सेट केवल $2^{128}$ बाइनरी स्ट्रिंग्स को शामिल करता है, जिनकी लंबाई 256 है। इन स्ट्रिंग्स पर इसका कुछ प्रायिकता वितरण है, लेकिन यह वितरण जरूरी नहीं कि समान हो।

मान लीजिए कि मैंने अब $S$ से हजारों नमूने लिए और $S'$ से भी हजारों नमूने लिए और इन दोनों सेटों के परिणाम आपको दे दिए। मैं आपको बताता हूँ कि कौन सा परिणाम किस रैंडम वेरिएबल से जुड़ा है। इसके बाद, मैं इन दो रैंडम वेरिएबल्स में से एक से एक नमूना लेता हूँ। लेकिन इस बार मैं आपको नहीं बताता कि मैंने किस रैंडम वेरिएबल से नमूना लिया। अगर $S'$ छद्म-रैंडम होता, तो विचार यह है कि आपके सही अनुमान लगाने की संभावना कि मैंने किस रैंडम वेरिएबल से नमूना लिया, लगभग 1/2 से बेहतर नहीं होगी।

आमतौर पर, एक छद्म-यादृच्छिक (pseudorandom) स्ट्रिंग की लंबाई $n$ होती है, जिसे $n - x$ आकार की स्ट्रिंग को यादृच्छिक रूप से चुनकर और उसे एक विस्तारक एल्गोरिदम के लिए इनपुट के रूप में उपयोग करके तैयार किया जाता है, जहाँ $x$ एक धनात्मक पूर्णांक है। इस यादृच्छिक स्ट्रिंग को, जिसका आकार $n - x$ होता है, **seed** के नाम से जाना जाता है।

छद्म-यादृच्छिक स्ट्रिंग्स क्रिप्टोग्राफी को व्यावहारिक बनाने के लिए एक महत्वपूर्ण अवधारणा हैं। उदाहरण के लिए, स्ट्रीम सिफर को लें। एक स्ट्रीम सिफर में, एक यादृच्छिक रूप से चुनी गई कुंजी को एक विस्तारक एल्गोरिदम में डाला जाता है ताकि एक बहुत बड़ी छद्म-यादृच्छिक स्ट्रिंग बनाई जा सके। फिर इस छद्म-यादृच्छिक स्ट्रिंग को प्लेनटेक्स्ट के साथ XOR ऑपरेशन के माध्यम से जोड़ा जाता है ताकि एक सिफरटेक्स्ट उत्पन्न हो सके।

अगर हम इस तरह के छद्म-यादृच्छिक स्ट्रिंग को स्ट्रीम सिफर के लिए उत्पन्न करने में असमर्थ होते, तो हमें सुरक्षा के लिए एक ऐसा कुंजी चाहिए होता जो संदेश जितनी लंबी हो। ज्यादातर मामलों में यह बहुत व्यावहारिक विकल्प नहीं है।

इस खंड में जिस छद्म-यादृच्छिकता की अवधारणा पर चर्चा की गई है, उसे अधिक औपचारिक रूप से परिभाषित किया जा सकता है। यह अन्य संदर्भों में भी विस्तारित होती है। लेकिन हमें यहां उस चर्चा में जाने की आवश्यकता नहीं है। क्रिप्टोग्राफी के अधिकांश हिस्से को समझने के लिए आपको बस इतना जानना है कि एक यादृच्छिक और एक छद्म-यादृच्छिक स्ट्रिंग में क्या अंतर होता है।

हमारी चर्चा में "रैंडम" और "यूनिफॉर्म" के बीच के अंतर को हटाने का कारण अब स्पष्ट होना चाहिए। व्यवहार में, हर कोई उस स्ट्रिंग को दर्शाने के लिए "प्सूडोरैंडम" शब्द का उपयोग करता है, जो ऐसा प्रतीत होता है **जैसे** वह एक यूनिफॉर्म वेरिएबल $S$ के सैंपलिंग का परिणाम हो। सख्ती से कहें तो, हमें ऐसी स्ट्रिंग को "प्सूडो-यूनिफॉर्म" कहना चाहिए, जैसा कि हमने पहले की भाषा में अपनाया था। चूंकि "प्सूडो-यूनिफॉर्म" शब्द बोझिल है और कोई इसका उपयोग नहीं करता, हम इसे स्पष्टता के लिए यहां पेश नहीं करेंगे। इसके बजाय, हम वर्तमान संदर्भ में "रैंडम" और "यूनिफॉर्म" के बीच के अंतर को हटा देते हैं।

**नोट्स**

अगर आप इन विषयों पर अधिक औपचारिक जानकारी चाहते हैं, तो आप Katz और Lindell की किताब *Introduction to Modern Cryptography* देख सकते हैं, खासकर अध्याय 3।

# क्रिप्टोग्राफी के गणितीय आधार 2

<partId>d7245cc9-bb6d-5403-b3d5-9c703d9a2f81</partId>

## संख्या सिद्धांत गणित की एक शाखा है जो संख्याओं, विशेष रूप से पूर्णांकों और उनकी विशेषताओं का अध्ययन करती है। इसमें गुणनखंड, अभाज्य संख्याएँ, सम और विषम संख्याएँ, और संख्याओं के बीच के संबंध शामिल होते हैं। संख्या सिद्धांत का उपयोग कई गणितीय समस्याओं को हल करने में किया जाता है और यह गणित का एक बहुत ही रोचक और महत्वपूर्ण क्षेत्र है।

<chapterId>c0051c34-fd5d-539c-93e2-5c6dfd4c3355</chapterId>

यह अध्याय गणितीय नींव पर आधारित एक अधिक उन्नत विषय को कवर करता है: संख्या सिद्धांत। संख्या सिद्धांत सममित क्रिप्टोग्राफी (जैसे कि Rijndael सिफर में) के लिए महत्वपूर्ण है, लेकिन यह सार्वजनिक कुंजी क्रिप्टोग्राफिक सेटिंग में विशेष रूप से महत्वपूर्ण है।

यदि आपको संख्या सिद्धांत के विवरण जटिल लग रहे हैं, तो मैं सुझाव दूंगा कि पहली बार में इसे ऊपरी तौर पर पढ़ें। आप हमेशा बाद में इसे फिर से देख सकते हैं।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आप **संख्या सिद्धांत** को पूर्णांकों और उन पर काम करने वाले गणितीय कार्यों के गुणों के अध्ययन के रूप में वर्णित कर सकते हैं।

मान लीजिए कि दो संख्याएँ $a$ और $N$ **को-प्राइम्स** (या **सापेक्ष अभाज्य**) होती हैं यदि उनका महत्तम समापवर्तक 1 होता है। अब मान लीजिए कि हमारे पास एक विशेष पूर्णांक $N$ है। कितनी संख्याएँ $N$ से छोटी हैं जो $N$ के साथ को-प्राइम्स हैं? क्या हम इस प्रश्न के उत्तर के बारे में कुछ सामान्य बातें कह सकते हैं? ये वे सामान्य प्रकार के प्रश्न हैं जिनका उत्तर संख्या सिद्धांत देने की कोशिश करता है।

आधुनिक संख्या सिद्धांत अमूर्त बीजगणित के उपकरणों पर निर्भर करता है। **अमूर्त बीजगणित** गणित की एक उपशाखा है, जहाँ विश्लेषण के मुख्य विषय अमूर्त वस्तुएँ होती हैं जिन्हें बीजगणितीय संरचनाएँ कहा जाता है। एक **बीजगणितीय संरचना** एक सेट होती है जो एक या अधिक क्रियाओं के साथ जुड़ी होती है, और जो कुछ निश्चित स्वयंसिद्धों को पूरा करती है। बीजगणितीय संरचनाओं के माध्यम से, गणितज्ञ विशेष गणितीय समस्याओं की गहरी समझ प्राप्त कर सकते हैं, क्योंकि वे समस्याओं के विवरण से परे जाकर उनके सार को समझने की कोशिश करते हैं।

अमूर्त बीजगणित के क्षेत्र को कभी-कभी आधुनिक बीजगणित भी कहा जाता है। आप **अमूर्त गणित** (या **शुद्ध गणित**) की अवधारणा से भी परिचित हो सकते हैं। यह दूसरा शब्द अमूर्त बीजगणित का संदर्भ नहीं है, बल्कि इसका मतलब है गणित का अध्ययन केवल उसके अपने लिए करना, न कि केवल संभावित उपयोगों को ध्यान में रखते हुए।

अमूर्त बीजगणित में सेट्स कई प्रकार की वस्तुओं से निपट सकते हैं, जैसे एक समबाहु त्रिभुज पर आकार-संरक्षण परिवर्तन से लेकर वॉलपेपर पैटर्न तक। संख्या सिद्धांत के लिए, हम केवल Elements के सेट्स पर विचार करते हैं जो पूर्णांक या उन कार्यों को शामिल करते हैं जो पूर्णांकों के साथ काम करते हैं।

## समूह

<chapterId>3209b270-f9cd-5224-803e-0ed19fbf7826</chapterId>

गणित में एक बुनियादी अवधारणा होती है Elements का सेट। एक सेट को आमतौर पर आकोलेड चिन्हों के साथ दर्शाया जाता है, जिसमें Elements को कॉमा से अलग किया जाता है।

उदाहरण के लिए, सभी पूर्णांकों का सेट $\{…, -2, -1, 0, 1, 2, …\}$ है। यहाँ पर जो बिंदु-बिंदु दिए गए हैं, उनका मतलब है कि एक विशेष पैटर्न एक दिशा में जारी रहता है। तो सभी पूर्णांकों के सेट में $3, 4, 5, 6$ और इसी तरह आगे के अंक शामिल होते हैं, साथ ही $-3, -4, -5, -6$ और इसी तरह पीछे के अंक भी शामिल होते हैं। इस सभी पूर्णांकों के सेट को आमतौर पर $\mathbb{Z}$ द्वारा दर्शाया जाता है।

एक और सेट का उदाहरण है $\mathbb{Z} \mod 11$, या सभी पूर्णांकों का सेट जो 11 से मॉड्यूलो हैं। पूरे सेट $\mathbb{Z}$ के विपरीत, इस सेट में केवल सीमित संख्या में तत्व होते हैं, जो हैं $\{0, 1, \ldots, 9, 10\}$।

एक आम गलती यह समझना है कि सेट $\mathbb{Z} \mod 11$ वास्तव में $\{-10, -9, \ldots, 0, \ldots, 9, 10\}$ होता है। लेकिन ऐसा नहीं है, जैसा कि हमने पहले मॉड्यूलो ऑपरेशन को परिभाषित किया था। कोई भी नकारात्मक पूर्णांक जब 11 से मॉड्यूलो किया जाता है, तो वह $\{0, 1, \ldots, 9, 10\}$ पर आ जाता है। उदाहरण के लिए, $-2 \mod 11$ का परिणाम $9$ होता है, जबकि $-27 \mod 11$ का परिणाम $5$ होता है।

गणित में एक और बुनियादी अवधारणा है द्विआधारी संक्रिया की। यह कोई भी ऐसी संक्रिया होती है जो दो संख्याओं को लेकर तीसरी संख्या उत्पन्न करती है। उदाहरण के लिए, बुनियादी अंकगणित और बीजगणित से, आप चार मुख्य द्विआधारी संक्रियाओं से परिचित होंगे: जोड़, घटाव, गुणा, और भाग।

ये दो बुनियादी गणितीय अवधारणाएँ, सेट्स और बाइनरी ऑपरेशन्स, का उपयोग समूह की धारणा को परिभाषित करने के लिए किया जाता है, जो अमूर्त बीजगणित में सबसे महत्वपूर्ण संरचना है।

मान लीजिए कि हमारे पास कोई द्विआधारी ऑपरेशन $\circ$ है। इसके अलावा, मान लीजिए कि हमारे पास Elements नामक कुछ सेट **S** है, जो इस ऑपरेशन से लैस है। यहाँ "लैस" होने का मतलब बस इतना है कि सेट **S** में किसी भी दो Elements के बीच ऑपरेशन $\circ$ किया जा सकता है।

संयोजन $\langle \mathbf{S}, \circ \rangle$ को **समूह** कहा जाता है यदि यह चार विशेष शर्तों को पूरा करता है, जिन्हें समूह स्वयंसिद्ध कहा जाता है।

1. किसी भी $a$ और $b$ के लिए जो $\mathbf{S}$ के Elements हैं, $a \circ b$ भी $\mathbf{S}$ का एक तत्व होता है। इसे **समापन शर्त** कहा जाता है।

यदि $a$, $b$, और $c$ $\mathbf{S}$ के Elements हैं, तो यह होता है कि $(a \circ b) \circ c = a \circ (b \circ c)$। इसे **सहयोगिता शर्त** के रूप में जाना जाता है।

3. $\mathbf{S}$ में एक अद्वितीय तत्व $e$ होता है, ऐसा कि $\mathbf{S}$ के हर तत्व $a$ के लिए निम्नलिखित समीकरण सही होता है: $e \circ a = a \circ e = a$। चूंकि ऐसा केवल एक ही तत्व $e$ होता है, इसे **पहचान तत्व** कहा जाता है। इस शर्त को **पहचान शर्त** के रूप में जाना जाता है।

4. प्रत्येक तत्व $a$ के लिए जो $\mathbf{S}$ में है, एक तत्व $b$ $\mathbf{S}$ में मौजूद होता है, जिससे निम्नलिखित समीकरण सत्य होता है: $a \circ b = b \circ a = e$, जहाँ $e$ पहचान तत्व है। यहाँ तत्व $b$ को **उल्टा तत्व** कहा जाता है, और इसे सामान्यतः $a^{-1}$ के रूप में दर्शाया जाता है। इस शर्त को **उल्टा शर्त** या **उलटनीयता शर्त** कहा जाता है।

आइए समूहों को थोड़ा और विस्तार से समझते हैं। सभी पूर्णांकों के सेट को $\mathbb{Z}$ से दर्शाते हैं। यह सेट जब सामान्य जोड़ के साथ, या $\langle \mathbb{Z}, + \rangle$, लिया जाता है, तो यह स्पष्ट रूप से समूह की परिभाषा में फिट बैठता है, क्योंकि यह चारों नियमों को पूरा करता है।

1. किसी भी $x$ और $y$ के लिए जो $\mathbb{Z}$ के Elements हैं, $x + y$ भी $\mathbb{Z}$ का एक तत्व होता है। इसलिए $\langle \mathbb{Z}, + \rangle$ समापन शर्त को पूरा करता है।

किसी भी $x$, $y$, और $z$ के लिए जो $\mathbb{Z}$ के Elements हैं, $(x + y) + z = x + (y + z)$ होता है। इसलिए $\langle \mathbb{Z}, + \rangle$ एसोसिएटिविटी की शर्त को पूरा करता है।

3. $\langle \mathbb{Z}, + \rangle$ में एक पहचान तत्व होता है, जो कि 0 है। किसी भी $x$ के लिए जो $\mathbb{Z}$ में है, यह सत्य होता है कि: $0 + x = x + 0 = x$। इसलिए $\langle \mathbb{Z}, + \rangle$ पहचान शर्त को पूरा करता है।

4. अंत में, प्रत्येक तत्व $x$ के लिए जो $\mathbb{Z}$ में है, एक $y$ होता है ताकि $x + y = y + x = 0$ हो जाए। उदाहरण के लिए, यदि $x$ 10 होता, तो $y$ $-10$ होता (यदि $x$ 0 होता, तो $y$ भी 0 होता)। इस प्रकार $\langle \mathbb{Z}, + \rangle$ उल्टा शर्त को पूरा करता है।

महत्वपूर्ण बात यह है कि पूर्णांकों का सेट जोड़ के साथ एक समूह बनाता है, इसका मतलब यह नहीं है कि यह गुणा के साथ भी एक समूह बनाता है। आप इसे $\langle \mathbb{Z}, \cdot \rangle$ को चार समूह स्वयंसिद्धों के खिलाफ जांचकर सत्यापित कर सकते हैं (जहां $\cdot$ का मतलब सामान्य गुणा है)।

पहले दो स्वयंसिद्ध सत्य स्पष्ट रूप से सही हैं। इसके अलावा, गुणा के तहत तत्व 1 पहचान तत्व के रूप में काम कर सकता है। किसी भी पूर्णांक $x$ को 1 से गुणा करने पर वही $x$ प्राप्त होता है। हालांकि, $\langle \mathbb{Z}, \cdot \rangle$ प्रतिलोम शर्त को पूरा नहीं करता है। अर्थात, हर $x$ के लिए $\mathbb{Z}$ में कोई अद्वितीय तत्व $y$ नहीं है, ताकि $x \cdot y = 1$ हो सके।

मान लीजिए कि $x = 22$ है। अब सवाल यह है कि $\mathbb{Z}$ सेट से कौन सी $y$ की वैल्यू $x$ के साथ गुणा करने पर पहचान तत्व 1 देगी? $1/22$ की वैल्यू काम करेगी, लेकिन यह $\mathbb{Z}$ सेट में नहीं है। वास्तव में, यह समस्या किसी भी पूर्णांक $x$ के लिए आती है, सिवाय 1 और -1 के (जहां $y$ को क्रमशः 1 और -1 होना पड़ेगा)।

यदि हम अपने सेट के लिए वास्तविक संख्याओं की अनुमति दें, तो हमारी समस्याएँ काफी हद तक गायब हो जाती हैं। सेट में किसी भी तत्व $x$ के लिए, $1/x$ से गुणा करने पर 1 प्राप्त होता है। चूंकि भिन्न वास्तविक संख्याओं के सेट में शामिल हैं, इसलिए हर वास्तविक संख्या के लिए एक व्युत्क्रम पाया जा सकता है। अपवाद शून्य है, क्योंकि शून्य के साथ किसी भी गुणा से कभी भी पहचान तत्व 1 प्राप्त नहीं होगा। इसलिए, गैर-शून्य वास्तविक संख्याओं का सेट, गुणा के साथ, वास्तव में एक समूह है।

कुछ समूह एक पाँचवीं सामान्य शर्त को पूरा करते हैं, जिसे **परिवर्तनीयता शर्त** के रूप में जाना जाता है। यह शर्त इस प्रकार है:


- मान लीजिए कि हमारे पास एक समूह $G$ है, जिसमें एक सेट **S** और एक द्विआधारी ऑपरेटर $\circ$ है। मान लीजिए कि $a$ और $b$ **S** के Elements हैं। अगर ऐसा होता है कि किसी भी दो Elements $a$ और $b$ के लिए $a \circ b = b \circ a$ होता है, तो $G$ समापवर्तनीयता की शर्त को पूरा करता है।

कोई भी समूह जो क्रमविनिमय की शर्त को पूरा करता है, उसे **क्रमविनिमय समूह** या **एबेलियन समूह** कहा जाता है (यह नाम नील्स हेनरिक एबेल के नाम पर रखा गया है)। यह आसानी से देखा जा सकता है कि वास्तविक संख्याओं का सेट जोड़ के साथ और पूर्णांकों का सेट जोड़ के साथ एबेलियन समूह होते हैं। पूर्णांकों का सेट गुणा के साथ समूह नहीं होता, इसलिए यह एबेलियन समूह भी नहीं हो सकता। इसके विपरीत, शून्य के अलावा वास्तविक संख्याओं का सेट गुणा के साथ भी एक एबेलियन समूह होता है।

आपको संकेतों के दो महत्वपूर्ण नियमों का ध्यान रखना चाहिए। पहला, संकेत “+” या “×” का अक्सर समूह संचालन को दर्शाने के लिए उपयोग किया जाएगा, भले ही Elements वास्तव में संख्याएँ न हों। इन मामलों में, आपको इन संकेतों को सामान्य अंकगणितीय जोड़ या गुणा के रूप में नहीं समझना चाहिए। इसके बजाय, ये संचालन केवल इन अंकगणितीय क्रियाओं के साथ एक अमूर्त समानता रखते हैं।

जब तक आप विशेष रूप से अंकगणितीय जोड़ या गुणा की बात नहीं कर रहे हैं, तब तक समूह संचालन के लिए $\circ$ और $\diamond$ जैसे प्रतीकों का उपयोग करना आसान होता है, क्योंकि इनका कोई विशेष सांस्कृतिक अर्थ नहीं होता है।

दूसरा, जिस तरह "+" और "×" का उपयोग अक्सर गैर-अंकगणितीय क्रियाओं को दर्शाने के लिए किया जाता है, उसी तरह समूहों के पहचान तत्व Elements को अक्सर "0" और "1" से दर्शाया जाता है, भले ही इन समूहों में Elements संख्याएँ न हों। जब तक आप किसी समूह के पहचान तत्व को संख्याओं के साथ संदर्भित नहीं कर रहे हैं, तब तक पहचान तत्व को दर्शाने के लिए "$e$" जैसे अधिक तटस्थ प्रतीक का उपयोग करना आसान होता है।

गणित में कई अलग-अलग और बहुत महत्वपूर्ण मानों के समूह होते हैं जिनमें कुछ द्विआधारी संचालन होते हैं। हालांकि, क्रिप्टोग्राफिक अनुप्रयोग केवल पूर्णांकों के सेट या कम से कम Elements के साथ काम करते हैं जो पूर्णांकों द्वारा वर्णित होते हैं, यानी संख्या सिद्धांत के क्षेत्र के भीतर। इसलिए, पूर्णांकों के अलावा वास्तविक संख्याओं वाले सेट क्रिप्टोग्राफिक अनुप्रयोगों में उपयोग नहीं किए जाते हैं।

चलो अंत में Elements का एक उदाहरण देते हैं जिसे "पूर्णांकों द्वारा वर्णित" किया जा सकता है, भले ही वे पूर्णांक न हों। एक अच्छा उदाहरण है एलिप्टिक कर्व्स के बिंदु। हालांकि एलिप्टिक कर्व पर कोई भी बिंदु स्पष्ट रूप से पूर्णांक नहीं होता, लेकिन ऐसा बिंदु वास्तव में दो पूर्णांकों द्वारा वर्णित होता है।

अंडाकार वक्र, उदाहरण के लिए, Bitcoin के लिए बहुत महत्वपूर्ण हैं। किसी भी मानक Bitcoin निजी और सार्वजनिक कुंजी जोड़ी को उन बिंदुओं के सेट से चुना जाता है जो निम्नलिखित अंडाकार वक्र द्वारा परिभाषित होते हैं:

$$
x^3 + 7 = y^2 \mod 2^{256} – 2^{32} – 29 – 28 – 27 – 26 - 24 - 1
$$

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। $2^{256}$ से कम सबसे बड़ा अभाज्य संख्या है। $x$-निर्देशांक आपका निजी कुंजी है और $y$-निर्देशांक आपकी सार्वजनिक कुंजी है।

Bitcoin में लेन-देन आमतौर पर एक या अधिक सार्वजनिक कुंजियों के लिए आउटपुट को लॉक करने से संबंधित होते हैं। इन लेन-देन से प्राप्त मूल्य को फिर संबंधित निजी कुंजियों के साथ डिजिटल हस्ताक्षर बनाकर अनलॉक किया जा सकता है।

## चक्रवर्ती समूह

<chapterId>bfa5c714-7952-5fef-88b1-ca5b07edd886</chapterId>

हम एक बड़ा अंतर यह कर सकते हैं कि एक **ससीम समूह** और एक **असीम समूह** के बीच। ससीम समूह में Elements की संख्या सीमित होती है, जबकि असीम समूह में Elements की संख्या असीमित होती है। किसी भी ससीम समूह में Elements की संख्या को समूह का **क्रम** कहा जाता है। सभी व्यावहारिक क्रिप्टोग्राफी जो समूहों के उपयोग पर निर्भर करती है, वह ससीम (संख्यात्मक) समूहों पर आधारित होती है।

सार्वजनिक कुंजी क्रिप्टोग्राफी में, एक विशेष प्रकार के सीमित एबेलियन समूह जिन्हें चक्रीय समूह कहा जाता है, बहुत महत्वपूर्ण होते हैं। चक्रीय समूहों को समझने के लिए, हमें पहले समूह तत्वों की घातांक की अवधारणा को समझना होगा।

मान लीजिए कि $G$ एक समूह है जिसमें समूह संचालन $\circ$ है, और $a$ इस समूह का एक तत्व है। तब $a^n$ का अर्थ है कि $a$ को स्वयं के साथ कुल $n – 1$ बार मिलाया गया है। उदाहरण के लिए, $a^2$ का मतलब है $a \circ a$, और $a^3$ का मतलब है $a \circ a \circ a$, और इसी तरह आगे। (ध्यान दें कि यहाँ घातांक का अर्थ सामान्य अंकगणितीय घातांक जैसा नहीं है।)

चलो एक उदाहरण की ओर चलते हैं। मान लीजिए कि $G = \langle \mathbb{Z} \mod 7, + \rangle$, और हमारा $a$ का मान 4 है। इस स्थिति में, $a^2 = [4 + 4 \mod 7] = [8 \mod 7] = 1 \mod 7$ होगा। दूसरी ओर, $a^4$ का अर्थ होगा $[4 + 4 + 4 + 4 \mod 7] = [16 \mod 7] = 2 \mod 7$।

कुछ एबेलियन समूहों में एक या अधिक Elements होते हैं, जो निरंतर घातांक के माध्यम से अन्य सभी समूह Elements उत्पन्न कर सकते हैं। इन Elements को **जनरेटर** या **प्राथमिक Elements** कहा जाता है।

ऐसे समूहों का एक महत्वपूर्ण वर्ग $\langle \mathbb{Z}^* \mod N, \cdot \rangle$ है, जहाँ $N$ एक अभाज्य संख्या है। यहाँ $\mathbb{Z}^*$ का अर्थ है कि समूह में सभी गैर-शून्य, सकारात्मक पूर्णांक शामिल होते हैं जो $N$ से छोटे होते हैं। इसलिए, ऐसे समूह में हमेशा $N – 1$ तत्व होते हैं।

उदाहरण के लिए, मान लीजिए $G = \langle \mathbb{Z}^* \mod 11, \cdot \rangle$। इस समूह में निम्नलिखित Elements हैं: $\{1, 2, 3, 4, 5, 6, 7, 8, 9, 10\}$। इस समूह का क्रम 10 है (जो वास्तव में $11 – 1$ के बराबर है)।

आइए इस समूह के तत्व 2 को घातांकित करने का अन्वेषण करें। $2^{12}$ तक की गणनाएँ नीचे दिखाई गई हैं। ध्यान दें कि समीकरण के बाईं ओर, घातांक समूह तत्व के घातांक को संदर्भित करता है। हमारे विशेष उदाहरण में, यह वास्तव में समीकरण के दाईं ओर अंकगणितीय घातांक को शामिल करता है (लेकिन इसमें, उदाहरण के लिए, जोड़ भी शामिल हो सकता था)। स्पष्ट करने के लिए, मैंने दाईं ओर घातांक रूप के बजाय दोहराई गई क्रिया को लिखा है।


- \(2^1 = 2 \mod 11\) का मतलब है कि जब 2 को 11 से भाग दिया जाता है, तो शेषफल 2 होता है।
- \(2^2 = 2 \times 2 \mod 11 = 4 \mod 11\)
- \(2^3 = 2 \times 2 \times 2 \mod 11 = 8 \mod 11\)
- $2^4 = 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 16 \mod 11 = 5 \mod 11$ का मतलब है कि जब हम 2 को चार बार खुद से गुणा करते हैं, तो हमें 16 मिलता है। फिर, जब हम 16 को 11 से भाग देते हैं, तो शेष 5 आता है। इसलिए, $2^4 \mod 11$ का परिणाम 5 होता है।
- $2^5 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 32 \mod 11 = 10 \mod 11$ का मतलब है कि जब आप 2 को 5 बार खुद से गुणा करते हैं, तो आपको 32 मिलता है। अब, 32 को 11 से भाग देने पर जो शेष बचता है, वह 10 होता है। इसलिए, $2^5 \mod 11$ का परिणाम 10 है।
- $2^6 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 64 \mod 11 = 9 \mod 11$ का मतलब है कि जब हम 2 को 6 बार खुद से गुणा करते हैं, तो हमें 64 मिलता है। अब, 64 को 11 से भाग देने पर शेषफल 9 आता है। इसलिए, $2^6$ को 11 से मॉड्यूलो करने पर परिणाम 9 होता है।
- \(2^7\) का मतलब है 2 को 7 बार अपने आप से गुणा करना, यानी \(2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2\). जब हम इसे 11 से भाग देते हैं, तो हमें शेषफल 7 मिलता है। इसलिए \(2^7 \mod 11 = 7\).
- $2^8 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 256 \mod 11 = 3 \mod 11$

इसका मतलब है कि जब हम 2 को 8 बार गुणा करते हैं, तो हमें 256 मिलता है। अब, अगर हम 256 को 11 से भाग करते हैं, तो शेषफल 3 आता है। इसलिए, $2^8$ को 11 से भाग देने पर शेष 3 होता है।
- $2^9 = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 512 \mod 11 = 6 \mod 11$

इसका मतलब है कि जब हम 2 को 9 बार गुणा करते हैं, तो हमें 512 मिलता है। फिर, जब हम 512 को 11 से भाग देते हैं, तो शेष 6 आता है। इसलिए, $2^9$ को 11 से भाग देने पर शेषफल 6 होता है।
- \(2^{10}\) का मतलब है 2 को 10 बार अपने आप से गुणा करना। जब हम इसे 11 से भाग देते हैं, तो हमें शेषफल 1 मिलता है। यानी \(2^{10} \mod 11 = 1\) होता है।
- $2^{11} = 2 \times 2 \times 2 \times 2 \times 2 \times 2 \times 2 \times 2 \times 2 \times 2 \times 2 \mod 11 = 2048 \mod 11 = 2 \mod 11$
- $2^{12} = 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \cdot 2 \mod 11 = 4096 \mod 11 = 4 \mod 11$

इसका मतलब है कि जब हम 2 को 12 बार गुणा करते हैं, तो हमें 4096 मिलता है। अब, अगर हम 4096 को 11 से भाग करते हैं, तो शेषफल 4 आता है। इसलिए, $2^{12}$ को 11 से भाग देने पर शेषफल 4 होता है।

अगर आप ध्यान से देखें, तो आप देख सकते हैं कि जब हम तत्व 2 पर घातांक लगाते हैं, तो यह $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ के सभी Elements को निम्नलिखित क्रम में चक्रित करता है: 2, 4, 8, 5, 10, 9, 7, 3, 6, 1। जब $2^{10}$ के बाद भी तत्व 2 पर घातांक लगाना जारी रखते हैं, तो यह फिर से सभी Elements को उसी क्रम में चक्रित करता है। इसलिए, तत्व 2 $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ में एक जनरेटर है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। 

हालांकि $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ समूह के कई जनरेटर होते हैं, लेकिन इस समूह के सभी Elements जनरेटर नहीं होते। उदाहरण के लिए, तत्व 3 को लें। पहले 10 घातांक के माध्यम से चलते हुए, बिना जटिल गणनाओं को दिखाए, निम्नलिखित परिणाम प्राप्त होते हैं:


- \(3^1 = 3 \mod 11\) का मतलब है कि जब 3 को 11 से भाग दिया जाता है, तो शेषफल 3 होता है।
- \(3^2 = 9 \mod 11\) का मतलब है कि जब 3 का वर्ग यानी 9 को 11 से भाग दिया जाता है, तो शेषफल 9 आता है। यहाँ पर \(3^2\) का मतलब 3 का वर्ग है, जो 9 होता है। और \( \mod 11\) का मतलब है कि 9 को 11 से भाग देने पर जो शेष बचेगा, वह 9 ही होगा।
- \(3^3\) को 11 से भाग देने पर शेषफल 5 आता है।
- \(3^4\) को 11 से भाग देने पर शेषफल 4 आता है।
- \(3^5 \equiv 1 \mod 11\) का मतलब है कि जब \(3\) को \(5\) बार गुणा किया जाता है, तो उसका परिणाम \(11\) से भाग देने पर शेष \(1\) आता है।
- \(3^6\) को 11 से भाग देने पर शेषफल 3 आता है।
- \(3^7\) को 11 से भाग देने पर शेषफल 9 आता है।
- \(3^8\) को 11 से भाग देने पर शेषफल 5 आता है।
- \(3^9\) को 11 से भाग देने पर शेषफल 4 आता है।
- \(3^{10} \equiv 1 \mod 11\) का मतलब है कि जब \(3^{10}\) को 11 से विभाजित किया जाता है, तो शेषफल 1 आता है।

11 के मापांक में $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ के सभी मानों के बजाय, जब हम तत्व 3 का घातांक करते हैं, तो यह केवल कुछ विशेष मानों तक ही सीमित रहता है: 3, 9, 5, 4, और 1। पांचवीं बार घातांक करने के बाद, ये मान दोहराने लगते हैं।

हम अब एक **चक्रवर्ती समूह** को उस समूह के रूप में परिभाषित कर सकते हैं जिसमें कम से कम एक जनक (जनरेटर) होता है। इसका मतलब है कि समूह में कम से कम एक ऐसा तत्व होता है जिससे आप घातांक के माध्यम से समूह के सभी अन्य तत्व Elements उत्पन्न कर सकते हैं।

आपने हमारे ऊपर दिए गए उदाहरण में देखा होगा कि $2^{10}$ और $3^{10}$ दोनों ही $1 \mod 11$ के बराबर हैं। वास्तव में, हम गणनाएँ नहीं करेंगे, लेकिन समूह $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ के किसी भी तत्व को 10 की घात तक बढ़ाने पर परिणाम $1 \mod 11$ ही होगा। ऐसा क्यों होता है?

इसका कारण यह है कि Fermat's Little Theorem के अनुसार, यदि $p$ एक अभाज्य संख्या है और $a$ एक ऐसा पूर्णांक है जो $p$ से विभाज्य नहीं है, तो $a^{p-1} \equiv 1 \mod p$ होता है। यहाँ $p = 11$ है, जो कि एक अभाज्य संख्या है, और $\mathbb{Z}^* \mod 11$ में सभी तत्व 11 से विभाज्य नहीं हैं। इसलिए, $a^{10} \equiv 1 \mod 11$ सभी $a$ के लिए सही है जो $\mathbb{Z}^* \mod 11$ में हैं। यही कारण है कि 10 की घात तक बढ़ाने पर परिणाम $1 \mod 11$ होता है।

यह एक महत्वपूर्ण सवाल है, लेकिन इसका जवाब देने में थोड़ी मेहनत लगती है।

शुरुआत करते हैं, मान लीजिए दो धनात्मक पूर्णांक $a$ और $N$ हैं। संख्या सिद्धांत में एक महत्वपूर्ण प्रमेय कहता है कि $a$ का एक गुणात्मक प्रतिलोम $N$ के मापांक में होता है (अर्थात, एक पूर्णांक $b$ ऐसा कि $a \cdot b = 1 \mod N$) तब और केवल तब जब $a$ और $N$ का महत्तम समापवर्तक 1 हो। अर्थात, यदि $a$ और $N$ परस्पर अभाज्य हैं।

तो, किसी भी पूर्णांकों के समूह में जब हम गुणा को $N$ के मापांक के साथ जोड़ते हैं, तो केवल वे छोटे पूर्णांक जो $N$ के साथ सहप्राइम होते हैं, उस सेट में शामिल होते हैं। हम इस सेट को $\mathbb{Z}^c \mod N$ द्वारा दर्शा सकते हैं।

मान लीजिए कि $N$ 10 है। केवल पूर्णांक 1, 3, 7, और 9 ही 10 के साथ सहप्राइम हैं। इसलिए सेट $\mathbb{Z}^c \mod 10$ में केवल $\{1, 3, 7, 9\}$ शामिल हैं। आप 1 से 10 के बीच के किसी अन्य पूर्णांक का उपयोग करके 10 के मापांक के साथ पूर्णांक गुणा का समूह नहीं बना सकते। इस विशेष समूह के लिए, उल्टे जोड़े 1 और 9, तथा 3 और 7 हैं।

जब $N$ स्वयं एक अभाज्य संख्या (prime) हो, तो 1 से लेकर $N – 1$ तक के सभी पूर्णांक $N$ के साथ सहाभाज्य (coprime) होते हैं। इस प्रकार के समूह का क्रम $N – 1$ होता है। हमारे पहले के संकेतों का उपयोग करते हुए, $\mathbb{Z}^c \mod N$ तब $\mathbb{Z}^* \mod N$ के बराबर होता है जब $N$ अभाज्य हो। हमारे पहले के उदाहरण में चुना गया समूह, $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$, इस प्रकार के समूहों का एक विशेष उदाहरण है।

अगला, फ़ंक्शन $\phi(N)$ एक संख्या $N$ तक के सभी सहमूल्यांक (coprimes) की संख्या की गणना करता है, और इसे **यूलर का फ़ाई फ़ंक्शन** कहा जाता है। [1] **यूलर के प्रमेय** के अनुसार, जब भी दो पूर्णांक $a$ और $N$ सहमूल्यांक होते हैं, तो निम्नलिखित सत्य होता है:


- $a^{\phi(N)} \bmod N = 1 \bmod N$ का मतलब है कि जब आप $a$ को $\phi(N)$ बार गुणा करते हैं और फिर उसे $N$ से भाग देते हैं, तो शेषफल 1 आता है। यहाँ $\phi(N)$, ऑयलर का टोटिएंट फंक्शन है, जो $N$ से छोटे उन संख्याओं की संख्या बताता है जो $N$ के साथ सह-प्राइम हैं। यह गणितीय प्रमेय फर्मा के लघु प्रमेय का एक सामान्यीकरण है।

इसका एक महत्वपूर्ण प्रभाव उन समूहों की श्रेणी के लिए है $\langle \mathbb{Z}^* \mod N, \cdot \rangle$ जहाँ $N$ एक अभाज्य संख्या है। इन समूहों के लिए, समूह तत्व का घातांक गणितीय घातांक का प्रतिनिधित्व करता है। अर्थात, $a^{\phi(N)} \mod N$ गणितीय क्रिया $a^{\phi(N)} \mod N$ का प्रतिनिधित्व करता है। चूंकि इन गुणात्मक समूहों में कोई भी तत्व $a$ और $N$ परस्पर अभाज्य होते हैं, इसका मतलब है कि $a^{\phi(N)} \mod N = a^{N – 1} \mod N = 1 \mod N$।

ऑयलर का प्रमेय एक बहुत महत्वपूर्ण परिणाम है। सबसे पहले, यह बताता है कि $\langle \mathbb{Z}^* \mod N, \cdot \rangle$ में सभी Elements केवल उन मूल्यों के माध्यम से चक्रीय रूप से जा सकते हैं जो $N – 1$ को विभाजित करते हैं। $\langle \mathbb{Z}^* \mod 11, \cdot \rangle$ के मामले में, इसका मतलब है कि प्रत्येक तत्व केवल 2, 5, या 10 Elements के माध्यम से चक्रीय रूप से जा सकता है। जिस समूह के मूल्यों के माध्यम से कोई तत्व घातांक के द्वारा चक्रीय रूप से जाता है, उसे उस तत्व का **क्रम** कहा जाता है। एक तत्व जिसका क्रम समूह के क्रम के बराबर होता है, उसे जनरेटर कहा जाता है।

इसके अलावा, ऑयलर का प्रमेय यह दर्शाता है कि हम हमेशा $a^{N – 1} \mod N$ का परिणाम जान सकते हैं, जब भी कोई समूह $\langle \mathbb{Z}^* \mod N, \cdot \rangle$ हो, जहाँ $N$ एक अभाज्य संख्या है। यह बात सही है, चाहे वास्तविक गणनाएँ कितनी भी जटिल क्यों न हों।

मान लीजिए कि हमारा समूह $\mathbb{Z}^* \mod 160,481,182$ है (जहाँ 160,481,182 वास्तव में एक अभाज्य संख्या है)। हमें पता है कि इस समूह के लिए सभी पूर्णांक 1 से 160,481,181 तक Elements होने चाहिए, और $\phi(n) = 160,481,181$ है। हालांकि हम सभी गणना के चरण नहीं कर सकते, हमें पता है कि $514^{160,481,181}$, $2,005^{160,481,181}$, और $256,212^{160,481,181}$ जैसे अभिव्यक्तियों का मान $1 \mod 160,481,182$ होना चाहिए।

**नोट्स:**

[1] यह फ़ंक्शन इस प्रकार काम करता है। कोई भी पूर्णांक $N$ को अभाज्य संख्याओं के गुणनफल के रूप में विभाजित किया जा सकता है। मान लीजिए कि किसी विशेष $N$ को इस प्रकार विभाजित किया गया है: $p_1^{e1} \cdot p_2^{e2} \cdot \ldots \cdot p_m^{em}$ जहाँ सभी $p$ अभाज्य संख्याएँ हैं और सभी $e$ ऐसे पूर्णांक हैं जो 1 या उससे अधिक हैं। तब:

$$
\phi(N) = \sum_{i=1}^m \left[p_i^{e_i} - p_i^{e_i - 1}\right]
$$

यदि \( N \) का अभाज्य गुणनखंडन (prime factorization) दिया गया है, तो ऑयलर का फ़ाई फ़ंक्शन \(\phi(N)\) को निम्नलिखित सूत्र से निकाला जा सकता है:

\[
\phi(N) = N \left(1 - \frac{1}{p_1}\right) \left(1 - \frac{1}{p_2}\right) \cdots \left(1 - \frac{1}{p_k}\right)
\]

यहाँ \( p_1, p_2, \ldots, p_k \) \( N \) के अभाज्य गुणनखंड हैं। इस सूत्र का मतलब यह है कि आप \( N \) को उसके सभी अभाज्य गुणनखंडों के साथ घटाते हुए \( \phi(N) \) की गणना कर सकते हैं।

## आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

<chapterId>fad52d86-3a22-5c9f-979e-3bec9eaa008e</chapterId>

एक समूह (ग्रुप) अमूर्त बीजगणित में बुनियादी बीजगणितीय संरचना है, लेकिन इसके अलावा और भी कई हैं। आपको जिस दूसरी बीजगणितीय संरचना से परिचित होना चाहिए, वह है **फील्ड**, विशेष रूप से **ससीम फील्ड**। इस प्रकार की बीजगणितीय संरचना का उपयोग अक्सर क्रिप्टोग्राफी में किया जाता है, जैसे कि एडवांस्ड एन्क्रिप्शन स्टैंडर्ड में। यह मुख्य सममित एन्क्रिप्शन योजना है जिससे आप व्यवहार में सामना करेंगे।

एक क्षेत्र (field) की अवधारणा समूह (group) से उत्पन्न होती है। विशेष रूप से, एक **क्षेत्र** Elements **S** का एक सेट होता है, जिसमें दो द्विआधारी ऑपरेटर $\circ$ और $\diamond$ होते हैं, जो निम्नलिखित शर्तों को पूरा करते हैं:

1. **S** सेट, $\circ$ ऑपरेशन के साथ, एक एबेलियन समूह है।

समूह **S** को $\diamond$ के साथ "गैर-शून्य" Elements के लिए एक एबेलियन समूह के रूप में प्रशिक्षित किया गया है।

समूह **S** को दो ऑपरेटरों के साथ इस तरह से तैयार किया गया है कि यह वितरणात्मक शर्त को पूरा करता है: मान लीजिए कि $a$, $b$, और $c$ **S** के Elements हैं। तब **S** दो ऑपरेटरों के साथ वितरणात्मक गुण को पूरा करता है जब $a \circ (b \diamond c) = (a \circ b) \diamond (a \circ c)$ होता है।

ध्यान दें कि, जैसे समूहों के साथ होता है, वैसे ही क्षेत्र की परिभाषा भी बहुत अमूर्त होती है। यह **S** में Elements के प्रकारों के बारे में या $\circ$ और $\diamond$ ऑपरेशनों के बारे में कोई दावा नहीं करती। यह बस यह कहती है कि एक क्षेत्र कोई भी Elements का सेट होता है जिसमें दो ऑपरेशन होते हैं और जिसके लिए ऊपर दिए गए तीन शर्तें पूरी होती हैं। (दूसरे एबेलियन समूह में "शून्य" तत्व को अमूर्त रूप से समझा जा सकता है।)

तो किसी क्षेत्र का उदाहरण क्या हो सकता है? एक अच्छा उदाहरण है सेट $\mathbb{Z} \mod 7$, या $\{0, 1, \ldots, 6\}$, जो सामान्य जोड़ (ऊपर $\circ$ की जगह) और सामान्य गुणा (ऊपर $\diamond$ की जगह) के साथ परिभाषित होता है।

पहले, $\mathbb{Z} \mod 7$ जोड़ के लिए एक एबेलियन समूह होने की शर्त को पूरा करता है, और यह गुणा के लिए एक एबेलियन समूह होने की शर्त को पूरा करता है यदि आप केवल गैर-शून्य Elements को ध्यान में रखते हैं। दूसरा, इस सेट का दो ऑपरेटरों के साथ संयोजन वितरणीय शर्त को पूरा करता है।

इन दावों की जांच करना शिक्षाप्रद रूप से फायदेमंद है, खासकर जब हम कुछ विशेष मानों का उपयोग करें। चलिए 5, 2, और 3 जैसे प्रयोगात्मक मान लेते हैं, जो कि सेट $\mathbb{Z} \mod 7$ से कुछ यादृच्छिक रूप से चुने गए Elements हैं, ताकि क्षेत्र $\langle \mathbb{Z} \mod 7, +, \cdot \rangle$ का निरीक्षण किया जा सके। हम इन तीन मानों का क्रम में उपयोग करेंगे, जब भी विशेष परिस्थितियों की जांच करने की आवश्यकता होगी।

चलो पहले यह जांचते हैं कि क्या $\mathbb{Z} \mod 7$ को जोड़ के साथ एक एबेलियन समूह माना जा सकता है। 

$\mathbb{Z} \mod 7$ का मतलब है कि हम संख्याओं को 7 से भाग देने के बाद जो शेष बचता है, उन पर काम कर रहे हैं। इसमें 0 से 6 तक की संख्याएँ शामिल होती हैं। 

अब, एक समूह बनने के लिए कुछ शर्तें पूरी करनी होती हैं:

1. **क्लोजर (Closure):** अगर हम दो संख्याओं को जोड़ते हैं, तो परिणाम भी उसी सेट में होना चाहिए। उदाहरण के लिए, अगर हम 3 और 5 को जोड़ते हैं, तो हमें 8 मिलता है। लेकिन 8 को 7 से भाग देने पर शेष 1 आता है, जो कि हमारे सेट में है। इसलिए क्लोजर की शर्त पूरी होती है।

2. **एसोसिएटिविटी (Associativity):** जोड़ने की प्रक्रिया एसोसिएटिव होनी चाहिए, यानी $(a + b) + c = a + (b + c)$। चूंकि यह गुण सामान्य जोड़ में भी होता है, इसलिए यह शर्त भी पूरी होती है।

3. **आइडेंटिटी एलिमेंट (Identity Element):** एक ऐसा तत्व होना चाहिए जो किसी भी संख्या के साथ जोड़ने पर वही संख्या दे। यहाँ 0 ऐसा तत्व है, क्योंकि $a + 0 = a$।

4. **इनवर्स एलिमेंट (Inverse Element):** हर संख्या का एक इनवर्स होना चाहिए, जो उसे जोड़ने पर आइडेंटिटी एलिमेंट दे। उदाहरण के लिए, 3 का इनवर्स 4 है, क्योंकि $3 + 4 = 7 \equiv 0 \mod 7$।

5. **कम्युटेटिविटी (Commutativity):** जोड़ने की प्रक्रिया कम्युटेटिव होनी चाहिए, यानी $a + b = b + a$। यह गुण भी सामान्य जोड़ में होता है।

इन सभी शर्तों के पूरा होने के कारण $\mathbb{Z} \mod 7$ जोड़ के साथ एक एबेलियन समूह है।

1. **समापन शर्त**: चलिए 5 और 2 को हमारे मान के रूप में लेते हैं। इस स्थिति में, $[5 + 2] \mod 7 = 7 \mod 7 = 0$। यह वास्तव में $\mathbb{Z} \mod 7$ का एक तत्व है, इसलिए परिणाम समापन शर्त के साथ संगत है।

2. **सहसंयोजन की शर्त**: चलिए 5, 2, और 3 को हमारे मान के रूप में लेते हैं। इस स्थिति में, $[(5 + 2) + 3] \mod 7 = [5 + (2 + 3)] \mod 7 = 10 \mod 7 = 3$। यह सहसंयोजन की शर्त के अनुरूप है।

3. **पहचान शर्त**: चलिए 5 को हमारी संख्या मान लेते हैं। इस स्थिति में, $[5 + 0] \mod 7 = [0 + 5] \mod 7 = 5$। तो 0 जोड़ के लिए पहचान तत्व लगता है।

4. **उल्टा शर्त**: 5 का उल्टा मान लीजिए। यह होना चाहिए कि $[5 + d] \mod 7 = 0$, किसी $d$ के मान के लिए। इस स्थिति में, $\mathbb{Z} \mod 7$ से वह अनोखा मान जो इस शर्त को पूरा करता है, वह 2 है।

5. **सम्प्रत्ययता की शर्त**: चलिए 5 और 3 को हमारे मान के रूप में लेते हैं। इस स्थिति में, $[5 + 3] \mod 7 = [3 + 5] \mod 7 = 1$। यह सम्प्रत्ययता की शर्त के अनुरूप है।

समूह $\mathbb{Z} \mod 7$ को जब जोड़ के साथ देखा जाता है, तो यह स्पष्ट रूप से एक एबेलियन समूह लगता है। अब आइए देखें कि क्या $\mathbb{Z} \mod 7$ को गुणा के साथ, सभी गैर-शून्य तत्वों के लिए, एक एबेलियन समूह माना जा सकता है।

1. **समापन शर्त**: चलिए 5 और 2 को अपनी मान लेते हैं। इस स्थिति में, $[5 \cdot 2] \mod 7 = 10 \mod 7 = 3$। यह भी $\mathbb{Z} \mod 7$ का एक तत्व है, इसलिए परिणाम समापन शर्त के साथ संगत है।

2. **सहसंयोजन की शर्त**: चलिए 5, 2, और 3 को हमारे मान के रूप में लेते हैं। इस स्थिति में, $[(5 \cdot 2) \cdot 3] \mod 7 = [5 \cdot (2 \cdot 3)] \mod 7 = 30 \mod 7 = 2$। यह सहसंयोजन की शर्त के साथ संगत है।

3. **पहचान शर्त**: मान लीजिए कि हमारा मान 5 है। इस स्थिति में, $[5 \cdot 1] \mod 7 = [1 \cdot 5] \mod 7 = 5$। तो 1 गुणा के लिए पहचान तत्व लगता है।

4. **उल्टा शर्त**: 5 का उल्टा मान लें। यह होना चाहिए कि $[5 \cdot d] \mod 7 = 1$, किसी $d$ के मान के लिए। $\mathbb{Z} \mod 7$ से जो अनोखा मान इस शर्त को पूरा करता है, वह 3 है। यह उल्टा शर्त के साथ संगत है।

5. **सम्प्रत्ययता की शर्त**: चलिए 5 और 3 को हमारे मान के रूप में लेते हैं। इस स्थिति में, $[5 \cdot 3] \mod 7 = [3 \cdot 5] \mod 7 = 15 \mod 7 = 1$। यह सम्प्रत्ययता की शर्त के अनुरूप है।

समूह $\mathbb{Z} \mod 7$ स्पष्ट रूप से एक एबेलियन समूह के नियमों को पूरा करता है जब इसे या तो जोड़ या गुणा के साथ जोड़ा जाता है, बशर्ते कि हम शून्य को छोड़ दें।

आखिरकार, यह सेट दोनों ऑपरेटरों के साथ मिलकर वितरणीय शर्त को पूरा करता हुआ लगता है। चलिए 5, 2, और 3 को हमारे मान के रूप में लेते हैं। हम देख सकते हैं कि $[5 \cdot (2 + 3)] \mod 7 = [5 \cdot 2 + 5 \cdot 3] \mod 7 = 25 \mod 7 = 4$।

हमने अब देखा है कि $\mathbb{Z} \mod 7$, जब इसे जोड़ और गुणा के साथ देखा जाता है, तो यह एक सीमित क्षेत्र (finite field) के लिए आवश्यक नियमों को पूरा करता है, जब हम इसे कुछ विशेष मानों के साथ जांचते हैं। बेशक, हम इसे सामान्य रूप से भी दिखा सकते हैं, लेकिन यहाँ हम ऐसा नहीं करेंगे।

एक मुख्य अंतर दो प्रकार के क्षेत्रों के बीच होता है: सीमित क्षेत्र और असीमित क्षेत्र।

एक **अनंत क्षेत्र** एक ऐसा क्षेत्र होता है जहाँ सेट **S** अनंत रूप से बड़ा होता है। वास्तविक संख्याओं का सेट $\mathbb{R}$, जिसे जोड़ और गुणा के साथ जोड़ा जाता है, एक अनंत क्षेत्र का उदाहरण है। एक **ससीम क्षेत्र**, जिसे **गैल्वा क्षेत्र** भी कहा जाता है, एक ऐसा क्षेत्र होता है जहाँ सेट **S** ससीम होता है। हमारे ऊपर दिए गए उदाहरण $\langle \mathbb{Z} \mod 7, +, \cdot \rangle$ एक ससीम क्षेत्र का उदाहरण है।

क्रिप्टोग्राफी में, हम मुख्य रूप से सीमित क्षेत्रों (finite fields) में रुचि रखते हैं। सामान्यतः, यह दिखाया जा सकता है कि एक सीमित क्षेत्र किसी सेट **S** के लिए तभी मौजूद होता है जब उसमें $p^m$ तत्व होते हैं, जहाँ $p$ एक अभाज्य संख्या (prime number) है और $m$ एक धनात्मक पूर्णांक (positive integer) है जो एक या उससे अधिक हो। दूसरे शब्दों में, यदि किसी सेट **S** का क्रम (order) एक अभाज्य संख्या ($p^m$ जहाँ $m = 1$) या किसी अभाज्य शक्ति ($p^m$ जहाँ $m > 1$) के रूप में है, तो आप दो ऑपरेटर $\circ$ और $\diamond$ पा सकते हैं जिससे क्षेत्र के लिए आवश्यक शर्तें पूरी होती हैं।

अगर किसी सीमित क्षेत्र में Elements की संख्या एक अभाज्य संख्या है, तो उसे **प्राइम फील्ड** कहा जाता है। अगर सीमित क्षेत्र में Elements की संख्या एक अभाज्य घातांक है, तो उस क्षेत्र को **विस्तार क्षेत्र** कहा जाता है। क्रिप्टोग्राफी में, हम प्राइम और विस्तार दोनों क्षेत्रों में रुचि रखते हैं।

क्रिप्टोग्राफी में मुख्य रूप से जिन प्राइम फील्ड्स में रुचि होती है, वे वे होते हैं जहाँ सभी पूर्णांक संख्याओं का सेट किसी प्राइम संख्या से मोड्यूलो किया जाता है, और ऑपरेटर सामान्य जोड़ और गुणा होते हैं। इस प्रकार के सीमित फील्ड्स में $\mathbb{Z} \mod 2$, $\mathbb{Z} \mod 3$, $\mathbb{Z} \mod 5$, $\mathbb{Z} \mod 7$, $\mathbb{Z} \mod 11$, $\mathbb{Z} \mod 13$, आदि शामिल होते हैं। किसी भी प्राइम फील्ड $\mathbb{Z} \mod p$ के लिए, फील्ड के पूर्णांकों का सेट इस प्रकार होता है: $\{0, 1, \ldots, p – 2, p – 1\}$।

क्रिप्टोग्राफी में, हम विस्तार क्षेत्रों में भी रुचि रखते हैं, विशेष रूप से ऐसे क्षेत्र जिनमें $2^m$ Elements होता है जहाँ $m > 1$ होता है। ऐसे सीमित क्षेत्र, उदाहरण के लिए, रिजनडेल सिफर में उपयोग किए जाते हैं, जो एडवांस्ड एन्क्रिप्शन स्टैंडर्ड का आधार बनता है। जबकि प्राइम फील्ड्स को समझना अपेक्षाकृत आसान होता है, ये बेस 2 विस्तार क्षेत्र शायद उन लोगों के लिए जटिल हो सकते हैं जो अमूर्त बीजगणित से परिचित नहीं हैं।

शुरुआत करने के लिए, यह सच है कि किसी भी $2^m$ Elements के सेट को दो ऑपरेटर दिए जा सकते हैं, जिससे उनका संयोजन एक क्षेत्र (फील्ड) बन सकता है, बशर्ते $m$ एक धनात्मक पूर्णांक हो। लेकिन, सिर्फ इसलिए कि एक क्षेत्र मौजूद है, इसका मतलब यह नहीं है कि उसे खोजना आसान है या वह कुछ विशेष अनुप्रयोगों के लिए व्यावहारिक है।

जैसा कि पता चलता है, क्रिप्टोग्राफी में $2^m$ के विशेष विस्तार क्षेत्र विशेष रूप से उन बहुपद अभिव्यक्तियों के सेट पर आधारित होते हैं, बजाय कुछ पूर्णांकों के सेट के।

मान लीजिए कि हम एक एक्सटेंशन फील्ड चाहते हैं जिसमें $2^3$ (यानी, 8) Elements शामिल हों। इस आकार के फील्ड के लिए कई अलग-अलग सेट हो सकते हैं, लेकिन एक ऐसा सेट है जिसमें सभी अद्वितीय बहुपद शामिल होते हैं जो इस रूप में होते हैं: $a_2x^2 + a_1x + a_0$, जहाँ प्रत्येक गुणांक $a_i$ या तो 0 होता है या 1। इसलिए, यह सेट **S** निम्नलिखित Elements को शामिल करता है:

1. $0$: यह वह स्थिति है जब $a_2 = 0$, $a_1 = 0$, और $a_0 = 0$ होते हैं।

2. $1$: वह स्थिति जब $a_2 = 0$, $a_1 = 0$, और $a_0 = 1$ हो।

3. $x$: वह स्थिति जब $a_2 = 0$, $a_1 = 1$, और $a_0 = 0$।

4. $x + 1$: यह वह स्थिति है जब $a_2 = 0$, $a_1 = 1$, और $a_0 = 1$ होते हैं।

5. $x^2$: यह वह स्थिति है जब $a_2 = 1$, $a_1 = 0$, और $a_0 = 0$ होते हैं।

6. \(x^2 + 1\): यह वह स्थिति है जहाँ \(a_2 = 1\), \(a_1 = 0\), और \(a_0 = 1\) हैं।

7. \(x^2 + x\): यहाँ \(a_2 = 1\), \(a_1 = 1\), और \(a_0 = 0\) का मामला है।

8. \(x^2 + x + 1\): यहाँ पर \(a_2 = 1\), \(a_1 = 1\), और \(a_0 = 1\) हैं।

तो **S** सेट होगा $\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$। इस Elements सेट पर कौन से दो ऑपरेशन परिभाषित किए जा सकते हैं ताकि उनका संयोजन एक क्षेत्र (field) बन सके?

समूह **S** पर पहला ऑपरेशन ($\circ$) को मानक बहुपद जोड़ के रूप में परिभाषित किया जा सकता है, जिसमें 2 का मापांक लिया जाता है। आपको बस बहुपदों को सामान्य रूप से जोड़ना है, और फिर परिणामी बहुपद के प्रत्येक गुणांक पर 2 का मापांक लागू करना है। यहाँ कुछ उदाहरण दिए गए हैं:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। 

अब इस गणितीय समीकरण को समझते हैं। 

पहले हिस्से में, हमारे पास है \((x^2) + (x^2 + x + 1)\)। इसे हल करने पर हमें \(2x^2 + x + 1\) मिलता है। 

अब, जब हम इसे \(\mod 2\) से लेते हैं, तो \(2x^2\) का भाग शून्य हो जाता है क्योंकि 2 का कोई भी गुणांक \(\mod 2\) में शून्य होता है। 

इसलिए, बचता है \(x + 1\)। 

तो, अंतिम उत्तर है \(x + 1\)।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। 

यह गणितीय समीकरण है: 

$[(x^2 + x) + (x)] \mod 2 = [x^2 + 2x] \mod 2 = x^2$

इसका मतलब है कि जब आप $x^2 + x + x$ को 2 से भाग करते हैं, तो शेषफल $x^2$ होता है। दूसरे शब्दों में, $x^2 + 2x$ को 2 से भाग करने पर भी शेषफल $x^2$ ही होता है।
- आपके पास यह समीकरण है: \([(x + 1) + (x^2 + x + 1)] \mod 2\)

इसे हल करते हैं:

पहले, अंदर के ब्रैकेट को जोड़ते हैं:
\[x + 1 + x^2 + x + 1 = x^2 + 2x + 2\]

अब, इसे \(\mod 2\) के साथ हल करते हैं:
\[x^2 + 2x + 2 \equiv x^2 + 0x + 0 \equiv x^2 \mod 2\]

तो, अंतिम उत्तर है:
\[x^2 + 1\]

सेट **S** पर दूसरा ऑपरेशन ($\diamond$) जो फील्ड बनाने के लिए जरूरी है, थोड़ा जटिल है। यह एक प्रकार का गुणा है, लेकिन यह सामान्य अंकगणितीय गुणा नहीं है। इसके बजाय, आपको प्रत्येक तत्व को एक वेक्टर के रूप में देखना होगा और इस ऑपरेशन को उन दो वेक्टरों के गुणा के रूप में समझना होगा, जो एक अविभाज्य बहुपद के मापांक में होता है।

चलो पहले अपरिवर्तनीय बहुपद के विचार की ओर चलते हैं। एक **अपरिवर्तनीय बहुपद** वह होता है जिसे घटकों में विभाजित नहीं किया जा सकता (जैसे एक अभाज्य संख्या को 1 और स्वयं उस संख्या के अलावा अन्य घटकों में विभाजित नहीं किया जा सकता)। हमारे उद्देश्य के लिए, हम उन बहुपदों में रुचि रखते हैं जो सभी पूर्णांकों के संदर्भ में अपरिवर्तनीय हैं। (ध्यान दें कि आप कुछ बहुपदों को वास्तविक या जटिल संख्याओं के माध्यम से घटकों में विभाजित कर सकते हैं, भले ही आप उन्हें पूर्णांकों का उपयोग करके विभाजित न कर सकें।)

उदाहरण के लिए, बहुपद $x^2 - 3x + 2$ को लें। इसे $(x – 1)(x – 2)$ के रूप में फिर से लिखा जा सकता है। इसलिए, यह अविभाज्य नहीं है। अब बहुपद $x^2 + 1$ पर विचार करें। केवल पूर्णांकों का उपयोग करते हुए, इस अभिव्यक्ति को और अधिक विभाजित करने का कोई तरीका नहीं है। इसलिए, यह पूर्णांकों के संदर्भ में एक अविभाज्य बहुपद है।

अब हम वेक्टर गुणा के विचार की ओर बढ़ते हैं। हम इस विषय को गहराई से नहीं समझेंगे, लेकिन आपको एक बुनियादी नियम समझना होगा: किसी भी वेक्टर का विभाजन तब तक हो सकता है जब तक कि भाजक की डिग्री से लाभांश की डिग्री अधिक या बराबर हो। अगर लाभांश की डिग्री भाजक से कम है, तो लाभांश को भाजक से विभाजित नहीं किया जा सकता।

उदाहरण के लिए, विचार करें अभिव्यक्ति $x^6 + x + 1 \mod x^5 + x^2$। यह स्पष्ट रूप से और घटाया जा सकता है क्योंकि भाजक की डिग्री, 6, भाजक की डिग्री, 5, से अधिक है। अब विचार करें अभिव्यक्ति $x^5 + x + 1 \mod x^5 + x^2$। यह भी और घटाया जा सकता है, क्योंकि भाजक की डिग्री, 5, और भाजक की डिग्री, 5, समान हैं।

अब विचार करें अभिव्यक्ति $x^4 + x + 1 \mod x^5 + x^2$ पर। यह और अधिक नहीं घटेगी, क्योंकि भाजक की डिग्री 5 है और भागफल की डिग्री 4 है, जो कि भाजक की डिग्री से कम है।

इस जानकारी के आधार पर, अब हम सेट $\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$ के लिए अपना दूसरा ऑपरेशन खोजने के लिए तैयार हैं।

मैंने पहले ही कहा है कि दूसरी प्रक्रिया को कुछ अविभाज्य बहुपद के मापांक के तहत वेक्टर गुणा के रूप में समझा जाना चाहिए। यह अविभाज्य बहुपद यह सुनिश्चित करना चाहिए कि दूसरी प्रक्रिया **S** पर एक एबेलियन समूह को परिभाषित करती है और वितरणीय स्थिति के साथ संगत है। तो वह अविभाज्य बहुपद क्या होना चाहिए?

चूंकि इस सेट के सभी वेक्टर डिग्री 2 या उससे कम के हैं, इसलिए अपरिवर्तनीय बहुपद डिग्री 3 का होना चाहिए। यदि सेट के दो वेक्टरों का गुणनफल डिग्री 3 या उससे अधिक का बहुपद देता है, तो हम जानते हैं कि डिग्री 3 के बहुपद से भाग लेने पर हमेशा डिग्री 2 या उससे कम का बहुपद प्राप्त होता है। ऐसा इसलिए होता है क्योंकि डिग्री 3 या उससे अधिक का कोई भी बहुपद हमेशा डिग्री 3 के बहुपद से विभाज्य होता है। इसके अलावा, जो बहुपद भाजक के रूप में कार्य करता है, उसे अपरिवर्तनीय होना चाहिए।

यह पता चला है कि डिग्री 3 के कई अपरिवर्तनीय बहुपद हैं जिन्हें हम अपने भाजक के रूप में उपयोग कर सकते हैं। इन बहुपदों में से प्रत्येक हमारे सेट **S** और 2 के मापांक में जोड़ के साथ मिलकर एक अलग क्षेत्र को परिभाषित करता है। इसका मतलब है कि जब आप क्रिप्टोग्राफी में विस्तार क्षेत्र $2^m$ का उपयोग करते हैं, तो आपके पास कई विकल्प होते हैं।

हमारे उदाहरण के लिए, मान लीजिए कि हमने बहुपद $x^3 + x + 1$ चुना है। यह वास्तव में अविभाज्य है, क्योंकि आप इसे पूर्णांकों का उपयोग करके कारक नहीं बना सकते। इसके अलावा, यह सुनिश्चित करेगा कि दो Elements के गुणन से अधिकतम डिग्री 2 या उससे कम का बहुपद प्राप्त होगा।

आइए, दूसरे ऑपरेशन का एक उदाहरण लेते हैं जिसमें हम बहुपद $x^3 + x + 1$ को भाजक के रूप में इस्तेमाल करेंगे ताकि यह समझ सकें कि यह कैसे काम करता है। मान लीजिए कि आप Elements $x^2 + 1$ को $x^2 + x$ के साथ हमारे सेट **S** में गुणा करते हैं। इसके बाद, हमें इस अभिव्यक्ति की गणना करनी होगी $[(x^2 + 1) \cdot (x^2 + x)] \mod x^3 + x + 1$। इसे निम्नलिखित तरीके से सरल किया जा सकता है:


- इस प्रश्न में हमें \( (x^2 + 1) \cdot (x^2 + x) \) को \( x^3 + x + 1 \) से भाग देकर शेषफल निकालना है।

पहले हम \( (x^2 + 1) \cdot (x^2 + x) \) को विस्तार से लिखते हैं:

\[
(x^2 + 1) \cdot (x^2 + x) = x^2(x^2 + x) + 1(x^2 + x)
\]

\[
= x^4 + x^3 + x^2 + x
\]

अब हमें \( x^4 + x^3 + x^2 + x \) को \( x^3 + x + 1 \) से भाग देना है।

भाग करने पर:

1. \( x^4 \) को \( x^3 \) से भाग दें, हमें \( x \) मिलता है।
2. \( x \cdot (x^3 + x + 1) = x^4 + x^2 + x \)
3. इसे \( x^4 + x^3 + x^2 + x \) से घटाएं:

\[
(x^4 + x^3 + x^2 + x) - (x^4 + x^2 + x) = x^3
\]

अब \( x^3 \) को \( x^3 + x + 1 \) से भाग दें:

1. \( x^3 \) को \( x^3 \) से भाग दें, हमें \( 1 \) मिलता है।
2. \( 1 \cdot (x^3 + x + 1) = x^3 + x + 1 \)
3. इसे \( x^3 \) से घटाएं:

\[
x^3 - (x^3 + x + 1) = -x - 1
\]

इसलिए, शेषफल \( -x - 1 \) है। 

अंततः, \( (x^2 + 1) \cdot (x^2 + x) \mod (x^3 + x + 1) = -x - 1 \) है।
- आपको दिए गए बहुपद को \(x^3 + x + 1\) से भाग देकर शेष निकालना है। 

पहले दिए गए बहुपद को सरल करते हैं:
\[ x^2 \cdot x^2 + x^2 \cdot x + 1 \cdot x^2 + 1 \cdot x = x^4 + x^3 + x^2 + x \]

अब, \(x^4 + x^3 + x^2 + x\) को \(x^3 + x + 1\) से भाग देते हैं।

1. सबसे पहले \(x^4\) को \(x^3\) से भाग दें, जिससे हमें \(x\) मिलेगा।
2. \(x\) को \(x^3 + x + 1\) से गुणा करें:
   \[ x \cdot (x^3 + x + 1) = x^4 + x^2 + x \]

3. अब इसे मूल बहुपद से घटाएं:
   \[ (x^4 + x^3 + x^2 + x) - (x^4 + x^2 + x) = x^3 \]

4. अब \(x^3\) को \(x^3 + x + 1\) से भाग दें, जिससे हमें 1 मिलेगा।
5. 1 को \(x^3 + x + 1\) से गुणा करें:
   \[ 1 \cdot (x^3 + x + 1) = x^3 + x + 1 \]

6. अब इसे शेष से घटाएं:
   \[ x^3 - (x^3 + x + 1) = -x - 1 \]

तो, शेष \( -x - 1 \) है। इसे \(x^3 + x + 1\) के संदर्भ में लिखें तो:
\[ \boxed{-x - 1} \]

यह आपका अंतिम उत्तर है।
- इस प्रश्न में हमें \(x^4 + x^3 + x^2 + x\) को \(x^3 + x + 1\) से भाग देकर शेष निकालना है।

चलिए इसे हल करते हैं:

1. सबसे पहले, \(x^4\) को \(x^3\) से भाग दें। हमें \(x\) मिलेगा।
2. अब \(x\) को \(x^3 + x + 1\) से गुणा करें: \(x \times (x^3 + x + 1) = x^4 + x^2 + x\)।
3. अब इसे \(x^4 + x^3 + x^2 + x\) से घटाएं: 
   \[
   (x^4 + x^3 + x^2 + x) - (x^4 + x^2 + x) = x^3
   \]
4. अब \(x^3\) को \(x^3 + x + 1\) से भाग दें। हमें 1 मिलेगा।
5. अब 1 को \(x^3 + x + 1\) से गुणा करें: \(1 \times (x^3 + x + 1) = x^3 + x + 1\)।
6. अब इसे \(x^3\) से घटाएं:
   \[
   x^3 - (x^3 + x + 1) = -x - 1
   \]

तो, \(x^4 + x^3 + x^2 + x\) को \(x^3 + x + 1\) से भाग देने पर शेष \(-x - 1\) आता है।

हम जानते हैं कि $[x^4 + x^3 + x^2 + x] \mod x^3 + x + 1$ को सरल किया जा सकता है क्योंकि डिविडेंड की डिग्री (4) डिवाइज़र (3) से अधिक है।

शुरू करने के लिए, आप देख सकते हैं कि $x^3 + x + 1$ को $x^4 + x^3 + x^2 + x$ में $x$ बार डाला जा सकता है। आप इसे $x^3 + x + 1$ को $x$ से गुणा करके सत्यापित कर सकते हैं, जो कि $x^4 + x^2 + x$ होता है। चूंकि यह अंतिम पद डिविडेंड के समान डिग्री का है, अर्थात 4, हम जानते हैं कि यह सही है। आप इस विभाजन का शेषफल $x$ द्वारा निम्नलिखित तरीके से गणना कर सकते हैं:


- इस प्रश्न में हमें दिए गए बहुपद के अंतर का एक अन्य बहुपद से मोड्यूलो निकालना है। 

पहले हम दिए गए बहुपद के अंतर को सरल करते हैं:

\[
(x^4 + x^3 + x^2 + x) - (x^4 + x^2 + x) = x^3
\]

अब हमें \(x^3\) को \(x^3 + x + 1\) से मोड्यूलो लेना है। 

जब हम \(x^3\) को \(x^3 + x + 1\) से विभाजित करते हैं, तो शेषफल 0 होगा और शेष \(0\) होगा क्योंकि \(x^3\) और \(x^3 + x + 1\) का उच्चतम घातांक समान है और \(x^3\) को \(x^3 + x + 1\) से घटाने पर शेष 0 आता है।

इसलिए, 

\[
x^3 \mod (x^3 + x + 1) = 0
\]

अतः उत्तर है \(0\)।
- इस प्रश्न में हमें \(x^3\) को \(x^3 + x + 1\) से भाग देकर शेष निकालना है। 

चूंकि \(x^3\) और \(x^3 + x + 1\) का डिग्री समान है, हम \(x^3\) को सीधे \(x^3 + x + 1\) से घटा सकते हैं। 

\[ x^3 - (x^3 + x + 1) = -x - 1 \]

इसलिए, \(x^3\) को \(x^3 + x + 1\) से भाग देने पर शेष \(-x - 1\) होगा। 

अतः, \([x^3] \mod (x^3 + x + 1) = -x - 1\)।
- $x$ का घन (क्यूब)

जब हमने \(x^4 + x^3 + x^2 + x\) को \(x^3 + x + 1\) से \(x\) बार विभाजित किया, तो हमें शेषफल \(x^3\) मिला। अब सवाल यह है कि क्या इस \(x^3\) को \(x^3 + x + 1\) से और विभाजित किया जा सकता है?

चूंकि \(x^3\) का डिग्री \(x^3 + x + 1\) के डिग्री के बराबर है, हम इसे एक बार और विभाजित करने की कोशिश कर सकते हैं। लेकिन ध्यान दें कि \(x^3\) में \(x^3 + x + 1\) के सभी घटक नहीं हैं, इसलिए इसे पूरी तरह से विभाजित नहीं किया जा सकता। इसलिए, \(x^3\ को \(x^3 + x + 1\) से और विभाजित करने पर शेषफल शून्य नहीं होगा।

सहज रूप से, यह कहना आकर्षक हो सकता है कि $x^3$ को $x^3 + x + 1$ से अब और विभाजित नहीं किया जा सकता, क्योंकि बाद वाला पद बड़ा लगता है। हालांकि, हमारे पहले के वेक्टर विभाजन पर चर्चा को याद करें। जब तक भाजक की डिग्री विभाजक के बराबर या उससे बड़ी होती है, तब तक अभिव्यक्ति को और घटाया जा सकता है। विशेष रूप से, $x^3 + x + 1$ को $x^3$ में ठीक 1 बार डाला जा सकता है। शेषफल की गणना इस प्रकार की जाती है:

$$
[(x^3) - (x^3 + x + 1)] \mod x^3 + x + 1 = [x + 1] \mod x^3 + x + 1 = x + 1
$$

आप सोच रहे होंगे कि $(x^3) - (x^3 + x + 1)$ का परिणाम $x + 1$ क्यों आता है, न कि $-x - 1$। याद रखें कि हमारे क्षेत्र में पहला ऑपरेशन मॉड्यूलो 2 के अनुसार परिभाषित है। इसलिए, दो वेक्टरों की घटाव का परिणाम दो वेक्टरों के जोड़ के समान ही होता है।

$x^2 + 1$ और $x^2 + x$ के गुणनफल को संक्षेप में समझें: जब आप इन दोनों पदों को गुणा करते हैं, तो आपको एक डिग्री 4 बहुपद मिलता है, $x^4 + x^3 + x^2 + x$, जिसे $x^3 + x + 1$ से घटाना होता है। यह डिग्री 4 बहुपद $x^3 + x + 1$ से ठीक $x + 1$ बार विभाज्य है। $x^4 + x^3 + x^2 + x$ को $x^3 + x + 1$ से $x + 1$ बार विभाजित करने के बाद शेषफल $x + 1$ होता है। यह वास्तव में हमारे सेट $\{0, 1, x, x + 1, x^2, x^2 + 1, x^2 + x, x^2 + x + 1\}$ का एक तत्व है।

पॉलिनोमियल्स के सेट पर बेस 2 के साथ एक्सटेंशन फील्ड्स क्रिप्टोग्राफी के लिए क्यों उपयोगी हो सकते हैं? इसका कारण यह है कि आप ऐसे सेट के पॉलिनोमियल्स में गुणांक, जो 0 या 1 होते हैं, को एक विशेष लंबाई के बाइनरी स्ट्रिंग्स के रूप में देख सकते हैं। हमारे ऊपर दिए गए उदाहरण में सेट **S** को एक ऐसे सेट **S** के रूप में देखा जा सकता है जिसमें लंबाई 3 के सभी बाइनरी स्ट्रिंग्स शामिल हैं (000 से 111 तक)। फिर **S** पर किए गए ऑपरेशन्स का उपयोग इन बाइनरी स्ट्रिंग्स पर ऑपरेशन्स करने और समान लंबाई की बाइनरी स्ट्रिंग उत्पन्न करने के लिए भी किया जा सकता है।

**नोट्स:**

विस्तार क्षेत्र बहुत ही उलझाऊ हो सकते हैं। जहाँ हम सामान्यतः पूर्णांकों के साथ काम करते हैं, वहाँ ये बहुपदों के सेट के साथ काम करते हैं। इसके अलावा, किसी भी गणना को एक अपरिवर्तनीय बहुपद के मापांक में किया जाता है।

## व्यावहारिक रूप में सारगर्भित बीजगणित

<chapterId>ed35b98d-18b4-5790-9911-1078e0f84f92</chapterId>

हालांकि चर्चा की भाषा औपचारिक और थोड़ी जटिल हो सकती है, लेकिन समूह की अवधारणा को समझना बहुत कठिन नहीं होना चाहिए। यह बस Elements का एक सेट होता है, जिसमें एक द्विआधारी ऑपरेशन होता है, और उस ऑपरेशन के प्रदर्शन पर चार सामान्य शर्तें पूरी होती हैं। एक एबेलियन समूह में बस एक अतिरिक्त शर्त होती है जिसे समापनीयता कहते हैं। एक चक्रीय समूह, बदले में, एक विशेष प्रकार का एबेलियन समूह होता है, जिसमें एक जनरेटर होता है। एक क्षेत्र बस मूल समूह की अवधारणा से एक अधिक जटिल संरचना है।

अगर आप एक व्यावहारिक सोच वाले व्यक्ति हैं, तो आप इस बिंदु पर सोच सकते हैं: इससे क्या फर्क पड़ता है? यह जानने का कि Elements का कोई सेट एक ऑपरेटर के साथ एक समूह है, या यहां तक कि एक एबेलियन या चक्रीय समूह है, क्या इसका वास्तविक दुनिया में कोई महत्व है? यह जानने का कि कुछ एक क्षेत्र है, क्या कोई मायने रखता है?

ज्यादा गहराई में जाए बिना, इसका जवाब "हाँ" है। समूहों की अवधारणा पहली बार 19वीं सदी में फ्रांसीसी गणितज्ञ एवेरिस्ट गैल्वा द्वारा विकसित की गई थी। उन्होंने इनका उपयोग पाँच से अधिक डिग्री वाले बहुपद समीकरणों को हल करने के बारे में निष्कर्ष निकालने के लिए किया था।

तब से समूह की अवधारणा ने गणित और अन्य क्षेत्रों में कई समस्याओं को समझने में मदद की है। उदाहरण के लिए, भौतिक विज्ञानी मरे-गेलमैन ने इसी आधार पर एक कण के अस्तित्व की भविष्यवाणी की थी, जिसे बाद में प्रयोगों में देखा गया। एक और उदाहरण के रूप में, रसायनज्ञ समूह सिद्धांत का उपयोग करके अणुओं के आकार को वर्गीकृत करते हैं। गणितज्ञों ने तो समूह की अवधारणा का उपयोग करके दीवार के कागज जैसी ठोस चीजों के बारे में निष्कर्ष भी निकाले हैं!

मूल रूप से यह दिखाना कि Elements का एक सेट किसी ऑपरेटर के साथ एक समूह है, इसका मतलब है कि आप जो वर्णन कर रहे हैं उसमें एक विशेष प्रकार की समरूपता है। यह समरूपता आमतौर पर समझे जाने वाले अर्थ में नहीं है, बल्कि एक अधिक अमूर्त रूप में है। और यह विशेष प्रणालियों और समस्याओं में महत्वपूर्ण अंतर्दृष्टि प्रदान कर सकती है। अमूर्त बीजगणित की जटिल अवधारणाएं हमें अतिरिक्त जानकारी देती हैं।

सबसे महत्वपूर्ण बात यह है कि आप संख्या सिद्धांत के समूहों और क्षेत्रों के महत्व को व्यवहार में देखेंगे, खासकर क्रिप्टोग्राफी में उनके उपयोग के माध्यम से, विशेष रूप से सार्वजनिक कुंजी क्रिप्टोग्राफी में। हमने पहले ही अपने क्षेत्रों की चर्चा में देखा है कि कैसे विस्तार क्षेत्रों का उपयोग रिजनडेल सिफर में किया जाता है। हम इस उदाहरण को *अध्याय 5* में विस्तार से समझेंगे।

अधिक चर्चा के लिए, मैं Socratica द्वारा बनाई गई अमूर्त बीजगणित पर उत्कृष्ट वीडियो श्रृंखला की सिफारिश करूंगा। मैं विशेष रूप से निम्नलिखित वीडियो की सिफारिश करूंगा: "अमूर्त बीजगणित क्या है?", "समूह की परिभाषा (विस्तारित)", "वृत्त की परिभाषा (विस्तारित)", और "क्षेत्र की परिभाषा (विस्तारित)"। ये चार वीडियो आपको ऊपर की चर्चा में कुछ अतिरिक्त जानकारी देंगे। (हमने वृत्तों पर चर्चा नहीं की, लेकिन एक क्षेत्र सिर्फ एक विशेष प्रकार का वृत्त होता है।)

आधुनिक संख्या सिद्धांत पर और अधिक चर्चा के लिए, आप क्रिप्टोग्राफी पर कई उन्नत चर्चाओं का संदर्भ ले सकते हैं। मैं सुझाव के रूप में Jonathan Katz और Yehuda Lindell की "Introduction to Modern Cryptography" या Christof Paar और Jan Pelzl की "Understanding Cryptography" की सिफारिश करूंगा।

**नोट्स:**

[3] इस [YouTube वीडियो](https://www.youtube.com/watch?v=NOMUnMuxDZY&feature=youtu.be) को देखें।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं। Katz और Lindell की किताब *Introduction to Modern Cryptography* का दूसरा संस्करण 2015 में प्रकाशित हुआ था (CRC प्रेस: बोका रैटन, FL)। वहीं Paar और Pelzl की किताब *Understanding Cryptography* 2010 में प्रकाशित हुई थी (स्प्रिंगर-वर्लाग: बर्लिन)।

# सिमेट्रिक क्रिप्टोग्राफी

<partId>ef768d0e-fe7b-510c-87d6-6febb3de1039</partId>

## एलिस और बॉब

<chapterId>47345330-be2d-5faf-afd0-d289a8d21bf1</chapterId>

क्रिप्टोग्राफी की दो मुख्य शाखाओं में से एक है सममित क्रिप्टोग्राफी। इसमें एन्क्रिप्शन योजनाएँ शामिल होती हैं, साथ ही प्रमाणीकरण और अखंडता से संबंधित योजनाएँ भी होती हैं। 1970 के दशक तक, क्रिप्टोग्राफी पूरी तरह से सममित एन्क्रिप्शन योजनाओं पर ही आधारित थी।

मुख्य चर्चा की शुरुआत सममित एन्क्रिप्शन योजनाओं को देखकर होती है और स्ट्रीम सिफर और ब्लॉक सिफर के बीच महत्वपूर्ण अंतर को समझने से होती है। इसके बाद, हम संदेश प्रमाणीकरण कोड्स की ओर बढ़ते हैं, जो संदेश की अखंडता और प्रामाणिकता सुनिश्चित करने की योजनाएँ हैं। अंत में, हम यह देखते हैं कि सममित एन्क्रिप्शन योजनाओं और संदेश प्रमाणीकरण कोड्स को मिलाकर सुरक्षित संचार कैसे सुनिश्चित किया जा सकता है।

यह अध्याय विभिन्न सममित क्रिप्टोग्राफिक योजनाओं पर संक्षेप में चर्चा करता है। अगला अध्याय व्यावहारिक रूप से स्ट्रीम सिफर और ब्लॉक सिफर के साथ एन्क्रिप्शन का विस्तृत विवरण प्रस्तुत करता है, अर्थात् क्रमशः RC4 और AES।

सिमेट्रिक क्रिप्टोग्राफी पर चर्चा शुरू करने से पहले, मैं इस और आने वाले अध्यायों में एलिस और बॉब के उदाहरणों पर कुछ संक्षिप्त टिप्पणी करना चाहता हूँ।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

क्रिप्टोग्राफी के सिद्धांतों को समझाने के लिए लोग अक्सर एलीस और बॉब के उदाहरणों का उपयोग करते हैं। मैं भी ऐसा ही करूंगा।

अगर आप क्रिप्टोग्राफी में नए हैं, तो यह समझना ज़रूरी है कि एलिस और बॉब के ये उदाहरण सिर्फ क्रिप्टोग्राफिक सिद्धांतों और संरचनाओं को एक सरल तरीके से समझाने के लिए हैं। हालांकि, ये सिद्धांत और संरचनाएँ असल ज़िंदगी के कई और क्षेत्रों में भी लागू होती हैं।

क्रिप्टोग्राफी में एलिस और बॉब से जुड़े उदाहरणों के बारे में ध्यान रखने योग्य पाँच मुख्य बातें निम्नलिखित हैं:

1. इन्हें आसानी से अन्य प्रकार के पात्रों जैसे कंपनियों या सरकारी संगठनों के उदाहरणों में बदला जा सकता है।

उन्हें आसानी से तीन या अधिक कलाकारों को शामिल करने के लिए बढ़ाया जा सकता है।

उदाहरणों में, बॉब और एलिस आमतौर पर प्रत्येक संदेश बनाने और उस पर क्रिप्टोग्राफिक योजनाओं को लागू करने में सक्रिय भागीदार होते हैं। लेकिन वास्तव में, इलेक्ट्रॉनिक संचार ज्यादातर स्वचालित होते हैं। जब आप ट्रांसपोर्ट Layer सुरक्षा का उपयोग करके किसी वेबसाइट पर जाते हैं, तो आमतौर पर क्रिप्टोग्राफी का सारा काम आपके कंप्यूटर और वेब सर्वर द्वारा संभाला जाता है।

4. इलेक्ट्रॉनिक संचार के संदर्भ में, जो "संदेश" संचार चैनल के माध्यम से भेजे जाते हैं, वे आमतौर पर TCP/IP पैकेट होते हैं। ये एक ई-मेल, फेसबुक संदेश, फोन बातचीत, फाइल ट्रांसफर, वेबसाइट, सॉफ्टवेयर अपलोड आदि का हिस्सा हो सकते हैं। ये पारंपरिक अर्थ में संदेश नहीं होते। फिर भी, क्रिप्टोग्राफर अक्सर इस वास्तविकता को सरल बनाते हुए कहते हैं कि संदेश, उदाहरण के लिए, एक ई-मेल है।

5. उदाहरण आमतौर पर इलेक्ट्रॉनिक संचार पर केंद्रित होते हैं, लेकिन इन्हें पारंपरिक संचार के रूपों जैसे पत्रों तक भी बढ़ाया जा सकता है।

## सिमेट्रिक एन्क्रिप्शन स्कीम्स

<chapterId>41bfdbe1-6d41-5272-98bb-81f24b2fd6af</chapterId>

हम एक **सिमेट्रिक एन्क्रिप्शन स्कीम** को ढीले तौर पर इस प्रकार परिभाषित कर सकते हैं कि यह किसी भी क्रिप्टोग्राफिक स्कीम में तीन एल्गोरिदम होते हैं:

1. एक **कुंजी निर्माण एल्गोरिदम**, जो एक निजी कुंजी उत्पन्न करता है।

एक **एन्क्रिप्शन एल्गोरिदम**, जो निजी कुंजी और एक साधारण पाठ को इनपुट के रूप में लेता है और एक गुप्त पाठ (साइफरटेक्स्ट) को आउटपुट के रूप में देता है।

3. एक **डिक्रिप्शन एल्गोरिदम**, जो निजी कुंजी और सिफरटेक्स्ट को इनपुट के रूप में लेता है और मूल प्लेनटेक्स्ट को आउटपुट करता है।

आमतौर पर, एक एन्क्रिप्शन स्कीम - चाहे वह सिमेट्रिक हो या असिमेट्रिक - एक कोर एल्गोरिदम के आधार पर एन्क्रिप्शन के लिए एक खाका प्रदान करती है, बजाय इसके कि वह एक सटीक विनिर्देश दे।

उदाहरण के लिए, Salsa20 को लें, जो एक सममित एन्क्रिप्शन स्कीम है। इसे 128-बिट और 256-बिट दोनों कुंजी लंबाई के साथ इस्तेमाल किया जा सकता है। कुंजी की लंबाई का चुनाव एल्गोरिदम के कुछ छोटे विवरणों को प्रभावित करता है (विशेष रूप से एल्गोरिदम में राउंड की संख्या)।

लेकिन कोई यह नहीं कहेगा कि Salsa20 को 128-बिट की कुंजी के साथ उपयोग करना एक अलग एन्क्रिप्शन योजना है बनिस्बत Salsa20 को 256-बिट की कुंजी के साथ उपयोग करने के। मुख्य एल्गोरिदम वही रहता है। केवल जब मुख्य एल्गोरिदम बदलता है, तब हम वास्तव में दो अलग-अलग एन्क्रिप्शन योजनाओं की बात करेंगे।

सिमेट्रिक एन्क्रिप्शन योजनाएँ आमतौर पर दो प्रकार के मामलों में उपयोगी होती हैं: (1) जब दो या अधिक लोग दूर से बातचीत कर रहे होते हैं और वे अपनी बातचीत की सामग्री को गुप्त रखना चाहते हैं; और (2) जब एक व्यक्ति किसी संदेश की सामग्री को समय के साथ गुप्त रखना चाहता है।

आप *चित्र 1* में स्थिति (1) का चित्रण देख सकते हैं। बॉब एक संदेश $M$ एलिस को भेजना चाहता है, लेकिन वह नहीं चाहता कि कोई और उस संदेश को पढ़ सके।

बॉब सबसे पहले संदेश $M$ को निजी कुंजी $K$ के साथ एन्क्रिप्ट करता है। फिर वह एन्क्रिप्टेड संदेश $C$ को एलिस को भेजता है। जब एलिस को एन्क्रिप्टेड संदेश मिल जाता है, तो वह कुंजी $K$ का उपयोग करके इसे डिक्रिप्ट कर सकती है और मूल संदेश पढ़ सकती है। एक अच्छे एन्क्रिप्शन प्रणाली के साथ, कोई भी हमलावर जो एन्क्रिप्टेड संदेश $C$ को पकड़ लेता है, उसे संदेश $M$ के बारे में कोई महत्वपूर्ण जानकारी नहीं मिलनी चाहिए।

आप *चित्र 2* में स्थिति (2) का चित्रण देख सकते हैं। बॉब चाहता है कि कुछ जानकारी को दूसरों से छुपा कर रखा जाए। एक सामान्य स्थिति यह हो सकती है कि बॉब एक कर्मचारी है जो अपने कंप्यूटर पर संवेदनशील डेटा स्टोर कर रहा है, जिसे न तो बाहरी लोग और न ही उसके सहकर्मी पढ़ सकें।

बॉब समय $T_0$ पर संदेश $M$ को कुंजी $K$ के साथ एन्क्रिप्ट करता है ताकि वह गुप्त संदेश $C$ बना सके। समय $T_1$ पर उसे फिर से संदेश की जरूरत होती है, और वह गुप्त संदेश $C$ को कुंजी $K$ के साथ डिक्रिप्ट करता है। इस बीच में, यदि कोई हमलावर गुप्त संदेश $C$ तक पहुँच भी जाता है, तो उसे $M$ के बारे में कोई महत्वपूर्ण जानकारी नहीं मिलनी चाहिए।

*चित्र 1: स्थान के अनुसार गोपनीयता*

![Figure 1: Secrecy across space](assets/Figure4-1.webp "Figure 1: Secrecy across space")

*चित्र 2: समय के साथ गोपनीयता*

![Figure 2: Secrecy across time](assets/Figure4-2.webp "Figure 2: Secrecy across time")

## एक उदाहरण: शिफ्ट सिफर

<chapterId>7b179ae8-8d15-5e80-a43f-22c970d87b5e</chapterId>

अध्याय 2 में, हमने शिफ्ट सिफर के बारे में जाना, जो एक बहुत ही सरल सममित एन्क्रिप्शन योजना का उदाहरण है। आइए इसे यहां फिर से देखें।

मान लीजिए एक शब्दकोश *D* है जो अंग्रेज़ी वर्णमाला के सभी अक्षरों को क्रम में संख्याओं के सेट $\{0,1,2,\dots,25\}$ के साथ जोड़ता है। एक संभावित संदेशों का सेट **M** मान लीजिए। तब शिफ्ट सिफर एक एन्क्रिप्शन योजना है जो इस प्रकार परिभाषित की जाती है:


- संभावित कुंजियों के सेट **K** से एक कुंजी $k$ को यादृच्छिक रूप से चुनें, जहाँ **K** = $\{0,1,2,\dots,25\}$।
- एक संदेश $m \in$ **M** को निम्नलिखित तरीके से एन्क्रिप्ट करें:
    - $m$ को उसके व्यक्तिगत अक्षरों में अलग करें: $m_0, m_1, \dots, m_i, \dots, m_l$।
    - आपको प्रत्येक $m_i$ को *D* के अनुसार एक संख्या में बदलना है।
    - प्रत्येक $m_i$ के लिए, $c_i = [(m_i + k) \mod 26]$।
    - आपको प्रत्येक $c_i$ को *D* के अनुसार एक अक्षर में बदलना है।
    - फिर $c_0, c_1, \dots, c_l$ को मिलाकर गुप्त संदेश $c$ प्राप्त करें।
- एक गुप्त संदेश $c$ को निम्नलिखित तरीके से डिक्रिप्ट करें:
    - प्रत्येक $c_i$ को *D* के अनुसार एक संख्या में बदलें।
    - प्रत्येक $c_i$ के लिए, $m_i = [(c_i - k) \mod 26]$।
    - आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
    - फिर $m_0, m_1, \dots, m_l$ को मिलाकर मूल संदेश $m$ प्राप्त करें।

शिफ्ट सिफर को एक सममित एन्क्रिप्शन योजना बनाता है कि एन्क्रिप्शन और डिक्रिप्शन दोनों प्रक्रियाओं के लिए एक ही कुंजी का उपयोग किया जाता है। उदाहरण के लिए, मान लीजिए कि आप "DOG" संदेश को शिफ्ट सिफर का उपयोग करके एन्क्रिप्ट करना चाहते हैं, और आपने "24" को एक कुंजी के रूप में यादृच्छिक रूप से चुना। इस कुंजी के साथ संदेश को एन्क्रिप्ट करने पर आपको "BME" मिलेगा। मूल संदेश को पुनः प्राप्त करने का एकमात्र तरीका यही है कि डिक्रिप्शन प्रक्रिया के लिए भी वही कुंजी, "24", का उपयोग किया जाए।

यह शिफ्ट सिफर एक **मोनोअल्फाबेटिक सब्स्टीट्यूशन सिफर** का उदाहरण है: एक एन्क्रिप्शन योजना जिसमें सिफरटेक्स्ट वर्णमाला स्थिर होती है (अर्थात, केवल एक वर्णमाला का उपयोग होता है)। मान लेते हैं कि डिक्रिप्शन एल्गोरिदम निश्चित है, तो सब्स्टीट्यूशन सिफरटेक्स्ट में प्रत्येक प्रतीक अधिकतम एक प्रतीक से संबंधित हो सकता है जो प्लेनटेक्स्ट में होता है।

1700 के दशक तक, एन्क्रिप्शन के कई उपयोग मोनोअल्फाबेटिक सब्स्टीट्यूशन सिफर्स पर बहुत अधिक निर्भर करते थे, हालांकि ये अक्सर शिफ्ट सिफर से कहीं अधिक जटिल होते थे। उदाहरण के लिए, आप प्रत्येक मूल पाठ अक्षर के लिए वर्णमाला से एक अक्षर को यादृच्छिक रूप से चुन सकते थे, इस शर्त के तहत कि प्रत्येक अक्षर सिफरटेक्स्ट वर्णमाला में केवल एक बार ही आता है। इसका मतलब है कि आपके पास 26 फैक्टोरियल संभावित निजी कुंजियाँ होतीं, जो कंप्यूटर युग से पहले बहुत बड़ी संख्या थी।

ध्यान दें कि आप क्रिप्टोग्राफी में **साइफर** शब्द का बहुत बार सामना करेंगे। यह जान लें कि इस शब्द के कई अलग-अलग अर्थ होते हैं। वास्तव में, मैं क्रिप्टोग्राफी के भीतर इस शब्द के कम से कम पांच अलग-अलग अर्थों के बारे में जानता हूँ।

कुछ मामलों में यह एक एन्क्रिप्शन योजना को संदर्भित करता है, जैसे कि शिफ्ट सिफर और मोनोअल्फाबेटिक सब्स्टीट्यूशन सिफर में होता है। हालांकि, यह शब्द विशेष रूप से एन्क्रिप्शन एल्गोरिदम, निजी कुंजी, या किसी भी ऐसी एन्क्रिप्शन योजना के केवल सिफरटेक्स्ट को भी संदर्भित कर सकता है।

अंत में, "साइफर" शब्द का मतलब एक मुख्य एल्गोरिदम से भी हो सकता है, जिससे आप क्रिप्टोग्राफिक योजनाएँ बना सकते हैं। इनमें विभिन्न एन्क्रिप्शन एल्गोरिदम शामिल हो सकते हैं, लेकिन अन्य प्रकार की क्रिप्टोग्राफिक योजनाएँ भी हो सकती हैं। इस अर्थ में यह शब्द ब्लॉक साइफर्स के संदर्भ में महत्वपूर्ण हो जाता है (नीचे "ब्लॉक साइफर्स" अनुभाग देखें)।

आपको **एन्सिफर** या **डिसिफर** जैसे शब्द भी मिल सकते हैं। ये शब्द बस एन्क्रिप्शन और डिक्रिप्शन के पर्यायवाची हैं।

## ब्रूट फोर्स हमले और केरखॉफ का सिद्धांत

<chapterId>2d73ef97-26c5-5d11-8815-0ddbe89c8003</chapterId>

शिफ्ट सिफर एक बहुत ही असुरक्षित सममित एन्क्रिप्शन योजना है, खासकर आज के आधुनिक समय में। [1] एक हमलावर किसी भी सिफरटेक्स्ट को 26 संभावित चाबियों के साथ डिक्रिप्ट करने की कोशिश कर सकता है ताकि यह देखा जा सके कि कौन सा परिणाम समझ में आता है। इस प्रकार के हमले को, जहां हमलावर चाबियों को आजमाकर देखता है कि कौन सी काम करती है, **ब्रूट फोर्स अटैक** या **थकाऊ कुंजी खोज** कहा जाता है।

किसी भी एन्क्रिप्शन योजना को सुरक्षा के न्यूनतम मानक पर खरा उतरने के लिए, उसके पास संभावित कुंजियों का एक सेट, या **कुंजी स्थान** होना चाहिए, जो इतना बड़ा हो कि बलपूर्वक हमले असंभव हो जाएं। सभी आधुनिक एन्क्रिप्शन योजनाएं इस मानक को पूरा करती हैं। इसे **पर्याप्त कुंजी स्थान सिद्धांत** के रूप में जाना जाता है। इसी तरह का सिद्धांत आमतौर पर विभिन्न प्रकार की क्रिप्टोग्राफिक योजनाओं में लागू होता है।

आधुनिक एन्क्रिप्शन योजनाओं में विशाल कुंजी स्थान के आकार को समझने के लिए, मान लीजिए कि एक फाइल को 128-बिट कुंजी के साथ एडवांस्ड एन्क्रिप्शन स्टैंडर्ड का उपयोग करके एन्क्रिप्ट किया गया है। इसका मतलब है कि एक हमलावर के पास $2^{128}$ कुंजियों का सेट है, जिन्हें उसे ब्रूट फोर्स अटैक के लिए आजमाना होगा। इस रणनीति के साथ 0.78% सफलता की संभावना के लिए हमलावर को लगभग $2.65 \times 10^{36}$ कुंजियों को आजमाना पड़ेगा।

मान लीजिए कि हम आशावादी रूप से यह मानते हैं कि एक हमलावर प्रति सेकंड $10^{16}$ कुंजियों की कोशिश कर सकता है (यानी, 10 क्वाड्रिलियन कुंजियाँ प्रति सेकंड)। सभी कुंजियों के 0.78% को जांचने के लिए, उसके हमले को $2.65 \times 10^{20}$ सेकंड तक चलना होगा। यह लगभग 8.4 ट्रिलियन वर्षों के बराबर है। इसलिए, एक अत्यधिक शक्तिशाली विरोधी द्वारा भी एक ब्रूट फोर्स हमला एक आधुनिक 128-बिट एन्क्रिप्शन योजना के साथ वास्तविक नहीं है। यह पर्याप्त कुंजी स्थान सिद्धांत का उदाहरण है।

अगर हमलावर को एन्क्रिप्शन एल्गोरिदम के बारे में नहीं पता है, तो क्या शिफ्ट सिफर ज्यादा सुरक्षित है? शायद, लेकिन ज्यादा नहीं।

किसी भी स्थिति में, आधुनिक क्रिप्टोग्राफी हमेशा यह मानती है कि किसी भी सममित एन्क्रिप्शन योजना की सुरक्षा केवल निजी कुंजी को गुप्त रखने पर निर्भर करती है। यह हमेशा माना जाता है कि हमलावर को बाकी सभी जानकारियाँ मालूम होती हैं, जैसे संदेश का दायरा, कुंजी का दायरा, सिफरटेक्स्ट का दायरा, कुंजी चयन एल्गोरिदम, एन्क्रिप्शन एल्गोरिदम, और डिक्रिप्शन एल्गोरिदम।

यह विचार कि एक सममित एन्क्रिप्शन योजना की सुरक्षा केवल निजी कुंजी की गोपनीयता पर निर्भर कर सकती है, **केर्कहोफ्स के सिद्धांत** के रूप में जाना जाता है।

केर्खॉफ्स द्वारा मूल रूप से जो सिद्धांत प्रस्तुत किया गया था, वह केवल सममित एन्क्रिप्शन योजनाओं पर लागू होता है। हालांकि, इस सिद्धांत का एक अधिक सामान्य संस्करण सभी आधुनिक प्रकार की क्रिप्टोग्राफिक योजनाओं पर भी लागू होता है: किसी भी क्रिप्टोग्राफिक योजना की डिज़ाइन को सुरक्षित रहने के लिए गुप्त रखने की आवश्यकता नहीं होनी चाहिए; गोपनीयता केवल कुछ जानकारी के स्ट्रिंग्स तक ही सीमित हो सकती है, आमतौर पर एक निजी कुंजी।

केर्कहोफ्स का सिद्धांत आधुनिक क्रिप्टोग्राफी में चार कारणों से महत्वपूर्ण है। पहला, कुछ विशेष प्रकार के अनुप्रयोगों के लिए केवल सीमित संख्या में क्रिप्टोग्राफिक योजनाएँ होती हैं। उदाहरण के लिए, अधिकांश आधुनिक सममित एन्क्रिप्शन अनुप्रयोगों में रिजनडेल सिफर का उपयोग होता है। इसलिए, किसी योजना के डिज़ाइन को गुप्त रखने की आपकी क्षमता बहुत सीमित होती है। हालांकि, रिजनडेल सिफर के लिए किसी निजी कुंजी को गुप्त रखने में अधिक लचीलापन होता है।

दूसरा, किसी जानकारी के एक हिस्से को बदलना पूरे क्रिप्टोग्राफिक योजना को बदलने से आसान होता है। मान लीजिए कि किसी कंपनी के सभी कर्मचारियों के पास एक ही एन्क्रिप्शन सॉफ्टवेयर है, और हर दो कर्मचारियों के पास गोपनीय रूप से संवाद करने के लिए एक निजी कुंजी है। इस स्थिति में कुंजी का समझौता एक परेशानी है, लेकिन कम से कम कंपनी ऐसे सुरक्षा उल्लंघनों के साथ सॉफ्टवेयर को बनाए रख सकती है। अगर कंपनी योजना की गोपनीयता पर निर्भर होती, तो उस गोपनीयता के किसी भी उल्लंघन के कारण पूरे सॉफ्टवेयर को बदलना पड़ता।

तीसरा, केरखॉफ्स का सिद्धांत क्रिप्टोग्राफिक योजनाओं के उपयोगकर्ताओं के बीच मानकीकरण और संगतता की अनुमति देता है। इसका दक्षता के लिए बहुत बड़ा लाभ है। उदाहरण के लिए, यह कल्पना करना मुश्किल है कि लाखों लोग हर दिन Google के वेब सर्वरों से सुरक्षित रूप से कैसे जुड़ सकते हैं, अगर उस सुरक्षा के लिए क्रिप्टोग्राफिक योजनाओं को गुप्त रखना आवश्यक होता।

चौथा, केरखॉफ का सिद्धांत क्रिप्टोग्राफिक योजनाओं की सार्वजनिक जांच की अनुमति देता है। इस प्रकार की जांच सुरक्षित क्रिप्टोग्राफिक योजनाओं को प्राप्त करने के लिए बिल्कुल आवश्यक है। उदाहरण के लिए, सममित क्रिप्टोग्राफी में मुख्य कोर एल्गोरिदम, रिंजडेल सिफर, 1997 से 2000 के बीच नेशनल इंस्टीट्यूट ऑफ स्टैंडर्ड्स एंड टेक्नोलॉजी द्वारा आयोजित एक प्रतियोगिता का परिणाम था।

कोई भी प्रणाली जो **अस्पष्टता द्वारा सुरक्षा** प्राप्त करने की कोशिश करती है, वह अपने डिज़ाइन और/या कार्यान्वयन के विवरण को गुप्त रखने पर निर्भर करती है। क्रिप्टोग्राफी में, यह विशेष रूप से एक ऐसी प्रणाली होगी जो क्रिप्टोग्राफिक योजना के डिज़ाइन विवरण को गुप्त रखने पर निर्भर करती है। इसलिए अस्पष्टता द्वारा सुरक्षा सीधे Kerckhoffs के सिद्धांत के विपरीत है।

खुलापन की क्षमता गुणवत्ता और सुरक्षा को बढ़ावा देने में केवल क्रिप्टोग्राफी तक ही सीमित नहीं है, बल्कि यह डिजिटल दुनिया में भी व्यापक रूप से लागू होती है। उदाहरण के लिए, फ्री और ओपन सोर्स लिनक्स वितरण जैसे कि डेबियन, आमतौर पर गोपनीयता, स्थिरता, सुरक्षा और लचीलापन के मामले में विंडोज और मैकओएस की तुलना में कई फायदे रखते हैं। इसके कई कारण हो सकते हैं, लेकिन सबसे महत्वपूर्ण सिद्धांत शायद एरिक रेमंड के प्रसिद्ध निबंध "द कैथेड्रल एंड द बाज़ार" में वर्णित है, कि "जब पर्याप्त लोग देखते हैं, तो सभी बग्स हल्के हो जाते हैं।" यह भीड़ की बुद्धिमत्ता का वही सिद्धांत है जिसने लिनक्स को उसकी सबसे बड़ी सफलता दिलाई।

किसी भी क्रिप्टोग्राफिक योजना को स्पष्ट रूप से "सुरक्षित" या "असुरक्षित" नहीं कहा जा सकता। इसके बजाय, क्रिप्टोग्राफिक योजनाओं के लिए सुरक्षा के विभिन्न विचार होते हैं। प्रत्येक **क्रिप्टोग्राफिक सुरक्षा की परिभाषा** को (1) सुरक्षा लक्ष्यों और (2) हमलावर की क्षमताओं को निर्दिष्ट करना होता है। किसी विशेष सुरक्षा विचार के खिलाफ क्रिप्टोग्राफिक योजनाओं का विश्लेषण करने से उनके उपयोग और सीमाओं के बारे में जानकारी मिलती है।

हम सभी क्रिप्टोग्राफिक सुरक्षा की विभिन्न अवधारणाओं के सभी विवरणों में नहीं जाएंगे, लेकिन आपको यह जानना चाहिए कि दो धारणाएँ सभी आधुनिक क्रिप्टोग्राफिक सुरक्षा अवधारणाओं में आम हैं, जो कि सिमेट्रिक और असिमेट्रिक योजनाओं से संबंधित हैं (और कुछ रूप में अन्य क्रिप्टोग्राफिक प्रिमिटिव्स के लिए भी)।


- हमलावर की योजना के बारे में जानकारी Kerckhoffs के सिद्धांत के अनुरूप है।
- हमलावर इस योजना पर आसानी से ब्रूट फोर्स हमला नहीं कर सकता। खासकर, सुरक्षा के क्रिप्टोग्राफिक धारणाओं के खतरे के मॉडल आमतौर पर ब्रूट फोर्स हमलों की अनुमति नहीं देते, क्योंकि वे मानते हैं कि ये हमले प्रासंगिक नहीं होते।

**नोट्स:**

[1] सेयूटोनियस के अनुसार, जूलियस सीज़र ने अपनी सैन्य संचार में एक शिफ्ट सिफर का उपयोग किया था, जिसमें कुंजी मान 3 था। तो A हमेशा D बन जाता, B हमेशा E, C हमेशा F, और इसी तरह। इस विशेष शिफ्ट सिफर को **सीज़र सिफर** के नाम से जाना जाता है (हालांकि यह वास्तव में आधुनिक अर्थ में सिफर नहीं है, क्योंकि कुंजी मान स्थिर है)। सीज़र सिफर पहली शताब्दी ईसा पूर्व में सुरक्षित हो सकता था, अगर रोम के दुश्मन एन्क्रिप्शन से बहुत अपरिचित होते। लेकिन यह स्पष्ट रूप से आधुनिक समय में एक बहुत सुरक्षित योजना नहीं होगी।

[2] जोनाथन कैट्ज़ और यहूदा लिंडेल, _आधुनिक क्रिप्टोग्राफी का परिचय_, सीआरसी प्रेस (बोका रैटन, एफएल: 2015), पृष्ठ 7f.

एरिक रेमंड का "द कैथेड्रल एंड द बाज़ार" पेपर लिनक्स कॉन्ग्रेस, वुर्जबर्ग, जर्मनी में 27 मई, 1997 को प्रस्तुत किया गया था। इसके बाद कई संस्करण उपलब्ध हैं और एक किताब भी है। मेरे उद्धरण किताब के पृष्ठ 30 से हैं: एरिक रेमंड, _द कैथेड्रल एंड द बाज़ार: म्यूसिंग्स ऑन लिनक्स एंड ओपन सोर्स बाय एन एक्सीडेंटल रेवोल्यूशनरी_, संशोधित संस्करण (2001), ओ'रेली: सेबास्टोपोल, सीए।

## स्ट्रीम सिफर

<chapterId>479aa6f4-45c4-59ca-8616-8cf8e61fc871</chapterId>

समान्यतः सममित एन्क्रिप्शन योजनाओं को दो प्रकारों में विभाजित किया जाता है: **स्ट्रीम सिफर** और **ब्लॉक सिफर**। हालांकि, यह विभाजन कुछ हद तक परेशानी भरा है क्योंकि लोग इन शब्दों का उपयोग असंगत तरीके से करते हैं। अगले कुछ अनुभागों में, मैं इस विभाजन को उस तरीके से प्रस्तुत करूंगा जो मुझे सबसे अच्छा लगता है। हालांकि, आपको यह जानना चाहिए कि कई लोग इन शब्दों का उपयोग उस तरीके से थोड़ा अलग करेंगे जैसा मैं प्रस्तुत कर रहा हूँ।

चलो पहले स्ट्रीम सिफर की बात करते हैं। एक **स्ट्रीम सिफर** एक सममित एन्क्रिप्शन योजना है जिसमें एन्क्रिप्शन दो चरणों में होता है।

सबसे पहले, एक निजी कुंजी के माध्यम से एक स्ट्रिंग बनाई जाती है, जिसकी लंबाई प्लेनटेक्स्ट के बराबर होती है। इस स्ट्रिंग को **कीस्ट्रीम** कहा जाता है।

इसके बाद, कीस्ट्रीम को गणितीय रूप से प्लेनटेक्स्ट के साथ मिलाया जाता है ताकि एक सिफरटेक्स्ट उत्पन्न हो सके। यह संयोजन आमतौर पर एक XOR ऑपरेशन होता है। डिक्रिप्शन के लिए, आप बस इस ऑपरेशन को उलट सकते हैं। (ध्यान दें कि $A \oplus B = B \oplus A$, जब $A$ और $B$ बिट-स्ट्रिंग्स होते हैं। इसलिए स्ट्रीम सिफर में XOR ऑपरेशन के क्रम का परिणाम पर कोई फर्क नहीं पड़ता। इस गुण को **प्रतिस्थापनशीलता** कहा जाता है।)

एक सामान्य XOR स्ट्रीम सिफर को *चित्र 3* में दर्शाया गया है। सबसे पहले, आप एक निजी कुंजी $K$ लेते हैं और इसका उपयोग करके generate एक कीस्ट्रीम बनाते हैं। फिर इस कीस्ट्रीम को प्लेनटेक्स्ट के साथ XOR ऑपरेशन के माध्यम से मिलाकर सिफरटेक्स्ट तैयार किया जाता है। कोई भी एजेंट जो सिफरटेक्स्ट प्राप्त करता है, उसे आसानी से डिक्रिप्ट कर सकता है यदि उसके पास कुंजी $K$ है। उसे बस इतना करना है कि योजना की निर्दिष्ट प्रक्रिया के अनुसार सिफरटेक्स्ट के जितनी लंबाई की कीस्ट्रीम बनानी है और उसे सिफरटेक्स्ट के साथ XOR करना है।

*चित्र 3: एक XOR स्ट्रीम सिफर*

![Figure 3: An XOR stream cipher](assets/Figure4-3.webp "Figure 3: An XOR stream cipher")

याद रखें कि एक एन्क्रिप्शन स्कीम आमतौर पर एन्क्रिप्शन के लिए एक खाका होती है जिसमें एक ही मुख्य एल्गोरिदम होता है, न कि एक सटीक विनिर्देश। इसी तरह, एक स्ट्रीम सिफर आमतौर पर एन्क्रिप्शन के लिए एक खाका होता है जिसमें आप विभिन्न लंबाई की चाबियों का उपयोग कर सकते हैं। हालांकि चाबी की लंबाई स्कीम के कुछ छोटे विवरणों को प्रभावित कर सकती है, लेकिन यह इसके मूल रूप को प्रभावित नहीं करेगी।

शिफ्ट सिफर एक बहुत ही सरल और असुरक्षित स्ट्रीम सिफर का उदाहरण है। एक अकेले अक्षर (जो कि निजी कुंजी होता है) का उपयोग करके, आप संदेश की लंबाई के बराबर अक्षरों की एक श्रृंखला (कीस्ट्रीम) बना सकते हैं। फिर इस कीस्ट्रीम को प्लेनटेक्स्ट के साथ एक मॉड्यूलो ऑपरेशन के जरिए मिलाया जाता है ताकि एक सिफरटेक्स्ट तैयार हो सके। (जब अक्षरों को बिट्स में दर्शाया जाता है, तो इस मॉड्यूलो ऑपरेशन को एक XOR ऑपरेशन के रूप में सरल किया जा सकता है)।

एक और प्रसिद्ध स्ट्रीम सिफर का उदाहरण है **विजनेर सिफर**, जिसका पूरा विकास 16वीं सदी के अंत में ब्लेज़ डी विजनेर ने किया था (हालांकि अन्य लोगों ने पहले भी इस पर काफी काम किया था)। यह एक **पॉलीअल्फाबेटिक सब्स्टीट्यूशन सिफर** का उदाहरण है: एक एन्क्रिप्शन योजना जिसमें प्लेनटेक्स्ट के प्रतीक के लिए सिफरटेक्स्ट वर्णमाला उसके टेक्स्ट में स्थिति के अनुसार बदलती रहती है। इसके विपरीत, एक मोनोअल्फाबेटिक सब्स्टीट्यूशन सिफर में, सिफरटेक्स्ट प्रतीक एक से अधिक प्लेनटेक्स्ट प्रतीकों से जुड़ा हो सकता है।

जैसे-जैसे पुनर्जागरण काल में यूरोप में एन्क्रिप्शन की लोकप्रियता बढ़ी, वैसे-वैसे **क्रिप्टएनालिसिस**—यानी, गुप्त संदेशों को तोड़ने की कला—भी बढ़ी, खासकर **फ्रीक्वेंसी एनालिसिस** का उपयोग करके। यह तकनीक हमारे भाषा में सांख्यिकीय नियमितताओं का उपयोग करके गुप्त संदेशों को तोड़ती है, और इसे नौवीं सदी में ही अरबी विद्वानों ने खोज लिया था। यह तकनीक विशेष रूप से लंबे पाठों के साथ अच्छी तरह से काम करती है। और 1700 के दशक तक, यूरोप में सबसे जटिल मोनोअल्फाबेटिक सब्स्टीट्यूशन सिफर भी फ्रीक्वेंसी एनालिसिस के खिलाफ पर्याप्त नहीं थे, खासकर सैन्य और सुरक्षा के संदर्भ में। जब विगेनेर सिफर ने सुरक्षा में एक महत्वपूर्ण प्रगति की पेशकश की, तो यह इस अवधि में लोकप्रिय हो गया और 1700 के दशक के अंत तक व्यापक रूप से उपयोग में आने लगा।

आसान भाषा में कहें तो, एन्क्रिप्शन स्कीम इस तरह काम करती है:

1. एक बहु-अक्षरीय शब्द को निजी कुंजी के रूप में चुनें।

किसी भी संदेश के लिए, संदेश के प्रत्येक अक्षर पर शिफ्ट सिफर लागू करें, जिसमें कुंजी शब्द के संबंधित अक्षर को शिफ्ट के रूप में उपयोग किया जाए।

3. अगर आपने की-वर्ड का इस्तेमाल करके टेक्स्ट को एन्क्रिप्ट करने की कोशिश की है, लेकिन फिर भी पूरा प्लेनटेक्स्ट एन्क्रिप्ट नहीं हुआ है, तो बचे हुए टेक्स्ट के अक्षरों पर फिर से की-वर्ड के अक्षरों को शिफ्ट सिफर के रूप में लागू करें।

4. इस प्रक्रिया को तब तक जारी रखें जब तक पूरा संदेश गुप्त कोड में बदल न जाए।

मान लीजिए कि आपकी निजी कुंजी "GOLD" है और आप संदेश "CRYPTOGRAPHY" को एन्क्रिप्ट करना चाहते हैं। इस स्थिति में, आप Vigenère सिफर के अनुसार इस प्रकार आगे बढ़ेंगे:


- $c_0 = [(2 + 6) \mod 26] = 8 = I$

यह गणना एक सरल गणितीय प्रक्रिया है जिसमें दो संख्याओं को जोड़ा जाता है और फिर 26 से भाग देकर शेषफल निकाला जाता है। यहाँ पर 2 और 6 को जोड़ा गया है, जिससे 8 प्राप्त होता है। फिर 8 को 26 से भाग देने पर शेषफल 8 ही रहता है। इस शेषफल को अंग्रेजी वर्णमाला के अनुसार अक्षर 'I' के रूप में दर्शाया गया है।
- $c_1 = [(17 + 14) \mod 26] = 5 = F$

यह गणना एक प्रकार की गणितीय प्रक्रिया है जिसमें दो संख्याओं को जोड़ा जाता है और फिर 26 से भाग देकर शेषफल निकाला जाता है। यहाँ, 17 और 14 को जोड़ा गया है, जिससे 31 प्राप्त होता है। फिर 31 को 26 से भाग दिया जाता है, जिससे शेषफल 5 आता है। इस शेषफल को अंग्रेजी वर्णमाला के अनुसार अक्षर 'F' से दर्शाया गया है।
- $c_2 = [(24 + 11) \mod 26] = 9 = J$

यह गणना एक मॉड्यूलो ऑपरेशन का उदाहरण है। यहाँ पर 24 और 11 को जोड़ा गया है, जिसका योग 35 होता है। फिर 35 को 26 से मॉड्यूलो किया गया है, जिससे शेषफल 9 आता है। इस शेषफल को अंग्रेजी वर्णमाला के अनुसार J अक्षर से दर्शाया गया है।
- $c_3 = [(15 + 3) \mod 26] = 18 = S$

यह गणना एक प्रकार की गणितीय प्रक्रिया है जिसमें हम 15 और 3 को जोड़ते हैं, फिर उसे 26 से भाग देकर शेष निकालते हैं। इस प्रक्रिया का परिणाम 18 आता है, जो अंग्रेजी वर्णमाला में 'S' अक्षर के बराबर है।
- $c_4 = [(19 + 6) \mod 26] = 25 = Z$

यह गणना एक मॉड्यूलो ऑपरेशन का उदाहरण है। यहाँ पर 19 और 6 को जोड़ा गया है, जिससे 25 प्राप्त होता है। फिर 25 को 26 से मॉड लिया गया है, जिसका परिणाम 25 ही आता है। इस प्रकार, 25 को अंग्रेजी वर्णमाला के अनुसार 'Z' अक्षर के रूप में दर्शाया गया है।
- $c_5 = [(14 + 14) \mod 26] = 2 = C$

यह गणना एक गणितीय समीकरण है जिसमें मोड्यूलो ऑपरेशन का उपयोग किया गया है। यहाँ पर 14 और 14 को जोड़ा गया है, जिसका योग 28 होता है। फिर 28 को 26 से मोड्यूलो किया गया है, जिसका परिणाम 2 आता है। इस प्रकार, $c_5$ का मान 2 है, जिसे अंग्रेजी वर्णमाला में 'C' के रूप में दर्शाया गया है।
- $c_6 = [(6 + 11) \mod 26] = 17 = R$ का मतलब है कि हम 6 और 11 को जोड़ते हैं, फिर 26 से भाग देकर शेष निकालते हैं। इसका परिणाम 17 आता है, जो अंग्रेजी वर्णमाला में 'R' अक्षर के बराबर होता है।
- $c_7 = [(17 + 3) \mod 26] = 20 = U$

यह गणितीय समीकरण है जो वर्णमाला के अक्षरों को संख्याओं में बदलने की प्रक्रिया को दर्शाता है। यहाँ पर 17 और 3 को जोड़ा गया है, फिर 26 से भाग देकर शेषफल निकाला गया है। इस प्रक्रिया का परिणाम 20 आता है, जो अंग्रेज़ी वर्णमाला में 'U' अक्षर के बराबर है।
- $c_8 = [(0 + 6) \mod 26] = 6 = G$

यह गणना एक प्रकार की गणितीय प्रक्रिया है जिसमें हम 0 और 6 को जोड़ते हैं और फिर 26 से भाग देकर शेष निकालते हैं। इस प्रक्रिया का परिणाम 6 आता है, जो अंग्रेजी वर्णमाला में 'G' अक्षर के बराबर होता है।
- $c_9 = [(15 + 14) \mod 26] = 3 = D$

यह गणना एक मॉड्यूलो ऑपरेशन का उदाहरण है। यहाँ पर 15 और 14 को जोड़ा गया है, जिससे 29 प्राप्त होता है। फिर 29 को 26 से मॉड्यूलो किया गया है, जिससे शेष 3 आता है। इस शेष को अंग्रेजी वर्णमाला के अनुसार अक्षर 'D' के रूप में दर्शाया गया है।
- $c_{10} = [(7 + 11) \mod 26] = 18 = S$

यह गणना एक प्रकार की गणितीय प्रक्रिया है जिसमें दो संख्याओं को जोड़ा जाता है और फिर 26 से भाग देकर शेषफल निकाला जाता है। यहाँ, 7 और 11 को जोड़ा गया, जिससे 18 प्राप्त हुआ। फिर 18 को 26 से भाग देने पर शेषफल 18 ही रहता है। इस प्रक्रिया का परिणाम 'S' अक्षर के रूप में दर्शाया गया है।
- $c_{11} = [(24 + 3) \mod 26] = 1 = B$

यह गणना एक गणितीय प्रक्रिया है जिसमें हम 24 और 3 को जोड़ते हैं, फिर उसे 26 से भाग देकर शेषफल निकालते हैं। इस प्रक्रिया का परिणाम 1 आता है, जो अंग्रेज़ी वर्णमाला में 'B' अक्षर के बराबर है।

इस प्रकार, गुप्त संदेश $c$ = "IFJSZCRUGDSB" है।

एक और प्रसिद्ध उदाहरण स्ट्रीम सिफर का **वन-टाइम पैड** है। वन-टाइम पैड के साथ, आप बस उतनी ही लंबाई की एक रैंडम बिट्स की स्ट्रिंग बनाते हैं जितना कि आपका प्लेनटेक्स्ट संदेश होता है और फिर XOR ऑपरेशन के जरिए सिफरटेक्स्ट तैयार करते हैं। इसलिए, वन-टाइम पैड के साथ प्राइवेट की और कीस्ट्रीम एक समान होते हैं।

हालांकि शिफ्ट सिफर और विजेनियर सिफर आधुनिक युग में बहुत असुरक्षित हैं, लेकिन अगर सही तरीके से इस्तेमाल किया जाए तो वन-टाइम पैड बहुत सुरक्षित होता है। शायद वन-टाइम पैड का सबसे प्रसिद्ध उपयोग, कम से कम 1980 के दशक तक, **वॉशिंगटन-मॉस्को हॉटलाइन** के लिए था। [4]

हॉटलाइन वॉशिंगटन और मॉस्को के बीच एक सीधी संचार लिंक है, जो आपातकालीन मामलों के लिए बनाई गई थी। इसे क्यूबा मिसाइल संकट के बाद स्थापित किया गया था। वर्षों में इसकी तकनीक में काफी बदलाव आया है। वर्तमान में, इसमें एक सीधा फाइबर ऑप्टिक केबल और दो सैटेलाइट लिंक शामिल हैं (जो अतिरिक्त सुरक्षा के लिए हैं), जो ई-मेल और टेक्स्ट मैसेजिंग की सुविधा देते हैं। यह लिंक अमेरिका में कई जगहों पर समाप्त होता है। पेंटागन, व्हाइट हाउस और रेवेन रॉक माउंटेन इसके प्रमुख स्थान हैं। आम धारणा के विपरीत, हॉटलाइन में कभी भी टेलीफोन का उपयोग नहीं किया गया है।

मूल रूप से, वन-टाइम पैड योजना इस प्रकार काम करती थी। वाशिंगटन और मॉस्को दोनों के पास दो सेट रैंडम नंबर होते थे। एक सेट रैंडम नंबर, जो रूसियों द्वारा बनाया गया था, रूसी भाषा में किसी भी संदेश के एन्क्रिप्शन और डिक्रिप्शन से संबंधित था। दूसरा सेट रैंडम नंबर, जो अमेरिकियों द्वारा बनाया गया था, अंग्रेजी भाषा में किसी भी संदेश के एन्क्रिप्शन और डिक्रिप्शन से संबंधित था। समय-समय पर, भरोसेमंद कूरियर द्वारा दूसरी तरफ और अधिक रैंडम नंबर भेजे जाते थे।

वॉशिंगटन और मॉस्को तब इन रैंडम नंबरों का उपयोग करके एक बार इस्तेमाल होने वाले पैड बनाने के लिए गुप्त रूप से संवाद कर सकते थे। हर बार जब आपको संवाद करना होता, तो आप अपने संदेश के लिए अगली रैंडम नंबरों की श्रृंखला का उपयोग करते।

हालांकि एक-बार उपयोग होने वाला पैड (वन-टाइम पैड) बहुत सुरक्षित होता है, लेकिन इसके कुछ व्यावहारिक सीमाएँ होती हैं: कुंजी को संदेश जितनी लंबी होना चाहिए और एक-बार उपयोग होने वाले पैड का कोई भी हिस्सा दोबारा उपयोग नहीं किया जा सकता। इसका मतलब है कि आपको यह ध्यान रखना होगा कि आप पैड में कहाँ हैं, बहुत बड़ी संख्या में बिट्स को स्टोर करना होगा, और समय-समय पर अपने साझेदारों के साथ Exchange रैंडम बिट्स साझा करने होंगे। इस वजह से, एक-बार उपयोग होने वाला पैड व्यावहारिक रूप से अक्सर उपयोग में नहीं लाया जाता।

इसके बजाय, व्यावहारिक रूप से जो मुख्य स्ट्रीम सिफर उपयोग किए जाते हैं, वे **छद्म-यादृच्छिक स्ट्रीम सिफर** होते हैं। Salsa20 और इसका करीबी संस्करण ChaCha, आमतौर पर उपयोग किए जाने वाले छद्म-यादृच्छिक स्ट्रीम सिफर के उदाहरण हैं।

इन छद्म-यादृच्छिक स्ट्रीम सिफर्स के साथ, आप पहले एक कुंजी K को यादृच्छिक रूप से चुनते हैं जो कि प्लेनटेक्स्ट की लंबाई से छोटी होती है। ऐसी यादृच्छिक कुंजी K आमतौर पर हमारे कंप्यूटर द्वारा अप्रत्याशित डेटा के आधार पर बनाई जाती है, जिसे यह समय के साथ इकट्ठा करता है, जैसे नेटवर्क संदेशों के बीच का समय, माउस की गतिविधियाँ, आदि।

यह रैंडम कुंजी $K$ फिर एक विस्तार एल्गोरिदम में डाली जाती है, जो संदेश की लंबाई के बराबर एक छद्म-रैंडम कुंजी स्ट्रीम बनाता है। आप ठीक-ठीक यह निर्धारित कर सकते हैं कि कुंजी स्ट्रीम कितनी लंबी होनी चाहिए (जैसे, 500 बिट्स, 1000 बिट्स, 1200 बिट्स, 29,117 बिट्स, आदि)।

एक छद्म-यादृच्छिक कीस्ट्रीम ऐसा *दिखाई देता है* जैसे कि उसे पूरी तरह से यादृच्छिक रूप से उसी लंबाई के सभी स्ट्रिंग्स के सेट से चुना गया हो। इसलिए, छद्म-यादृच्छिक कीस्ट्रीम के साथ एन्क्रिप्शन ऐसा लगता है जैसे कि इसे एक बार के पैड के साथ किया गया हो। लेकिन, वास्तव में ऐसा नहीं होता है।

हमारी निजी कुंजी की लंबाई कीस्ट्रीम से छोटी है और हमारा विस्तारक एल्गोरिदम निर्धारक होना चाहिए ताकि एन्क्रिप्शन/डिक्रिप्शन प्रक्रिया सही से काम कर सके। इसलिए, उस विशेष लंबाई की हर कीस्ट्रीम हमारे विस्तारक ऑपरेशन से आउटपुट के रूप में नहीं आ सकती।

मान लीजिए कि हमारी निजी कुंजी की लंबाई 128 बिट्स है और हम इसे एक विस्तारक एल्गोरिदम में डाल सकते हैं ताकि एक बहुत लंबी कीस्ट्रीम बनाई जा सके, जैसे कि 2,500 बिट्स की। चूंकि हमारा विस्तारक एल्गोरिदम निर्धारक होना चाहिए, हमारा एल्गोरिदम अधिकतम $1/2^{128}$ स्ट्रिंग्स का चयन कर सकता है जिनकी लंबाई 2,500 बिट्स है। इसलिए, ऐसी कीस्ट्रीम को कभी भी पूरी तरह से यादृच्छिक रूप से समान लंबाई की सभी स्ट्रिंग्स में से नहीं चुना जा सकता।

हमारे स्ट्रीम सिफर की परिभाषा के दो पहलू हैं: (1) एक कीस्ट्रीम, जो कि प्लेनटेक्स्ट जितनी लंबी होती है, एक निजी कुंजी की मदद से उत्पन्न की जाती है; और (2) इस कीस्ट्रीम को प्लेनटेक्स्ट के साथ मिलाया जाता है, आमतौर पर एक XOR ऑपरेशन के माध्यम से, ताकि सिफरटेक्स्ट तैयार किया जा सके।

कभी-कभी लोग शर्त (1) को और अधिक सख्ती से परिभाषित करते हैं, यह कहते हुए कि कीस्ट्रीम विशेष रूप से छद्म-यादृच्छिक (pseudorandom) होना चाहिए। इसका मतलब है कि न तो शिफ्ट सिफर और न ही वन-टाइम पैड को स्ट्रीम सिफर माना जाएगा।

मेरे विचार में, शर्त (1) को अधिक व्यापक रूप से परिभाषित करने से एन्क्रिप्शन योजनाओं को व्यवस्थित करने का एक आसान तरीका मिलता है। इसके अलावा, इसका मतलब यह है कि हमें किसी विशेष एन्क्रिप्शन योजना को स्ट्रीम सिफर कहना बंद नहीं करना पड़ेगा, सिर्फ इसलिए कि हमें पता चलता है कि यह वास्तव में छद्म-यादृच्छिक कीस्ट्रीम पर निर्भर नहीं करता।

**नोट्स:**

[4] क्रिप्टो म्यूज़ियम, "वॉशिंगटन-मॉस्को हॉटलाइन," 2013, उपलब्ध है [https://www.cryptomuseum.com/crypto/hotline/index.htm](https://www.cryptomuseum.com/crypto/hotline/index.htm) पर।

## ब्लॉक सिफर

<chapterId>2df52d51-943d-5df7-9d49-333e4c5d97b7</chapterId>

**ब्लॉक सिफर** को आमतौर पर एक स्ट्रीम सिफर से अधिक मौलिक रूप में समझा जाता है। यह एक मुख्य एल्गोरिदम होता है जो एक उपयुक्त लंबाई की स्ट्रिंग पर एक लंबाई-संरक्षण परिवर्तन करता है, जिसमें एक कुंजी की सहायता ली जाती है। इस एल्गोरिदम का उपयोग एन्क्रिप्शन योजनाएँ बनाने के लिए और शायद अन्य प्रकार की क्रिप्टोग्राफिक योजनाओं के लिए किया जा सकता है।

अक्सर, एक ब्लॉक सिफर विभिन्न लंबाई के इनपुट स्ट्रिंग्स जैसे 64, 128, या 256 बिट्स और विभिन्न लंबाई की चाबियाँ जैसे 128, 192, या 256 बिट्स ले सकता है। हालांकि इन चर के आधार पर एल्गोरिदम के कुछ विवरण बदल सकते हैं, लेकिन मुख्य एल्गोरिदम नहीं बदलता। अगर ऐसा होता, तो हम दो अलग-अलग ब्लॉक सिफर की बात करते। ध्यान दें कि यहां मुख्य एल्गोरिदम शब्दावली का उपयोग एन्क्रिप्शन योजनाओं के लिए भी वैसा ही है।

*चित्र 4* में दिखाया गया है कि एक ब्लॉक सिफर कैसे काम करता है। एक संदेश $M$ जिसकी लंबाई $L$ है और एक कुंजी $K$ ब्लॉक सिफर के इनपुट के रूप में काम करते हैं। यह एक संदेश $M'$ जिसकी लंबाई $L$ है, को आउटपुट करता है। ज्यादातर ब्लॉक सिफरों के लिए कुंजी की लंबाई $M$ और $M'$ के समान होना जरूरी नहीं है।

*चित्र 4: एक ब्लॉक सिफर*

![Figure 4: A block cipher](assets/Figure4-4.webp "Figure 4: A block cipher")

एक ब्लॉक सिफर अपने आप में एक एन्क्रिप्शन योजना नहीं होती है। लेकिन एक ब्लॉक सिफर को विभिन्न **ऑपरेशन मोड्स** के साथ उपयोग करके अलग-अलग एन्क्रिप्शन योजनाएँ बनाई जा सकती हैं। एक ऑपरेशन मोड बस ब्लॉक सिफर के बाहर कुछ अतिरिक्त कार्य जोड़ देता है।

इसका काम कैसे होता है यह समझाने के लिए, मान लीजिए कि हमारे पास एक ब्लॉक सिफर (BC) है जो 128-बिट इनपुट स्ट्रिंग और 128-बिट प्राइवेट की की आवश्यकता रखता है। नीचे दिए गए चित्र 5 में दिखाया गया है कि इस ब्लॉक सिफर का उपयोग **इलेक्ट्रॉनिक कोड बुक मोड** (**ECB मोड**) के साथ कैसे किया जा सकता है ताकि एक एन्क्रिप्शन स्कीम बनाई जा सके। (दाईं ओर के अंडाकार संकेत करते हैं कि आप इस पैटर्न को जितनी बार चाहें उतनी बार दोहरा सकते हैं)।

*चित्र 5: ईसीबी मोड के साथ एक ब्लॉक सिफर*

![Figure 5: A block cipher with ECB mode](assets/Figure4-5.webp "Figure 5: A block cipher with ECB mode")

ब्लॉक सिफर के साथ इलेक्ट्रॉनिक कोड बुक एन्क्रिप्शन की प्रक्रिया इस प्रकार है। सबसे पहले, देखें कि क्या आप अपने प्लेनटेक्स्ट संदेश को 128-बिट ब्लॉकों में विभाजित कर सकते हैं। अगर नहीं, तो संदेश में **पैडिंग** जोड़ें, ताकि परिणाम को 128 बिट्स के ब्लॉक आकार से समान रूप से विभाजित किया जा सके। यही आपका डेटा है जिसका उपयोग एन्क्रिप्शन प्रक्रिया के लिए किया जाएगा।

अब डेटा को 128-बिट स्ट्रिंग्स के टुकड़ों में बाँट लें ($M_1$, $M_2$, $M_3$, आदि)। हर 128-बिट स्ट्रिंग को अपने 128-बिट कुंजी के साथ ब्लॉक सिफर के माध्यम से चलाएँ ताकि 128-बिट के चंक्स का सिफरटेक्स्ट ($C_1$, $C_2$, $C_3$, आदि) प्राप्त हो सके। जब इन चंक्स को फिर से जोड़ा जाता है, तो वे पूरा सिफरटेक्स्ट बनाते हैं।

डिक्रिप्शन बस उल्टा प्रक्रिया है, हालांकि प्राप्तकर्ता को डिक्रिप्ट किए गए डेटा से किसी भी पैडिंग को हटाने का कोई पहचानने योग्य तरीका चाहिए ताकि वह मूल प्लेनटेक्स्ट संदेश प्राप्त कर सके।

हालांकि यह अपेक्षाकृत सरल है, लेकिन इलेक्ट्रॉनिक कोड बुक मोड के साथ एक ब्लॉक सिफर में सुरक्षा की कमी होती है। इसका कारण यह है कि यह **निर्धारित एन्क्रिप्शन** की ओर ले जाता है। किसी भी दो समान 128-बिट डेटा स्ट्रिंग्स को बिल्कुल एक ही तरीके से एन्क्रिप्ट किया जाता है। इस जानकारी का दुरुपयोग किया जा सकता है।

इसके बजाय, किसी भी ब्लॉक सिफर से बने एन्क्रिप्शन स्कीम को **प्रायिक** होना चाहिए: यानी, किसी भी संदेश $M$ का एन्क्रिप्शन, या $M$ के किसी विशेष हिस्से का एन्क्रिप्शन, हर बार आमतौर पर एक अलग परिणाम देना चाहिए। [5]

**साइफर ब्लॉक चेनिंग मोड** (**CBC मोड**) शायद सबसे आम मोड है जो ब्लॉक साइफर के साथ इस्तेमाल किया जाता है। अगर इसे सही तरीके से किया जाए, तो यह एक संभाव्य एन्क्रिप्शन योजना बनाता है। आप इस मोड के काम करने का तरीका *चित्र 6* में नीचे देख सकते हैं।

*चित्र 6: सीबीसी मोड के साथ एक ब्लॉक सिफर*

![Figure 6: A block cipher with CBC mode](assets/Figure4-6.webp "Figure 6: A block cipher with CBC mode")

मान लीजिए कि ब्लॉक साइज फिर से 128 बिट्स है। तो शुरू करने के लिए, आपको यह सुनिश्चित करना होगा कि आपकी मूल प्लेनटेक्स्ट संदेश को आवश्यक पैडिंग मिल जाए।

सबसे पहले, आप अपने प्लेनटेक्स्ट के पहले 128-बिट हिस्से को 128-बिट के **इनिशियलाइजेशन वेक्टर** के साथ XOR करते हैं। इसका परिणाम ब्लॉक सिफर में डाला जाता है ताकि पहले ब्लॉक के लिए सिफरटेक्स्ट तैयार हो सके। दूसरे 128-बिट ब्लॉक के लिए, आप पहले प्लेनटेक्स्ट को पहले ब्लॉक के सिफरटेक्स्ट के साथ XOR करते हैं, फिर इसे ब्लॉक सिफर में डालते हैं। आप इस प्रक्रिया को तब तक जारी रखते हैं जब तक कि आपका पूरा प्लेनटेक्स्ट संदेश एन्क्रिप्ट नहीं हो जाता।

जब आप काम पूरा कर लेते हैं, तो आप एन्क्रिप्टेड संदेश को बिना एन्क्रिप्ट किए गए इनिशियलाइजेशन वेक्टर के साथ प्राप्तकर्ता को भेजते हैं। प्राप्तकर्ता को इनिशियलाइजेशन वेक्टर के बारे में पता होना चाहिए, वरना वह सिफरटेक्स्ट को डिक्रिप्ट नहीं कर पाएगी।

यह निर्माण इलेक्ट्रॉनिक कोड बुक मोड की तुलना में अधिक सुरक्षित है, जब इसे सही तरीके से उपयोग किया जाए। सबसे पहले, आपको यह सुनिश्चित करना चाहिए कि इनिशियलाइजेशन वेक्टर एक रैंडम या छद्म-रैंडम स्ट्रिंग हो। इसके अलावा, जब भी आप इस एन्क्रिप्शन स्कीम का उपयोग करें, तो हर बार एक अलग इनिशियलाइजेशन वेक्टर का उपयोग करें।

दूसरे शब्दों में, आपका इनिशियलाइजेशन वेक्टर एक रैंडम या छद्म-रैंडम Nonce होना चाहिए, जहाँ **Nonce** का मतलब है "एक ऐसा नंबर जो केवल एक बार उपयोग किया जाता है।" अगर आप इस प्रथा का पालन करते हैं, तो CBC मोड के साथ ब्लॉक सिफर यह सुनिश्चित करता है कि कोई भी दो समान प्लेनटेक्स्ट ब्लॉक आमतौर पर हर बार अलग-अलग तरीके से एन्क्रिप्ट किए जाएंगे।

आखिरकार, चलिए अब हम **आउटपुट फीडबैक मोड** (**OFB मोड**) पर ध्यान केंद्रित करते हैं। आप इस मोड का चित्रण *चित्र 7* में देख सकते हैं।

*चित्र 7: OFB मोड के साथ एक ब्लॉक सिफर*

![Figure 7: A block cipher with OFB mode](assets/Figure4-7.webp "Figure 7: A block cipher with OFB mode")

OFB मोड में आप एक initialization vector भी चुनते हैं। लेकिन यहाँ, पहले ब्लॉक के लिए, initialization vector को सीधे आपके कुंजी के साथ ब्लॉक सिफर में डाला जाता है। इसके परिणामस्वरूप जो 128-बिट्स बनते हैं, उन्हें एक कीस्ट्रीम के रूप में माना जाता है। इस कीस्ट्रीम को प्लेनटेक्स्ट के साथ XOR किया जाता है ताकि उस ब्लॉक के लिए सिफरटेक्स्ट तैयार हो सके। अगले ब्लॉकों के लिए, आप पिछले ब्लॉक से कीस्ट्रीम को ब्लॉक सिफर में इनपुट के रूप में उपयोग करते हैं और इन चरणों को दोहराते हैं।

अगर आप ध्यान से देखें, तो यहाँ ब्लॉक सिफर को OFB मोड के साथ इस्तेमाल करके असल में एक स्ट्रीम सिफर बनाया गया है। आप generate कीस्ट्रीम के 128-बिट के हिस्से तब तक बनाते हैं जब तक कि आपके पास प्लेनटेक्स्ट की लंबाई के बराबर न हो जाए (आखिरी 128-बिट कीस्ट्रीम हिस्से से जो बिट्स आपको नहीं चाहिए, उन्हें हटा देते हैं)। फिर, आप कीस्ट्रीम को अपने प्लेनटेक्स्ट संदेश के साथ XOR करते हैं ताकि आपको सिफरटेक्स्ट मिल सके।

पिछले भाग में, जहाँ हमने स्ट्रीम सिफर्स के बारे में बात की थी, मैंने बताया था कि आप एक निजी कुंजी की मदद से कीस्ट्रीम बनाते हैं। लेकिन सही मायने में, इसे केवल निजी कुंजी से ही नहीं बनाया जाता। जैसा कि आप OFB मोड में देख सकते हैं, कीस्ट्रीम निजी कुंजी और एक इनिशियलाइजेशन वेक्टर दोनों की सहायता से तैयार की जाती है।

ध्यान दें कि जैसे CBC मोड में होता है, वैसे ही OFB मोड में ब्लॉक सिफर का उपयोग करते समय हर बार एक छद्म-रैंडम या रैंडम Nonce को इनिशियलाइजेशन वेक्टर के रूप में चुनना महत्वपूर्ण है। अन्यथा, एक ही 128-बिट संदेश स्ट्रिंग को अलग-अलग संचार में भेजने पर भी उसी तरीके से एन्क्रिप्ट किया जाएगा। यह स्ट्रीम सिफर के साथ संभाव्य एन्क्रिप्शन बनाने का एक तरीका है।

कुछ स्ट्रीम सिफर केवल एक निजी कुंजी का उपयोग करके कीस्ट्रीम बनाते हैं। ऐसे स्ट्रीम सिफर के लिए, यह महत्वपूर्ण है कि आप प्रत्येक संचार के लिए निजी कुंजी चुनने के लिए एक रैंडम Nonce का उपयोग करें। अन्यथा, उन स्ट्रीम सिफर के साथ एन्क्रिप्शन के परिणाम भी पूर्वनिर्धारित हो जाएंगे, जिससे सुरक्षा समस्याएं उत्पन्न हो सकती हैं।

सबसे लोकप्रिय आधुनिक ब्लॉक सिफर **रिजंडेल सिफर** है। यह पंद्रह प्रविष्टियों में से विजेता था, जो 1997 से 2000 के बीच नेशनल इंस्टीट्यूट ऑफ स्टैंडर्ड्स एंड टेक्नोलॉजी (NIST) द्वारा आयोजित एक प्रतियोगिता में चुना गया था। इस प्रतियोगिता का उद्देश्य पुराने एन्क्रिप्शन मानक, **डेटा एन्क्रिप्शन स्टैंडर्ड** (**DES**) को बदलना था।

रिजंडेल सिफर को विभिन्न कुंजी लंबाई और ब्लॉक आकार के विनिर्देशों के साथ-साथ विभिन्न संचालन मोड में उपयोग किया जा सकता है। NIST प्रतियोगिता की समिति ने रिजंडेल सिफर का एक संकुचित संस्करण अपनाया, जिसमें 128-बिट ब्लॉक आकार और 128 बिट, 192 बिट, या 256 बिट की कुंजी लंबाई की आवश्यकता होती है, और इसे **एडवांस्ड एन्क्रिप्शन स्टैंडर्ड** (**AES**) के रूप में शामिल किया गया। यह वास्तव में सममित एन्क्रिप्शन अनुप्रयोगों के लिए मुख्य मानक है। यह इतना सुरक्षित है कि NSA भी इसे 256-बिट कुंजियों के साथ शीर्ष गुप्त दस्तावेजों के लिए उपयोग करने के लिए तैयार है।

AES ब्लॉक सिफर को विस्तार से *अध्याय 5* में समझाया जाएगा।

**नोट्स:**

शाफी गोल्डवेसर और सिल्वियो मिकाली ने पहली बार प्रायिकता आधारित एन्क्रिप्शन के महत्व पर जोर दिया था। उन्होंने इस विषय पर "प्रायिकता आधारित एन्क्रिप्शन" नामक एक लेख लिखा, जो _जर्नल ऑफ कंप्यूटर एंड सिस्टम साइंसेज_ के 28वें संस्करण (1984) में पृष्ठ 270-99 पर प्रकाशित हुआ था।

[6] NSA, "वाणिज्यिक राष्ट्रीय सुरक्षा एल्गोरिदम सूट" देखें, [https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm](https://apps.nsa.gov/iaarchive/programs/iad-initiatives/cnsa-suite.cfm)।

## गलतफहमी दूर करना

<chapterId>121c1858-27e3-5862-b0ce-4ff2f70f9f0f</chapterId>

ब्लॉक सिफर और स्ट्रीम सिफर के बीच के अंतर को लेकर अक्सर भ्रम होता है क्योंकि कई बार लोग ब्लॉक सिफर को *ब्लॉक मोड ऑफ एन्क्रिप्शन के साथ ब्लॉक सिफर* के रूप में समझ लेते हैं।

पिछले सेक्शन में ECB और CBC मोड पर विचार करें। इन मोड्स में विशेष रूप से यह आवश्यक होता है कि एन्क्रिप्शन के लिए डेटा को ब्लॉक साइज़ से विभाज्य होना चाहिए (जिसका मतलब है कि आपको मूल संदेश में पैडिंग का उपयोग करना पड़ सकता है)। इसके अलावा, इन मोड्स में डेटा को सीधे ब्लॉक सिफर द्वारा संचालित किया जाता है (और केवल ब्लॉक सिफर ऑपरेशन के परिणाम के साथ संयोजित नहीं किया जाता जैसा कि OFB मोड में होता है)।

इसलिए, आप **ब्लॉक सिफर** को एक एन्क्रिप्शन योजना के रूप में परिभाषित कर सकते हैं, जो एक समय में संदेश के निश्चित-लंबाई वाले ब्लॉकों पर काम करती है (जहां कोई भी ब्लॉक एक बाइट से लंबा होना चाहिए, अन्यथा यह एक स्ट्रीम सिफर में बदल जाता है)। एन्क्रिप्शन के लिए डेटा और सिफरटेक्स्ट दोनों को इस ब्लॉक आकार में समान रूप से विभाजित होना चाहिए। आमतौर पर, ब्लॉक का आकार 64, 128, 192, या 256 बिट्स लंबा होता है। इसके विपरीत, एक स्ट्रीम सिफर किसी भी संदेश को एक समय में एक बिट या बाइट के टुकड़ों में एन्क्रिप्ट कर सकता है।

अब जब आपको ब्लॉक सिफर के बारे में अधिक विशेष जानकारी हो गई है, तो आप वास्तव में कह सकते हैं कि आधुनिक एन्क्रिप्शन योजनाएँ या तो स्ट्रीम सिफर होती हैं या ब्लॉक सिफर। आगे से, जब तक विशेष रूप से कुछ और नहीं कहा जाता, मैं ब्लॉक सिफर शब्द का सामान्य अर्थ में उपयोग करूंगा।

पिछले भाग में OFB मोड पर चर्चा ने एक और दिलचस्प बिंदु उठाया। कुछ स्ट्रीम सिफर ब्लॉक सिफर से बनाए जाते हैं, जैसे कि Rijndael के साथ OFB। जबकि कुछ, जैसे Salsa20 और ChaCha, ब्लॉक सिफर से नहीं बनाए जाते। आप इन्हें **प्राथमिक स्ट्रीम सिफर** कह सकते हैं। (ऐसे स्ट्रीम सिफर को संदर्भित करने के लिए वास्तव में कोई मानकीकृत शब्द नहीं है।)

जब लोग स्ट्रीम सिफर और ब्लॉक सिफर के फायदों और नुकसानों की बात करते हैं, तो वे आमतौर पर प्राचीन स्ट्रीम सिफर की तुलना ब्लॉक सिफर पर आधारित एन्क्रिप्शन योजनाओं से कर रहे होते हैं।

आप हमेशा एक ब्लॉक सिफर से आसानी से एक स्ट्रीम सिफर बना सकते हैं, लेकिन एक प्राइमिटिव स्ट्रीम सिफर से ब्लॉक मोड एन्क्रिप्शन (जैसे कि CBC मोड) का कोई प्रकार का निर्माण करना आमतौर पर बहुत मुश्किल होता है।

इस चर्चा से, अब आपको *चित्र 8* समझ में आ जाना चाहिए। यह सममित एन्क्रिप्शन योजनाओं का एक अवलोकन प्रदान करता है। हम तीन प्रकार की एन्क्रिप्शन योजनाओं का उपयोग करते हैं: प्राचीन स्ट्रीम सिफर, ब्लॉक सिफर स्ट्रीम सिफर, और ब्लॉक मोड में ब्लॉक सिफर (जिसे चित्र में "ब्लॉक सिफर" भी कहा गया है)।

*चित्र 8: सममित एन्क्रिप्शन योजनाओं का अवलोकन*

![Figure 8: Overview of symmetric encryption schemes](assets/Figure4-8.webp "Figure 8: Overview of symmetric encryption schemes")

## संदेश प्रमाणीकरण कोड्स

<chapterId>19fa7c00-db59-56a0-9654-5350a137939d</chapterId>

एन्क्रिप्शन का संबंध गोपनीयता से होता है। लेकिन क्रिप्टोग्राफी का दायरा इससे भी व्यापक है, जिसमें संदेश की अखंडता, प्रामाणिकता और गैर-प्रतिस्वीकृति जैसे विषय शामिल हैं। **संदेश प्रमाणीकरण कोड** (MACs) कहलाने वाली तकनीकें सममित कुंजी क्रिप्टोग्राफिक योजनाएं हैं जो संचार में प्रामाणिकता और अखंडता का समर्थन करती हैं।

संचार में गोपनीयता के अलावा और क्या आवश्यक है? मान लीजिए कि बॉब एलिस को एक संदेश भेजता है जिसका एन्क्रिप्शन लगभग तोड़ना असंभव है। कोई भी हमलावर जो इस संदेश को पकड़ लेता है, वह इसके सामग्री के बारे में कोई महत्वपूर्ण जानकारी प्राप्त नहीं कर पाएगा। हालांकि, हमलावर के पास अभी भी कम से कम दो अन्य हमले के तरीके उपलब्ध हैं:

1. वह सिफरटेक्स्ट को रोक सकती है, उसके सामग्री को बदल सकती है, और बदले हुए सिफरटेक्स्ट को एलिस के पास भेज सकती है।

2. वह बॉब के संदेश को पूरी तरह से ब्लॉक कर सकती है और अपनी खुद की बनाई हुई गुप्त संदेश भेज सकती है।

इन दोनों मामलों में, हमलावर को सिफरटेक्स्ट (1) और (2) की सामग्री के बारे में कोई जानकारी नहीं हो सकती है। लेकिन फिर भी वह इस तरीके से काफी नुकसान पहुंचा सकती है। यहीं पर संदेश प्रमाणीकरण कोड महत्वपूर्ण हो जाते हैं।

संदेश प्रमाणीकरण कोड (MAC) को आमतौर पर सममित क्रिप्टोग्राफिक योजनाओं के रूप में परिभाषित किया जाता है, जिनमें तीन एल्गोरिदम होते हैं: एक कुंजी उत्पन्न करने वाला एल्गोरिदम, एक टैग उत्पन्न करने वाला एल्गोरिदम, और एक सत्यापन एल्गोरिदम। एक सुरक्षित MAC यह सुनिश्चित करता है कि टैग किसी भी हमलावर के लिए **अस्तित्वगत रूप से जालसाजी योग्य** नहीं होते हैं—यानी, वे संदेश पर ऐसा टैग नहीं बना सकते जो सत्यापित हो जाए, जब तक कि उनके पास निजी कुंजी न हो।

बॉब और एलिस एक विशेष संदेश के साथ छेड़छाड़ को रोकने के लिए MAC (मैसेज ऑथेंटिकेशन कोड) का उपयोग कर सकते हैं। मान लीजिए कि फिलहाल उन्हें गोपनीयता की चिंता नहीं है। वे केवल यह सुनिश्चित करना चाहते हैं कि एलिस को जो संदेश मिला है, वह वास्तव में बॉब द्वारा ही भेजा गया है और उसमें किसी भी प्रकार का बदलाव नहीं किया गया है।

इस प्रक्रिया को *चित्र 9* में दर्शाया गया है। **MAC** (मैसेज ऑथेंटिकेशन कोड) का उपयोग करने के लिए, वे पहले एक निजी कुंजी $K$ को generate करेंगे जो उनके बीच साझा होती है। बॉब इस निजी कुंजी $K$ का उपयोग करके संदेश के लिए एक टैग $T$ बनाता है। फिर वह संदेश और संदेश टैग दोनों को एलिस को भेजता है। एलिस फिर इस बात की पुष्टि कर सकती है कि बॉब ने वास्तव में टैग बनाया है, इसके लिए वह निजी कुंजी, संदेश, और टैग को एक सत्यापन एल्गोरिदम के माध्यम से चलाती है।

*चित्र 9: सममित एन्क्रिप्शन योजनाओं का अवलोकन*

![Figure 9: Overview of symmetric encryption schemes](assets/Figure4-9.webp "Figure 9: Overview of symmetric encryption schemes")

**अस्तित्वगत अप्रमाणिकता** के कारण, एक हमलावर संदेश $M$ को किसी भी तरह से बदल नहीं सकता या अपने खुद के संदेश के लिए एक वैध टैग नहीं बना सकता। ऐसा इसलिए है, भले ही हमलावर बॉब और एलिस के बीच कई संदेशों के टैग देख ले, जो एक ही निजी कुंजी का उपयोग करते हैं। अधिक से अधिक, एक हमलावर एलिस को संदेश $M$ प्राप्त करने से रोक सकता है (जो एक समस्या है जिसे क्रिप्टोग्राफी हल नहीं कर सकती)।

एक MAC यह सुनिश्चित करता है कि कोई संदेश वास्तव में बॉब द्वारा ही बनाया गया है। यह प्रामाणिकता अपने आप में संदेश की अखंडता की गारंटी देती है - यानी, अगर बॉब ने कोई संदेश बनाया है, तो इसका मतलब है कि इसे किसी हमलावर द्वारा किसी भी तरह से बदला नहीं गया है। इसलिए, आगे से, जब भी प्रामाणिकता की बात होगी, तो यह समझा जाना चाहिए कि अखंडता की भी चिंता है।

हालांकि मैंने अपने चर्चा में संदेश की प्रामाणिकता और अखंडता के बीच एक अंतर किया है, लेकिन अक्सर इन शब्दों का उपयोग समानार्थी के रूप में भी किया जाता है। तब ये उन संदेशों के विचार को संदर्भित करते हैं जो किसी विशेष प्रेषक द्वारा बनाए गए थे और किसी भी तरह से बदले नहीं गए थे। इसी भावना में, संदेश प्रमाणीकरण कोड को अक्सर **संदेश अखंडता कोड** भी कहा जाता है।

## प्रमाणित एन्क्रिप्शन

<chapterId>33f2ec9b-9fb4-5c61-8fb4-50836270a144</chapterId>

आम तौर पर, आप संचार में गोपनीयता और प्रामाणिकता दोनों सुनिश्चित करना चाहेंगे, इसलिए एन्क्रिप्शन स्कीम और मैक स्कीम को आमतौर पर एक साथ उपयोग किया जाता है।

एक **प्रमाणित एन्क्रिप्शन योजना** एक ऐसी योजना है जो एन्क्रिप्शन को एक मैक (MAC) के साथ बहुत ही सुरक्षित तरीके से जोड़ती है। विशेष रूप से, इसे अस्तित्वगत नकली न होने की मानकों को पूरा करना होता है और साथ ही एक बहुत ही मजबूत गोपनीयता की धारणा को भी, जो कि **चयनित-साइफरटेक्स्ट हमलों** के प्रति प्रतिरोधी होती है। [7]

किसी एन्क्रिप्शन योजना को चुने गए-साइफरटेक्स्ट हमलों के प्रति प्रतिरोधी बनाने के लिए, उसे **गैर-परिवर्तनीयता** के मानकों को पूरा करना चाहिए: यानी, यदि कोई हमलावर किसी साइफरटेक्स्ट में बदलाव करता है, तो वह या तो एक अमान्य साइफरटेक्स्ट बनना चाहिए या ऐसा प्लेनटेक्स्ट बनना चाहिए जिसका मूल प्लेनटेक्स्ट से कोई संबंध न हो।

एक प्रमाणित एन्क्रिप्शन योजना यह सुनिश्चित करती है कि एक हमलावर द्वारा बनाया गया सिफरटेक्स्ट हमेशा अमान्य होता है (क्योंकि टैग सत्यापित नहीं होगा), यह चुने गए सिफरटेक्स्ट हमलों के प्रतिरोध के मानकों को पूरा करता है। दिलचस्प बात यह है कि आप यह साबित कर सकते हैं कि एक प्रमाणित एन्क्रिप्शन योजना हमेशा एक अस्तित्वगत रूप से अक्षम्य MAC और एक एन्क्रिप्शन योजना के संयोजन से बनाई जा सकती है, जो सुरक्षा की एक कम मजबूत धारणा को पूरा करती है, जिसे **चुने गए-प्लेनटेक्स्ट-हमला सुरक्षा** के रूप में जाना जाता है।

हम प्रमाणित एन्क्रिप्शन योजनाओं के निर्माण की सभी विवरणों में नहीं जाएंगे। लेकिन उनके निर्माण के दो विवरण जानना महत्वपूर्ण है।

सबसे पहले, एक प्रमाणित एन्क्रिप्शन योजना पहले एन्क्रिप्शन को संभालती है और फिर सिफरटेक्स्ट पर एक संदेश टैग बनाती है। यह पता चला है कि अन्य तरीके - जैसे कि सिफरटेक्स्ट को प्लेनटेक्स्ट पर टैग के साथ जोड़ना, या पहले एक टैग बनाना और फिर प्लेनटेक्स्ट और टैग दोनों को एन्क्रिप्ट करना - असुरक्षित होते हैं। इसके अलावा, दोनों प्रक्रियाओं के लिए उनके अपने अलग-अलग चुने गए निजी कुंजी होनी चाहिए, अन्यथा आपकी सुरक्षा गंभीर रूप से खतरे में पड़ जाती है।

उपरोक्त सिद्धांत सामान्य रूप से लागू होता है: *जब भी आप बुनियादी क्रिप्टोग्राफिक योजनाओं को मिलाते हैं, तो हमेशा अलग-अलग कुंजियों का उपयोग करना चाहिए*।

*चित्र 10* में एक प्रमाणित एन्क्रिप्शन योजना को दर्शाया गया है। सबसे पहले, बॉब एक यादृच्छिक रूप से चुनी गई कुंजी $K_C$ का उपयोग करके संदेश $M$ से एक सिफरटेक्स्ट $C$ बनाता है। फिर वह सिफरटेक्स्ट और एक अलग यादृच्छिक रूप से चुनी गई कुंजी $K_T$ को टैग जनरेशन एल्गोरिदम के माध्यम से चलाकर एक संदेश टैग $T$ बनाता है। बॉब सिफरटेक्स्ट और संदेश टैग दोनों को एलिस के पास भेजता है।

एलिस अब सबसे पहले यह जांचती है कि टैग सही है या नहीं, दिए गए सिफरटेक्स्ट $C$ और कुंजी $K_T$ के आधार पर। अगर टैग सही है, तो वह कुंजी $K_C$ का उपयोग करके संदेश को डिक्रिप्ट कर सकती है। इससे न केवल उसे उनके संवाद में बहुत मजबूत गोपनीयता का भरोसा मिलता है, बल्कि उसे यह भी पता चलता है कि संदेश बॉब द्वारा ही बनाया गया है।

*चित्र 10: एक प्रमाणित एन्क्रिप्शन योजना*

![Figure 10: An authenticated encryption scheme](assets/Figure4-10.webp "Figure 10: An authenticated encryption scheme")

MACs कैसे बनाए जाते हैं? MACs को कई तरीकों से बनाया जा सकता है, लेकिन उन्हें बनाने का एक सामान्य और प्रभावी तरीका **क्रिप्टोग्राफिक Hash फंक्शन्स** के माध्यम से है।

हम *अध्याय 6* में क्रिप्टोग्राफिक Hash फंक्शन्स को अधिक विस्तार से समझाएंगे। फिलहाल, बस इतना जान लें कि एक **Hash फंक्शन** एक ऐसा फंक्शन है जिसे आसानी से गणना की जा सकती है, जो किसी भी आकार के इनपुट को लेता है और निश्चित लंबाई के आउटपुट देता है। उदाहरण के लिए, लोकप्रिय Hash फंक्शन **SHA-256** (सिक्योर Hash एल्गोरिदम 256) हमेशा 256-बिट का आउटपुट उत्पन्न करता है, चाहे इनपुट का आकार कुछ भी हो। कुछ Hash फंक्शन्स, जैसे SHA-256, का क्रिप्टोग्राफी में उपयोगी अनुप्रयोग होता है।

क्रिप्टोग्राफिक Hash फंक्शन के साथ सबसे आम प्रकार का टैग जो उत्पन्न होता है, वह है **Hash-आधारित संदेश प्रमाणीकरण कोड** (HMAC)। इस प्रक्रिया को *चित्र 11* में दर्शाया गया है। एक पार्टी एक निजी कुंजी $K$ से दो अलग-अलग कुंजियाँ उत्पन्न करती है, आंतरिक कुंजी $K_1$ और बाहरी कुंजी $K_2$। फिर साधारण पाठ $M$ या गुप्त पाठ $C$ को आंतरिक कुंजी के साथ हैश किया जाता है। परिणाम $T'$ को फिर बाहरी कुंजी के साथ हैश किया जाता है ताकि संदेश टैग $T$ उत्पन्न हो सके।

Hash फंक्शन्स का एक सेट है जिसका उपयोग HMAC बनाने के लिए किया जा सकता है। इनमें से सबसे आमतौर पर इस्तेमाल किया जाने वाला Hash फंक्शन SHA-256 है।

*चित्र 11: एचएमएसी*

![Figure 11: HMAC](assets/Figure4-11.webp "Figure 11: HMAC")

**नोट्स:**

[7] इस खंड में चर्चा किए गए विशेष परिणाम Katz और Lindell की पुस्तक के पृष्ठ 131-47 से लिए गए हैं।

तकनीकी रूप से, चुने हुए सिफर टेक्स्ट हमलों की परिभाषा गैर-परिवर्तनीयता की अवधारणा से अलग है। लेकिन आप यह दिखा सकते हैं कि सुरक्षा की ये दोनों अवधारणाएँ समकक्ष हैं।

## सुरक्षित संचार सत्र

<chapterId>c7f7dcd3-bbed-53ed-a43d-039da0f180c5</chapterId>

मान लीजिए कि दो पक्ष एक संचार सत्र में हैं, तो वे एक-दूसरे को कई संदेश भेजते और प्राप्त करते हैं।

एक प्रमाणित एन्क्रिप्शन योजना एक संदेश प्राप्तकर्ता को यह सत्यापित करने की अनुमति देती है कि वह संदेश उसके संचार सत्र के साथी द्वारा ही बनाया गया है (जब तक कि निजी कुंजी लीक नहीं हुई है)। यह एकल संदेश के लिए अच्छी तरह से काम करता है। हालांकि, आमतौर पर दो पक्ष एक संचार सत्र में एक-दूसरे को संदेश भेज रहे होते हैं। और इस स्थिति में, जैसा कि पिछले खंड में वर्णित साधारण प्रमाणित एन्क्रिप्शन योजना सुरक्षा प्रदान करने में असफल होती है।

मुख्य कारण यह है कि एक प्रमाणित एन्क्रिप्शन योजना यह गारंटी नहीं देती कि संदेश वास्तव में उसी एजेंट द्वारा भेजा गया था जिसने इसे एक संचार सत्र के दौरान बनाया था। निम्नलिखित तीन हमले के तरीकों पर विचार करें:

1. **रीप्ले हमला**: एक हमलावर पहले से दो पक्षों के बीच भेजे गए सिफरटेक्स्ट और टैग को फिर से भेजता है जिसे उसने पहले इंटरसेप्ट किया था।

2. **पुनः क्रमबद्धता हमला**: एक हमलावर अलग-अलग समय पर दो संदेशों को पकड़ लेता है और उन्हें प्राप्तकर्ता को उल्टे क्रम में भेजता है।

3. **रिफ्लेक्शन अटैक**: एक हमलावर A से B को भेजे गए संदेश को देखता है, और फिर उसी संदेश को A को भेज देता है।

हालांकि हमलावर को सिफरटेक्स्ट की जानकारी नहीं है और वह नकली सिफरटेक्स्ट नहीं बना सकता, फिर भी ऊपर बताए गए हमले संचार में काफी नुकसान पहुंचा सकते हैं।

मान लीजिए कि दो पक्षों के बीच एक विशेष संदेश में वित्तीय धन का स्थानांतरण शामिल है। एक रिप्ले अटैक उस धन को दूसरी बार स्थानांतरित कर सकता है। एक साधारण प्रमाणित एन्क्रिप्शन योजना के पास ऐसे हमलों के खिलाफ कोई सुरक्षा नहीं होती है।

सौभाग्य से, इन प्रकार के हमलों को एक संचार सत्र में **पहचानकर्ताओं** और **सापेक्ष समय संकेतकों** का उपयोग करके आसानी से कम किया जा सकता है।

एन्क्रिप्शन से पहले प्लेनटेक्स्ट संदेश में पहचानकर्ता जोड़े जा सकते हैं। इससे किसी भी रिफ्लेक्शन अटैक को रोका जा सकता है। एक सापेक्ष समय संकेतक, उदाहरण के लिए, एक विशेष संचार सत्र में एक अनुक्रम संख्या हो सकती है। प्रत्येक पक्ष एन्क्रिप्शन से पहले संदेश में एक अनुक्रम संख्या जोड़ता है, ताकि प्राप्तकर्ता को पता चल सके कि संदेश किस क्रम में भेजे गए थे। इससे पुनः क्रमबद्ध करने वाले हमलों की संभावना समाप्त हो जाती है। यह रिप्ले अटैक को भी समाप्त करता है। कोई भी संदेश जो हमलावर आगे भेजता है, उसमें पुरानी अनुक्रम संख्या होगी, और प्राप्तकर्ता जान जाएगा कि उस संदेश को फिर से प्रोसेस नहीं करना है।

यह समझाने के लिए कि सुरक्षित संचार सत्र कैसे काम करते हैं, फिर से कल्पना करें कि एलीस और बॉब हैं। वे कुल चार संदेश एक-दूसरे को भेजते हैं। आप देख सकते हैं कि पहचानकर्ताओं और क्रम संख्या के साथ एक प्रमाणित एन्क्रिप्शन योजना कैसे काम करेगी, नीचे *चित्र 11* में।

संचार सत्र की शुरुआत में, बॉब एक सिफरटेक्स्ट $C_{0,B}$ ऐलिस को भेजता है, जिसमें एक संदेश टैग $T_{0,B}$ होता है। इस सिफरटेक्स्ट में संदेश के साथ-साथ एक पहचानकर्ता (BOB) और एक क्रम संख्या (0) शामिल होती है। टैग $T_{0,B}$ पूरे सिफरटेक्स्ट पर बनाया जाता है। अपनी आगे की बातचीत में, ऐलिस और बॉब इस प्रोटोकॉल को बनाए रखते हैं और आवश्यकतानुसार फील्ड्स को अपडेट करते रहते हैं।

*चित्र 12: एक सुरक्षित संचार सत्र*

![Figure 12: A secure communication session](assets/Figure4-12.webp "Figure 12: A secure communication sessesion")

# RC4 और AES

<partId>a48c4a7d-0a41-523f-a4ab-1305b4430324</partId>

## RC4 स्ट्रीम सिफर

<chapterId>5caec5bd-5a77-56c9-b5e6-1e86f0d294aa</chapterId>

इस अध्याय में, हम एक एन्क्रिप्शन योजना के विवरण पर चर्चा करेंगे जिसमें एक आधुनिक प्राइमिटिव स्ट्रीम सिफर, RC4 (या "रिवेस्ट सिफर 4"), और एक आधुनिक ब्लॉक सिफर, AES शामिल हैं। हालांकि RC4 सिफर एन्क्रिप्शन के तरीके के रूप में अब उतना लोकप्रिय नहीं है, AES आधुनिक सममित एन्क्रिप्शन के लिए मानक है। ये दो उदाहरण आपको यह समझने में मदद करेंगे कि सममित एन्क्रिप्शन अंदर से कैसे काम करता है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आधुनिक छद्म-यादृच्छिक स्ट्रीम सिफर कैसे काम करते हैं, इसे समझने के लिए मैं RC4 स्ट्रीम सिफर पर ध्यान केंद्रित करूंगा। यह एक छद्म-यादृच्छिक स्ट्रीम सिफर है जिसका उपयोग WEP और WAP वायरलेस एक्सेस पॉइंट सुरक्षा प्रोटोकॉल में और TLS में किया गया था। हालांकि, RC4 में कई सिद्ध कमजोरियाँ हैं, जिसके कारण यह अब अप्रचलित हो गया है। वास्तव में, इंटरनेट इंजीनियरिंग टास्क फोर्स ने अब सभी TLS मामलों में क्लाइंट और सर्वर अनुप्रयोगों द्वारा RC4 सूट के उपयोग पर प्रतिबंध लगा दिया है। फिर भी, यह एक आदिम स्ट्रीम सिफर के काम करने के तरीके को समझाने के लिए एक अच्छे उदाहरण के रूप में काम करता है।

शुरू करने के लिए, मैं पहले दिखाऊंगा कि एक साधारण RC4 सिफर के साथ एक साधारण संदेश को कैसे एन्क्रिप्ट किया जाता है। मान लीजिए कि हमारा साधारण संदेश "SOUP" है। हमारे साधारण RC4 सिफर के साथ एन्क्रिप्शन चार चरणों में होता है।

### चरण 1

सबसे पहले, एक array **S** को परिभाषित करें जिसमें $S[0] = 0$ से $S[7] = 7$ तक हो। यहाँ array का मतलब एक ऐसी संग्रह से है जिसमें मानों को एक अनुक्रमणिका (index) के द्वारा व्यवस्थित किया जाता है, जिसे कुछ प्रोग्रामिंग भाषाओं (जैसे, Python) में सूची (list) भी कहा जाता है। इस मामले में, अनुक्रमणिका 0 से 7 तक चलती है, और मान भी 0 से 7 तक होते हैं। तो **S** इस प्रकार है:


- $S = [0, 1, 2, 3, 4, 5, 6, 7]$ एक सेट है जिसमें 0 से 7 तक के अंक शामिल हैं।

यहाँ दिए गए मान ASCII नंबर नहीं हैं, बल्कि 1-बाइट स्ट्रिंग्स के दशमलव मान हैं। इसलिए मान 2 का अर्थ होगा $0000 \ 0011$। इस प्रकार, एरे **S** की लंबाई 8 बाइट्स है।

### चरण 2

दूसरा, एक मुख्य एरे **K** को 8 बाइट्स की लंबाई में परिभाषित करें, जिसमें आप 1 से 8 बाइट्स के बीच एक कुंजी चुन सकते हैं (बाइट्स के अंश की अनुमति नहीं है)। चूंकि प्रत्येक बाइट 8 बिट्स की होती है, आप अपनी कुंजी के प्रत्येक बाइट के लिए 0 से 255 के बीच कोई भी संख्या चुन सकते हैं।

मान लीजिए कि हमने अपनी कुंजी **k** को $[14, 48, 9]$ के रूप में चुना है, जिससे इसकी लंबाई 3 बाइट्स है। हमारी कुंजी सरणी के प्रत्येक इंडेक्स को, क्रम में, कुंजी के उस विशेष तत्व के दशमलव मान के अनुसार सेट किया गया है। यदि आप पूरी कुंजी के माध्यम से चलते हैं, तो फिर से शुरुआत से शुरू करें, जब तक कि आपने कुंजी सरणी के 8 स्लॉट्स को भर नहीं लिया। इस प्रकार, हमारी कुंजी सरणी इस प्रकार है:


- $K = [14, 48, 9, 14, 48, 9, 14, 48]$

### चरण 3

तीसरा, हम कुंजी सरणी **K** का उपयोग करके सरणी **S** को रूपांतरित करेंगे, जिसे **कुंजी अनुसूची** के रूप में जाना जाता है। इस प्रक्रिया को निम्नलिखित छद्मकोड में समझाया गया है:


- आपको दो वेरिएबल बनाने हैं: **j** और **i**।
- वेरिएबल $j$ को 0 पर सेट करें।
- प्रत्येक $i$ के लिए 0 से 7 तक:
    - $j = (j + S[i] + K[i]) \bmod 8$ को हिंदी में इस प्रकार समझा जा सकता है: 

"ज को (ज + S[i] + K[i]) का 8 से भाग देने पर जो शेष बचे, उसके बराबर सेट करें।" 

यह गणितीय अभिव्यक्ति है जिसमें $j$, $S[i]$, और $K[i]$ कुछ मान हैं और $\mod 8$ का मतलब है कि आप 8 से भाग देने पर जो शेष बचेगा, वही अंतिम परिणाम होगा।
    - $S[i]$ और $S[j]$ की अदला-बदली करें।

सरणी **S** का रूपांतरण *तालिका 1* में दर्शाया गया है।

शुरुआत में, आप **S** की प्रारंभिक स्थिति को $[0, 1, 2, 3, 4, 5, 6, 7]$ के रूप में देख सकते हैं, जिसमें **j** की प्रारंभिक मान 0 है। इसे कुंजी सरणी $[14, 48, 9, 14, 48, 9, 14, 48]$ का उपयोग करके परिवर्तित किया जाएगा।

फॉर लूप $i = 0$ से शुरू होता है। हमारे ऊपर दिए गए छद्मकोड के अनुसार, **j** का नया मान 6 हो जाता है ($j = (j + S[0] + K[0]) \mod 8 = (0 + 0 + 14) \mod 8 = 6 \mod 8$)। $S[0]$ और $S[6]$ की अदला-बदली करने पर, 1 राउंड के बाद **S** की स्थिति $[6, 1, 2, 3, 4, 5, 0, 7]$ हो जाती है।

अगली पंक्ति में, $i = 1$ है। फॉर लूप से फिर से गुजरते हुए, **j** को 7 का मान प्राप्त होता है ($j = (j + S[1] + K[1]) \mod 8 = (6 + 1 + 48) \mod 8 = 55 \mod 8 = 7 \mod 8$)। वर्तमान स्थिति **S** से $S[1]$ और $S[7]$ की अदला-बदली करने पर, $[6, 1, 2, 3, 4, 5, 0, 7]$ से $[6, 7, 2, 3, 4, 5, 0, 1]$ प्राप्त होता है, जो राउंड 2 के बाद की स्थिति है।

हम इस प्रक्रिया को तब तक जारी रखते हैं जब तक कि हम **S** नामक array के लिए अंतिम पंक्ति नहीं बना लेते, जो है $[6, 4, 1, 0, 3, 7, 5, 2]$।

*तालिका 1: मुख्य समय-सारणी तालिका*

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

### चरण 4

चौथे कदम के रूप में, हम **कीस्ट्रीम** तैयार करते हैं। यह एक छद्म-यादृच्छिक स्ट्रिंग होती है, जिसकी लंबाई उस संदेश के बराबर होती है जिसे हम भेजना चाहते हैं। इसका उपयोग मूल संदेश "SOUP" को एन्क्रिप्ट करने के लिए किया जाएगा। चूंकि कीस्ट्रीम को संदेश जितना लंबा होना चाहिए, हमें 4 बाइट्स की एक कीस्ट्रीम की आवश्यकता होती है।

कीस्ट्रीम निम्नलिखित छद्मकोड द्वारा उत्पन्न की जाती है:


- आपको तीन वेरिएबल बनाने हैं: **j**, **i**, और **t**।
- $j = 0$ सेट करें।
- प्रत्येक $i$ के लिए, जो कि प्लेनटेक्स्ट का हिस्सा है, $i = 1$ से शुरू होकर $i = 4$ तक जाता है, कीस्ट्रीम का प्रत्येक बाइट इस प्रकार उत्पन्न होता है:
    - $j = (j + S[i]) \mod 8$
    - $S[i]$ और $S[j]$ की अदला-बदली करें।
    - $t = (S[i] + S[j]) \bmod 8$
    - कीस्ट्रीम का $i^{th}$ बाइट = $S[t]$

आप *टेबल 2* में गणनाओं का अनुसरण कर सकते हैं।

शुरुआती स्थिति में **S** है $S = [6, 4, 1, 0, 3, 7, 5, 2]$। जब हम $i = 1$ सेट करते हैं, तो **j** का मान 4 हो जाता है ($j = (j + S[i]) \mod 8 = (0 + 4) \mod 8 = 4$)। इसके बाद हम $S[1]$ और $S[4]$ को अदला-बदली करते हैं, जिससे **S** का दूसरा रूपांतरण मिलता है, $[6, 3, 1, 0, 4, 7, 5, 2]$। फिर **t** का मान 7 होता है ($t = (S[i] + S[j]) \mod 8 = (3 + 4) \mod 8 = 7$)। अंत में, कीस्ट्रीम के लिए बाइट $S[7]$ होता है, जो कि 2 है।

इसके बाद हम अन्य बाइट्स का उत्पादन करते हैं जब तक कि हमारे पास निम्नलिखित चार बाइट्स नहीं हो जाते: 2, 6, 3, और 7। इन बाइट्स का उपयोग फिर "SOUP" के प्रत्येक अक्षर को एन्क्रिप्ट करने के लिए किया जा सकता है।

शुरू करने के लिए, एक ASCII तालिका का उपयोग करके, हम देख सकते हैं कि "SOUP" को उसके बाइट स्ट्रिंग्स के दशमलव मानों द्वारा "83 79 85 80" के रूप में एन्कोड किया गया है। इसे कीस्ट्रीम "2 6 3 7" के साथ मिलाने पर "85 85 88 87" प्राप्त होता है, जो 256 के मॉड्यूलो ऑपरेशन के बाद भी वही रहता है। ASCII में, सिफरटेक्स्ट "85 85 88 87" "UUXW" के बराबर होता है।

अगर एन्क्रिप्ट करने वाला शब्द array **S** से लंबा हो, तो क्या होगा? उस स्थिति में, array **S** हर बाइट **i** के लिए ऊपर दिखाए गए तरीके से बदलता रहता है, जब तक कि हमारे पास कीस्ट्रीम में उतने बाइट्स नहीं हो जाते जितने कि प्लेनटेक्स्ट में अक्षर हैं।

*तालिका 2: कीस्ट्रीम निर्माण*

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

हमने जो उदाहरण अभी चर्चा की, वह **RC4 स्ट्रीम सिफर** का केवल एक सरल संस्करण है। असली RC4 स्ट्रीम सिफर में **S** एरे 256 बाइट्स लंबा होता है, न कि 8 बाइट्स, और एक कुंजी जो 1 से 256 बाइट्स के बीच हो सकती है, न कि 1 से 8 बाइट्स के बीच। कुंजी एरे और कीस्ट्रीम्स तब 256-बाइट लंबाई के **S** एरे को ध्यान में रखते हुए उत्पन्न होते हैं। गणनाएँ अत्यधिक जटिल हो जाती हैं, लेकिन सिद्धांत वही रहते हैं। उसी कुंजी [14,48,9] का उपयोग करते हुए, मानक RC4 सिफर के साथ, साधारण संदेश "SOUP" को हेक्साडेसिमल प्रारूप में 67 02 ed df के रूप में एन्क्रिप्ट किया जाता है।

एक स्ट्रीम सिफर जिसमें कीस्ट्रीम का अपडेट प्लेनटेक्स्ट संदेश या सिफरटेक्स्ट से स्वतंत्र होता है, उसे **सिंक्रोनस स्ट्रीम सिफर** कहा जाता है। कीस्ट्रीम केवल कुंजी पर निर्भर होती है। स्पष्ट रूप से, RC4 एक सिंक्रोनस स्ट्रीम सिफर का उदाहरण है, क्योंकि कीस्ट्रीम का प्लेनटेक्स्ट या सिफरटेक्स्ट से कोई संबंध नहीं होता। हमारे द्वारा पिछले अध्याय में उल्लेखित सभी प्रारंभिक स्ट्रीम सिफर, जैसे कि शिफ्ट सिफर, विजनेयर सिफर, और वन-टाइम पैड, भी सिंक्रोनस प्रकार के थे।

इसके विपरीत, एक **असिंक्रोनस स्ट्रीम सिफर** में कीस्ट्रीम को कुंजी और सिफरटेक्स्ट के पिछले Elements दोनों से उत्पन्न किया जाता है। इस प्रकार के सिफर को **स्वयं-सिंक्रीकृत सिफर** भी कहा जाता है।

महत्वपूर्ण बात यह है कि RC4 के साथ उत्पन्न कीस्ट्रीम को एक बार इस्तेमाल होने वाले पैड की तरह माना जाना चाहिए, और आप अगली बार बिल्कुल उसी तरह से कीस्ट्रीम नहीं बना सकते। हर बार कुंजी बदलने के बजाय, व्यावहारिक समाधान यह है कि कुंजी को **Nonce** के साथ मिलाकर बाइटस्ट्रीम उत्पन्न की जाए।

## AES (एईएस) एक एन्क्रिप्शन तकनीक है जो डेटा को सुरक्षित रखने के लिए उपयोग की जाती है। जब हम 128-बिट की कुंजी के साथ AES का उपयोग करते हैं, तो इसका मतलब है कि एन्क्रिप्शन प्रक्रिया में 128-बिट लंबाई की एक कुंजी का उपयोग किया जा रहा है। यह कुंजी डेटा को एन्क्रिप्ट और डिक्रिप्ट करने के लिए आवश्यक होती है, जिससे केवल अधिकृत व्यक्ति ही उस डेटा को पढ़ सकें। 128-बिट कुंजी AES के लिए एक मानक विकल्प है और यह सुरक्षा और प्रदर्शन के बीच एक अच्छा संतुलन प्रदान करती है।

<chapterId>0b30886f-e620-5b8d-807b-9d84685ca8ff</chapterId>

जैसा कि पिछले अध्याय में बताया गया था, नेशनल इंस्टीट्यूट ऑफ स्टैंडर्ड्स एंड टेक्नोलॉजी (NIST) ने 1997 से 2000 के बीच एक प्रतियोगिता आयोजित की थी ताकि एक नया सममित एन्क्रिप्शन मानक निर्धारित किया जा सके। **रिजंडेल सिफर** इस प्रतियोगिता का विजेता बना। इसका नाम इसके बेल्जियन निर्माताओं, विंसेंट रिजमेन और जोआन डेमेन के नामों पर एक शब्द खेल है।

रिजंडेल सिफर एक **ब्लॉक सिफर** है, जिसका मतलब है कि इसमें एक मुख्य एल्गोरिदम होता है, जिसे विभिन्न कुंजी लंबाई और ब्लॉक आकार के साथ इस्तेमाल किया जा सकता है। इसके बाद, आप इसे विभिन्न ऑपरेशन मोड के साथ उपयोग करके एन्क्रिप्शन योजनाएँ बना सकते हैं।

NIST प्रतियोगिता के लिए समिति ने Rijndael सिफर का एक संकुचित संस्करण अपनाया, जिसमें 128-बिट ब्लॉक साइज और 128 बिट, 192 बिट, या 256 बिट की कुंजी लंबाई की आवश्यकता होती है। इसे **एडवांस्ड एन्क्रिप्शन स्टैंडर्ड (AES)** के रूप में जाना जाता है। Rijndael सिफर का यह संकुचित संस्करण कई ऑपरेशन मोड्स के तहत भी इस्तेमाल किया जा सकता है। इस मानक के लिए जो विनिर्देश है, उसे **एडवांस्ड एन्क्रिप्शन स्टैंडर्ड (AES)** कहा जाता है।

यह दिखाने के लिए कि Rijndael सिफर, जो AES का मुख्य हिस्सा है, कैसे काम करता है, मैं 128-बिट की कुंजी के साथ एन्क्रिप्शन की प्रक्रिया को समझाऊंगा। कुंजी का आकार एन्क्रिप्शन के प्रत्येक ब्लॉक के लिए होने वाले राउंड की संख्या पर प्रभाव डालता है। 128-बिट की कुंजी के लिए, 10 राउंड की आवश्यकता होती है। अगर कुंजी 192 बिट की होती, तो 12 राउंड होते और 256 बिट की कुंजी के लिए 14 राउंड होते।

इसके अलावा, मैं यह मानूंगा कि AES को **ECB-मोड** में इस्तेमाल किया जा रहा है। इससे समझाना थोड़ा आसान हो जाता है और यह Rijndael एल्गोरिदम के लिए कोई फर्क नहीं पड़ता। ध्यान देने वाली बात यह है कि ECB मोड व्यावहारिक रूप से सुरक्षित नहीं है क्योंकि यह निश्चित एन्क्रिप्शन की ओर ले जाता है। AES के साथ सबसे आमतौर पर इस्तेमाल किया जाने वाला सुरक्षित मोड **CBC** (साइफर ब्लॉक चेनिंग) है।

हम इस कुंजी को $K_0$ कहेंगे। ऊपर दिए गए पैरामीटरों के साथ निर्माण *चित्र 1* में दिखाया गया है, जहाँ $M_i$ 128 बिट्स के प्लेनटेक्स्ट संदेश के एक भाग का प्रतिनिधित्व करता है और $C_i$ 128 बिट्स के सिफरटेक्स्ट के एक भाग का। यदि प्लेनटेक्स्ट को ब्लॉक आकार से समान रूप से विभाजित नहीं किया जा सकता है, तो अंतिम ब्लॉक के लिए प्लेनटेक्स्ट में पैडिंग जोड़ी जाती है।

*चित्र 1: AES-ECB 128-बिट कुंजी के साथ*

![Figure 1: AES-ECB with a 128-bit key](assets/Figure5-1.webp "Figure 1: AES-ECB with a 128-bit key")

Rijndael एन्क्रिप्शन स्कीम में प्रत्येक 128-बिट टेक्स्ट ब्लॉक को दस राउंड से गुजारा जाता है। इसके लिए प्रत्येक राउंड के लिए एक अलग राउंड कुंजी की आवश्यकता होती है ($K_1$ से $K_{10}$ तक)। ये कुंजियाँ मूल 128-बिट कुंजी $K_0$ से **कुंजी विस्तार एल्गोरिदम** का उपयोग करके प्रत्येक राउंड के लिए बनाई जाती हैं। इसलिए, प्रत्येक टेक्स्ट ब्लॉक को एन्क्रिप्ट करने के लिए, हम मूल कुंजी $K_0$ के साथ-साथ दस अलग-अलग राउंड कुंजियों का उपयोग करेंगे। ध्यान दें कि इन 11 कुंजियों का उपयोग प्रत्येक 128-बिट प्लेनटेक्स्ट ब्लॉक के लिए किया जाता है जिसे एन्क्रिप्शन की आवश्यकता होती है।

कुंजी विस्तार एल्गोरिदम लंबा और जटिल है। इसे समझने से शिक्षण में ज्यादा लाभ नहीं होता। अगर आप चाहें तो आप खुद से कुंजी विस्तार एल्गोरिदम देख सकते हैं। एक बार जब राउंड कुंजियाँ तैयार हो जाती हैं, तो रिंजडेल सिफर पहले 128-बिट ब्लॉक के प्लेनटेक्स्ट, $M_1$, को *चित्र 2* में दिखाए अनुसार बदल देगा। अब हम इन चरणों को देखेंगे।

चित्र 2: Rijndael सिफर के साथ $M_1$ का हेरफेर:

**राउंड 0:**


- $M_1$ और $K_0$ को XOR करें ताकि $S_0$ प्राप्त हो सके।

---
**n को राउंड करें जहाँ n = {1,...,9}:**

मतलब, आपको 1 से 9 तक के हर नंबर को राउंड करना है। राउंड करने का मतलब है कि अगर नंबर 5 या उससे ज्यादा है तो उसे अगले पूरे नंबर तक बढ़ा दें, और अगर 4 या उससे कम है तो उसे पिछले पूरे नंबर तक घटा दें। उदाहरण के लिए, अगर n = 3 है, तो राउंड करने पर भी 3 ही रहेगा, लेकिन अगर n = 5 है, तो राउंड करने पर 5 ही रहेगा।


- $S_{n-1}$ और $K_n$ का XOR करें।
- बाइट प्रतिस्थापन
- पंक्तियों को शिफ्ट करें
- मिक्स कॉलम्स
- $S$ और $K_n$ को XOR करें ताकि $S_n$ प्राप्त हो सके।

---
**राउंड 10:**


- $S_9$ और $K_{10}$ का XOR करें।
- बाइट प्रतिस्थापन
- पंक्तियों को शिफ्ट करें
- $S$ और $K_{10}$ का XOR करें ताकि $S_{10}$ प्राप्त हो सके।
- $S_{10}$ = $C_1$

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

रिजंडेल सिफर का राउंड 0 काफी सरल है। एक ऐरे $S_0$ तैयार किया जाता है, जो 128-बिट के प्लेनटेक्स्ट और प्राइवेट की के बीच XOR ऑपरेशन करके प्राप्त होता है। मतलब,


- $S_0 = M_1 \oplus K_0$ का मतलब है कि $S_0$ को $M_1$ और $K_0$ के बीच XOR ऑपरेशन करके प्राप्त किया गया है। यहाँ $\oplus$ का मतलब XOR ऑपरेशन है, जो एक बिटवाइज ऑपरेशन है।

### आपकी जानकारी अक्टूबर 2023 तक के डेटा पर आधारित है।

राउंड 1 में, सबसे पहले $S_0$ नामक ऐरे को राउंड कुंजी $K_1$ के साथ XOR ऑपरेशन के जरिए जोड़ा जाता है। इससे $S$ की एक नई स्थिति बनती है।

दूसरा, **बाइट सब्स्टीट्यूशन** ऑपरेशन वर्तमान $S$ की स्थिति पर किया जाता है। यह 16-बाइट $S$ एरे के प्रत्येक बाइट को लेकर और उसे **रिजंडेल का S-बॉक्स** नामक एरे से एक बाइट के साथ बदलकर काम करता है। प्रत्येक बाइट का एक अनोखा परिवर्तन होता है, और इसके परिणामस्वरूप $S$ की एक नई स्थिति उत्पन्न होती है। रिजंडेल का S-बॉक्स *चित्र 3* में दिखाया गया है।

*चित्र 3: रिजनडेल का एस-बॉक्स*

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

यह S-Box वह जगह है जहाँ Rijndael सिफर में अमूर्त बीजगणित का उपयोग होता है, विशेष रूप से **गैलोइस फील्ड्स**।

शुरू करने के लिए, आप प्रत्येक संभावित बाइट तत्व 00 से FF को एक 8-बिट वेक्टर के रूप में परिभाषित करते हैं। प्रत्येक ऐसा वेक्टर **गैलोइस फील्ड GF(2^8)** का एक तत्व होता है, जहाँ माड्यूलो ऑपरेशन के लिए अपरिवर्तनीय बहुपद $x^8 + x^4 + x^3 + x + 1$ है। इन विशिष्टताओं के साथ गैलोइस फील्ड को **रिजंडेल का सीमित क्षेत्र** भी कहा जाता है।

अब, क्षेत्र के प्रत्येक संभावित तत्व के लिए, हम **नाइबर्ग एस-बॉक्स** बनाते हैं। इस बॉक्स में, प्रत्येक बाइट को उसके **गुणात्मक व्युत्क्रम** (यानी, ऐसा कि उनका गुणनफल 1 हो) पर मैप किया जाता है। फिर हम उन मूल्यों को नाइबर्ग एस-बॉक्स से रिजनडेल के एस-बॉक्स में **एफाइन ट्रांसफॉर्मेशन** का उपयोग करके मैप करते हैं।

**S** ऐरे पर तीसरी प्रक्रिया **शिफ्ट रोज़** ऑपरेशन है। यह **S** की स्थिति को लेता है और सभी सोलह बाइट्स को एक मैट्रिक्स में सूचीबद्ध करता है। मैट्रिक्स को भरना ऊपर बाएँ से शुरू होता है और यह ऊपर से नीचे की ओर जाता है। जब भी एक कॉलम भर जाता है, तो इसे एक कॉलम दाईं ओर और ऊपर की ओर शिफ्ट कर दिया जाता है।

जब **S** का मैट्रिक्स तैयार हो जाता है, तो चारों पंक्तियों को शिफ्ट किया जाता है। पहली पंक्ति वैसे ही रहती है। दूसरी पंक्ति को एक स्थान बाईं ओर खिसकाया जाता है। तीसरी पंक्ति को दो स्थान बाईं ओर खिसकाया जाता है। चौथी पंक्ति को तीन स्थान बाईं ओर खिसकाया जाता है। इस प्रक्रिया का एक उदाहरण *चित्र 4* में दिया गया है। **S** की मूल स्थिति ऊपर दिखाई गई है, और पंक्तियों को शिफ्ट करने के बाद की स्थिति उसके नीचे दिखाई गई है।

*चित्र 4: पंक्तियों को स्थानांतरित करने की प्रक्रिया*

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

| D4   | 72   | 04   | 21   |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

चौथे चरण में, **गैलोइस फील्ड्स** फिर से दिखाई देते हैं। शुरुआत में, **S** मैट्रिक्स के प्रत्येक कॉलम को *चित्र 5* में दिखाए गए 4 x 4 मैट्रिक्स के कॉलम से गुणा किया जाता है। लेकिन यह सामान्य मैट्रिक्स गुणा नहीं है, बल्कि यह एक वेक्टर गुणा है **एक अपरिवर्तनीय बहुपद** $x^8 + x^4 + x^3 + x + 1$ के माड्यूलो के साथ। परिणामी वेक्टर गुणांक एक बाइट के व्यक्तिगत बिट्स का प्रतिनिधित्व करते हैं।

*चित्र 5: मिक्स कॉलम्स मैट्रिक्स*

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

**S** मैट्रिक्स के पहले कॉलम को ऊपर दिए गए 4 x 4 मैट्रिक्स से गुणा करने पर *चित्र 6* में दिखाया गया परिणाम मिलता है।

*चित्र 6: पहले कॉलम का गुणा:*

$$
\begin{matrix}
02 \cdot F1 + 03 \cdot EF + 01 \cdot B0 + 01 \cdot 21 \\
01 \cdot F1 + 02 \cdot EF + 03 \cdot B0 + 01 \cdot 21 \\
01 \cdot F1 + 01 \cdot EF + 02 \cdot B0 + 03 \cdot 21 \\
03 \cdot F1 + 01 \cdot EF + 01 \cdot B0 + 02 \cdot 21
\end{matrix}
$$

अगले कदम के रूप में, मैट्रिक्स में सभी तत्वों को बहुपदों में बदलना होगा। उदाहरण के लिए, F1 जो 1 बाइट को दर्शाता है, उसे $x^7 + x^6 + x^5 + x^4 + 1$ में बदल दिया जाएगा, और 03 जो 1 बाइट को दर्शाता है, उसे $x + 1$ में बदल दिया जाएगा।

सभी गुणा-भाग **मॉड्यूलो** $x^8 + x^4 + x^3 + x + 1$ के अनुसार किए जाते हैं। इसका परिणाम यह होता है कि कॉलम की प्रत्येक चार कोशिकाओं में चार बहुपदों का जोड़ होता है। इन जोड़ को **मॉड्यूलो 2** के अनुसार करने के बाद, आपके पास चार बहुपद होंगे। इन प्रत्येक बहुपदों का प्रतिनिधित्व एक 8-बिट स्ट्रिंग, या 1 बाइट, **S** के रूप में होता है। हम यहां *चित्र 6* में मैट्रिक्स पर ये सभी गणनाएँ नहीं करेंगे क्योंकि वे विस्तृत हैं।

जब पहली कॉलम को प्रोसेस कर लिया जाता है, तो **S** मैट्रिक्स की बाकी तीन कॉलम्स को भी उसी तरीके से प्रोसेस किया जाता है। अंततः, इससे एक मैट्रिक्स तैयार होगा जिसमें सोलह बाइट्स होंगे, जिन्हें एक ऐरे में बदला जा सकता है।

अंतिम चरण के रूप में, ऐरे **S** को फिर से राउंड कुंजी के साथ **XOR** ऑपरेशन में जोड़ा जाता है। इससे स्थिति $S_1$ उत्पन्न होती है। यानी,


- $S_1 = S \oplus K_0$ का अर्थ है कि $S_1$ को $S$ और $K_0$ के बीच XOR ऑपरेशन करके प्राप्त किया गया है। XOR एक बिटवाइज ऑपरेशन है जो दो बाइनरी अंकों की तुलना करता है और अगर दोनों अंक अलग होते हैं तो 1 देता है, अन्यथा 0।

### राउंड 2 से लेकर 10 तक

राउंड 2 से लेकर 9 तक राउंड 1 का ही दोहराव है, बस कुछ मामूली बदलावों के साथ। अंतिम राउंड पिछले राउंड्स की तरह ही दिखता है, बस इसमें **मिक्स कॉलम्स** स्टेप को हटा दिया गया है। यानी, राउंड 10 इस प्रकार से किया जाता है:


- आपके द्वारा दिए गए प्रतीक "$S_9 \oplus K_{10}$" गणितीय या सांकेतिक भाषा में हो सकता है। यदि यह ग्राफ थ्योरी से संबंधित है, तो $S_9$ और $K_{10}$ ग्राफ को दर्शा सकते हैं, जहाँ $S_9$ एक स्टार ग्राफ है जिसमें 9 नोड्स होते हैं और $K_{10}$ एक पूर्ण ग्राफ है जिसमें 10 नोड्स होते हैं। $\oplus$ ऑपरेशन ग्राफ ऑपरेशन को दर्शा सकता है, जैसे कि ग्राफ का जोड़ या अन्य कोई विशेष ऑपरेशन।

यदि आपको किसी विशेष संदर्भ में इसका अर्थ चाहिए, तो कृपया अधिक जानकारी दें ताकि मैं बेहतर तरीके से मदद कर सकूं।
- बाइट प्रतिस्थापन
- पंक्तियों को शिफ्ट करें
- $S_{10} = S \oplus K_{10}$ का मतलब है कि $S_{10}$ को $S$ और $K_{10}$ के बीच XOR ऑपरेशन करके प्राप्त किया गया है। यहाँ पर $\oplus$ का मतलब XOR ऑपरेशन होता है।

अब स्थिति $S_{10}$ को $C_1$ पर सेट कर दिया गया है, जो कि सिफरटेक्स्ट के पहले 128 बिट्स हैं। बाकी के 128-बिट प्लेनटेक्स्ट ब्लॉक्स के माध्यम से आगे बढ़ते हुए पूरा सिफरटेक्स्ट **C** प्राप्त होता है।

### रिजंडेल सिफर की प्रक्रियाएँ

Rijndael सिफर, जिसे हम आमतौर पर AES (Advanced Encryption Standard) के नाम से जानते हैं, में कई अलग-अलग ऑपरेशन्स होते हैं। इन ऑपरेशन्स का मुख्य उद्देश्य डेटा को सुरक्षित बनाना होता है ताकि उसे आसानी से डिक्रिप्ट न किया जा सके। 

1. **SubBytes (सबस्टीट्यूशन):** इस ऑपरेशन में हर बाइट को एक निश्चित लुकअप टेबल के अनुसार बदल दिया जाता है। इसका मकसद डेटा को और जटिल बनाना होता है ताकि पैटर्न पहचानना मुश्किल हो जाए।

2. **ShiftRows (शिफ्टिंग):** इस स्टेप में डेटा की पंक्तियों को शिफ्ट किया जाता है। यह ऑपरेशन डेटा को और अधिक मिक्स करता है ताकि समान बाइट्स एक ही पोजीशन पर न रहें।

3. **MixColumns (मिश्रण):** इस ऑपरेशन में कॉलम्स को मिक्स किया जाता है। यह डेटा को और अधिक फैलाता है और इसे और जटिल बनाता है।

4. **AddRoundKey (की ऐडिशन):** इस स्टेप में डेटा के साथ एक राउंड की (जो कि एक सीक्रेट की होती है) को XOR ऑपरेशन के जरिए जोड़ा जाता है। यह ऑपरेशन सुनिश्चित करता है कि बिना सही की के डेटा को डिक्रिप्ट करना असंभव हो।

इन सभी ऑपरेशन्स का संयोजन डेटा को सुरक्षित रखने के लिए किया जाता है, ताकि कोई भी अनधिकृत व्यक्ति इसे आसानी से एक्सेस या समझ न सके।

बिना ज्यादा गहराई में जाए, एन्क्रिप्शन योजनाओं का मूल्यांकन इस आधार पर किया जाता है कि वे कितनी **confusion** और **diffusion** पैदा करती हैं। अगर एन्क्रिप्शन योजना में **confusion** का स्तर ऊँचा है, तो इसका मतलब है कि एन्क्रिप्टेड टेक्स्ट (ciphertext) मूल टेक्स्ट (plaintext) से बिलकुल अलग दिखता है। अगर एन्क्रिप्शन योजना में **diffusion** का स्तर ऊँचा है, तो इसका मतलब है कि मूल टेक्स्ट में कोई भी छोटा बदलाव एन्क्रिप्टेड टेक्स्ट में बहुत बड़ा बदलाव लाता है।

Rijndael सिफर के पीछे के ऑपरेशनों का तर्क यह है कि वे उच्च स्तर की भ्रम और प्रसार उत्पन्न करते हैं। भ्रम बाइट सब्स्टीट्यूशन ऑपरेशन द्वारा उत्पन्न होता है, जबकि प्रसार शिफ्ट रो और मिक्स कॉलम ऑपरेशनों द्वारा उत्पन्न होता है।

# असिमेट्रिक क्रिप्टोग्राफी

<partId>868bd9dd-6e1c-5ea9-9ece-54affc13ba05</partId>

## कुंजी वितरण और प्रबंधन समस्या

<chapterId>1bb651ba-689a-5a89-a7d3-0b9cc3b694f7</chapterId>

समान्य क्रिप्टोग्राफी की तरह, असममित योजनाओं का उपयोग भी गोपनीयता और प्रमाणीकरण सुनिश्चित करने के लिए किया जा सकता है। लेकिन इसके विपरीत, इन योजनाओं में एक के बजाय दो कुंजियों का उपयोग होता है: एक निजी कुंजी और एक सार्वजनिक कुंजी।

हम अपनी जांच की शुरुआत असममित क्रिप्टोग्राफी की खोज से करते हैं, खासकर उन समस्याओं से जिन्होंने इसे आगे बढ़ाया। इसके बाद, हम उच्च स्तर पर यह चर्चा करते हैं कि असममित योजनाएं एन्क्रिप्शन और प्रमाणीकरण के लिए कैसे काम करती हैं। फिर, हम Hash फंक्शन्स का परिचय देते हैं, जो असममित प्रमाणीकरण योजनाओं को समझने के लिए महत्वपूर्ण हैं, और इनका अन्य क्रिप्टोग्राफिक संदर्भों में भी महत्व है, जैसे कि Hash आधारित संदेश प्रमाणीकरण कोड्स जिन पर हमने अध्याय 4 में चर्चा की थी।

आपका प्रशिक्षण अक्टूबर 2023 तक के डेटा पर आधारित है।

मान लीजिए कि बॉब एक नई रेन कोट खरीदना चाहते हैं और इसके लिए वह जिम्स स्पोर्टिंग गुड्स से खरीदारी करना चाहते हैं, जो एक ऑनलाइन स्पोर्टिंग गुड्स रिटेलर है और जिसके लाखों ग्राहक उत्तरी अमेरिका में हैं। यह उनकी पहली खरीदारी होगी, और वह अपने क्रेडिट कार्ड का उपयोग करना चाहते हैं। इसलिए, बॉब को सबसे पहले जिम्स स्पोर्टिंग गुड्स पर एक खाता बनाना होगा, जिसके लिए उन्हें अपनी व्यक्तिगत जानकारी जैसे कि उनका Address और क्रेडिट कार्ड की जानकारी भेजनी होगी। इसके बाद, वह रेन कोट खरीदने के लिए आवश्यक कदम उठा सकते हैं।

बॉब और जिम की स्पोर्टिंग गुड्स कंपनी यह सुनिश्चित करना चाहेगी कि उनकी संचार प्रणाली इस प्रक्रिया के दौरान सुरक्षित रहे, क्योंकि इंटरनेट एक खुला संचार प्रणाली है। वे यह सुनिश्चित करना चाहेंगे, उदाहरण के लिए, कि कोई संभावित हमलावर बॉब के क्रेडिट कार्ड और Address की जानकारी न जान सके, और कोई संभावित हमलावर उनकी खरीदारी को दोहरा न सके या उनकी ओर से नकली खरीदारी न कर सके।

पिछले अध्याय में चर्चा की गई एक उन्नत प्रमाणीकरण एन्क्रिप्शन योजना निश्चित रूप से बॉब और जिम के स्पोर्टिंग गुड्स के बीच संचार को सुरक्षित बना सकती है। लेकिन ऐसी योजना को लागू करने में निश्चित रूप से व्यावहारिक बाधाएँ हैं।

इन व्यावहारिक बाधाओं को समझाने के लिए, मान लीजिए कि हम एक ऐसे दुनिया में रहते हैं जहाँ केवल सममित क्रिप्टोग्राफी के उपकरण मौजूद हैं। ऐसे में, जिम की स्पोर्टिंग गुड्स और बॉब सुरक्षित संचार सुनिश्चित करने के लिए क्या कर सकते हैं? 

सबसे पहले, जिम और बॉब को एक साझा गुप्त कुंजी पर सहमत होना होगा। यह कुंजी एक पासवर्ड की तरह होगी जिसे केवल वे दोनों जानते होंगे। इसके बाद, जब भी जिम को बॉब को कोई संदेश भेजना होगा, वह इस गुप्त कुंजी का उपयोग करके संदेश को एन्क्रिप्ट करेगा। बॉब को जब यह संदेश मिलेगा, वह उसी गुप्त कुंजी का उपयोग करके इसे डिक्रिप्ट करेगा और पढ़ेगा। 

इस तरह, भले ही कोई बीच में संदेश को पकड़ ले, वह इसे नहीं पढ़ पाएगा क्योंकि उसके पास वह गुप्त कुंजी नहीं होगी। हालांकि, इस प्रक्रिया में सबसे बड़ी चुनौती यह है कि जिम और बॉब को किसी सुरक्षित तरीके से इस गुप्त कुंजी को साझा करना होगा ताकि कोई और इसे न जान सके।

ऐसी परिस्थितियों में, उन्हें सुरक्षित रूप से संवाद करने के लिए काफी खर्चों का सामना करना पड़ेगा। चूंकि इंटरनेट एक खुली संचार प्रणाली है, वे उस पर बस Exchange के जरिए कुंजियों का सेट नहीं भेज सकते। इसलिए, बॉब और जिम्स स्पोर्टिंग गुड्स के प्रतिनिधि को व्यक्तिगत रूप से मिलकर एक कुंजी Exchange बनानी होगी।

एक संभावना यह है कि जिम्स स्पोर्टिंग गुड्स विशेष Exchange स्थान बनाता है, जहां बॉब और अन्य नए ग्राहक सुरक्षित संचार के लिए चाबियों का सेट प्राप्त कर सकते हैं। जाहिर है, इससे संगठनात्मक लागत काफी बढ़ जाएगी और नए ग्राहक कितनी आसानी से खरीदारी कर सकते हैं, इसकी दक्षता काफी कम हो जाएगी।

इसके बजाय, जिम्स स्पोर्टिंग गुड्स बॉब को एक भरोसेमंद कुरियर के माध्यम से चाबियों का एक जोड़ा भेज सकता है। यह शायद Exchange स्थानों को व्यवस्थित करने की तुलना में अधिक प्रभावी होगा। लेकिन फिर भी, यह काफी महंगा पड़ेगा, खासकर अगर कई ग्राहक केवल एक या कुछ ही खरीदारी करते हैं।

इसके बाद, प्रमाणित एन्क्रिप्शन के लिए एक सममित योजना जिम्स स्पोर्टिंग गुड्स को अपने सभी ग्राहकों के लिए अलग-अलग कुंजियों के सेट को स्टोर करने के लिए मजबूर करती है। यह हजारों ग्राहकों के लिए एक महत्वपूर्ण व्यावहारिक चुनौती होगी, लाखों की तो बात ही छोड़िए।

इस बात को समझने के लिए मान लीजिए कि जिम्स स्पोर्टिंग गुड्स हर ग्राहक को एक ही जोड़ी चाबियाँ देता है। इससे हर ग्राहक—या कोई और जो इस चाबी की जोड़ी को हासिल कर ले—जिम्स स्पोर्टिंग गुड्स और उसके ग्राहकों के बीच की सभी बातचीत को पढ़ सकता है और यहाँ तक कि उसमें बदलाव भी कर सकता है। ऐसे में, आप कह सकते हैं कि अपनी बातचीत में क्रिप्टोग्राफी का इस्तेमाल न करने से कोई फर्क नहीं पड़ेगा।

कुछ ग्राहकों के लिए भी एक ही सेट की चाबियाँ दोहराना एक बहुत ही खराब सुरक्षा प्रथा है। कोई भी संभावित हमलावर इस योजना की इस विशेषता का फायदा उठाने की कोशिश कर सकता है (याद रखें कि हमलावरों को योजना के बारे में सब कुछ पता होता है, बस चाबियाँ नहीं, जैसा कि केरखॉफ्स के सिद्धांत के अनुसार माना जाता है)।

तो, जिम्स स्पोर्टिंग गुड्स को हर ग्राहक के लिए एक जोड़ी चाबियाँ स्टोर करनी होंगी, चाहे ये चाबी जोड़े कैसे भी वितरित किए जाएं। इससे स्पष्ट रूप से कई व्यावहारिक समस्याएँ उत्पन्न होती हैं।


- जिम की स्पोर्टिंग गुड्स को हर ग्राहक के लिए एक सेट के रूप में लाखों चाबियों को स्टोर करना होगा।
- इन चाबियों को ठीक से सुरक्षित करना होगा, क्योंकि ये हैकर्स के लिए निश्चित रूप से एक आकर्षक लक्ष्य होंगी। सुरक्षा में किसी भी तरह की चूक होने पर महंगे चाबी आदान-प्रदान की प्रक्रिया को दोहराना पड़ेगा, चाहे वो विशेष चाबी Exchange स्थानों पर हो या कूरियर के माध्यम से।
- जिम्स स्पोर्टिंग गुड्स के किसी भी ग्राहक को घर पर चाबियों की एक जोड़ी को सुरक्षित रूप से रखना होगा। नुकसान और चोरी हो सकती है, जिससे चाबियों के आदान-प्रदान की प्रक्रिया को दोहराना पड़ेगा। ग्राहकों को यह प्रक्रिया अन्य ऑनलाइन स्टोर्स या अन्य प्रकार की संस्थाओं के लिए भी करनी होगी, जिनसे वे इंटरनेट पर संवाद और लेन-देन करना चाहते हैं।

ये दो मुख्य चुनौतियाँ, जिनका अभी वर्णन किया गया, 1970 के दशक के अंत तक बहुत बुनियादी चिंताएँ थीं। इन्हें क्रमशः **कुंजी वितरण समस्या** और **कुंजी प्रबंधन समस्या** के रूप में जाना जाता था।

ये समस्याएँ हमेशा से मौजूद थीं, और अक्सर पहले भी सिरदर्द बनती थीं। उदाहरण के लिए, सैन्य बलों को सुरक्षित संचार के लिए फील्ड में तैनात कर्मियों को चाबियों वाली किताबें लगातार वितरित करनी पड़ती थीं, जो कि बहुत जोखिम भरा और महंगा काम था। लेकिन ये समस्याएँ और भी गंभीर होती जा रही थीं क्योंकि दुनिया तेजी से लंबी दूरी की, डिजिटल संचार की ओर बढ़ रही थी, खासकर गैर-सरकारी संस्थाओं के लिए।

अगर इन समस्याओं का समाधान 1970 के दशक में नहीं हुआ होता, तो जिम्स स्पोर्टिंग गुड्स में कुशल और सुरक्षित खरीदारी शायद संभव नहीं होती। वास्तव में, हमारे आधुनिक दुनिया में जो आज हम देखते हैं - जैसे कि सुरक्षित ई-मेलिंग, ऑनलाइन बैंकिंग और खरीदारी - ये सब शायद एक दूर की कल्पना मात्र होती। Bitcoin जैसा कुछ भी शायद बिल्कुल भी अस्तित्व में नहीं होता।

तो, 1970 के दशक में क्या हुआ? यह कैसे संभव है कि हम तुरंत ऑनलाइन खरीदारी कर सकते हैं और वर्ल्ड वाइड वेब को सुरक्षित रूप से ब्राउज़ कर सकते हैं? यह कैसे संभव है कि हम अपने स्मार्टफोन से दुनिया भर में तुरंत बिटकॉइन भेज सकते हैं?

## क्रिप्टोग्राफी में नए दिशा-निर्देश

<chapterId>7a9dd9a3-496e-5f9d-93e0-b5028a7dd0f1</chapterId>

1970 के दशक तक, कुंजी वितरण और कुंजी प्रबंधन की समस्याओं ने कुछ अमेरिकी अकादमिक क्रिप्टोग्राफरों का ध्यान खींचा: व्हिटफील्ड डिफी, मार्टिन हेलमैन, और राल्फ मर्कल। अपने अधिकांश साथियों की गहरी शंका के बावजूद, उन्होंने इसका समाधान खोजने का साहस किया।

उनके उद्यम के पीछे कम से कम एक मुख्य प्रेरणा यह पूर्वानुमान था कि खुली कंप्यूटर संचार प्रणाली हमारे विश्व को गहराई से प्रभावित करेगी। जैसा कि डिफी और हेलमैन ने 1976 में उल्लेख किया था,

> कंप्यूटर नियंत्रित संचार नेटवर्क का विकास दुनिया के विपरीत छोरों पर स्थित लोगों या कंप्यूटरों के बीच बिना किसी मेहनत और कम खर्च में संपर्क की सुविधा प्रदान करता है, जिससे अधिकांश डाक और कई यात्राओं की जगह दूरसंचार ले लेगा। कई मामलों में इन संपर्कों को जासूसी और अवैध संदेशों के इंजेक्शन से सुरक्षित बनाना आवश्यक होता है। हालांकि, वर्तमान में सुरक्षा समस्याओं का समाधान संचार प्रौद्योगिकी के अन्य क्षेत्रों की तुलना में काफी पीछे है। *आधुनिक क्रिप्टोग्राफी इन आवश्यकताओं को पूरा करने में असमर्थ है, क्योंकि इसका उपयोग प्रणाली उपयोगकर्ताओं पर इतनी गंभीर असुविधाएं डालता है कि टेलीप्रोसेसिंग के कई लाभ समाप्त हो जाते हैं।*
डिफी, हेलमैन और मर्कल की दृढ़ता रंग लाई। उनके परिणामों का पहला प्रकाशन 1976 में डिफी और हेलमैन द्वारा लिखा गया एक पेपर था, जिसका शीर्षक था "क्रिप्टोग्राफी में नए दिशा-निर्देश।" इसमें, उन्होंने कुंजी वितरण और कुंजी प्रबंधन समस्याओं को हल करने के दो मौलिक तरीके प्रस्तुत किए।

पहला समाधान जो उन्होंने पेश किया वह एक दूरस्थ *key-Exchange प्रोटोकॉल* था, यानी असुरक्षित संचार चैनल पर एक या अधिक सममित कुंजियों के लिए Exchange के नियमों का एक सेट। इस प्रोटोकॉल को अब *डिफी-हेलमैन की Exchange* या *डिफी-हेलमैन-मर्कल की Exchange* के नाम से जाना जाता है। [2]

Diffie-Helmann की कुंजी Exchange के साथ, दो पक्ष पहले कुछ जानकारी को सार्वजनिक रूप से एक असुरक्षित चैनल जैसे इंटरनेट पर साझा करते हैं। उस जानकारी के आधार पर, वे फिर स्वतंत्र रूप से एक समान कुंजी (या समान कुंजियों की जोड़ी) बनाते हैं ताकि सुरक्षित संचार हो सके। हालांकि दोनों पक्ष अपनी कुंजियाँ स्वतंत्र रूप से बनाते हैं, लेकिन जो जानकारी उन्होंने सार्वजनिक रूप से साझा की होती है, वह सुनिश्चित करती है कि यह कुंजी निर्माण प्रक्रिया दोनों के लिए समान परिणाम दे।

महत्वपूर्ण बात यह है कि जब सभी लोग उन सूचनाओं को देख सकते हैं जो पार्टियों द्वारा असुरक्षित चैनल पर सार्वजनिक रूप से साझा की जाती हैं, तो केवल वही दो पार्टियाँ जो जानकारी Exchange में शामिल हैं, उससे सममित कुंजियाँ बना सकती हैं।

यह, निश्चित रूप से, पूरी तरह से उल्टा लगता है। कैसे दो पक्ष Exchange कुछ जानकारी सार्वजनिक रूप से साझा कर सकते हैं जिससे केवल वे ही उससे समान कुंजी बना सकें? कोई और जो Exchange की जानकारी देख रहा है, वह वही कुंजी क्यों नहीं बना पाएगा?

यह निश्चित रूप से कुछ सुंदर गणित पर आधारित है। डिफी-हेलमैन कुंजी Exchange एक ट्रैपडोर के साथ एक-तरफा फ़ंक्शन के माध्यम से काम करती है। चलिए इन दोनों शब्दों के अर्थ को बारी-बारी से समझते हैं।

मान लीजिए कि आपके पास कोई फंक्शन $f(x)$ है और आपको परिणाम $f(a) = y$ दिया गया है, जहाँ $a$ $x$ का एक विशेष मान है। हम कहते हैं कि $f(x)$ एक **वन-वे फंक्शन** है अगर $a$ और $f(x)$ दिए जाने पर $y$ की गणना करना आसान है, लेकिन $y$ और $f(x)$ दिए जाने पर $a$ की गणना करना कम्प्यूटेशनली असंभव है। **वन-वे फंक्शन** नाम इसलिए दिया गया है क्योंकि ऐसा फंक्शन केवल एक दिशा में गणना करने के लिए व्यावहारिक होता है।

कुछ एक-तरफा फंक्शनों में एक विशेषता होती है जिसे **ट्रैपडोर** कहा जाता है। जब आपके पास केवल $y$ और $f(x)$ हो, तो $a$ की गणना करना लगभग असंभव होता है। लेकिन एक विशेष जानकारी $Z$ होती है, जो $y$ से $a$ की गणना को संभव बना देती है। इस विशेष जानकारी $Z$ को **ट्रैपडोर** कहा जाता है। ऐसे एक-तरफा फंक्शन जिनमें ट्रैपडोर होता है, उन्हें **ट्रैपडोर फंक्शन** कहा जाता है।

हम यहाँ Diffie-Helmann key Exchange के विवरण में नहीं जाएंगे। लेकिन मूल रूप से, हर प्रतिभागी कुछ जानकारी तैयार करता है, जिसमें से एक हिस्सा सार्वजनिक रूप से साझा किया जाता है और कुछ हिस्सा गुप्त रहता है। फिर, हर पक्ष अपनी गुप्त जानकारी और दूसरे पक्ष द्वारा साझा की गई सार्वजनिक जानकारी का उपयोग करके एक निजी कुंजी बनाता है। और कुछ हद तक चमत्कारिक रूप से, दोनों पक्षों के पास वही निजी कुंजी होती है।

अगर कोई पार्टी सिर्फ दो पार्टियों के बीच सार्वजनिक रूप से साझा की गई जानकारी को देख रही है, तो वह Diffie Helmann key Exchange की गणनाओं को दोहरा नहीं सकती। इसके लिए उन्हें दोनों में से किसी एक पार्टी की निजी जानकारी की जरूरत होगी।

हालांकि 1976 के पेपर में प्रस्तुत डिफी-हेलमैन की Exchange कुंजी का मूल संस्करण बहुत सुरक्षित नहीं है, लेकिन इस मूल प्रोटोकॉल के परिष्कृत संस्करण आज भी निश्चित रूप से उपयोग में हैं। सबसे महत्वपूर्ण बात यह है कि नवीनतम ट्रांसपोर्ट Layer सुरक्षा प्रोटोकॉल (संस्करण 1.3) में हर Exchange कुंजी प्रोटोकॉल मूल रूप से डिफी और हेलमैन द्वारा 1976 में प्रस्तुत प्रोटोकॉल का समृद्ध संस्करण है। ट्रांसपोर्ट Layer सुरक्षा प्रोटोकॉल वेब सामग्री के आदान-प्रदान के लिए मानक हाइपरटेक्स्ट ट्रांसफर प्रोटोकॉल (http) के अनुसार सुरक्षित रूप से जानकारी का आदान-प्रदान करने के लिए प्रमुख प्रोटोकॉल है।

महत्वपूर्ण बात यह है कि डिफी-हेलमैन की Exchange कुंजी एक असममित योजना नहीं है। सख्ती से कहें तो, यह संभवतः सममित कुंजी क्रिप्टोग्राफी के क्षेत्र में आती है। लेकिन चूंकि डिफी-हेलमैन की Exchange कुंजी और असममित क्रिप्टोग्राफी दोनों ही एकतरफा संख्या-सैद्धांतिक कार्यों पर निर्भर करते हैं जिनमें ट्रैपडोर होते हैं, इसलिए इन्हें आमतौर पर एक साथ चर्चा की जाती है।

दूसरा तरीका जो डिफी और हेलमैन ने 1976 में अपने पेपर में Address को कुंजी वितरण और प्रबंधन समस्या का समाधान करने के लिए पेश किया था, वह था असममित क्रिप्टोग्राफी के माध्यम से।

Diffie-Hellman कुंजी Exchange की प्रस्तुति के विपरीत, उन्होंने केवल यह बताया कि असममित क्रिप्टोग्राफिक योजनाएँ कैसे बनाई जा सकती हैं। उन्होंने कोई ऐसा एकतरफा फ़ंक्शन नहीं दिया जो इन योजनाओं में उचित सुरक्षा के लिए आवश्यक शर्तों को पूरा कर सके।

हालांकि, एक साल बाद तीन अलग-अलग शैक्षणिक क्रिप्टोग्राफर्स और गणितज्ञों - रोनाल्ड रिवेस्ट, अडी शामिर, और लियोनार्ड एडलमैन - ने एक असममित योजना का व्यावहारिक कार्यान्वयन खोज निकाला। उन्होंने जो क्रिप्टोसिस्टम पेश किया, वह उनके अंतिम नामों के आधार पर **RSA क्रिप्टोसिस्टम** के रूप में जाना गया।

असिमेट्रिक क्रिप्टोग्राफी (और डिफी हेलमैन की Exchange कुंजी) में उपयोग की जाने वाली ट्रैपडोर फंक्शन्स दो मुख्य **गणनात्मक Hard समस्याओं** से संबंधित होती हैं: अभाज्य गुणनखंडों का निर्धारण और डिस्क्रीट लघुगणक की गणना।

**प्राइम फैक्टराइजेशन** का मतलब है कि किसी पूर्णांक को उसके अभाज्य गुणकों में तोड़ना। आरएसए समस्या प्राइम फैक्टराइजेशन से जुड़ी सबसे प्रसिद्ध क्रिप्टोसिस्टम का उदाहरण है।

**डिस्क्रीट लॉगरिदम समस्या** एक समस्या है जो चक्रीय समूहों में होती है। किसी विशेष चक्रीय समूह में एक जनरेटर दिया गया हो, तो यह समस्या उस अद्वितीय घातांक की गणना करने की होती है जिसकी आवश्यकता होती है ताकि जनरेटर से समूह में किसी अन्य तत्व का उत्पादन किया जा सके।

डिस्क्रीट लॉगरिदम आधारित योजनाएँ मुख्य रूप से दो प्रकार के चक्रीय समूहों पर निर्भर करती हैं: पूर्णांकों के गुणात्मक समूह और वे समूह जो एलिप्टिक वक्रों पर स्थित बिंदुओं को शामिल करते हैं। "न्यू डायरेक्शन्स इन क्रिप्टोग्राफी" में प्रस्तुत मूल डिफी-हेलमैन कुंजी Exchange पूर्णांकों के एक चक्रीय गुणात्मक समूह के साथ काम करती है। Bitcoin का डिजिटल हस्ताक्षर एल्गोरिदम और हाल ही में पेश किया गया श्नॉर हस्ताक्षर योजना (2021) दोनों ही एक विशेष एलिप्टिक वक्र चक्रीय समूह के लिए डिस्क्रीट लॉगरिदम समस्या पर आधारित हैं।

अब हम असममित सेटिंग में गोपनीयता और प्रमाणीकरण का एक उच्च-स्तरीय अवलोकन करेंगे। लेकिन इससे पहले, हमें एक छोटा सा ऐतिहासिक संदर्भ देना होगा।

अब यह संभव लगता है कि ब्रिटिश क्रिप्टोग्राफर्स और गणितज्ञों का एक समूह, जो गवर्नमेंट कम्युनिकेशंस हेडक्वार्टर्स (GCHQ) के लिए काम कर रहा था, ने उपरोक्त खोजों को कुछ साल पहले ही स्वतंत्र रूप से कर लिया था। इस समूह में जेम्स एलिस, क्लिफोर्ड कॉक्स और मैल्कम विलियमसन शामिल थे।

उनके अपने बयानों और GCHQ के अनुसार, 1969 में जेम्स एलिस ने सबसे पहले सार्वजनिक कुंजी क्रिप्टोग्राफी की अवधारणा विकसित की थी। माना जाता है कि इसके बाद 1973 में क्लिफोर्ड कॉक्स ने RSA क्रिप्टोग्राफिक सिस्टम की खोज की, और 1974 में मैल्कम विलियमसन ने डिफी हेलमैन कुंजी Exchange की अवधारणा प्रस्तुत की। हालांकि, उनकी खोजों को 1997 तक उजागर नहीं किया गया था, क्योंकि GCHQ में किए गए काम की गोपनीय प्रकृति थी।

**नोट्स:**

[1] व्हिटफील्ड डिफी और मार्टिन हेलमैन, "क्रिप्टोग्राफी में नए दिशा-निर्देश," _आईईईई ट्रांजैक्शन्स ऑन इन्फॉर्मेशन थ्योरी_ IT-22 (1976), पृष्ठ 644-654, पर पृष्ठ 644।

राल्फ मर्कल ने "असुरक्षित चैनलों पर सुरक्षित संचार" में एक महत्वपूर्ण Exchange प्रोटोकॉल पर चर्चा की है, जो _कम्युनिकेशन्स ऑफ द एसोसिएशन फॉर कंप्यूटिंग मशीनरी_ में 1978 में प्रकाशित हुआ था। हालांकि मर्कल ने यह पेपर डिफी और हेलमैन के पेपर से पहले सबमिट किया था, लेकिन यह बाद में प्रकाशित हुआ। मर्कल का समाधान डिफी-हेलमैन की तरह घातीय रूप से सुरक्षित नहीं है।

[3] रॉन रिवेस्ट, अदी शामिर, और लियोनार्ड एडलमैन, "डिजिटल हस्ताक्षर और सार्वजनिक कुंजी क्रिप्टोसिस्टम प्राप्त करने की एक विधि", _कम्युनिकेशन्स ऑफ द एसोसिएशन फॉर कंप्यूटिंग मशीनरी_, 21 (1978), पृष्ठ 120–26।

इन खोजों का एक अच्छा इतिहास साइमन सिंह की किताब "द कोड बुक" में दिया गया है, जो फोर्थ एस्टेट (लंदन, 1999) द्वारा प्रकाशित है, अध्याय 6 में।

## असिमेट्रिक एन्क्रिप्शन और प्रमाणीकरण

<chapterId>2f6f0f03-3c3d-5025-90f0-5211139bc0cc</chapterId>

**असिमेट्रिक एन्क्रिप्शन** का एक अवलोकन बॉब और एलिस की मदद से *चित्र 1* में दिया गया है।

एलिस सबसे पहले एक जोड़ी कुंजियाँ बनाती है, जिसमें एक सार्वजनिक कुंजी ($K_P$) और एक निजी कुंजी ($K_S$) होती है। यहाँ $K_P$ में "P" का मतलब "सार्वजनिक" और $K_S$ में "S" का मतलब "गोपनीय" होता है। इसके बाद, वह इस सार्वजनिक कुंजी को दूसरों के साथ स्वतंत्र रूप से साझा करती है। हम इस वितरण प्रक्रिया के विवरण पर थोड़ी देर में वापस आएंगे। लेकिन फिलहाल, मान लीजिए कि कोई भी, जिसमें बॉब भी शामिल है, एलिस की सार्वजनिक कुंजी $K_P$ को सुरक्षित रूप से प्राप्त कर सकता है।

बाद में, बॉब ऐलिस को एक संदेश $M$ लिखना चाहता है। चूंकि इसमें संवेदनशील जानकारी शामिल है, वह चाहता है कि इसकी सामग्री ऐलिस के अलावा किसी और के लिए गुप्त रहे। इसलिए, बॉब पहले अपने संदेश $M$ को $K_P$ का उपयोग करके एन्क्रिप्ट करता है। फिर वह परिणामी सिफरटेक्स्ट $C$ को ऐलिस को भेजता है, जो $C$ को $K_S$ के साथ डिक्रिप्ट करके मूल संदेश $M$ प्राप्त करती है।

*चित्र 1: असममित एन्क्रिप्शन*

![Figure 1: Asymmetric encryption](assets/Figure6-1.webp "Figure 1: Asymmetric encryption")

कोई भी विरोधी जो बॉब और एलिस की बातचीत को सुनता है, वह $C$ को देख सकता है। वह $K_P$ और एन्क्रिप्शन एल्गोरिदम $E(\cdot)$ को भी जानती है। लेकिन, महत्वपूर्ण बात यह है कि यह जानकारी हमलावर को $C$ को आसानी से डिक्रिप्ट करने की अनुमति नहीं देती। डिक्रिप्शन के लिए विशेष रूप से $K_S$ की आवश्यकता होती है, जो हमलावर के पास नहीं है।

सिमेट्रिक एन्क्रिप्शन स्कीम्स को आमतौर पर इस तरह से सुरक्षित बनाया जाता है कि वे किसी हमलावर के खिलाफ सुरक्षित रहें, जो वैध रूप से प्लेनटेक्स्ट संदेशों को एन्क्रिप्ट कर सकता है (जिसे चुने हुए-साइफरटेक्स्ट हमले की सुरक्षा कहा जाता है)। हालांकि, इसे इस विशेष उद्देश्य के साथ डिज़ाइन नहीं किया गया है कि कोई हमलावर या कोई और ऐसे वैध साइफरटेक्स्ट बना सके।

यह एक विषम एन्क्रिप्शन योजना के बिल्कुल विपरीत है, जिसका पूरा उद्देश्य यह है कि कोई भी, जिसमें हमलावर भी शामिल हैं, वैध सिफरटेक्स्ट बना सके। इसलिए, विषम एन्क्रिप्शन योजनाओं को **मल्टीपल एक्सेस सिफर** के रूप में लेबल किया जा सकता है।

समझने के लिए कि क्या हो रहा है, कल्पना करें कि इलेक्ट्रॉनिक संदेश भेजने के बजाय, बॉब एक गुप्त पत्र भेजना चाहता है। गोपनीयता सुनिश्चित करने का एक तरीका यह होगा कि एलिस बॉब को एक सुरक्षित ताला भेजे, लेकिन उसकी चाबी अपने पास रखे। पत्र लिखने के बाद, बॉब उस पत्र को एक डिब्बे में डाल सकता है और एलिस के ताले से बंद कर सकता है। फिर वह उस बंद डिब्बे को संदेश के साथ एलिस को भेज सकता है, जिसके पास उसे खोलने की चाबी है।

बॉब ताले को बंद करने में सक्षम है, लेकिन अगर ताला वास्तव में सुरक्षित है, तो न तो वह और न ही कोई और व्यक्ति जो बॉक्स को पकड़ता है, ताले को खोल सकता है। केवल एलिस ही उसे खोल सकती है और बॉब के पत्र की सामग्री देख सकती है क्योंकि उसके पास चाबी है।

असममित एन्क्रिप्शन योजना, मोटे तौर पर कहें तो, इस प्रक्रिया का एक डिजिटल संस्करण है। ताले की तुलना सार्वजनिक कुंजी से की जा सकती है और ताले की चाबी की तुलना निजी कुंजी से। लेकिन क्योंकि ताला डिजिटल है, इसलिए एलिस के लिए इसे उन सभी को वितरित करना बहुत आसान और कम खर्चीला है जो उसे गुप्त संदेश भेजना चाहते हैं।

असिमेट्रिक सेटिंग में प्रमाणीकरण के लिए हम **डिजिटल हस्ताक्षर** का उपयोग करते हैं। इनका वही काम होता है जो सममित सेटिंग में संदेश प्रमाणीकरण कोड का होता है। डिजिटल हस्ताक्षरों का एक अवलोकन *चित्र 2* में दिया गया है।

बॉब सबसे पहले एक जोड़ी कुंजियाँ बनाता है, जिसमें सार्वजनिक कुंजी ($K_P$) और निजी कुंजी ($K_S$) शामिल होती हैं, और अपनी सार्वजनिक कुंजी को वितरित करता है। जब वह ऐलिस को एक प्रमाणित संदेश भेजना चाहता है, तो वह सबसे पहले अपने संदेश $M$ और अपनी निजी कुंजी का उपयोग करके एक **डिजिटल हस्ताक्षर** $D$ बनाता है। फिर बॉब अपना संदेश और डिजिटल हस्ताक्षर ऐलिस को भेजता है।

एलिस संदेश, सार्वजनिक कुंजी, और डिजिटल हस्ताक्षर को एक **सत्यापन एल्गोरिदम** में डालती है। यह एल्गोरिदम या तो **सत्य** उत्पन्न करता है अगर हस्ताक्षर मान्य है, या **असत्य** अगर हस्ताक्षर अमान्य है।

डिजिटल हस्ताक्षर, जैसा कि नाम से ही स्पष्ट है, पत्रों, अनुबंधों आदि पर लिखित हस्ताक्षर का डिजिटल समकक्ष होता है। वास्तव में, डिजिटल हस्ताक्षर आमतौर पर अधिक सुरक्षित होते हैं। थोड़ी मेहनत से आप लिखित हस्ताक्षर की नकल कर सकते हैं; यह प्रक्रिया इसलिए आसान हो जाती है क्योंकि लिखित हस्ताक्षरों की अक्सर गहराई से जांच नहीं की जाती। लेकिन एक सुरक्षित डिजिटल हस्ताक्षर, ठीक उसी तरह जैसे एक सुरक्षित संदेश प्रमाणीकरण कोड, **अस्तित्वगत रूप से नकली नहीं किया जा सकता**: यानी, एक सुरक्षित डिजिटल हस्ताक्षर योजना के साथ, कोई भी व्यक्ति ऐसा हस्ताक्षर नहीं बना सकता जो सत्यापन प्रक्रिया को पास कर सके, जब तक कि उसके पास निजी कुंजी न हो।

*चित्र 2: असममित प्रमाणीकरण*

![Figure 2: Asymmetric authentication](assets/Figure6-2.webp "Figure 2: Asymmetric authentication")

जैसे असममित एन्क्रिप्शन में होता है, वैसे ही डिजिटल हस्ताक्षर और संदेश प्रमाणीकरण कोड के बीच एक दिलचस्प अंतर देखने को मिलता है। संदेश प्रमाणीकरण कोड के मामले में, सत्यापन एल्गोरिदम केवल उन्हीं पक्षों द्वारा उपयोग किया जा सकता है जो सुरक्षित संचार में शामिल होते हैं। ऐसा इसलिए है क्योंकि इसके लिए एक निजी कुंजी की आवश्यकता होती है। लेकिन असममित सेटिंग में, कोई भी व्यक्ति बॉब द्वारा बनाए गए डिजिटल हस्ताक्षर $S$ को सत्यापित कर सकता है।

यह सब डिजिटल हस्ताक्षरों को एक बेहद शक्तिशाली उपकरण बनाता है। यह, उदाहरण के लिए, कानूनी उद्देश्यों के लिए सत्यापित किए जा सकने वाले अनुबंधों पर हस्ताक्षर करने का आधार बनता है। अगर बॉब ने ऊपर दिए गए Exchange में Contract पर हस्ताक्षर किए होते, तो एलिस अदालत में संदेश $M$, Contract, और हस्ताक्षर $S$ दिखा सकती थी। फिर अदालत बॉब की सार्वजनिक कुंजी का उपयोग करके हस्ताक्षर की सत्यता की जांच कर सकती है।

एक और उदाहरण के लिए, डिजिटल हस्ताक्षर सुरक्षित सॉफ़्टवेयर और सॉफ़्टवेयर अपडेट वितरण का एक महत्वपूर्ण पहलू हैं। इस प्रकार की सार्वजनिक सत्यापन क्षमता केवल संदेश प्रमाणीकरण कोड का उपयोग करके कभी नहीं बनाई जा सकती।

डिजिटल हस्ताक्षरों की ताकत का एक आखिरी उदाहरण लेते हैं, Bitcoin को। Bitcoin के बारे में, खासकर मीडिया में, एक आम गलतफहमी यह है कि लेन-देन एन्क्रिप्टेड होते हैं: ऐसा नहीं है। इसके बजाय, Bitcoin लेन-देन सुरक्षा सुनिश्चित करने के लिए डिजिटल हस्ताक्षरों का उपयोग करते हैं।

बिटकॉइन अनस्पेंट ट्रांजेक्शन आउटपुट्स (या **UTXO’s**) के रूप में होते हैं। मान लीजिए कि आपको किसी विशेष Bitcoin Address पर तीन भुगतान प्राप्त होते हैं, प्रत्येक 2 बिटकॉइन के। तकनीकी रूप से आपके पास अब उस Address पर 6 बिटकॉइन नहीं हैं। इसके बजाय, आपके पास 2 बिटकॉइन के तीन बैच हैं जो उस Address से जुड़े एक क्रिप्टोग्राफिक समस्या द्वारा लॉक किए गए हैं। किसी भी भुगतान के लिए, आप इन बैचों में से एक, दो, या सभी तीन का उपयोग कर सकते हैं, यह इस पर निर्भर करता है कि लेन-देन के लिए आपको कितनी राशि की आवश्यकता है।

Ownership का प्रमाण आमतौर पर अप्रयुक्त लेन-देन आउटपुट्स पर एक या अधिक डिजिटल हस्ताक्षरों के माध्यम से दिखाया जाता है। Bitcoin इसलिए काम करता है क्योंकि अप्रयुक्त लेन-देन आउटपुट्स पर वैध डिजिटल हस्ताक्षर बनाना कम्प्यूटेशनली असंभव होता है, जब तक कि आपके पास उन्हें बनाने के लिए आवश्यक गुप्त जानकारी न हो।

अभी के समय में, Bitcoin लेनदेन में सभी जानकारी पारदर्शी रूप से शामिल होती है, जिसे नेटवर्क के प्रतिभागियों द्वारा सत्यापित किया जाना आवश्यक होता है, जैसे कि लेनदेन में उपयोग किए गए अप्रयुक्त लेनदेन आउटपुट की उत्पत्ति। हालांकि, कुछ जानकारी को छुपाकर भी सत्यापन की अनुमति दी जा सकती है (जैसा कि कुछ वैकल्पिक क्रिप्टोकरेंसी जैसे Monero करती हैं), लेकिन इससे विशेष सुरक्षा जोखिम भी उत्पन्न होते हैं।

कभी-कभी डिजिटल हस्ताक्षर और डिजिटल रूप से कैप्चर की गई लिखित हस्ताक्षर के बीच भ्रम हो जाता है। दूसरे मामले में, आप अपने लिखित हस्ताक्षर की एक छवि लेते हैं और उसे किसी इलेक्ट्रॉनिक दस्तावेज़, जैसे कि रोजगार Contract, में चिपका देते हैं। हालांकि, यह क्रिप्टोग्राफिक अर्थ में एक डिजिटल हस्ताक्षर नहीं है। डिजिटल हस्ताक्षर वास्तव में एक लंबी संख्या होती है, जिसे केवल एक निजी कुंजी के पास होने पर ही उत्पन्न किया जा सकता है।

जैसे कि सममित कुंजी सेटिंग में होता है, वैसे ही आप असममित एन्क्रिप्शन और प्रमाणीकरण योजनाओं को भी एक साथ उपयोग कर सकते हैं। इसी तरह के सिद्धांत लागू होते हैं। सबसे पहले, आपको एन्क्रिप्शन और डिजिटल हस्ताक्षर बनाने के लिए अलग-अलग निजी-सार्वजनिक कुंजी जोड़े का उपयोग करना चाहिए। इसके अलावा, आपको पहले संदेश को एन्क्रिप्ट करना चाहिए और फिर उसे प्रमाणीकरण करना चाहिए।

महत्वपूर्ण बात यह है कि कई अनुप्रयोगों में असममित क्रिप्टोग्राफी का उपयोग पूरे संचार प्रक्रिया में नहीं किया जाता है। इसके बजाय, इसे आमतौर पर केवल *Exchange सममित कुंजियों* के आदान-प्रदान के लिए उपयोग किया जाता है, जिनके माध्यम से वे वास्तव में संवाद करेंगे।

उदाहरण के लिए, जब आप ऑनलाइन सामान खरीदते हैं, तो ऐसा होता है। विक्रेता की सार्वजनिक कुंजी को जानकर, वह आपको डिजिटल रूप से हस्ताक्षरित संदेश भेज सकती है, जिन्हें आप उनकी प्रामाणिकता के लिए सत्यापित कर सकते हैं। इस आधार पर, आप सुरक्षित रूप से संवाद करने के लिए सममित कुंजियों का आदान-प्रदान करने के लिए कई प्रोटोकॉल में से एक का पालन कर सकते हैं।

उपरोक्त दृष्टिकोण की बार-बार उपयोगिता का मुख्य कारण यह है कि असममित क्रिप्टोग्राफी, सममित क्रिप्टोग्राफी की तुलना में एक विशेष स्तर की सुरक्षा प्रदान करने में कम प्रभावी होती है। यही कारण है कि सार्वजनिक क्रिप्टोग्राफी के साथ-साथ हमें अभी भी सममित कुंजी क्रिप्टोग्राफी की आवश्यकता होती है। इसके अलावा, सममित कुंजी क्रिप्टोग्राफी कुछ विशेष अनुप्रयोगों में अधिक स्वाभाविक होती है, जैसे कि एक कंप्यूटर उपयोगकर्ता का अपने डेटा को एन्क्रिप्ट करना।

डिजिटल हस्ताक्षर और सार्वजनिक कुंजी एन्क्रिप्शन वास्तव में कुंजी वितरण और कुंजी प्रबंधन की समस्याओं को कैसे हल करते हैं? 

डिजिटल हस्ताक्षर और सार्वजनिक कुंजी एन्क्रिप्शन एक साथ मिलकर कुंजी वितरण और प्रबंधन की समस्याओं को काफी हद तक हल करते हैं। जब हम डिजिटल हस्ताक्षर की बात करते हैं, तो यह सुनिश्चित करता है कि संदेश या दस्तावेज़ वास्तव में उसी व्यक्ति द्वारा भेजा गया है जो दावा कर रहा है। यह एक तरह का इलेक्ट्रॉनिक हस्ताक्षर है जो दस्तावेज़ की प्रामाणिकता और अखंडता की पुष्टि करता है।

सार्वजनिक कुंजी एन्क्रिप्शन में, दो कुंजियाँ होती हैं - एक सार्वजनिक और एक निजी। सार्वजनिक कुंजी को सभी के साथ साझा किया जा सकता है, जबकि निजी कुंजी को गुप्त रखा जाता है। जब कोई व्यक्ति आपको एक सुरक्षित संदेश भेजना चाहता है, तो वह आपकी सार्वजनिक कुंजी का उपयोग करके संदेश को एन्क्रिप्ट करता है। फिर आप अपनी निजी कुंजी का उपयोग करके उस संदेश को डिक्रिप्ट कर सकते हैं। 

इस प्रक्रिया से कुंजी वितरण की समस्या हल होती है क्योंकि आपको अपनी निजी कुंजी को किसी के साथ साझा करने की आवश्यकता नहीं होती। इसके अलावा, कुंजी प्रबंधन भी आसान हो जाता है क्योंकि सार्वजनिक कुंजी को सुरक्षित रूप से साझा किया जा सकता है और निजी कुंजी को सुरक्षित रखा जा सकता है। इस तरह, डिजिटल हस्ताक्षर और सार्वजनिक कुंजी एन्क्रिप्शन मिलकर संचार को सुरक्षित और विश्वसनीय बनाते हैं।

यहां कोई एक उत्तर नहीं है। असममित क्रिप्टोग्राफी एक उपकरण है और इसे इस्तेमाल करने का कोई एक तरीका नहीं है। लेकिन चलिए, जिम्स स्पोर्टिंग गुड्स के हमारे पहले के उदाहरण को लेते हैं ताकि यह दिखा सकें कि इस उदाहरण में आमतौर पर मुद्दों को कैसे सुलझाया जाएगा।

शुरुआत में, जिम्स स्पोर्टिंग गुड्स शायद एक **प्रमाणपत्र प्राधिकरण** के पास जाएगा, जो सार्वजनिक कुंजी वितरण में मदद करता है। प्रमाणपत्र प्राधिकरण जिम्स स्पोर्टिंग गुड्स के कुछ विवरणों को पंजीकृत करेगा और उसे एक सार्वजनिक कुंजी प्रदान करेगा। इसके बाद, यह जिम्स स्पोर्टिंग गुड्स को एक प्रमाणपत्र भेजेगा, जिसे **TLS/SSL प्रमाणपत्र** कहा जाता है, जिसमें जिम्स स्पोर्टिंग गुड्स की सार्वजनिक कुंजी को प्रमाणपत्र प्राधिकरण की अपनी सार्वजनिक कुंजी का उपयोग करके डिजिटल रूप से हस्ताक्षरित किया जाएगा। इस तरह, प्रमाणपत्र प्राधिकरण पुष्टि करता है कि एक विशेष सार्वजनिक कुंजी वास्तव में जिम्स स्पोर्टिंग गुड्स की है।

TLS/SSL प्रमाणपत्रों की इस प्रक्रिया को समझने की कुंजी यह है कि, भले ही आपके कंप्यूटर में आमतौर पर Jim’s Sporting Goods की सार्वजनिक कुंजी कहीं भी संग्रहीत नहीं होगी, लेकिन मान्यता प्राप्त प्रमाणपत्र प्राधिकरणों की सार्वजनिक कुंजियाँ वास्तव में आपके ब्राउज़र या आपके ऑपरेटिंग सिस्टम में संग्रहीत होती हैं। इन्हें **रूट प्रमाणपत्र** कहा जाता है।

इसलिए, जब जिम्स स्पोर्टिंग गुड्स आपको अपना TLS/SSL प्रमाणपत्र देता है, तो आप अपने ब्राउज़र या ऑपरेटिंग सिस्टम में एक रूट प्रमाणपत्र के माध्यम से प्रमाणपत्र प्राधिकरण के डिजिटल हस्ताक्षर को सत्यापित कर सकते हैं। अगर हस्ताक्षर मान्य है, तो आप अपेक्षाकृत सुनिश्चित हो सकते हैं कि प्रमाणपत्र पर मौजूद सार्वजनिक कुंजी वास्तव में जिम्स स्पोर्टिंग गुड्स की है। इस आधार पर, जिम्स स्पोर्टिंग गुड्स के साथ सुरक्षित संचार के लिए एक प्रोटोकॉल स्थापित करना आसान हो जाता है।

जिम्स स्पोर्टिंग गुड्स के लिए अब कुंजी वितरण काफी सरल हो गया है। यह देखना मुश्किल नहीं है कि कुंजी प्रबंधन भी काफी आसान हो गया है। हजारों कुंजियों को स्टोर करने की बजाय, जिम्स स्पोर्टिंग गुड्स को केवल एक निजी कुंजी स्टोर करनी होती है, जो उसे अपने एसएसएल प्रमाणपत्र के सार्वजनिक कुंजी के लिए हस्ताक्षर करने की अनुमति देती है। जब भी कोई ग्राहक जिम्स स्पोर्टिंग गुड्स की साइट पर आता है, वे इस सार्वजनिक कुंजी से एक सुरक्षित संचार सत्र स्थापित कर सकते हैं। ग्राहकों को भी कोई जानकारी स्टोर करने की आवश्यकता नहीं होती (सिवाय उनके ऑपरेटिंग सिस्टम और ब्राउज़र में मान्यता प्राप्त प्रमाणपत्र प्राधिकरणों की सार्वजनिक कुंजियों के)।

**नोट्स:**

[5] कोई भी योजना जो गैर-प्रत्याख्यान (non-repudiation) प्राप्त करने की कोशिश कर रही है, जैसा कि हमने अध्याय 1 में चर्चा की थी, उसके मूल में डिजिटल हस्ताक्षरों को शामिल करना आवश्यक होगा।

## Hash के कार्य क्या हैं?

<chapterId>ea8327ab-b0e3-5635-941c-4b51f396a648</chapterId>

Hash फंक्शन्स क्रिप्टोग्राफी में हर जगह पाए जाते हैं। ये न तो पूरी तरह से सिमेट्रिक होते हैं और न ही असिमेट्रिक स्कीम्स होते हैं, बल्कि ये अपनी ही एक क्रिप्टोग्राफिक श्रेणी में आते हैं।

हमने पहले ही अध्याय 4 में Hash फंक्शन्स के बारे में जाना था, जब हमने Hash आधारित प्रमाणीकरण संदेश बनाए थे। ये डिजिटल हस्ताक्षरों के संदर्भ में भी महत्वपूर्ण हैं, हालांकि थोड़े अलग कारण से: डिजिटल हस्ताक्षर आमतौर पर किसी (एन्क्रिप्टेड) संदेश के वास्तविक (एन्क्रिप्टेड) संदेश के बजाय Hash मान पर किए जाते हैं। इस खंड में, मैं Hash फंक्शन्स का एक अधिक विस्तृत परिचय दूंगा।

चलो Hash फ़ंक्शन की परिभाषा से शुरू करते हैं। एक **Hash फ़ंक्शन** वह होता है जिसे आसानी से गणना किया जा सकता है, जो किसी भी आकार के इनपुट लेता है और निश्चित लंबाई के आउटपुट देता है।

एक **क्रिप्टोग्राफिक Hash फंक्शन** बस एक Hash फंक्शन होता है जो क्रिप्टोग्राफी के अनुप्रयोगों में उपयोगी होता है। एक क्रिप्टोग्राफिक Hash फंक्शन का आउटपुट आमतौर पर **Hash**, **Hash-वैल्यू**, या **संदेश सार** कहा जाता है।

क्रिप्टोग्राफी के संदर्भ में, "Hash फंक्शन" आमतौर पर एक क्रिप्टोग्राफिक Hash फंक्शन को संदर्भित करता है। मैं आगे से इसी तरीके का पालन करूंगा।

एक लोकप्रिय Hash फंक्शन का उदाहरण **SHA-256** (सिक्योर Hash एल्गोरिदम 256) है। चाहे इनपुट का आकार कुछ भी हो (जैसे, 15 बिट्स, 100 बिट्स, या 10,000 बिट्स), यह फंक्शन हमेशा 256-बिट का Hash मान देगा। नीचे आप SHA-256 फंक्शन के कुछ उदाहरण आउटपुट देख सकते हैं।

"हैलो": `185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969`

"52398": `a3b14d2bf378c1bd47e7f8eaec63b445150a3d7a80465af16dd9fd319454ba90`

"क्रिप्टोग्राफी मजेदार है": `3cee2a5c7d2cc1d62db4893564c34ae553cc88623992d994e114e344359b146c`

सभी आउटपुट ठीक 256 बिट्स के होते हैं, जो हेक्साडेसिमल फॉर्मेट में लिखे जाते हैं (हर हेक्स अंक को चार बाइनरी अंकों से दर्शाया जा सकता है)। तो भले ही आपने टॉल्किन की *द लॉर्ड ऑफ द रिंग्स* किताब को SHA-256 फंक्शन में डाला हो, आउटपुट फिर भी 256 बिट्स का ही होगा।

Hash जैसे फंक्शन, जैसे SHA-256, क्रिप्टोग्राफी में विभिन्न उद्देश्यों के लिए उपयोग किए जाते हैं। किसी विशेष एप्लिकेशन के संदर्भ में Hash फंक्शन से कौन-कौन सी विशेषताएँ अपेक्षित हैं, यह वास्तव में उस संदर्भ पर निर्भर करता है। क्रिप्टोग्राफी में Hash फंक्शन से आमतौर पर दो मुख्य विशेषताएँ अपेक्षित होती हैं। [6]

1.	टकराव-प्रतिरोधकता

2. छुपाना

Hash फ़ंक्शन $H$ को **कोलिज़न-प्रतिरोधी** कहा जाता है यदि यह असंभव हो कि दो मान, $x$ और $y$, ढूंढे जा सकें, जहाँ $x \neq y$ हो, फिर भी $H(x) = H(y)$ हो।

टकराव-प्रतिरोधी Hash फंक्शन महत्वपूर्ण होते हैं, जैसे कि सॉफ़्टवेयर की सत्यापन प्रक्रिया में। मान लीजिए कि आप Bitcoin कोर 0.21.0 के विंडोज़ संस्करण को डाउनलोड करना चाहते हैं (जो कि Bitcoin नेटवर्क ट्रैफिक को प्रोसेस करने के लिए एक सर्वर एप्लिकेशन है)। सॉफ़्टवेयर की वैधता की पुष्टि करने के लिए आपको निम्नलिखित मुख्य कदम उठाने होंगे:

सबसे पहले, आपको एक या अधिक योगदानकर्ताओं के Bitcoin कोर के सार्वजनिक कुंजियों को डाउनलोड और इम्पोर्ट करना होगा, ताकि आप डिजिटल हस्ताक्षरों को सत्यापित कर सकें (जैसे कि Kleopatra सॉफ़्टवेयर का उपयोग करके)। आप इन सार्वजनिक कुंजियों को [यहां](https://github.com/Bitcoin/Bitcoin/blob/master/contrib/builder-keys/keys.txt) पा सकते हैं। यह सलाह दी जाती है कि आप Bitcoin कोर सॉफ़्टवेयर को कई योगदानकर्ताओं की सार्वजनिक कुंजियों से सत्यापित करें।

2.	अगला कदम यह है कि आपको उन सार्वजनिक कुंजियों को सत्यापित करना होगा जिन्हें आपने आयात किया है। कम से कम एक कदम जो आपको उठाना चाहिए वह यह है कि यह सुनिश्चित करें कि जो सार्वजनिक कुंजियाँ आपने पाई हैं, वे विभिन्न अन्य स्थानों पर प्रकाशित की गई कुंजियों के समान हैं। उदाहरण के लिए, आप उन लोगों के व्यक्तिगत वेब पेज, ट्विटर पेज या गिटहब पेज देख सकते हैं जिनकी सार्वजनिक कुंजियाँ आपने आयात की हैं। आमतौर पर इस सार्वजनिक कुंजी की तुलना एक छोटे Hash के माध्यम से की जाती है, जिसे फिंगरप्रिंट कहा जाता है।

अगला कदम यह है कि आपको Bitcoin कोर के लिए एक्सिक्यूटेबल फाइल उनकी [वेबसाइट](www.bitcoincore.org) से डाउनलोड करनी होगी। वहां पर Linux, Windows और MAC ऑपरेटिंग सिस्टम के लिए पैकेज उपलब्ध होंगे।

अब आपको दो रिलीज़ फाइलें ढूंढनी होंगी। पहली फाइल में उस एक्सीक्यूटेबल के लिए आधिकारिक SHA-256 Hash होगा जिसे आपने डाउनलोड किया है, साथ ही उन सभी अन्य पैकेजों के हैश होंगे जो रिलीज़ किए गए थे। दूसरी रिलीज़ फाइल में विभिन्न योगदानकर्ताओं के हस्ताक्षर होंगे जो पैकेज हैश वाली रिलीज़ फाइल पर होंगे। ये दोनों रिलीज़ फाइलें Bitcoin कोर वेबसाइट पर होनी चाहिए।

इसके बाद, आपको अपने कंप्यूटर पर Bitcoin कोर वेबसाइट से डाउनलोड किए गए एक्सीक्यूटेबल का SHA-256 Hash कैलकुलेट करना होगा। फिर, इस परिणाम की तुलना आधिकारिक पैकेज Hash के एक्सीक्यूटेबल के साथ करें। दोनों परिणाम समान होने चाहिए।

अंत में, आपको यह सुनिश्चित करना होगा कि रिलीज़ फाइल पर मौजूद एक या अधिक डिजिटल हस्ताक्षर वास्तव में आपके द्वारा इम्पोर्ट किए गए एक या अधिक सार्वजनिक कुंजियों से मेल खाते हैं (Bitcoin कोर के सभी रिलीज़ सभी द्वारा साइन नहीं किए जाते)। आप यह काम Kleopetra जैसे एप्लिकेशन का उपयोग करके कर सकते हैं।

इस सॉफ़्टवेयर सत्यापन प्रक्रिया के दो मुख्य लाभ हैं। पहला, यह सुनिश्चित करता है कि Bitcoin कोर की वेबसाइट से डाउनलोड करते समय कोई त्रुटि नहीं हुई। दूसरा, यह सुनिश्चित करता है कि कोई हमलावर आपको संशोधित, हानिकारक कोड डाउनलोड करने के लिए मजबूर नहीं कर सका, चाहे वह Bitcoin कोर वेबसाइट को हैक करके हो या ट्रैफ़िक को इंटरसेप्ट करके।

ऊपर बताए गए सॉफ़्टवेयर सत्यापन प्रक्रिया इन समस्याओं से कैसे बचाती है?

यदि आपने सावधानीपूर्वक उन सार्वजनिक कुंजियों को सत्यापित किया है जिन्हें आपने आयात किया है, तो आप काफी हद तक सुनिश्चित हो सकते हैं कि ये कुंजियाँ वास्तव में उन्हीं की हैं और इनमें कोई छेड़छाड़ नहीं हुई है। चूंकि डिजिटल हस्ताक्षरों में अस्तित्वगत नकली न होने की विशेषता होती है, आप जानते हैं कि केवल वही योगदानकर्ता आधिकारिक पैकेज हैश पर रिलीज़ फ़ाइल में डिजिटल हस्ताक्षर कर सकते थे।

मान लीजिए कि आपने जो रिलीज़ फाइल डाउनलोड की है, उसके सिग्नेचर सही हैं। अब आप अपने कंप्यूटर पर जो Windows executable डाउनलोड किया है, उसके लिए आपने जो Hash वैल्यू कैलकुलेट की है, उसे सही तरीके से साइन की गई रिलीज़ फाइल में शामिल वैल्यू से तुलना कर सकते हैं। जैसा कि आप जानते हैं, SHA-256 Hash फंक्शन टकराव प्रतिरोधी है, तो अगर दोनों वैल्यू मैच करती हैं, तो इसका मतलब है कि आपका executable बिल्कुल वही है जो आधिकारिक executable है।

अब हम Hash फंक्शन्स की दूसरी सामान्य विशेषता की ओर ध्यान देते हैं: **छुपाना**। किसी भी Hash फंक्शन $H$ के बारे में कहा जाता है कि उसमें छुपाने की विशेषता होती है, अगर किसी बहुत बड़े दायरे से कोई भी $x$ यादृच्छिक रूप से चुना जाए, तो केवल $H(x)$ दिए जाने पर $x$ को खोजना असंभव होता है।

नीचे आप मेरे द्वारा लिखे गए संदेश का SHA-256 आउटपुट देख सकते हैं। पर्याप्त रैंडमनेस सुनिश्चित करने के लिए, संदेश के अंत में मैंने एक रैंडमली जनरेट किया गया अक्षरों का स्ट्रिंग शामिल किया। चूंकि SHA-256 में हाइडिंग प्रॉपर्टी होती है, इसलिए कोई भी इस संदेश को समझ नहीं पाएगा।


- मुझे खेद है, लेकिन यह एक जटिल कोड या टेक्स्ट का हिस्सा लगता है। क्या आप कृपया इसे समझाने या इसके बारे में अधिक जानकारी देने में मदद कर सकते हैं? इससे मुझे आपकी बेहतर सहायता करने में मदद मिलेगी।

लेकिन मैं आपको तब तक सस्पेंस में नहीं रखूंगा जब तक SHA-256 कमजोर नहीं हो जाता। मैंने जो मूल संदेश लिखा था, वह इस प्रकार है:


- "यह एक बहुत ही रैंडम संदेश है, या कह सकते हैं कि थोड़ा रैंडम है। शुरुआत का हिस्सा तो नहीं है, लेकिन मैं अंत में कुछ रैंडम अक्षर जोड़ूंगा ताकि यह संदेश पूरी तरह से अप्रत्याशित हो जाए। XLWz4dVG3BxUWm7zQ9qS"

Hash का उपयोग अक्सर पासवर्ड प्रबंधन में किया जाता है, जिसमें छुपाने की विशेषता महत्वपूर्ण होती है (इस एप्लिकेशन के लिए टकराव-प्रतिरोध भी महत्वपूर्ण है)। कोई भी अच्छा ऑनलाइन खाता-आधारित सेवा जैसे फेसबुक या गूगल आपके पासवर्ड को सीधे स्टोर नहीं करेगी ताकि आपके खाते तक पहुंच को प्रबंधित किया जा सके। इसके बजाय, वे केवल उस पासवर्ड का Hash स्टोर करेंगे। जब भी आप अपने ब्राउज़र में पासवर्ड भरते हैं, तो पहले एक Hash की गणना की जाती है। केवल वही Hash सेवा प्रदाता के सर्वर पर भेजा जाता है और बैक-एंड डेटाबेस में स्टोर किए गए Hash से तुलना की जाती है। छुपाने की विशेषता यह सुनिश्चित करने में मदद कर सकती है कि हमलावर Hash मान से इसे पुनः प्राप्त नहीं कर सकते।

पासवर्ड प्रबंधन हैश के माध्यम से तभी काम करता है जब उपयोगकर्ता वास्तव में कठिन पासवर्ड चुनते हैं। छिपाने की विशेषता यह मानती है कि x को बहुत बड़े दायरे से यादृच्छिक रूप से चुना गया है। "1234", "mypassword", या आपकी जन्मतिथि जैसे पासवर्ड चुनने से कोई वास्तविक सुरक्षा नहीं मिलेगी। सामान्य पासवर्ड और उनके हैश की लंबी सूचियाँ मौजूद हैं, जिनका उपयोग हमलावर कर सकते हैं यदि वे कभी आपके पासवर्ड का Hash प्राप्त कर लेते हैं। इस प्रकार के हमलों को **डिक्शनरी अटैक** कहा जाता है। यदि हमलावर आपके कुछ व्यक्तिगत विवरण जानते हैं, तो वे कुछ सूचित अनुमान लगाने का भी प्रयास कर सकते हैं। इसलिए, आपको हमेशा लंबे, सुरक्षित पासवर्ड की आवश्यकता होती है (अधिमानतः पासवर्ड मैनेजर से लंबे, यादृच्छिक स्ट्रिंग)।

कभी-कभी किसी एप्लिकेशन को Hash फंक्शन की ज़रूरत होती है जिसमें टकराव प्रतिरोध और छुपाने की क्षमता दोनों होती हैं। लेकिन ऐसा हमेशा नहीं होता। उदाहरण के लिए, जिस सॉफ़्टवेयर सत्यापन प्रक्रिया के बारे में हमने चर्चा की, उसमें केवल यह आवश्यक है कि Hash फंक्शन टकराव प्रतिरोध दिखाए, छुपाने की क्षमता महत्वपूर्ण नहीं है।

क्रिप्टोग्राफी में Hash फंक्शन्स के लिए टकराव प्रतिरोध और छुपाने की क्षमता मुख्य गुण होते हैं, लेकिन कुछ विशेष अनुप्रयोगों में अन्य प्रकार के गुण भी वांछनीय हो सकते हैं।

**नोट्स:**

[6] "छुपाने" की शब्दावली आम भाषा में नहीं है, बल्कि इसे विशेष रूप से अरविंद नारायणन, जोसेफ बोनो, एडवर्ड फेल्टन, एंड्रयू मिलर, और स्टीवन गोल्डफेडर की पुस्तक *Bitcoin and Cryptocurrency Technologies*, प्रिंसटन यूनिवर्सिटी प्रेस (प्रिंसटन, 2016), अध्याय 1 से लिया गया है।

# आरएसए क्रिप्टोसिस्टम

<partId>864dca42-2a8d-530f-bb94-2e1f68b3f411</partId>

## फैक्टरिंग समस्या

<chapterId>a31a66e4-52ea-539c-9953-4769ad565d7e</chapterId>

अधिकांश लोगों के लिए सममित क्रिप्टोग्राफी आमतौर पर काफी सहज होती है, लेकिन विषममित क्रिप्टोग्राफी के साथ ऐसा नहीं होता। हालांकि आप शायद पिछले हिस्सों में दी गई उच्च-स्तरीय व्याख्या से सहज हैं, लेकिन आप शायद यह जानना चाह रहे हैं कि वास्तव में एक-तरफा फंक्शन क्या होते हैं और इन्हें विषममित योजनाओं को बनाने में कैसे उपयोग किया जाता है।

इस अध्याय में, मैं असममित क्रिप्टोग्राफी के रहस्य को थोड़ा कम करूंगा, खासकर एक विशेष उदाहरण, यानी RSA क्रिप्टोसिस्टम को गहराई से देखकर। पहले भाग में, मैं उस फैक्टराइजेशन समस्या का परिचय दूंगा जिस पर RSA समस्या आधारित है। इसके बाद, मैं संख्या सिद्धांत के कुछ महत्वपूर्ण परिणामों को कवर करूंगा। आखिरी भाग में, हम इस जानकारी को एक साथ रखकर RSA समस्या को समझाएंगे और यह कैसे असममित क्रिप्टोग्राफिक योजनाएं बनाने में उपयोगी हो सकता है।

हमारी चर्चा में इस गहराई को जोड़ना आसान काम नहीं है। इसके लिए कई संख्या-सिद्धांत के प्रमेय और प्रस्तावनाओं को पेश करना पड़ता है। लेकिन गणित से घबराएं नहीं। इस चर्चा को समझने से आपकी विषमलंबी क्रिप्टोग्राफी की समझ में काफी सुधार होगा और यह एक सार्थक निवेश है।

अब चलिए पहले फैक्टरिंग समस्या की ओर ध्यान देते हैं।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

जब भी आप दो संख्याओं, जैसे $a$ और $b$, का गुणा करते हैं, तो हम इन संख्याओं $a$ और $b$ को **गुणनखंड** कहते हैं, और जो परिणाम मिलता है उसे **गुणनफल** कहते हैं। किसी संख्या $N$ को दो या अधिक गुणनखंडों के गुणन के रूप में लिखने की प्रक्रिया को **गुणनखंडीकरण** या **गुणनखंड बनाना** कहते हैं। [1] किसी भी समस्या को, जिसमें यह प्रक्रिया शामिल हो, **गुणनखंडीकरण समस्या** कहा जा सकता है।

लगभग 2,500 साल पहले, एलेक्ज़ेंड्रिया के ग्रीक गणितज्ञ यूक्लिड ने पूर्णांकों के गुणनखंडन के बारे में एक महत्वपूर्ण प्रमेय की खोज की। इसे आमतौर पर **अद्वितीय गुणनखंडन प्रमेय** कहा जाता है और यह निम्नलिखित बात कहता है:

**थियोरम 1**. हर पूर्णांक $N$ जो 1 से बड़ा है, या तो एक अभाज्य संख्या होता है, या उसे अभाज्य गुणकों के गुणनफल के रूप में व्यक्त किया जा सकता है।

इस कथन के अंतिम भाग का मतलब बस इतना है कि आप 1 से बड़े किसी भी गैर-प्राइम संख्या $N$ को ले सकते हैं और उसे प्राइम संख्याओं के गुणनफल के रूप में लिख सकते हैं। नीचे कुछ उदाहरण दिए गए हैं जहाँ गैर-प्राइम संख्याओं को प्राइम गुणकों के गुणनफल के रूप में लिखा गया है।


- $18 = 2 \cdot 3 \cdot 3 = 2 \cdot 3^2$ का मतलब है कि 18 को उसके गुणनखंडों में तोड़कर लिखा गया है। यहाँ 18 को 2 और 3 के गुणनखंडों के रूप में लिखा गया है, जिसमें 3 का वर्ग (3^2) भी शामिल है।
- 84 को गुणनखंडों में तोड़ने पर हमें मिलता है: 2 × 2 × 3 × 7। इसे घातांक रूप में लिखा जा सकता है: \(2^2 \times 3 \times 7\)।
- 144 को 2 और 3 के गुणकों के रूप में लिखा जा सकता है। इसे इस तरह से समझें: 144 = 2 × 2 × 2 × 2 × 3 × 3। इसे घातांक के रूप में लिखें तो यह होगा: 2^4 × 3^2।

ऊपर दिए गए तीनों पूर्णांकों के लिए उनके अभाज्य गुणकों की गणना करना अपेक्षाकृत आसान है, भले ही आपके पास केवल $N$ दिया गया हो। आप सबसे छोटे अभाज्य संख्या, यानी 2 से शुरू करते हैं, और देखते हैं कि $N$ कितनी बार इससे विभाजित होता है। फिर आप $N$ की 3, 5, 7, आदि से विभाज्यता की जांच करते हैं। आप इस प्रक्रिया को तब तक जारी रखते हैं जब तक आपका पूर्णांक $N$ केवल अभाज्य संख्याओं के गुणनफल के रूप में नहीं लिखा जाता।

मान लीजिए, हमारे पास संख्या 84 है। नीचे आप देख सकते हैं कि इसके अभाज्य गुणांक (प्राइम फैक्टर्स) कैसे निकाले जाते हैं। हर कदम पर, हम सबसे छोटा बचा हुआ अभाज्य गुणांक (बाईं ओर) निकालते हैं और शेष संख्या को गुणांकित करने के लिए देखते हैं। हम तब तक जारी रखते हैं जब तक शेष संख्या भी एक अभाज्य संख्या न बन जाए। हर कदम पर, 84 का वर्तमान गुणांकीकरण सबसे दाईं ओर दिखाया गया है।


- मुख्य गुणनखंड = 2: शेषांक = 42 (क्योंकि $84 = 2 \cdot 42$)
- मुख्य गुणनखंड = 2: शेषांक पद = 21 (84 = 2 × 2 × 21)
- मुख्य गुणनखंड = 3: शेषांक = 7 (84 = 2 × 2 × 3 × 7)
- चूंकि 7 एक अभाज्य संख्या है, इसलिए परिणाम $2 \cdot 2 \cdot 3 \cdot 7$, या $2^2 \cdot 3 \cdot 7$ होगा।

मान लीजिए कि $N$ बहुत बड़ा है। $N$ को उसके अभाज्य गुणकों में विभाजित करना कितना कठिन होगा?

यह वास्तव में $N$ पर निर्भर करता है। मान लीजिए, उदाहरण के लिए, कि $N$ 50,450,400 है। हालांकि यह संख्या देखने में डरावनी लग सकती है, लेकिन गणनाएँ इतनी जटिल नहीं हैं और इन्हें आसानी से हाथ से किया जा सकता है। जैसा कि ऊपर बताया गया है, आप 2 से शुरू करते हैं और आगे बढ़ते जाते हैं। नीचे, आप इस प्रक्रिया का परिणाम उसी तरह देख सकते हैं जैसा कि ऊपर बताया गया है।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- 2: 12,612,600 ($50,450,400 = 2^2 \cdot 12,612,600$)
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- 3: 525,525 	($50,450,400 = 2^5 \cdot 3 \cdot 525,525$) का मतलब है कि संख्या 50,450,400 को 2 की घात 5, 3 और 525,525 के गुणनफल के रूप में लिखा जा सकता है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- 11:13 ($50,450,400 = 2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 11 \cdot 13$) का मतलब है कि संख्या 50,450,400 को उसके अभाज्य गुणकों में तोड़ा गया है। यह संख्या 2 को 5 बार, 3 को 2 बार, 5 को 2 बार, 7 को 2 बार, 11 को 1 बार और 13 को 1 बार गुणा करके बनाई गई है।
- चूंकि 13 एक अभाज्य संख्या है, इसलिए परिणाम $2^5 \cdot 3^2 \cdot 5^2 \cdot 7^2 \cdot 11 \cdot 13$ है।

इस समस्या को हाथ से हल करने में कुछ समय लगता है। लेकिन एक कंप्यूटर, निश्चित रूप से, इसे सेकंड के एक छोटे से हिस्से में कर सकता है। वास्तव में, एक कंप्यूटर अक्सर बहुत बड़े संख्याओं का गुणनखंड भी सेकंड के एक हिस्से में कर सकता है।

हालाँकि, कुछ अपवाद भी होते हैं। मान लीजिए कि हम पहले दो बहुत बड़े अभाज्य संख्याओं का यादृच्छिक चयन करते हैं। आमतौर पर इन्हें $p$ और $q$ के रूप में लेबल किया जाता है, और मैं यहाँ उसी परंपरा का पालन करूंगा।

चलो इसे और स्पष्ट करते हैं, मान लेते हैं कि $p$ और $q$ दोनों 1024-बिट के अभाज्य संख्याएँ हैं, और इन्हें दर्शाने के लिए कम से कम 1024 बिट्स की आवश्यकता होती है (इसलिए पहला बिट 1 होना चाहिए)। उदाहरण के लिए, 37 इनमें से कोई एक अभाज्य संख्या नहीं हो सकती। आप निश्चित रूप से 37 को 1024 बिट्स के साथ दर्शा सकते हैं। लेकिन स्पष्ट रूप से *आपको* इसे दर्शाने के लिए इतने बिट्स की आवश्यकता नहीं है। आप 37 को किसी भी स्ट्रिंग के साथ दर्शा सकते हैं जिसमें 6 बिट्स या उससे अधिक हों। (6 बिट्स में, 37 को $100101$ के रूप में दर्शाया जाएगा)।

यह समझना महत्वपूर्ण है कि $p$ और $q$ कितने बड़े होते हैं जब उन्हें ऊपर दिए गए शर्तों के तहत चुना जाता है। उदाहरण के लिए, मैंने एक यादृच्छिक अभाज्य संख्या चुनी है जिसे नीचे 1024 बिट्स की आवश्यकता होती है।


- आपके पास अक्टूबर 2023 तक के डेटा पर प्रशिक्षण है।

मान लीजिए कि हमने अब यादृच्छिक रूप से दो अभाज्य संख्याएँ $p$ और $q$ चुनीं, और उन्हें गुणा करके एक पूर्णांक $N$ प्राप्त किया। यह पूर्णांक, इसलिए, 2048 बिट की संख्या है, जिसे दर्शाने के लिए कम से कम 2048 बिट की आवश्यकता होती है। यह संख्या $p$ या $q$ में से किसी भी संख्या से कहीं अधिक बड़ी होती है।

मान लीजिए कि आप एक कंप्यूटर को केवल $N$ देते हैं और उससे कहते हैं कि वह $N$ के दो 1024 बिट के अभाज्य गुणक $p$ और $q$ खोजे। कंप्यूटर के लिए $p$ और $q$ का पता लगाने की संभावना बेहद कम है। आप कह सकते हैं कि यह व्यावहारिक दृष्टिकोण से असंभव है। ऐसा तब भी है, जब आप एक सुपरकंप्यूटर या सुपरकंप्यूटरों के नेटवर्क का उपयोग करें।

शुरुआत करने के लिए, मान लीजिए कि कंप्यूटर 1024 बिट नंबरों के माध्यम से समस्या को हल करने की कोशिश करता है, और हर मामले में यह जांचता है कि वे संख्या अभाज्य हैं या नहीं और क्या वे $N$ के गुणक हैं। परीक्षण के लिए अभाज्य संख्याओं का सेट लगभग $1.265 \cdot 10^{305}$ है।

अगर आप धरती के सभी कंप्यूटरों को ले लें और उनसे 1024-बिट के अभाज्य संख्याओं को इस तरीके से खोजने और जांचने को कहें, तो $N$ का एक अभाज्य गुणक खोजने की 1 अरब में 1 की संभावना के लिए इतनी लंबी गणना की अवधि की आवश्यकता होगी जो ब्रह्मांड की उम्र से भी ज्यादा है।

अब व्यवहार में एक कंप्यूटर उस मोटे तरीके से बेहतर कर सकता है जो अभी बताया गया। कई एल्गोरिदम मौजूद हैं जिन्हें कंप्यूटर तेजी से फैक्टराइजेशन करने के लिए लागू कर सकता है। लेकिन बात यह है कि इन अधिक कुशल एल्गोरिदम का उपयोग करने के बावजूद, कंप्यूटर का काम अभी भी गणनात्मक रूप से असंभव है।

महत्वपूर्ण बात यह है कि जिस स्थिति का वर्णन किया गया है, उसमें गुणनखंड निकालने की कठिनाई इस धारणा पर आधारित है कि अभाज्य गुणनखंड निकालने के लिए कोई गणनात्मक रूप से कुशल एल्गोरिदम नहीं है। हम वास्तव में यह साबित नहीं कर सकते कि ऐसा कोई कुशल एल्गोरिदम नहीं है। फिर भी, यह धारणा बहुत ही संभावित है: सैकड़ों वर्षों के व्यापक प्रयासों के बावजूद, हम अब तक ऐसा कोई गणनात्मक रूप से कुशल एल्गोरिदम नहीं खोज पाए हैं।

इसलिए, कुछ विशेष परिस्थितियों में, फैक्टरीकरण की समस्या को Hard समस्या माना जा सकता है। खासकर जब $p$ और $q$ बहुत बड़े अभाज्य संख्याएँ होती हैं, तो उनका गुणनफल $N$ निकालना आसान होता है; लेकिन केवल $N$ दिए जाने पर उसका फैक्टरीकरण करना लगभग असंभव होता है।

**नोट्स:**

[1] गुणनखंडन केवल संख्याओं के साथ काम करने के लिए ही महत्वपूर्ण नहीं होता, बल्कि अन्य प्रकार की गणितीय वस्तुओं के लिए भी महत्वपूर्ण हो सकता है। उदाहरण के लिए, यह बहुपद अभिव्यक्तियों जैसे $x^2 - 2x + 1$ को गुणनखंडित करने में उपयोगी हो सकता है। हमारी चर्चा में, हम केवल संख्याओं, विशेष रूप से पूर्णांकों के गुणनखंडन पर ध्यान केंद्रित करेंगे।

**प्राइम नंबर थ्योरम** के अनुसार, $N$ से कम या उसके बराबर प्राइम नंबरों की संख्या लगभग $N/\LN(N)$ होती है। इसका मतलब है कि आप 1024 बिट लंबाई के प्राइम नंबरों की संख्या का अनुमान इस तरीके से लगा सकते हैं:

आपके द्वारा दिए गए गणितीय अभिव्यक्ति को हिंदी में समझाना थोड़ा जटिल हो सकता है, लेकिन मैं इसे सरल भाषा में समझाने की कोशिश करता हूँ।

यह एक गणितीय समीकरण है जिसमें दो भिन्न (fractions) हैं। पहले भिन्न में, 2 को 1024 बार गुणा किया गया है और इसे GW से घटाकर 142 गुना 2 को 1024 बार गुणा किया गया है, से भाग दिया गया है। दूसरे भिन्न में, 2 को 1023 बार गुणा किया गया है और इसे GW से घटाकर 142 गुना 2 को 1023 बार गुणा किया गया है, से भाग दिया गया है। 

इसका मतलब है कि आप पहले भिन्न से दूसरे भिन्न को घटा रहे हैं। यह गणितीय अभिव्यक्ति किसी विशेष गणना या समस्या को हल करने के लिए हो सकती है।

...जो लगभग $1.265 \times 10^{305}$ के बराबर है।

[3] यही बात डिस्क्रीट लॉगरिदम समस्याओं के लिए भी सही है। इसलिए, असममित संरचनाएँ सममित क्रिप्टोग्राफिक संरचनाओं की तुलना में बहुत बड़े कुंजियों के साथ काम करती हैं।

## संख्या सिद्धांत के परिणाम

<chapterId>23cd2186-8d97-5709-a4a7-b984f1eb9999</chapterId>

दुर्भाग्यवश, फैक्टरिंग समस्या को सीधे असममित क्रिप्टोग्राफिक योजनाओं के लिए उपयोग नहीं किया जा सकता। हालांकि, हम इस उद्देश्य के लिए एक अधिक जटिल लेकिन संबंधित समस्या का उपयोग कर सकते हैं: आरएसए समस्या।

RSA समस्या को समझने के लिए, हमें संख्या सिद्धांत से जुड़े कुछ प्रमेय और प्रस्तावों को समझना होगा। इस खंड में इन्हें तीन उपखंडों में प्रस्तुत किया गया है: (1) N का क्रम, (2) N के मापांक में प्रतिलोमता, और (3) यूलर का प्रमेय।

तीन उपखंडों में से कुछ सामग्री पहले ही *अध्याय 3* में पेश की जा चुकी है। लेकिन आपकी सुविधा के लिए मैं यहाँ उस सामग्री को फिर से प्रस्तुत करूँगा।

### आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं।

यदि कोई पूर्णांक $a$ और कोई पूर्णांक $N$ **कोप्राइम** या **सापेक्ष अभाज्य** होते हैं, तो इसका मतलब है कि उनके बीच का महत्तम समापवर्तक 1 होता है। हालांकि 1 को परंपरागत रूप से अभाज्य संख्या नहीं माना जाता, लेकिन यह हर पूर्णांक का कोप्राइम होता है (जैसे कि $-1$ भी होता है)।

उदाहरण के लिए, मान लीजिए कि $a = 18$ और $N = 37$ हैं। ये दोनों स्पष्ट रूप से सहप्राइम हैं। 18 और 37 दोनों में विभाजित होने वाली सबसे बड़ी संख्या 1 है। इसके विपरीत, मान लीजिए कि $a = 42$ और $N = 16$ हैं। ये स्पष्ट रूप से सहप्राइम नहीं हैं। दोनों संख्याएँ 2 से विभाजित होती हैं, जो 1 से बड़ी है।

अब हम $N$ के क्रम को इस प्रकार परिभाषित कर सकते हैं। मान लीजिए कि $N$ एक पूर्णांक है जो 1 से बड़ा है। तब **$N$ का क्रम** उन सभी संख्याओं की संख्या है जो $N$ के साथ सहप्राइम हैं, और जिनके लिए यह शर्त पूरी होती है: $1 \leq a < N$।

उदाहरण के लिए, यदि $N = 12$ है, तो 1, 5, 7, और 11 ही ऐसे संख्याएँ हैं जो उपरोक्त शर्त को पूरा करती हैं। इसलिए, 12 का क्रम 4 के बराबर है।

मान लीजिए कि $N$ एक अभाज्य संख्या है। तो $N$ से छोटी लेकिन 1 के बराबर या उससे बड़ी कोई भी पूर्णांक $N$ के साथ सह-प्राइम होती है। इसमें निम्नलिखित सेट में सभी Elements शामिल हैं: $\{1,2,3,....,N - 1\}$। इसलिए, जब $N$ अभाज्य होता है, तो $N$ का क्रम $N - 1$ होता है। यह प्रस्तावना 1 में कहा गया है, जहाँ $\phi(N)$ $N$ का क्रम दर्शाता है।

**प्रस्ताव 1**. $\phi(N) = N - 1$ जब $N$ एक अभाज्य संख्या होती है।

मान लीजिए कि $N$ एक अभाज्य संख्या नहीं है। तब आप इसका क्रम **यूलर के फाई फंक्शन** का उपयोग करके निकाल सकते हैं। जब किसी छोटे पूर्णांक का क्रम निकालना अपेक्षाकृत सरल होता है, तो बड़े पूर्णांकों के लिए यूलर का फाई फंक्शन विशेष रूप से महत्वपूर्ण हो जाता है। यूलर के फाई फंक्शन का प्रस्ताव नीचे दिया गया है।

**थियोरम 2**. मान लीजिए $N$ बराबर है $p_1^{e_1} \cdot p_2^{e_2} \cdot \ldots \cdot p_i^{e_i} \cdot \ldots \cdot p_n^{e_n}$ के, जहाँ $\{p_i\}$ का सेट $N$ के सभी भिन्न अभाज्य गुणकों से बना है और प्रत्येक $e_i$ यह दर्शाता है कि अभाज्य गुणक $p_i$ कितनी बार $N$ में आता है। तब,

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

**थियोरम 2** यह दर्शाता है कि जब आप किसी भी गैर-प्राइम $N$ को उसके विशिष्ट प्राइम गुणकों में विभाजित कर लेते हैं, तो $N$ का क्रम निकालना आसान हो जाता है।

उदाहरण के लिए, मान लीजिए कि $N = 270$ है। यह स्पष्ट रूप से एक अभाज्य संख्या नहीं है। $N$ को उसके अभाज्य गुणकों में तोड़ने पर हमें यह अभिव्यक्ति मिलती है: $2 \cdot 3^3 \cdot 5$। ऑयलर के फाई (Phi) फंक्शन के अनुसार, $N$ का क्रम इस प्रकार होगा:

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

मान लीजिए कि $N$ दो अभाज्य संख्याओं, $p$ और $q$ का गुणनफल है। तब **थियोरम 2** के अनुसार, $N$ का क्रम इस प्रकार है:

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

यह विशेष रूप से RSA समस्या के लिए एक महत्वपूर्ण परिणाम है, और इसे नीचे **प्रस्ताव 2** में बताया गया है।

**प्रस्तावना 2**. यदि $N$ दो अभाज्य संख्याओं $p$ और $q$ का गुणनफल है, तो $N$ का क्रम $(p - 1) \cdot (q - 1)$ के गुणनफल के बराबर होता है।

उदाहरण के लिए, मान लीजिए कि $N = 119$ है। इस पूर्णांक को दो अभाज्य संख्याओं में विभाजित किया जा सकता है, जो हैं 7 और 17। इसलिए, ऑयलर का फाई फंक्शन यह सुझाव देता है कि 119 का क्रम इस प्रकार है:

आपके पास अक्टूबर 2023 तक का डेटा है।

दूसरे शब्दों में, संख्या 119 के पास 1 से लेकर 119 तक की सीमा में 96 सहमूल्यांक हैं। वास्तव में, इस सेट में वे सभी पूर्णांक शामिल हैं जो 1 से लेकर 119 तक हैं, और जो 7 या 17 के गुणज नहीं हैं।

यहां से, चलिए उस सेट को $C_N$ के रूप में दर्शाते हैं जो $N$ के क्रम को निर्धारित करता है। हमारे उदाहरण में जहां $N = 119$ है, सेट $C_{119}$ को पूरी तरह से सूचीबद्ध करना बहुत बड़ा है। लेकिन कुछ Elements इस प्रकार हैं:

$$C_{119} = \{1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 35, 36, \dots, 96\}$$

यह सेट $C_{119}$ उन संख्याओं का समूह है जो 1 से शुरू होकर 96 तक जाती हैं, लेकिन इसमें कुछ विशेष संख्याएँ जैसे 7, 14, 17, 34 आदि शामिल नहीं हैं।

### मॉड्यूलो \( N \) में इनवर्टिबिलिटी

हम कह सकते हैं कि एक पूर्णांक $a$ **मॉड्यूलो N के अनुसार उलटने योग्य** है, यदि कम से कम एक पूर्णांक $b$ मौजूद है जिससे $a \cdot b \mod N = 1 \mod N$ हो। ऐसा कोई भी पूर्णांक $b$, $a$ का **उल्टा** (या **गुणात्मक उल्टा**) कहा जाता है, जब इसे मॉड्यूलो $N$ के अनुसार घटाया जाता है।

मान लीजिए, उदाहरण के लिए, कि $a = 5$ और $N = 11$ हैं। ऐसे कई पूर्णांक हैं जिनसे आप 5 को गुणा कर सकते हैं, ताकि $5 \cdot b \mod 11 = 1 \mod 11$ हो। उदाहरण के लिए, पूर्णांक 20 और 31 को देखें। यह आसानी से देखा जा सकता है कि ये दोनों पूर्णांक 5 के प्रतिलोम हैं जब 11 के मापांक में घटाया जाता है।


- $5 \times 20 \mod 11 = 100 \mod 11 = 1 \mod 11$
- 5 को 31 से गुणा करने पर 155 प्राप्त होता है। अब 155 को 11 से भाग देने पर शेषफल 1 आता है। इसलिए $5 \cdot 31 \mod 11 = 1$।

हालांकि 5 के कई प्रतिलोम होते हैं जब हम इसे 11 के मापांक में घटाते हैं, आप दिखा सकते हैं कि 5 का केवल एक ही सकारात्मक प्रतिलोम होता है जो 11 से कम होता है। वास्तव में, यह केवल हमारे विशेष उदाहरण के लिए ही नहीं है, बल्कि यह एक सामान्य परिणाम है।

**प्रस्ताव 3**. यदि पूर्णांक $a$ मापांक $N$ के अनुसार उलटने योग्य है, तो यह आवश्यक है कि $a$ का ठीक एक सकारात्मक प्रतिलोम $N$ से कम हो। (इसलिए, $a$ का यह अद्वितीय प्रतिलोम $\{1, \dots, N - 1\}$ सेट से ही आना चाहिए)।

**प्रस्ताव 3** से $a$ के अद्वितीय व्युत्क्रम को $a^{-1}$ के रूप में दर्शाते हैं। जब $a = 5$ और $N = 11$ हो, तो आप देख सकते हैं कि $a^{-1} = 9$ है, क्योंकि $5 \cdot 9 \mod 11 = 45 \mod 11 = 1 \mod 11$ होता है।

ध्यान दें कि हमारे उदाहरण में आप $a^{-1}$ के लिए 9 का मान प्राप्त कर सकते हैं, बस $a$ के किसी अन्य इनवर्स को 11 से घटाकर। उदाहरण के लिए, $20 \mod 11 = 31 \mod 11 = 9 \mod 11$। इसलिए जब भी कोई पूर्णांक $a > N$ $N$ के मापांक में उलटने योग्य होता है, तो $a \mod N$ भी $N$ के मापांक में उलटने योग्य होना चाहिए।

यह जरूरी नहीं है कि $a$ का व्युत्क्रम $N$ के मापांक में मौजूद हो। मान लीजिए, उदाहरण के लिए, कि $a = 2$ और $N = 8$। ऐसा कोई $b$, या विशेष रूप से कोई $a^{-1}$ नहीं है, जिससे $2 \cdot b \mod 8 = 1 \mod 8$ हो। ऐसा इसलिए है क्योंकि $b$ का कोई भी मान हमेशा 2 का गुणज ही देगा, इसलिए 8 से विभाजन कभी भी ऐसा शेष नहीं दे सकता जो 1 के बराबर हो।

हम कैसे जान सकते हैं कि किसी दिए गए $N$ के लिए कोई पूर्णांक $a$ का व्युत्क्रम है या नहीं? जैसा कि आपने ऊपर के उदाहरण में देखा होगा, 2 और 8 के बीच का महत्तम समापवर्तक 1 से अधिक है, अर्थात 2। और यह वास्तव में निम्नलिखित सामान्य परिणाम को दर्शाता है:

**प्रस्ताव 4**. किसी पूर्णांक $a$ का प्रतिलोम अस्तित्व में होता है जब उसे $N$ के मापांक में घटाया जाता है, और विशेष रूप से एक अद्वितीय सकारात्मक प्रतिलोम जो $N$ से कम होता है, तब और केवल तब जब $a$ और $N$ के बीच का महत्तम समापवर्तक 1 हो (अर्थात, यदि वे सह-प्राइम हैं)।

जब $a = 5$ और $N = 11$ होता है, तो हमने निष्कर्ष निकाला कि $a^{-1} = 9$ है, क्योंकि $5 \cdot 9 \mod 11 = 45 \mod 11 = 1 \mod 11$ होता है। यह ध्यान देने योग्य है कि इसका उल्टा भी सही है। यानी, जब $a = 9$ और $N = 11$ होता है, तो $a^{-1} = 5$ होता है।

### यूलेर का प्रमेय

RSA समस्या पर जाने से पहले, हमें एक और महत्वपूर्ण प्रमेय को समझना होगा, जिसे **यूलर का प्रमेय** कहा जाता है। यह निम्नलिखित बात कहता है:

**थियोरम 3**. मान लीजिए कि दो पूर्णांक $a$ और $N$ सह-प्राइम हैं। तब, $a^{\phi(N)} \mod N = 1 \mod N$।

यह एक उल्लेखनीय परिणाम है, लेकिन शुरुआत में थोड़ा भ्रमित करने वाला है। इसे समझने के लिए चलिए एक उदाहरण की ओर रुख करते हैं।

मान लीजिए कि $a = 5$ और $N = 7$ हैं। ये वास्तव में सह-प्राइम हैं जैसा कि यूलर के प्रमेय की आवश्यकता होती है। हम जानते हैं कि 7 का क्रम 6 के बराबर है, क्योंकि 7 एक अभाज्य संख्या है (देखें **प्रस्तावना 1**)।

अब, ऑयलर का प्रमेय यह कहता है कि $5^6 \mod 7$ का मान $1 \mod 7$ के बराबर होना चाहिए। नीचे दिए गए गणना से यह साबित होता है कि यह वास्तव में सही है।


- यह गणितीय समस्या है जिसमें हमें \(5^6 \mod 7\) का मान निकालना है। 

पहले \(5^6\) की गणना करते हैं, जो कि 15,625 होता है। अब हमें इसे 7 से भाग देकर शेष निकालना है। 

जब हम 15,625 को 7 से भाग देते हैं, तो शेष 1 आता है। 

इसलिए, \(5^6 \mod 7 = 1\) होता है। 

यहाँ \(N\) का कोई विशेष अर्थ नहीं है, यह केवल यह दर्शाने के लिए है कि शेष 1 है।

अंक 7 को 15,624 में 2,233 बार विभाजित किया जा सकता है। इसलिए, 16,625 को 7 से विभाजित करने पर शेषफल 1 होता है।

अब, यूलर के फाई फंक्शन का उपयोग करके, **थियोरम 2** से आप नीचे दिए गए **प्रस्ताव 5** को प्राप्त कर सकते हैं।

**प्रस्ताव 5**. $\phi(a \cdot b) = \phi(a) \cdot \phi(b)$ किसी भी धनात्मक पूर्णांक $a$ और $b$ के लिए।

हम यह नहीं दिखाएंगे कि ऐसा क्यों है। लेकिन बस यह नोट करें कि आपने पहले ही इस प्रस्ताव का प्रमाण देखा है, इस तथ्य से कि जब $p$ और $q$ अभाज्य संख्याएँ हैं, तो $\phi(p \cdot q) = \phi(p) \cdot \phi(q) = (p - 1) \cdot (q - 1)$ होता है, जैसा कि **प्रस्ताव 2** में कहा गया है।

ऑयलर का प्रमेय और **प्रस्ताव 5** मिलकर महत्वपूर्ण प्रभाव डालते हैं। उदाहरण के लिए, नीचे दिए गए अभिव्यक्तियों में देखें कि क्या होता है, जहाँ $a$ और $N$ परस्पर अभाज्य हैं।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

यहां दिए गए गणितीय समीकरण का मतलब है कि यदि आपके पास कोई संख्या \(a\) है और आप उसे \(N\) से मॉड्यूलो लेना चाहते हैं, तो आप इसे इस तरह से तोड़ सकते हैं:

1. पहले \(a\) को \(8 \cdot \phi(N)\) की शक्ति तक बढ़ाएं, जहां \(\phi(N)\) ईलर का टोटिएंट फंक्शन है, जो \(N\) के साथ सह-प्राइम संख्याओं की संख्या को दर्शाता है। 
2. फिर इसे \(a^3\) से गुणा करें।
3. अंत में, इसे \(N\) से मॉड्यूलो लें।

इस प्रक्रिया के अनुसार, \(a^{8 \cdot \phi(N)}\) का परिणाम 1 होगा (क्योंकि ईलर के प्रमेय के अनुसार \(a^{\phi(N)} \equiv 1 \mod N\) जब \(a\) और \(N\) सह-प्राइम होते हैं), इसलिए पूरा समीकरण \(a^3 \mod N\) के बराबर होगा। 

इसका मतलब है कि \(a^{8 \cdot \phi(N) + 3} \mod N\) का परिणाम \(a^3 \mod N\) के बराबर होगा।

इसलिए, ऑयलर के प्रमेय और **प्रस्ताव 5** के संयोजन से हम कई अभिव्यक्तियों की गणना आसानी से कर सकते हैं। सामान्य रूप से, हम इस समझ को **प्रस्ताव 6** के रूप में संक्षेप में प्रस्तुत कर सकते हैं।

**प्रस्तावना 6**. $a^x \mod N = a^{x \mod \phi(N)}$

इसका मतलब यह है कि यदि आप किसी संख्या $a$ को $x$ घात तक बढ़ाते हैं और फिर उसे $N$ से भाग देकर शेष निकालते हैं, तो यह उसी के बराबर होगा जैसे आप $a$ को $x \mod \phi(N)$ घात तक बढ़ाएं और फिर उसे $N$ से भाग देकर शेष निकालें। यहाँ $\phi(N)$ का मतलब है कि $N$ का ओइलर टोटिएंट फंक्शन, जो $N$ से छोटे उन संख्याओं की संख्या बताता है जो $N$ के साथ सह-प्राइम हैं।

अब हमें सब कुछ एक साथ जोड़ना है, और यह आखिरी कदम थोड़ा पेचीदा है।

जैसे $N$ का एक क्रम $\phi(N)$ होता है, जिसमें सेट $C_N$ का Elements शामिल होता है, वैसे ही हम जानते हैं कि पूर्णांक $\phi(N)$ का भी एक क्रम और एक सेट होता है जो उससे सहप्राइम होते हैं। मान लेते हैं कि $\phi(N) = R$ है। तो हमें यह भी पता है कि $\phi(R)$ का भी एक मान होता है और एक सेट $C_R$ होता है जो उससे सहप्राइम होते हैं।

मान लीजिए कि अब हम सेट $C_R$ से एक पूर्णांक $e$ चुनते हैं। हमें **प्रस्ताव 3** से पता है कि इस पूर्णांक $e$ का केवल एक अद्वितीय सकारात्मक प्रतिलोम $R$ से कम होता है। यानी, $e$ का सेट $C_R$ से एक अद्वितीय प्रतिलोम होता है। चलिए इस प्रतिलोम को $d$ कहते हैं। प्रतिलोम की परिभाषा के अनुसार, इसका मतलब है कि $e \cdot d = 1 \mod R$।

हम इस परिणाम का उपयोग करके हमारे मूल पूर्णांक $N$ के बारे में एक कथन बना सकते हैं। इसे **प्रस्तावना 7** में संक्षेपित किया गया है।

**प्रस्तावना 7**. मान लीजिए कि $e \cdot d \mod \phi(N) = 1 \mod \phi(N)$ है। तो सेट $C_N$ के किसी भी तत्व $a$ के लिए यह आवश्यक है कि $a^{e \cdot d \mod \phi(N)} = a^{1 \mod \phi(N)} = a \mod N$ हो।

अब हमारे पास सभी संख्या सिद्धांत से संबंधित परिणाम हैं जो हमें RSA समस्या को स्पष्ट रूप से बताने के लिए आवश्यक हैं।

## आरएसए क्रिप्टोसिस्टम

<chapterId>0253c2f7-b8a4-5d0e-bd60-812ed6b6c7a9</chapterId>

अब हम RSA समस्या को समझने के लिए तैयार हैं। मान लीजिए कि आपने कुछ चर बनाए हैं जिनमें $p$, $q$, $N$, $\phi(N)$, $e$, $d$, और $y$ शामिल हैं। इस सेट को $\Pi$ कहते हैं। इसे इस प्रकार बनाया जाता है:

आपको दो यादृच्छिक अभाज्य संख्याएँ $p$ और $q$ दी गई हैं, जिनका आकार समान है। इन दोनों संख्याओं का गुणनफल $N$ निकालें।

आपको $N$ और $\phi(N)$ की गणना करनी है, जहाँ $\phi(N)$ को निम्नलिखित गुणनफल से प्राप्त किया जाता है: $(p - 1) \cdot (q - 1)$।

3. एक $e > 2$ चुनें जो $\phi(N)$ से छोटा हो और उसके साथ सहप्राइम हो।

4. $d$ की गणना इस तरह करें कि $e \cdot d \mod \phi(N) = 1$ हो।

5. एक यादृच्छिक मान $y$ चुनें जो $N$ से छोटा हो और $N$ के साथ सहप्राइम हो।

RSA समस्या में $x$ को ढूंढना होता है ताकि $x^e = y$ हो, जबकि आपको $\Pi$ के बारे में केवल कुछ जानकारी दी जाती है, जैसे कि $N$, $e$, और $y$। जब $p$ और $q$ बहुत बड़े होते हैं, आमतौर पर यह सुझाव दिया जाता है कि वे 1024 बिट्स के आकार के हों, तो RSA समस्या को Hard माना जाता है। अब आप समझ सकते हैं कि यह क्यों होता है, जैसा कि ऊपर की चर्चा से स्पष्ट है।

जब आपके पास समीकरण $x^e \mod N = y \mod N$ हो, तो $x$ की गणना करने का एक आसान तरीका है $y^d \mod N$ की गणना करना। हम जानते हैं कि $y^d \mod N = x \mod N$ निम्नलिखित गणनाओं के माध्यम से:

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

समस्या यह है कि हमें $d$ का मान नहीं पता है, क्योंकि यह समस्या में दिया नहीं गया है। इसलिए, हम सीधे $y^d \mod N$ की गणना करके $x \mod N$ प्राप्त नहीं कर सकते।

हालांकि, हम $N$ के क्रम $\phi(N)$ से $d$ को अप्रत्यक्ष रूप से गणना कर सकते हैं, क्योंकि हमें पता है कि $e \cdot d \mod \phi(N) = 1 \mod \phi(N)$ होता है। लेकिन समस्या यह है कि हमें $\phi(N)$ का मान भी नहीं दिया गया है।

आखिरकार, क्रम को अप्रत्यक्ष रूप से प्रमुख गुणनखंड $p$ और $q$ के साथ गणना किया जा सकता था, ताकि हम अंततः $d$ की गणना कर सकें। लेकिन मान्यता के अनुसार, हमें $p$ और $q$ के मान भी नहीं दिए गए थे।

सख्ती से कहें तो, भले ही RSA समस्या के भीतर फैक्टरिंग समस्या Hard हो, हम यह साबित नहीं कर सकते कि RSA समस्या भी Hard है। इसका मतलब यह है कि RSA समस्या को हल करने के लिए फैक्टरिंग के अलावा भी अन्य तरीके हो सकते हैं। हालांकि, आमतौर पर यह स्वीकार किया जाता है और माना जाता है कि अगर RSA समस्या के भीतर फैक्टरिंग समस्या Hard है, तो RSA समस्या खुद भी Hard है।

यदि RSA समस्या वास्तव में Hard है, तो यह एक एकतरफा फ़ंक्शन उत्पन्न करती है जिसमें एक ट्रैपडोर होता है। यहाँ फ़ंक्शन है $f(g) = g^e \mod N$। $f(g)$ की जानकारी के साथ, कोई भी आसानी से किसी विशेष $g = x$ के लिए एक मान $y$ की गणना कर सकता है। हालांकि, केवल $y$ और फ़ंक्शन $f(g)$ की जानकारी से किसी विशेष $x$ का मान निकालना व्यावहारिक रूप से असंभव है। अपवाद तब होता है जब आपको एक जानकारी $d$ दी जाती है, जो ट्रैपडोर है। उस स्थिति में, आप आसानी से $y^d$ की गणना करके $x$ प्राप्त कर सकते हैं।

आइए एक विशेष उदाहरण के माध्यम से RSA समस्या को समझने की कोशिश करते हैं। मैं उन शर्तों के तहत Hard के रूप में मानी जाने वाली RSA समस्या का चयन नहीं कर सकता, क्योंकि उन संख्याओं को संभालना मुश्किल होगा। इसके बजाय, यह उदाहरण सिर्फ यह दिखाने के लिए है कि RSA समस्या आमतौर पर कैसे काम करती है।

शुरू करने के लिए, मान लीजिए कि आपने दो यादृच्छिक अभाज्य संख्याएँ चुनीं, 13 और 31। तो $p = 13$ और $q = 31$ हैं। इन दोनों अभाज्य संख्याओं का गुणनफल $N$ 403 के बराबर होता है। हम आसानी से 403 का क्रम निकाल सकते हैं। यह $(13 - 1) \cdot (31 - 1) = 360$ के बराबर होता है।

अब, जैसा कि RSA समस्या के चरण 3 में बताया गया है, हमें 360 के लिए एक सह-प्राइम चुनना है जो 2 से बड़ा और 360 से छोटा हो। हमें इस मान को यादृच्छिक रूप से चुनने की आवश्यकता नहीं है। मान लीजिए कि हम 103 चुनते हैं। यह 360 का सह-प्राइम है क्योंकि 103 के साथ इसका महत्तम समापवर्तक 1 है।

चरण 4 में अब हमें एक मान $d$ की गणना करनी है ताकि $103 \cdot d \mod 360 = 1$ हो। जब $N$ का मान बड़ा होता है, तो यह काम हाथ से करना आसान नहीं होता। इसके लिए हमें **विस्तारित यूक्लिडियन एल्गोरिदम** नामक प्रक्रिया का उपयोग करना पड़ता है।

हालांकि मैं यहाँ प्रक्रिया नहीं दिखा रहा हूँ, लेकिन जब $e = 103$ होता है, तो यह प्रक्रिया 7 का मान देती है। आप नीचे दिए गए गणनाओं के माध्यम से सत्यापित कर सकते हैं कि 103 और 7 की जोड़ी वास्तव में सामान्य शर्त $e \cdot d \mod \phi(n) = 1$ को पूरा करती है।


- $103 \cdot 7 \mod 360 = 721 \mod 360 = 1 \mod 360$

इस गणना का मतलब है कि जब आप 103 को 7 से गुणा करते हैं, तो आपको 721 मिलता है। फिर, 721 को 360 से भाग देने पर शेषफल 1 आता है। इसलिए, $103 \cdot 7$ का 360 से मॉड्यूलो 1 है।

महत्वपूर्ण बात यह है कि *प्रस्ताव 4* के अनुसार, हमें पता है कि 1 से 360 के बीच कोई और पूर्णांक $d$ के लिए ऐसा परिणाम नहीं देगा कि $103 \cdot d = 1 \mod 360$ हो। इसके अलावा, यह प्रस्ताव यह भी बताता है कि अगर हम $e$ के लिए कोई अलग मान चुनते हैं, तो $d$ के लिए एक अलग और अद्वितीय मान प्राप्त होगा।

RSA समस्या के चरण 5 में, हमें 403 का एक छोटा सह-अपरिमेय धनात्मक पूर्णांक $y$ चुनना होता है। मान लीजिए कि हमने $y = 2^{103}$ चुना। 2 को 103 से घातांकित करने पर नीचे दिया गया परिणाम प्राप्त होता है।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। 

$2^{103} \mod 403 = 10,141,204,801,825,835,211,973,625,643,008 \mod 403 = 349 \mod 403$

इसका मतलब है कि जब $2^{103}$ को 403 से विभाजित किया जाता है, तो शेषफल 349 होता है।

इस विशेष उदाहरण में RSA समस्या इस प्रकार है: आपको $N = 403$, $e = 103$, और $y = 349 \mod 403$ दिए गए हैं। अब आपको $x$ की गणना करनी है ताकि $x^{103} = 349 \mod 403$ हो। मतलब, आपको यह पता लगाना है कि 103 से घातांकित करने से पहले मूल मान 2 था।

अगर हमें पता होता कि $d = 7$, तो $x$ की गणना करना (कम से कम एक कंप्यूटर के लिए) आसान होता। उस स्थिति में, आप नीचे दिए गए तरीके से $x$ को निर्धारित कर सकते थे।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। 

यहाँ गणना की गई है कि $x = y^7 \mod 403 = 349^7 \mod 403$ का मान क्या होगा। जब 349 को 7 बार खुद से गुणा किया जाता है, तो हमें एक बहुत बड़ा संख्या $630,634,881,591,804,949$ मिलता है। इस संख्या को 403 से भाग देने पर शेषफल 2 आता है। इसलिए, $x = 2 \mod 403$ है।

समस्या यह है कि आपको यह जानकारी नहीं दी गई है कि $d = 7$ है। आप, निश्चित रूप से, $d$ की गणना इस तथ्य से कर सकते हैं कि $103 \cdot d = 1 \mod 360$। समस्या यह है कि आपको यह जानकारी भी नहीं दी गई है कि $N = 360$ का क्रम क्या है। अंत में, आप 403 के क्रम की गणना इस उत्पाद की गणना करके कर सकते हैं: $(p - 1) \cdot (q - 1)$। लेकिन आपको यह भी नहीं बताया गया है कि $p = 13$ और $q = 31$ हैं।

बिल्कुल, इस उदाहरण में एक कंप्यूटर RSA समस्या को आसानी से हल कर सकता है, क्योंकि इसमें शामिल अभाज्य संख्याएँ बहुत बड़ी नहीं हैं। लेकिन जब ये अभाज्य संख्याएँ बहुत बड़ी हो जाती हैं, तो कंप्यूटर के लिए इसे हल करना लगभग असंभव हो जाता है।

हमने अब RSA समस्या, Hard के अंतर्गत स्थितियों का सेट, और इसके पीछे की गणितीय अवधारणाएँ प्रस्तुत की हैं। यह सब असममित क्रिप्टोग्राफी में कैसे मदद करता है? विशेष रूप से, हम कैसे RSA समस्या की कठिनाई को कुछ विशेष स्थितियों में एक एन्क्रिप्शन योजना या एक डिजिटल हस्ताक्षर योजना में बदल सकते हैं?

एक तरीका यह है कि आप RSA समस्या को लें और योजनाओं को सीधे तरीके से बनाएं। उदाहरण के लिए, मान लीजिए कि आपने RSA समस्या में वर्णित अनुसार एक सेट $\Pi$ उत्पन्न किया है, और सुनिश्चित किया है कि $p$ और $q$ पर्याप्त बड़े हैं। आप अपनी सार्वजनिक कुंजी को $(N, e)$ के बराबर सेट करते हैं और इस जानकारी को दुनिया के साथ साझा करते हैं। जैसा कि ऊपर वर्णित है, आप $p$, $q$, $\phi(n)$, और $d$ के मानों को गुप्त रखते हैं। वास्तव में, $d$ आपकी निजी कुंजी है।

कोई भी व्यक्ति जो आपको एक संदेश $m$ भेजना चाहता है, जो $C_N$ का एक तत्व है, उसे बस इस तरह से एन्क्रिप्ट कर सकता है: $c = m^e \mod N$. (यहां पर एन्क्रिप्टेड संदेश $c$ RSA समस्या में $y$ के बराबर है।) आप इस संदेश को आसानी से डिक्रिप्ट कर सकते हैं बस $c^d \mod N$ की गणना करके।

आप इसी तरीके से एक डिजिटल हस्ताक्षर योजना बनाने की कोशिश कर सकते हैं। मान लीजिए कि आप किसी को एक संदेश $m$ डिजिटल हस्ताक्षर $S$ के साथ भेजना चाहते हैं। आप बस $S = m^d \mod N$ सेट कर सकते हैं और जोड़ी $(m,S)$ प्राप्तकर्ता को भेज सकते हैं। कोई भी व्यक्ति डिजिटल हस्ताक्षर को सत्यापित कर सकता है बस यह जांच कर कि क्या $S^e \mod N = m \mod N$ है। हालांकि, किसी भी हमलावर के लिए एक वैध $S$ बनाना बहुत मुश्किल होगा, क्योंकि उनके पास $d$ नहीं है।

दुर्भाग्यवश, जो अपने आप में एक Hard समस्या है, RSA समस्या को एक क्रिप्टोग्राफिक योजना में बदलना इतना सीधा नहीं है। सीधे एन्क्रिप्शन योजना के लिए, आप केवल $N$ के सह-प्राइम्स को अपने संदेश के रूप में चुन सकते हैं। इससे हमारे पास बहुत अधिक संभावित संदेश नहीं बचते, निश्चित रूप से मानक संचार के लिए पर्याप्त नहीं। इसके अलावा, इन संदेशों को यादृच्छिक रूप से चुना जाना चाहिए। यह कुछ हद तक अव्यवहारिक लगता है। अंत में, कोई भी संदेश जो दो बार चुना जाता है, वही सटीक सिफरटेक्स्ट देगा। यह किसी भी एन्क्रिप्शन योजना में अत्यधिक अवांछनीय है और एन्क्रिप्शन में किसी भी कठोर आधुनिक मानक सुरक्षा धारणा को पूरा नहीं करता।

हमारी सरल डिजिटल हस्ताक्षर योजना के लिए समस्याएँ और भी गंभीर हो जाती हैं। वर्तमान स्थिति में, कोई भी हमलावर आसानी से डिजिटल हस्ताक्षर बना सकता है। वह पहले $N$ का एक सह-प्राइम चुनकर उसे हस्ताक्षर के रूप में ले सकता है और फिर उसके अनुसार मूल संदेश की गणना कर सकता है। यह स्पष्ट रूप से अस्तित्वगत अप्रमाणिकता की आवश्यकता को तोड़ता है।

फिर भी, थोड़ी सी समझदारी भरी जटिलता जोड़कर, RSA समस्या का उपयोग एक सुरक्षित सार्वजनिक कुंजी एन्क्रिप्शन योजना और एक सुरक्षित डिजिटल हस्ताक्षर योजना बनाने के लिए किया जा सकता है। हम यहां इन संरचनाओं के विवरण में नहीं जाएंगे। लेकिन महत्वपूर्ण बात यह है कि यह अतिरिक्त जटिलता उन योजनाओं के आधारभूत RSA समस्या को नहीं बदलती है।

**नोट्स:**

देखिए, उदाहरण के लिए, जोनाथन कैट्ज़ और यहूदा लिंडेल की किताब _इंट्रोडक्शन टू मॉडर्न क्रिप्टोग्राफी_, जो सीआरसी प्रेस (बोका रैटन, फ्लोरिडा: 2015) द्वारा प्रकाशित है। इसमें पृष्ठ 410-32 पर आरएसए एन्क्रिप्शन और पृष्ठ 444-41 पर आरएसए डिजिटल हस्ताक्षरों के बारे में जानकारी दी गई है।

# निष्कर्ष

<partId>e538fb79-bf28-40cd-a5c3-badf864d8567</partId>

## समीक्षाएँ और रेटिंग्स

<chapterId>366d6fd0-ceb2-4299-bf37-8c6dfcb681d5</chapterId>

<isCourseReview>true</isCourseReview>
## अंतिम परीक्षा

<chapterId>44882d2b-63cd-4fde-8485-f76f14d8b2fe</chapterId>

<isCourseExam>true</isCourseExam>
## निष्कर्ष

<chapterId>f1905f78-8cf7-5031-949a-dfa8b76079b4</chapterId>

<isCourseConclusion>true</isCourseConclusion>