---
name: Elements और Liquid Network के साथ निर्माण करना
goal: Elements ओपन-सोर्स Blockchain प्लेटफॉर्म का उपयोग करना और उसके मुख्य फीचर्स के साथ विकास करना सीखें।
objectives: 

  - Elements Blockchain प्लेटफॉर्म और Liquid साइडचेन के मूलभूत सिद्धांतों को समझें।
  - Elements नोड्स को स्टैंडअलोन और Sidechain कॉन्फ़िगरेशन के लिए सेट अप और चलाना सीखें।
  - फेडरेटेड block signing और Federated 2-Way Peg के साथ व्यावहारिक अनुभव प्राप्त करें।
  - वास्तविक जीवन के उपयोग के मामलों के लिए सुरक्षित और कुशल Blockchain वातावरण स्थापित और प्रबंधित करें।

---
# Liquid और Elements पर आगे बढ़ें।

Liquid और Elements की उन्नत विशेषताओं और क्षमताओं की खोज करें, और जानें कि इन उपकरणों का प्रभावी ढंग से उपयोग कैसे करें ताकि आपके विकास परियोजनाओं को बेहतर बनाया जा सके। यह प्रशिक्षण आपको एक संपूर्ण सैद्धांतिक और व्यावहारिक आधार प्रदान करता है, जिससे आप Confidential Transactions, Issued Assets, और Federated block signing जैसी विशेषताओं में महारत हासिल कर सकते हैं।

Elements के ढांचे पर आधारित Liquid को वित्तीय और तकनीकी समाधानों के लिए गोपनीयता, विस्तार क्षमता और कार्यक्षमता को बेहतर बनाने के लिए डिज़ाइन किया गया है। इस कोर्स में, आप संपत्ति जारी करने और प्रबंधन, Federated 2-Way Peg, और elementsd और elements-cli जैसे उपकरणों के उपयोग का व्यावहारिक अनुभव प्राप्त करेंगे, जिससे आप अपनी आवश्यकताओं के अनुसार नवाचारी समाधान बना सकें।

यह कोर्स सभी अनुभव स्तरों के डेवलपर्स के लिए बनाया गया है। शुरुआती और मध्यम स्तर के उपयोगकर्ताओं को सरल व्याख्याएँ और व्यावहारिक उदाहरण मिलेंगे, जबकि उन्नत उपयोगकर्ता Liquid और Elements की तकनीकी जानकारियों और कम ज्ञात विशेषताओं में गहराई से जा सकते हैं।

हमारे साथ जुड़ें और अपनी क्षमताओं को बढ़ाएं, Liquid और Elements की पूरी क्षमता को खोलें, और Liquid इनोवेशन के भविष्य के लिए प्रभावशाली उपकरण बनाएं।

+++
# परिचय

<partId>8f34de87-6e9a-4e3b-a326-50fc7c1803b3</partId>

## कोर्स का परिचय

<chapterId>a721398e-7040-4edd-be53-b485ea759fa9</chapterId>

![Video](https://youtu.be/gkQfnwYLyI0?si=H6cIPhgZaSAwHaHI)

Elements अकादमी का उद्देश्य Elements के मुख्य अवधारणाओं को समझाना और परिचय देना है, जो कि एक ओपन-सोर्स प्लेटफॉर्म है और जिस पर Liquid आधारित है। इस कोर्स के अंत तक, आपको Elements के मुख्य विशेषताओं जैसे Confidential Transactions और Issued Assets की अच्छी समझ होनी चाहिए, और Elements कोर को चलाने में शामिल प्रक्रियाओं की जानकारी होनी चाहिए।

प्रत्येक अनुभाग में व्याख्यात्मक पाठ और एक वीडियो के साथ पाठ होंगे, जो एक क्विज़ के साथ समाप्त होंगे। प्रश्नों की संख्या पिछले विषय के आकार के अनुसार होगी। अनुभाग 10 में पाठ्यक्रम की सामग्री का सारांश होगा और यह एक बड़े क्विज़ के साथ समाप्त होगा।

किसी भी सवाल, अतिरिक्त जानकारी की आवश्यकता या क्विज़ के उत्तरों पर कोई शंका हो तो आप अपने शिक्षक जेम्स डॉर्फ़मैन से संपर्क कर सकते हैं।

## Elements का अवलोकन

<chapterId>7a7f2712-5300-4a6d-b1ed-05eab731bc35</chapterId>

![Video](https://youtu.be/ns-JLGdkNig?si=fmWye_boRSvVF1Bt)

Elements एक ओपन सोर्स प्लेटफॉर्म है, जो Sidechain के साथ संगत है और Blockchain पर आधारित है। यह समुदाय के सदस्यों द्वारा विकसित की गई शक्तिशाली विशेषताओं जैसे Confidential Transactions और Issued Assets तक पहुंच प्रदान करता है।

Elements मूल रूप से एक प्रोटोकॉल है जो यह सुनिश्चित करता है कि लेन-देन के इतिहास और उन नियमों पर सहमति बने जो Blockchain Ledger में संग्रहीत संपत्तियों के हस्तांतरण और निर्माण को नियंत्रित करते हैं।

Elements के बारे में अधिक जानकारी आसानी से Elements प्रोजेक्ट की वेबसाइट (https://elementsproject.org/), आधिकारिक Liquid ब्लॉग (https://blog.Liquid.net/), और डेवलपर पोर्टल (https://Liquid.net/devs) पर पाई जा सकती है।

### मुझे खेद है, लेकिन "Elements" से आपका क्या मतलब है, यह स्पष्ट नहीं है। कृपया अधिक जानकारी दें ताकि मैं आपकी मदद कर सकूं।

2015 में लॉन्च किया गया Elements आंतरिक विकास और अनुसंधान लागत को कम करता है और नवीनतम Blockchain तकनीक का उपयोग करता है, जिससे कई नए उपयोग मामलों के लिए रास्ते खुलते हैं। Elements आधारित Blockchain या तो एक स्वतंत्र Blockchain के रूप में काम कर सकता है या इसे किसी अन्य से जोड़ा जा सकता है और Sidechain के रूप में चलाया जा सकता है। Elements को Sidechain के रूप में चलाने से विभिन्न ब्लॉकचेन के बीच संपत्तियों का सत्यापित रूप से स्थानांतरण संभव हो जाता है।

Bitcoin के कोडबेस पर आधारित और उसका विस्तार करते हुए, यह डेवलपर्स को bitcoind API से परिचित कराता है ताकि वे जल्दी और कम खर्च में काम करने वाले ब्लॉकचेन बना सकें और प्रूफ-ऑफ-कॉन्सेप्ट प्रोजेक्ट्स का परीक्षण कर सकें। Bitcoin के कोडबेस पर आधारित होने के कारण, Elements खुद Bitcoin प्रोटोकॉल में बदलावों के लिए एक परीक्षण मंच के रूप में भी काम कर सकता है।

Elements की कुछ मुख्य विशेषताएँ निम्नलिखित हैं।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

डिफ़ॉल्ट रूप से, Elements में सभी पते blinded होते हैं जो Confidential Transactions का उपयोग करते हैं। ब्लाइंडिंग एक प्रक्रिया है जिसके द्वारा स्थानांतरित की जा रही संपत्ति की मात्रा और प्रकार को क्रिप्टोग्राफिक तरीके से सभी से छुपाया जाता है, सिवाय उन प्रतिभागियों के और जिनको वे ब्लाइंडिंग कुंजी दिखाने का निर्णय लेते हैं।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Issued Assets पर Elements कई प्रकार की संपत्तियों को जारी करने और नेटवर्क के प्रतिभागियों के बीच स्थानांतरित करने की अनुमति देता है। एक जारी की गई संपत्ति को Confidential Transactions का भी लाभ मिलता है और इसे कोई भी व्यक्ति, जिसके पास संबंधित reissuance token है, फिर से जारी कर सकता है या नष्ट कर सकता है।

#### Federated 2-Way Peg एक उपकरण या मॉडल का नाम हो सकता है, लेकिन आपके सवाल में इसके बारे में कोई विशेष जानकारी नहीं दी गई है। अगर आप इसके बारे में अधिक जानकारी चाहते हैं, तो कृपया थोड़ा और विवरण प्रदान करें ताकि मैं आपकी मदद कर सकूं।

Elements एक सामान्य उपयोग के लिए Blockchain प्लेटफॉर्म है, जिसे किसी मौजूदा Blockchain (जैसे Bitcoin) से "जोड़" कर सकते हैं ताकि एक चेन से दूसरी चेन में संपत्तियों का दो-तरफा हस्तांतरण संभव हो सके। Elements को Sidechain के रूप में लागू करने से आप मुख्य चेन की कुछ अंतर्निहित विशेषताओं से बच सकते हैं, जबकि मुख्य चेन पर सुरक्षित संपत्तियों द्वारा प्रदान की गई सुरक्षा का एक अच्छा स्तर बनाए रख सकते हैं।

#### साइन किए गए ब्लॉक्स

Elements एक Strong Federation का उपयोग करता है, जिसे Block Signers कहा जाता है, जो भरोसेमंद और समय पर ब्लॉक्स को साइन और क्रिएट करते हैं। यह PoW Mining प्रक्रिया की ट्रांजैक्शन लेटेंसी को हटा देता है, जो कि इसके रैंडम पोइसन वितरण के कारण बड़े ब्लॉक समय परिवर्तन के अधीन होती है। फेडरेटेड block signing प्रक्रिया बिना किसी तीसरे पक्ष के विश्वास या कंप्यूटेशनल 'एल्गोरिदम' आधारित Mining की आवश्यकता के, भरोसेमंद ब्लॉक निर्माण को प्राप्त करती है।

Elements, Bitcoin के मुख्य कोडबेस पर सभी इन विशेषताओं को जोड़ता है, जिससे mainchain प्रोटोकॉल की क्षमता बढ़ जाती है और जब इसे Sidechain के रूप में या एक स्वतंत्र Blockchain समाधान के रूप में लागू किया जाता है, तो नए व्यावसायिक उपयोग के मामले सक्षम होते हैं।

# तत्व

<partId>ac68d611-be84-432f-a3a8-620d310e131c</partId>

## Elements कैसे काम करता है

<chapterId>05d88877-58b0-455b-9ae6-a72d19070525</chapterId>

![Video](https://youtu.be/v0lzmfH81AY?si=V-xDWfmDLKyBcdPs)

Elements एक तकनीकी समाधान प्रदान करता है जो Blockchain उपयोगकर्ताओं को रोज़ाना होने वाली समस्याओं से निपटने में मदद करता है; जैसे कि लेन-देन में देरी, गोपनीयता की कमी, और विनिमय क्षमता का जोखिम।

Elements इन समस्याओं को Federated block signing और Confidential Transactions के उपयोग से हल करता है।

Bitcoin नेटवर्क के विपरीत, Elements के भीतर block signing की प्रक्रिया Dynamic Membership Multiparty Signatures (DMMS) और Proof of Work (PoW) पर निर्भर नहीं करती है। इसके बजाय, Elements एक Strong Federation का उपयोग करता है, जिसे Block Signers कहा जाता है, जो विश्वसनीय और समय पर ब्लॉक साइन और क्रिएट कर सकते हैं। यह PoW Mining प्रक्रिया की लेन-देन विलंबता को हटा देता है, जो अपने रैंडम पोइसन वितरण के कारण बड़े ब्लॉक समय परिवर्तनशीलता के अधीन होता है। संघीय block signing प्रक्रिया तीसरे पक्ष के विश्वास की आवश्यकता को बिना बढ़ाए विश्वसनीय ब्लॉक निर्माण प्राप्त करती है।

Elements को Sidechain के रूप में Blockchain जैसे कि Bitcoin के साथ चलाया जा सकता है, या फिर इसे एक स्वतंत्र Blockchain के रूप में भी चलाया जा सकता है, जिसमें अन्य नेटवर्क पर कोई निर्भरता नहीं होती।

जब Sidechain के रूप में उपयोग किया जाता है, तो Strong Federation में ऐसे सदस्य भी शामिल होते हैं जो मुख्य चेन और Elements Sidechain के बीच संपत्तियों के सुरक्षित और नियंत्रित हस्तांतरण को सक्षम बनाते हैं। संपत्तियों के इस नियंत्रित हस्तांतरण को Federated 2-Way Peg कहा जाता है और जो सदस्य इस संपत्ति हस्तांतरण की भूमिका निभाते हैं उन्हें watchmen कहा जाता है।

Elements नेटवर्क के संचालन में शामिल प्रक्रियाएँ और नेटवर्क में भाग लेने वालों की भूमिकाएँ समझना महत्वपूर्ण है ताकि यह समझा जा सके कि Elements कैसे काम करता है।

चाहे इसे Sidechain के रूप में लागू किया जाए या एक स्वतंत्र Blockchain के रूप में, Elements ब्लॉक साइनर्स के मजबूत संघों का उपयोग करके ब्लॉक बनाने का काम करता है।

### मजबूत महासंघ

Elements एक सहमति मॉडल का उपयोग करता है जिसे सबसे पहले Blockstream द्वारा प्रस्तावित किया गया था, जिसे Strong Federations कहा जाता है। Strong Federation को Proof of Work (PoW) की आवश्यकता नहीं होती है और इसके बजाय यह एक समूह के सामूहिक कार्यों पर निर्भर करता है, जिन्हें Functionaries कहा जाता है, जो एक-दूसरे पर भरोसा नहीं करते।

Strong Federation के भीतर एक Functionary जिन भूमिकाओं को पूरा कर सकता है, वे हैं: Block Signers और watchmen। अगर आप Elements को Sidechain या standalone Blockchain मोड में चलाते हैं, तो Block Signers की आवश्यकता होती है, जबकि watchmen केवल Sidechain सेटअप में ही आवश्यक होते हैं।

Strong Federation के एक सदस्य द्वारा किए जाने वाले कार्यों को दो अलग-अलग भूमिकाओं में बांटा गया है ताकि सुरक्षा को बढ़ाया जा सके और किसी हमलावर द्वारा किए जा सकने वाले नुकसान को सीमित किया जा सके।

इन प्रतिभागियों की भूमिकाओं को मिलाकर, Elements को तेज़ी से ब्लॉक निर्माण (तेज़ और अंतिम लेन-देन की पुष्टि) और सुनिश्चित, हस्तांतरणीय संपत्तियाँ (पेग्ड संपत्तियाँ जो सीधे दूसरे Blockchain से जुड़ी होती हैं) प्रदान करने की अनुमति मिलती है।

आप Strong Federations श्वेतपत्र को यहाँ पढ़ सकते हैं: https://blockstream.com/strong-federations.pdf

### ब्लॉक साइनर्स

Blockchain की तरह Bitcoin का विस्तार तब होता है जब ब्लॉक साइनर्स के एक गतिशील समूह का कोई सदस्य चेन को बढ़ाता है, यह दिखाते हुए कि Proof of Work का उपयोग किया गया है। इस सेट की गतिशील प्रकृति ऐसे सिस्टम में देरी की समस्याएँ उत्पन्न करती है।

एक निश्चित साइनर सेट का उपयोग करके, एक फेडरेटेड मॉडल गतिशील सेट को एक ज्ञात सेट, मल्टी-सिग्नेचर योजना के साथ बदल देता है। Blockchain को बढ़ाने के लिए आवश्यक प्रतिभागियों की संख्या को कम करने से सिस्टम की गति और विस्तार क्षमता बढ़ जाती है, जबकि सभी पक्षों द्वारा सत्यापन लेन-देन के इतिहास की अखंडता सुनिश्चित करता है।

फेडरेटेड block signing में कई चरण शामिल हैं:


- चरण 1 - ब्लॉक साइनर्स राउंड-रॉबिन तरीके से सभी अन्य भाग लेने वाले ब्लॉक साइनर्स को उम्मीदवार ब्लॉक प्रस्तावित करते हैं।
- चरण 2 - प्रत्येक block signer अपनी मंशा जाहिर करता है कि वह दिए गए उम्मीदवार ब्लॉक पर हस्ताक्षर करने के लिए पहले से प्रतिबद्ध है।
- चरण 3 - यदि प्री-Commitment के लिए दिया गया सीमा मान पूरा होता है, तो प्रत्येक block signer ब्लॉक पर हस्ताक्षर करता है।
- चरण 4 - यदि हस्ताक्षर सीमा (जो चरण 3 से अलग हो सकती है) पूरी हो जाती है, तो ब्लॉक को स्वीकार कर लिया जाता है और नेटवर्क पर भेज दिया जाता है। Strong Federation ने लेन-देन के नवीनतम ब्लॉक पर सहमति बना ली है।
- चरण 5 - इसके बाद अगला ब्लॉक अगले block signer द्वारा राउंड-रॉबिन तरीके से प्रस्तावित किया जाता है और यह प्रक्रिया फिर से शुरू हो जाती है।

Strong Federation का ब्लॉक निर्माण संभावनाओं पर आधारित नहीं होता है, बल्कि एक निश्चित समूह के साइनर्स पर निर्भर करता है। इसलिए, यह कभी भी मल्टी-ब्लॉक पुनर्गठन का शिकार नहीं होगा। इससे लेन-देन की पुष्टि के लिए लगने वाले समय में काफी कमी आती है। यह लाभ के लिए खनन करने की प्रेरणा (जैसे कि ब्लॉक रिवार्ड्स) को भी हटा देता है और इसे एक नेटवर्क में उत्पादक रूप से भाग लेने की प्रेरणा से बदल देता है, जहाँ सभी प्रतिभागियों का एक साझा लक्ष्य होता है; यह सुनिश्चित करना कि नेटवर्क सभी के लिए लाभकारी तरीके से कार्य करता रहे। यह सब एकल विफलता बिंदु या उच्च विश्वास आवश्यकताओं को पेश किए बिना करता है।

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। Elements को Sidechain - watchmen और Federated 2-Way Peg के रूप में समझें।

जब Sidechain के रूप में चलाया जाता है, तो Strong Federation के कुछ सदस्यों को एक अतिरिक्त भूमिका निभानी होती है, जो watchmen की होती है। watchmen की जिम्मेदारी होती है Elements Sidechain में संपत्तियों के हस्तांतरण की, जिसे 'Peg-In' और 'Peg-Out' प्रक्रियाएं कहा जाता है।

Sidechain को विश्वसनीय तरीके से काम करने के लिए यह जरूरी है कि यह प्रतिभागियों को यह सत्यापित करने की अनुमति दे कि Supply के अंतर्गत आने वाली संपत्तियाँ नियंत्रित और सत्यापन योग्य हैं। एक Elements Sidechain, 2-वे फेडरेटेड पेग का उपयोग करता है ताकि Elements Blockchain में और बाहर संपत्तियों का दो-तरफा स्थानांतरण संभव हो सके। यह प्रमाणित जारी करने और इंटर-चेन ट्रांसफर की आवश्यकताओं को पूरा करता है।

Federated 2-Way Peg फीचर एक संपत्ति को अन्य ब्लॉकचेन के साथ इंटरऑपरेबल बनाता है और इसे दूसरे Blockchain की मूल संपत्ति का प्रतिनिधि बनाता है। जब आप अपने Blockchain को किसी अन्य से जोड़ते हैं, तो आप mainchain की क्षमताओं को बढ़ा सकते हैं और उसकी कुछ मौलिक सीमाओं को पार कर सकते हैं।

साधारण शब्दों में, Sidechain में ट्रांसफर तब होता है जब कोई व्यक्ति mainchain की संपत्तियों को Address में भेजता है, जिसे एक मल्टी-सिग्नेचर watchmen Wallet द्वारा नियंत्रित किया जाता है। इससे mainchain पर संपत्तियाँ अस्थायी रूप से फ्रीज़ हो जाती हैं। इसके बाद, watchmen लेन-देन की पुष्टि करता है और Sidechain में संबंधित संपत्ति की समान मात्रा को जारी करता है। जारी की गई संपत्तियाँ Sidechain Wallet को भेजी जाती हैं, जो मूल mainchain संपत्तियों का दावा साबित कर सकती हैं। इस प्रक्रिया के माध्यम से संपत्तियाँ मूल चेन से Sidechain में स्थानांतरित हो जाती हैं।

mainchain पर संपत्तियों को वापस स्थानांतरित करने के लिए, एक उपयोगकर्ता Sidechain पर एक विशेष पेग-आउट लेन-देन करता है। इस लेन-देन की जांच watchmen द्वारा की जाती है, जो फिर mainchain पर उनके नियंत्रण में बहु-हस्ताक्षर Wallet से खर्च करने के लिए एक लेन-देन पर हस्ताक्षर करते हैं। संघ में एक निश्चित संख्या में प्रतिभागियों को हस्ताक्षर करना आवश्यक होता है, तभी mainchain का लेन-देन मान्य होता है। जब watchmen संपत्ति को mainchain पर वापस भेजते हैं, तो वे Sidechain पर उसी मात्रा को नष्ट भी कर देते हैं, जिससे प्रभावी रूप से संपत्तियों का ब्लॉकचेन के बीच स्थानांतरण होता है।

## Elements को सेट अप और चलाना

<chapterId>cc806e5a-81ab-457b-9531-9f863120a019</chapterId>

![Video](https://youtu.be/Frr_OjTEPAM?si=iq5XonJyQk8S5OAu)

Elements, Bitcoin कोडबेस पर आधारित है, इसलिए एक कार्यशील नेटवर्क बनाने वाले घटक बहुत हद तक समान हैं।

Elements नोड सॉफ़्टवेयर को `elementsd` कहा जाता है और यह उपयोगकर्ता की मशीन पर daemon के रूप में चलता है। daemon (या Windows में सेवा) एक प्रोग्राम है जो बैकग्राउंड सेवा के रूप में चलता है, जिसे लॉग इन किए हुए उपयोगकर्ता के सीधे नियंत्रण की आवश्यकता नहीं होती।

ध्यान दें: इस दस्तावेज़ में, हम हमेशा elementsd को daemon संस्करण के रूप में संदर्भित करेंगे, लेकिन अगर सर्वर विकल्प सक्षम है, तो सब कुछ Elements-qt के साथ भी किया जा सकता है।

Elements daemon नेटवर्क पर अन्य नोड्स से जुड़ता है ताकि वह Exchange लेन-देन और ब्लॉक डेटा को सत्यापित कर सके और नेटवर्क की अपनी स्थानीय प्रति को बढ़ा सके।

Elements सॉफ़्टवेयर में एक क्लाइंट प्रोग्राम भी शामिल है जिसे `elements-cli` कहा जाता है। यह आपको कमांड लाइन से elementsd को रिमोट प्रोसीजर कॉल (RPC) कमांड भेजने की अनुमति देता है। इसका उपयोग Wallet बैलेंस की जानकारी प्राप्त करने, लेन-देन या ब्लॉक डेटा देखने या किसी लेन-देन को प्रसारित करने के लिए किया जा सकता है। यह सेटअप उन लोगों के लिए परिचित होना चाहिए जिन्होंने Bitcoin के समकक्षों; bitcoind और bitcoin-cli का उपयोग किया है।

Elements नोड को स्टार्टअप पर पैरामीटर्स पास करके या एक कॉन्फ़िगरेशन फ़ाइल के माध्यम से कॉन्फ़िगर किया जा सकता है, जिससे एक ही मशीन पर एक से अधिक इंस्टेंस चलाना संभव होता है। यह परीक्षण और विकास के उद्देश्यों के लिए उपयोगी है क्योंकि आप एक ही मशीन पर अपनी खुद की लोकल नेटवर्क सेटअप कर सकते हैं। प्रत्येक Elements नोड के पास Blockchain डेटा की अपनी कॉपी होती है, यह अपने स्वयं के अपुष्ट वैध लेन-देन के पूल को प्रबंधित करता है और विभिन्न पोर्ट्स पर RPC अनुरोधों को सुनता है।

### Elements कोड भंडार और समुदाय

Elements एक ओपन-सोर्स प्रोजेक्ट है और इसका सोर्स कोड Elements GitHub रिपॉजिटरी में उपलब्ध है, जिसे आप https://github.com/ElementsProject/Elements पर देख सकते हैं। इस रिपॉजिटरी में elementsd और elements-cli प्रोग्राम्स का सोर्स कोड है, साथ ही इंस्टॉलेशन और बिल्ड टूल्स, टेस्ट्स का एक सेट और कुछ निर्देशात्मक दस्तावेज भी शामिल हैं।

कोड रिपॉजिटरी के साथ-साथ, https://elementsproject.org वेबसाइट भी है, जो एक समुदाय-केंद्रित संसाधन है। इसमें Elements क्या है, यह कैसे काम करता है, इसकी व्याख्या और एक व्यापक ट्यूटोरियल सेक्शन शामिल है। ट्यूटोरियल में कमांड लाइन उदाहरणों के माध्यम से Elements के बारे में सीखने पर ध्यान केंद्रित किया गया है और यह दिखाता है कि इसके ऊपर सरल डेस्कटॉप और वेब एप्लिकेशन कैसे बनाए जा सकते हैं। साइट पर लोकप्रिय Elements समुदाय चर्चा मंचों की सूची भी है और यह स्वयं GitHub पर होस्ट की गई है, जिससे समुदाय के लोग साइट की सामग्री में योगदान कर सकते हैं।

Elements को अपने कंप्यूटर पर चलाने के लिए, सबसे पहले आपको इसका सोर्स कोड क्लोन (डाउनलोड) करना होगा। इसके बाद, कोड की सभी आवश्यकताओं को इंस्टॉल करना होगा और अंत में daemon और क्लाइंट एक्सीक्यूटेबल्स को बनाना होगा। इसके बाद, Elements सॉफ़्टवेयर को कॉन्फ़िगर और चलाने के लिए तैयार है।

## नोड्स और नेटवर्किंग को कॉन्फ़िगर करना

<chapterId>df1ec0aa-84ea-4149-af7a-b4523d67e1d9</chapterId>

Elements नोड को स्टार्टअप पर कॉन्फ़िगरेशन सेटिंग्स दी जा सकती हैं ताकि यह तय किया जा सके कि वह कैसे काम करेगा, डेटा को कैसे सत्यापित करेगा, अन्य नोड्स से कैसे जुड़ेगा और अपने Blockchain डेटा को कैसे प्रारंभ करेगा।

सेटिंग्स या तो निर्धारित `Elements.conf` फाइल से लोड की जाती हैं या फिर कमांड लाइन के माध्यम से पैरामीटर के रूप में पास की जाती हैं।

इन पैरामीटर्स का उपयोग करके कुछ चीजों को बदला जा सकता है:


- default asset का नाम एकल Blockchain कार्यान्वयन में उपयोग किया जाता है।
- शुरुआती संपत्ति की संख्या बनाई गई।
- नेटवर्क पर लेन-देन शुल्क का भुगतान करते समय उपयोग की जाने वाली संपत्ति।
- Blockchain डेटा फाइलों का भंडारण स्थान।
- RPC प्रमाण-पत्रों का उपयोग Bitcoin नोड से जुड़ने के लिए किया गया।
- `n of m` थ्रेशोल्ड का मतलब है कि कुल m में से n सार्वजनिक कुंजियाँ (public keys) होनी चाहिए जो ब्लॉक्स पर हस्ताक्षर कर सकें। यह एक सुरक्षा उपाय है जो सुनिश्चित करता है कि केवल अधिकृत कुंजियाँ ही ब्लॉक्स पर हस्ताक्षर कर सकती हैं।
- Sidechain में संपत्तियों को अंदर-बाहर करने के लिए जिस स्क्रिप्ट की जरूरत होती है, उसे पूरा करना होता है।
- आपको यह तय करना है कि Bitcoin नोड से Sidechain के रूप में कनेक्ट करना है या नहीं।

इनमें से कई नेटवर्क के सहमति नियमों का हिस्सा होते हैं, इसलिए यह महत्वपूर्ण है कि इन्हें सभी नोड्स पर स्टार्टअप के समय लागू किया जाए। कुछ को चेन के शुरू होने के बाद बदला जा सकता है, लेकिन कुछ को चेन को शुरू करने के बाद स्थिर रखना पड़ता है।

पैरामीटर्स का उपयोग इस कोर्स में बाद में कवर किया जाएगा, जब-जब वे प्रत्येक सेक्शन से संबंधित होंगे।

### कमांड लाइन का उपयोग करके बुनियादी संचालन

इस कोर्स में आपको `elements-cli` प्रोग्राम का उपयोग करके एक या अधिक Elements नोड्स पर RPC कॉल करने के उदाहरण दिखाए जाएंगे। यह एक टर्मिनल सत्र से किया जाता है और कमांड्स को संक्षिप्त बनाने के लिए एक `उपनाम` का उपयोग किया जाएगा। इस नियम के अनुसार, जब आप निम्नलिखित कमांड्स जैसा कुछ देखेंगे:

```bash
e1-dae
e1-cli getnewaddress
```

`e1-dae` और `e1-CLI` वास्तव में टर्मिनल के `alias` फीचर का उपयोग करके एक टाइपोग्राफिक शॉर्टकट हैं। जब कमांड चलाया जाता है, तो `e1-dae` और `e1-CLI` वास्तव में बदल दिए जाएंगे और जो कमांड चलेगा वह कुछ इस तरह होगा:

```
$HOME/elements/src/elementsd -datadir=$HOME/elementsdir1
$HOME/elements/src/elements-cli -datadir=$HOME/elementsdir1 getnewaddress
```

ऊपर जो हम देख रहे हैं, वह Elements और daemon को शुरू करने के लिए एक कॉल है और elements-cli प्रोग्राम को `$HOME/Elements/src` डायरेक्टरी में स्थित करने के लिए एक कॉल है, साथ ही `datadir` पैरामीटर के लिए एक मान है। `datadir` पैरामीटर हमें यह बताने की अनुमति देता है कि daemon और क्लाइंट इंस्टेंस अपने कॉन्फ़िग फाइल्स को कहां ढूंढें और daemon के मामले में, Blockchain की अपनी कॉपी कहां स्टोर करें। चूंकि वे एक कॉन्फ़िग फाइल साझा करते हैं, क्लाइंट daemon को RPC कॉल्स करने में सक्षम होगा।

ऊपर दिए गए कमांड को फिर से चलाकर, लेकिन इस बार अलग `datadir` मान के साथ, हम Elements के एक से अधिक इंस्टेंस शुरू कर सकते हैं, जिनमें से प्रत्येक का अपना अलग Blockchain और कॉन्फ़िग सेटिंग्स की कॉपी होगी। इस तरीके से हम कोर्स में `e2-dae` और `e2-CLI` उपनाम का उपयोग करेंगे ताकि e1 के अलावा एक अलग datadir डायरेक्टरी को संदर्भित किया जा सके। तो हमारे दूसरे `e2` इंस्टेंस के लिए ऊपर दिया गया उदाहरण होगा:

```
$HOME/elements/src/elementsd -datadir=$HOME/elementsdir2
$HOME/elements/src/elements-cli -datadir=$HOME/elementsdir2 getnewaddress
```

यह हमें विभिन्न प्रकार के कार्य करने की अनुमति देगा, जैसे कि नोड्स के बीच संपत्तियों का लेन-देन करना, संपत्तियों को जारी करना और एक ही नेटवर्क पर विभिन्न नोड्स के बीच Confidential Transactions में ब्लाइंडिंग के उपयोग की जांच करना।

# एलीमेंट का व्यावहारिक उपयोग कैसे करें

एलीमेंट का उपयोग कई तरीकों से किया जा सकता है, जैसे:

1. **वेब डेवलपमेंट में**: एलीमेंट्स का उपयोग HTML और CSS में वेब पेज बनाने के लिए किया जाता है। उदाहरण के लिए, `<div>`, `<p>`, और `<a>` जैसे एलीमेंट्स का उपयोग पेज की संरचना और स्टाइलिंग के लिए किया जाता है।

2. **रासायनिक प्रयोगशालाओं में**: रासायनिक एलीमेंट्स का उपयोग विभिन्न रासायनिक प्रतिक्रियाओं और प्रयोगों में किया जाता है। जैसे, हाइड्रोजन और ऑक्सीजन का उपयोग पानी बनाने के लिए किया जाता है।

3. **डिजाइन में**: ग्राफिक डिजाइन में, एलीमेंट्स का उपयोग विभिन्न डिज़ाइन तत्वों जैसे कि रंग, आकार, और टेक्स्ट को व्यवस्थित करने के लिए किया जाता है।

4. **सॉफ्टवेयर डेवलपमेंट में**: कोडिंग में, एलीमेंट्स का उपयोग डेटा स्ट्रक्चर और एल्गोरिदम को व्यवस्थित करने के लिए किया जाता है।

इन सभी क्षेत्रों में, एलीमेंट्स का सही उपयोग करने से कार्य को अधिक प्रभावी और कुशल बनाया जा सकता है।

<partId>3f31a30a-957a-4813-b5fe-5dccbb5366f3</partId>

## आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

<chapterId>263b1c5b-59ed-49e7-b811-95c354f41eae</chapterId>

![Video](https://youtu.be/-by2xBtXQeE?si=7bLo_geGn3qh7MXN)

इस भाग में आप सीखेंगे कि Elements के Confidential Transactions फीचर का उपयोग कैसे करें।

Elements में सभी पते, डिफ़ॉल्ट रूप से, blinded का उपयोग करते हैं जो Confidential Transactions के माध्यम से काम करता है। यह व्यवस्था सुनिश्चित करती है कि लेन-देन में शामिल प्रतिभागियों के अलावा किसी और को स्थानांतरित की गई संपत्तियों की मात्रा और प्रकार दिखाई न दे। हालांकि, यह क्रिप्टोग्राफिक रूप से यह भी गारंटी देता है कि जितने सिक्के उपलब्ध हैं, उससे अधिक खर्च नहीं किए जा सकते। प्रतिभागी चाहें तो ब्लाइंडिंग कुंजी को दूसरों के साथ साझा कर सकते हैं।

### गोपनीय पते और Confidential Transactions

डिफ़ॉल्ट रूप से, जब आप `getnewaddress` कमांड का उपयोग करके Elements में एक नया Address बनाते हैं, तो यह एक गोपनीय Address के रूप में बनाया जाता है।

Confidential Transactions को दिखाने के लिए हम e2 को खुद को कुछ फंड भेजने देंगे और फिर e1 से उस लेन-देन को देखने की कोशिश करेंगे। इससे Elements में लेन-देन की गोपनीय प्रकृति का प्रदर्शन होगा।

हर नया Address जो Elements नोड द्वारा उत्पन्न होता है, वह स्वाभाविक रूप से गोपनीय होता है। हम इसे इस तरह से दिखा सकते हैं कि e2 को एक नया Address generate पर भेजकर।

```
e2-cli getnewaddress
```

ध्यान दें कि Address की शुरुआत e1 से होती है। यह इसे एक गोपनीय Address के रूप में पहचानता है। Address की अधिक जानकारी प्राप्त करने के लिए getaddressinfo कमांड का उपयोग करके इसे और विस्तार से देखा जा सकता है।

```
e2-cli getaddressinfo <address>
```

आप देख सकते हैं कि वहाँ एक confidential_key प्रॉपर्टी है जो हमें बताती है कि यह एक गोपनीय Address है।

गोपनीय कुंजी एक सार्वजनिक ब्लाइंडिंग कुंजी है, जिसे गोपनीय Address में जोड़ा जाता है। यही कारण है कि गोपनीय Address इतना लंबा होता है।

इसके साथ एक असंबद्ध गैर-गोपनीय Address भी है। यदि आप Elements के भीतर सामान्य, गैर-गोपनीय लेन-देन का उपयोग करना चाहते हैं, तो संपत्तियों को lq1 उपसर्ग वाले के बजाय इस Address पर भेजा जाना चाहिए।

अब हम e2 को कुछ धनराशि Address को भेजने के लिए कह सकते हैं, जिसे उसने उत्पन्न किया था। इससे बाद में यह दिखाया जाएगा कि e1, जो लेन-देन करने वाले पक्षों में से एक नहीं है, लेन-देन के विवरण को नहीं देख पाएगा।

```
e2-cli sendtoaddress <address>
```

transaction ID को नोट करें। लेन-देन की पुष्टि करें।

```
e2-cli -generate 101
```

e2 ने खुद को कुछ फंड भेजे, इस लेन-देन को e2 के नजरिए से देखना।

```
e2-cli gettransaction <txid>
```

लेन-देन की जानकारी ऊपर स्क्रॉल करते हुए, आप देख सकते हैं कि e2 भेजी और प्राप्त की गई राशि के साथ-साथ लेन-देन की गई संपत्ति को भी देख सकता है। आप amountblinder और assetblinder गुण भी देख सकते हैं, जो लेन-देन में शामिल नहीं अन्य नोड्स से विवरण छिपाने के लिए उपयोग किए जाते हैं।

e1 से उसी लेन-देन का विवरण जांचने के लिए, सबसे पहले हमें कच्चे लेन-देन का विवरण प्राप्त करना होगा।

```
e1-cli getrawtransaction <txid>
```

यह कच्चे लेन-देन के विवरण को लौटाता है। अगर आप vout सेक्शन में देखें, तो आपको तीन उदाहरण दिखाई देंगे। पहले दो उदाहरण प्राप्ति और परिवर्तन राशि हैं, और तीसरा लेन-देन शुल्क है। इन तीनों राशियों में से, शुल्क ही एकमात्र है जिसमें आप एक मूल्य देख सकते हैं, क्योंकि शुल्क हमेशा Elements के भीतर unblinded होता है।

### अंधेरे में चाबी ढूंढना

पहले दो वाउट सेक्शन "blinded रेंज" दिखाते हैं, जो मूल्य की मात्रा को दर्शाते हैं, और Commitment डेटा जो वास्तविक राशि और लेन-देन की गई संपत्ति के प्रकार का प्रमाण होता है।

भले ही हम e2 की प्राइवेट की को e1 के Wallet में इम्पोर्ट कर लें, फिर भी वह लेन-देन की राशि और संपत्ति के प्रकार को नहीं देख पाएगा क्योंकि उसे e2 द्वारा उपयोग की गई ब्लाइंडिंग की की जानकारी नहीं है। हम इसे साबित करेंगे e2 के Wallet की प्राइवेट की को e1 में इम्पोर्ट करके। सबसे पहले हमें e2 से की को एक्सपोर्ट करना होगा।

```
e2-cli dumpprivkey <address>
```

फिर इसे e1 में आयात करें।

```
e1-cli importprivkey <privkey>
```

अब हम यह साबित कर सकते हैं कि e1 अभी भी उन मूल्यों को नहीं देख सकता है।

```
e1-cli gettransaction <txid>
```

वास्तव में, यह tx राशि को 0 दिखा रहा है जबकि वास्तव में यह 1 थी।

वास्तविक, बिना छुपाए गए मूल्य को देखने के लिए हमें ब्लाइंडिंग कुंजी की आवश्यकता होती है। ऐसा करने के लिए, हम पहले e2 से ब्लाइंडिंग कुंजी को निर्यात करते हैं।

```
e2-cli dumpblindingkey <address>
```

फिर इसे e1 में आयात करें।

```
e1-cli importblindingkey <address> <blinding key>
```

अब जब हमें e1 से लेन-देन का विवरण मिलता है।

```
e1-cli gettransaction <txid>
```

यह दिखाता है कि ब्लाइंडिंग की इम्पोर्ट करने के बाद, अब हम लेन-देन के भीतर 1 का वास्तविक मूल्य देख सकते हैं।

इस खंड में हमने देखा कि ब्लाइंडिंग कुंजी का उपयोग लेन-देन में राशि और संपत्तियों के प्रकार को छिपाने के लिए किया जाता है, और सही ब्लाइंडिंग कुंजी आयात करके, हम उन मूल्यों को प्रकट कर सकते हैं। व्यावहारिक उपयोग में, एक ब्लाइंडिंग कुंजी, उदाहरण के लिए, एक ऑडिटर को दी जा सकती है, यदि किसी पार्टी द्वारा रखी गई संपत्तियों की मात्रा और प्रकार को सत्यापित करने की आवश्यकता हो। Confidential Transactions की विशेषता Elements में "रेंज प्रूफ्स" करने की अनुमति भी देती है। रेंज प्रूफ्स यह साबित कर सकते हैं कि किसी संपत्ति की मात्रा एक निश्चित सीमा के भीतर है, बिना वास्तविक मात्रा को उजागर किए।

हमने यह भी देखा है कि Confidential Transactions वैकल्पिक हैं, लेकिन जब एक नया Address बनाया जाता है, तो वे डिफ़ॉल्ट रूप से सक्षम होते हैं।

इस पाठ के लिए बस इतना ही; क्विज़ के लिए शुभकामनाएँ और अगले पाठ में मिलते हैं!

## मुझे खेद है, लेकिन "Issued Assets" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया अधिक जानकारी या संदर्भ प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

<chapterId>c33c7020-5975-457a-99db-4f8b90d1fa1c</chapterId>

![Video](https://youtu.be/XnY4WZUNSs4?si=dG8I5OoSh_0EBdvL)

इस भाग में आप सीखेंगे कि Elements के Issued Assets फीचर का उपयोग कैसे करें।

Issued Assets कई प्रकार की संपत्तियों को जारी करने और Elements नेटवर्क के प्रतिभागियों के बीच स्थानांतरित करने की अनुमति देता है। नेटवर्क पर कोई भी नोड अपनी खुद की संपत्तियाँ जारी कर सकता है। जारी की गई संपत्तियाँ किसी भी संपत्ति के फंगिबल Ownership का प्रतिनिधित्व कर सकती हैं, जिसमें वाउचर, कूपन, मुद्राएँ, जमा, बांड, शेयर आदि शामिल हैं। Issued Assets Trustless एक्सचेंज, विकल्प और अन्य उन्नत स्मार्ट कॉन्ट्रैक्ट्स बनाने के लिए दरवाजे खोलता है, जिसमें स्व- Issued Assets शामिल है।

एक जारी की गई संपत्ति को Confidential Transactions का लाभ मिलता है और इसे किसी भी व्यक्ति द्वारा फिर से जारी किया जा सकता है जो संबंधित टोकन को धारण करता है।

पहला कदम यह है कि हमें दो Elements नोड्स की आवश्यकता होगी, जिन्हें हम e1 और e2 कहेंगे। इन नोड्स की ब्लॉकचेन को रीसेट कर दिया गया है और default asset को इनके बीच विभाजित कर दिया गया है।

दोनों नोड्स एक ही लोकल नेटवर्क पर हैं और एक-दूसरे से जुड़े हुए हैं, इसलिए वे अपने लेन-देन Mempool और समान ब्लॉकचेन साझा करते हैं। हालांकि वे एक ही मशीन पर चल रहे हैं, यह ध्यान देने योग्य है कि वे एक ही वास्तविक Blockchain फाइलें साझा नहीं करते हैं। प्रत्येक नोड अपनी खुद की लोकल Blockchain की कॉपी को मैनेज करता है, जिसमें वही लेन-देन इतिहास होता है क्योंकि वे सहमति में हैं और एक-दूसरे के समान प्रोटोकॉल नियमों का पालन करते हैं।

चलो शुरू करते हैं और नेटवर्क पर मौजूदा संपत्ति जारी करने की स्थिति को प्रत्येक नोड के दृष्टिकोण से जांचते हैं।

यह listissuances कमांड का उपयोग करके किया जाता है।

```
e1-cli listissuances
e2-cli listissuances
```

जैसा कि आप देख सकते हैं, दोनों नोड्स एक ही जारी इतिहास दिखा रहे हैं। दोनों एक ही एसेट को दिखाते हैं, जो 21 मिलियन Bitcoin की प्रारंभिक जारी की गई थी, जो on chain के इनिशियलाइज़ेशन के दौरान बनाई गई थी। आप ऊपर दिए गए कमांड को चलाने के परिणामों में एसेट का हेक्स आईडी देख सकते हैं और साथ ही एसेट को दिया गया लेबल, जो 'Bitcoin' है।

यह ध्यान देने योग्य है कि जब चेन को प्रारंभ किया जाता है, तो default asset को हमेशा एक लेबल दिया जाता है। जब आप अपनी खुद की संपत्तियाँ जारी करते हैं, तो आप उनके लिए खुद लेबल सेट कर सकते हैं, जो हम जल्द ही करने वाले हैं। इससे पहले कि हम ऐसा कर सकें, हमें अपनी खुद की संपत्ति जारी करनी होगी।

हम e1 को नया एसेट जारी करने के लिए कहेंगे। यह issueasset कमांड का उपयोग करके किया जाता है।

```
e1-cli issueasset 100 1 false
```

`issueasset` तीन पैरामीटर स्वीकार करता है।

हमने नए एसेट को जारी करने के लिए 100 की मात्रा का उपयोग किया है। टोकन की मात्रा, जो एसेट की मात्रा को फिर से जारी करने के लिए उपयोग की जाती है, उसमें हमने 1 चुना है। अंतिम पैरामीटर Elements को यह बताता है कि एसेट जारी करने को blinded के रूप में बनाना है या unblinded के रूप में। हम unblinded का उपयोग करेंगे क्योंकि हम एक मिनट में e2 से जारी की गई मात्रा देखना चाहते हैं, इसलिए हम 'false' दर्ज करेंगे।

इस कमांड को चलाने पर आपको जारी किए गए डेटा की जानकारी मिलती है। इसमें transaction ID शामिल है, जिसकी एक प्रति आप बाद में उपयोग के लिए ले सकते हैं, साथ ही संपत्ति का अनोखा हेक्स मूल्य और संपत्ति के टोकन का अनोखा हेक्स मूल्य भी शामिल है।

generate एक ब्लॉक है जो लेन-देन की पुष्टि करने के लिए जारी किया गया है।

```
e1-cli -generate 1
```

`listissuances` कमांड को फिर से e1 पर चलाएं।

```
e1-cli listissuances
```

यह हमें दिखाता है कि e1 अब दो जारी किए गए एसेट्स के बारे में जानता है - पहला Bitcoin का जारी किया गया एसेट और दूसरा हमारा नया जारी किया गया एसेट, जिसमें से हम 100 देख सकते हैं। नए एसेट का हेक्स वैल्यू ध्यान दें और यह भी कि इसके साथ कोई एसेट लेबल नहीं है, जैसा कि Bitcoin के जारी किए गए एसेट के साथ है।

फिर से e2 की ज्ञात जारी की गई सूची की जांच करें।

```
e2-cli listissuances
```

यह हमें दिखाता है कि e2 को उस संपत्ति के जारी होने की जानकारी नहीं है जो e1 ने की थी। यह केवल Bitcoin की प्रारंभिक जारी की गई जानकारी देख सकता है, जो वह पहले से देख सकता था।

यह इसलिए है क्योंकि e2 को इस बात की जानकारी नहीं है और वह उस Address पर नजर नहीं रख रहा है, जहां नया संपत्ति e1 द्वारा जारी किए जाने पर भेजा गया था।

यह ध्यान देने योग्य है कि भले ही e2 खुद उस एसेट के जारी होने को नहीं देख सकता, फिर भी e1 e2 को उस एसेट का कुछ हिस्सा भेज सकता है। इसके बाद नया एसेट e2 के Wallet में उपलब्ध बैलेंस के रूप में दिखाई देगा, भले ही उसे मूल जारी होने की जानकारी न हो।

e2 को वास्तविक जारी की गई राशि देखने के लिए, हमें Address को e2 में एक निगरानी किए गए Address के रूप में जोड़ना होगा।

इसके लिए हमें यह पता लगाना होगा कि वह संपत्ति किस Address को भेजी गई थी। इसके लिए, हम पहले से कॉपी किए गए transaction ID का उपयोग करेंगे और e1 से उस लेन-देन का विवरण प्राप्त करेंगे ताकि हम सही Address का पता लगा सकें और उसे e2 की Wallet वॉच लिस्ट में जोड़ सकें।

```
e1-cli gettransaction <the-issuance-transaction-id>
```

जब आप लेन-देन डेटा के हेक्स को ऊपर स्क्रॉल करेंगे, तो आप देखेंगे कि Address ने हमारे नए एसेट के 100 यूनिट प्राप्त किए हैं, जिसे उसके हेक्स वैल्यू से पहचाना गया है।

Address को ले लो और उसकी कॉपी बना लो ताकि हम उसे e2 में इम्पोर्ट कर सकें।

अब चलिए उस Address को e2 में इम्पोर्ट करते हैं। इसके लिए हम importaddress कमांड का उपयोग करेंगे।

```
e2-cli importaddress <the-issued-to-address>
```

अगर हम अब e2 की जारी की गई सूचियों की जांच करें।

```
e2-cli listissuances
```

आप देख सकते हैं कि हमारी नई जारी की गई संपत्ति अब सूची में शामिल हो गई है। e2 नोड यह भी निर्धारित कर सकता है कि कितनी संपत्ति जारी की गई थी, साथ ही संबंधित टोकन की मात्रा भी, क्योंकि यह एक unblinded जारी करना था। Elements के भीतर संपत्ति आईडी को नाम से जोड़ने की सुविधा के लिए, पहले Elements को रोकें।

```
e1-cli stop
```

फिर इसे एक अतिरिक्त पैरामीटर के साथ पुनः प्रारंभ करें जो एक संपत्ति के हेक्स को दिए गए लेबल से मैप करता है। इससे नोड को संपत्ति के बारे में डेटा को हमारे लिए एक अधिक मानव-पठनीय प्रारूप में प्रदर्शित करने की सुविधा मिलती है। यदि आप चाहें तो इसे Elements.conf के अंत में जोड़ सकते हैं, फिर आपको हर बार daemon को शुरू करते समय इस तर्क को जोड़ने की आवश्यकता नहीं होगी। उदाहरण के लिए:

```
assetdir=5186d0bc8ed15e6ef85571bd2d8070573adf0e06fd4507082694526975ce4f35:My new asset (MNA)
```

लेकिन यहाँ हम तर्क विधि का उपयोग करेंगे।

```
e1-dae -assetdir=<assetid-here>:<name-of-the-new-asset>
```

नोड से फिर से जारी किए गए सूची की जानकारी प्राप्त करना।

```
e1-cli listissuances
```

यह हमें दिखाता है कि एसेट के हेक्स वैल्यू को उसके लेबल से जोड़ना सही तरीके से काम कर रहा है। अब फिर से e2 नोड की जारी की गई सूची की जांच कर रहे हैं।

```
e2-cli listissuances
```

आप देख सकते हैं कि e2 नोड को इस लेबल का एक्सेस नहीं है, क्योंकि लेबल केवल उसी नोड के लिए उपलब्ध होते हैं जिसने उन्हें सेट किया है। वास्तव में, हम e2 पर उसी एसेट हेक्स को एक अलग लेबल दे सकते हैं जैसा हमने e1 पर किया था। सबसे पहले e2 नोड को रोकें।

```
e2-cli stop
```

हमारे नए संपत्ति के हेक्स को एक अलग लेबल के साथ फिर से शुरू करना।

```
e2-dae -assetdir=<assetid-here>:<another-name-for-the-new-asset>
```

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। e2 से जारी की गई सूचियों का उल्लेख करें।

```
e2-cli listissuances
```

एसेट लेबल्स हर नोड के लिए स्थानीय होते हैं, नेटवर्क पर अन्य नोड्स द्वारा केवल एसेट का हेक्स पहचाना जाता है।

लेबल को एसेट हेक्स से जोड़ना तब उपयोगी होता है जब हम लेन-देन और Wallet बैलेंस क्वेरी जैसी क्रियाएं कर रहे होते हैं, क्योंकि यह एसेट को संक्षेप में संदर्भित करने का एक तरीका प्रदान करता है। उदाहरण के लिए, अगर हम अपने नए एसेट (10 की मात्रा) को e1 से e2 भेजना चाहते हैं बिना लेबल का उपयोग किए।

पहले हमें एक Address की जरूरत है ताकि हम संपत्ति को वहां भेज सकें।

```
e2-cli getnewaddress
```

फिर sendtoaddress कमांड का उपयोग करें।

```
e1-cli sendtoaddress <address> 10 "" "" false false 1 UNSET false <asset-id-here>
```

लेन-देन की पुष्टि करने के लिए एक ब्लॉक बनाएं।

```
generate 1
```

यह सुनिश्चित करना कि संपत्ति e2 पर प्राप्त हो गई है।

```
e2-cli getwalletinfo
```

हम देख सकते हैं कि वाकई में संपत्ति प्राप्त हो गई थी।

ध्यान दें कि e2 उस संपत्ति के हेक्स को मैप करता है जो प्राप्त हुई है और उसे अपने लेबल के साथ दिखाता है। इसे करने का एक आसान तरीका यह होगा कि जब आप भेज रहे हों तो e1 के संपत्ति लेबल का उपयोग करें।

```
e1-cli sendtoaddress <address> 10 "" "" false false 1 UNSET false <name-of-the-new-asset>
```

पर्दे के पीछे, Elements स्थानीय लेबल्स को हेक्स वैल्यूज़ में बदलता है ताकि Issued Assets का उपयोग आसान हो सके।

इस भाग में हमने देखा कि संपत्तियों को कैसे जारी और लेबल किया जाता है। अगले भाग में हम देखेंगे कि जारी की गई संपत्ति की मात्रा को फिर से जारी और नष्ट कैसे किया जाता है।

## संपत्तियों का पुनः जारी करना

<chapterId>78751b21-1dc8-4877-a406-e71bc80a95b0</chapterId>

![Video](https://youtu.be/5em79YHtYk0?si=rhponm6Hw9AB6RJp)

इस भाग में, आप पहले से जारी की गई संपत्ति की मात्रा को बढ़ाने और जारी की गई संपत्ति की एक निश्चित मात्रा को नष्ट करने का तरीका सीखेंगे।

जब किसी संपत्ति का पुनः जारी करना (अधिक बनाना) या उस संपत्ति की कुछ मात्रा को नष्ट करना आवश्यक हो जाता है, तो यह तब होता है जब वह संपत्ति किसी ऐसी चीज़ का प्रतिनिधित्व करती है जिसका निश्चित Supply नहीं होता। उदाहरण के लिए, यह उन संपत्तियों पर लागू हो सकता है जो किसी तिजोरी में रखे गए सोने का प्रतिनिधित्व करती हैं; जैसे-जैसे सोने की इकाइयाँ तिजोरी में आती-जाती रहती हैं, तिजोरी के Supply का प्रतिनिधित्व करने वाली संपत्ति को उसी के अनुसार ऊपर या नीचे समायोजित करना पड़ता है।

किसी संपत्ति की राशि को फिर से जारी करने के लिए उस संबंधित टोकन का Ownership चाहिए, जो संपत्ति के साथ ही तब बनाया गया था जब वह पहली बार जारी की गई थी।

जब किसी संपत्ति को फिर से बनाया जा रहा है, तो यह मायने नहीं रखता कि शुरुआत में किस नोड ने संपत्ति जारी की थी। बस यह जरूरी है कि जो नोड संपत्ति की मात्रा को फिर से जारी कर रहा है, उसके पास उस संपत्ति का reissuance token हो। हम देखेंगे कि शुरुआत में reissuance token कैसे बनाया जाता है, इसे संपत्ति की मात्रा को फिर से जारी करने के लिए कैसे उपयोग किया जाता है और इसे अन्य नोड्स को कैसे स्थानांतरित किया जाता है, ताकि उनके पास भी संपत्ति को फिर से जारी करने की अनुमति हो।

हमें दो Elements नोड्स की आवश्यकता होगी, जिन्हें हम e1 और e2 कहेंगे। इन नोड्स की ब्लॉकचेन को रीसेट किया गया है और default asset को इनके बीच बांटा गया है।

हम e1 को एक नए संपत्ति के 100 की राशि जारी करने के लिए प्रशिक्षित करेंगे और उसी संपत्ति के लिए 1 reissuance token बनाएंगे। इस उदाहरण को सरल बनाने के लिए हम इसे unblinded के रूप में जारी करेंगे। तो चलिए आगे बढ़ते हैं और संपत्ति और उसके संबंधित reissuance token को जारी करते हैं।

```
e1-cli issueasset 100 1 false
```

संपत्ति की आईडी और (पुनः जारी) टोकन की आईडी नोट कर लें।

बाद में जब हम e2 से और संपत्ति फिर से जारी करेंगे, तो हमें यह ध्यान रखना होगा कि संपत्ति transaction ID में जारी की गई थी और इसका उपयोग करके Address में आयात करना होगा, जहां संपत्ति भेजी गई थी।

लेन-देन की पुष्टि करें।

```
e1-cli -generate 1
```

अब हम gettransaction कमांड का उपयोग करके लेन-देन के विवरण की जांच करेंगे।

```
e1-cli gettransaction <txid>
```

जब आप लेन-देन के डेटा के हेक्स को ऊपर स्क्रॉल करेंगे, तो आप देखेंगे कि इस लेन-देन में e1 को 1 reissuance token और 100 संबंधित संपत्ति प्राप्त हुई है।

Address की एक कॉपी ले लो ताकि हम इसे e2 में इम्पोर्ट कर सकें।

अब Address को e2 के Wallet में इम्पोर्ट कर रहे हैं।

```
e2-cli importaddress <address>
```

अब हम देख सकते हैं कि e1 और e2 दोनों को संपत्ति जारी करने की जानकारी है।

```
e1-cli listissuances
e2-cli listissuances
```

वर्तमान में e1 के पास उस संपत्ति की एक राशि है और 1 reissuance token भी है, लेकिन e2 के पास नहीं है।

```
e1-cli getwalletinfo
```

ध्यान दें कि e1 के पास पहले की तुलना में कम default asset है क्योंकि उसने लेन-देन शुल्क को कवर करने के लिए एक छोटी राशि का भुगतान किया है। यह राशि e1 द्वारा तब एकत्र की जानी है जब ब्लॉक 100 ब्लॉक्स गहरे परिपक्व हो जाएगा।

```
e2-cli getwalletinfo
```

चूंकि e1 के पास reissuance token है, वह इसे फिर से जारी कर सकता है। यह reissueasset कमांड का उपयोग करके किया जाता है। चलिए e1 को इस संपत्ति के 100 और जारी करने देते हैं।

```
e1-cli reissueasset <asset-id> 100
```

पुनः जारी करना सफल रहा या नहीं, यह जांच रहे हैं।

```
e1-cli getwalletinfo
```

आप देख सकते हैं कि e1 अब 200 संपत्ति रखता है, जैसा कि उम्मीद थी।

चूंकि e2 के पास reissuance token की कोई मात्रा नहीं है, इसलिए अगर वे इस संपत्ति को फिर से जारी करने की कोशिश करेंगे तो उन्हें एक त्रुटि मिलेगी।

```
e2-cli reissueasset <asset-id> 100
```

त्रुटि संदेश को नोट करें।

हम e1 से पुनः जारी करने का विवरण listissuances कमांड का उपयोग करके देख सकते हैं।

```
e1-cli listissuances
```

`is_reissuance` फ्लैग पर ध्यान दें।

अगर हम अब e2 को reissuance token की एक मात्रा भेजते हैं, तो वे खुद उस संपत्ति की एक मात्रा फिर से जारी कर सकेंगे। सबसे पहले हमें एक Address की जरूरत है जिसे हम भेज सकें। यह ध्यान देने योग्य है कि reissuance token को Elements के भीतर किसी अन्य संपत्ति की तरह ही माना जाता है जब हम इसे भेजते हैं और बैलेंस दिखाते हैं, और इसे किसी अन्य संपत्ति की तरह छोटे हिस्सों में भी तोड़ा जा सकता है, इसलिए हमें e2 को 1 reissuance token भेजने की जरूरत नहीं है ताकि वह संपत्ति को फिर से जारी कर सके। कोई भी मात्रा पर्याप्त होगी। e2 के लिए reissuance token प्राप्त करने के लिए एक Address तैयार कर रहे हैं।

```
e2-cli getnewaddress
```

फिर e1 से e2 तक RIT का एक हिस्सा भेजें।

```
e1-cli sendtoaddress <address-of-e2> 0.1 "" "" false false 1 UNSET false <reissuance-token-id>
```

लेन-देन की पुष्टि करें।

```
e1-cli -generate 1
```

अब हम देख सकते हैं कि e2 के पास वह 0.1 है जो उसे भेजा गया था।

```
e2-cli getwalletinfo
```

इसका मतलब है कि अब e2 अपने Wallet में मौजूद RIT से जुड़े एसेट को फिर से जारी कर सकता है। हम e2 से कहेंगे कि वह 500 एसेट को फिर से जारी करे।

```
e2-cli reissueasset <asset-id> 500
```

पुनः जारी करने के परिणाम की जाँच करें।

```
e2-cli getwalletinfo
```

आप देख सकते हैं कि e2 अब अपने Wallet बैलेंस में पुनः जारी की गई राशि को रखता है और इस प्रक्रिया में RIT का उपयोग नहीं होता है।

किसी संपत्ति की एक मात्रा को नष्ट करना ऐसा कुछ है जो कोई भी व्यक्ति कर सकता है, बशर्ते उसके पास उतनी ही मात्रा हो जितनी नष्ट की जा रही है। यह प्रक्रिया reissuance token द्वारा नियंत्रित नहीं होती है।

```
e2-cli destroyamount <asset-id>
e2-cli getwalletinfo
```

इस भाग में हमने देखा कि किसी संपत्ति को कैसे जारी किया जाता है, साथ ही reissuance token का उपयोग कैसे किया जाता है जो संपत्ति जारी करने के हिस्से के रूप में वैकल्पिक रूप से बनाया जाता है। हमने यह भी देखा कि reissuance token का स्थानांतरण किसी अन्य संपत्ति के स्थानांतरण जितना ही सरल है, और reissuance token की कोई भी मात्रा रखने से धारक को संबंधित संपत्ति को और अधिक जारी करने का अधिकार मिलता है। इसलिए यह बहुत महत्वपूर्ण है कि आपके नेटवर्क में पुनः जारी करने वाले टोकन तक किसकी पहुंच है, इसे नियंत्रित किया जाए। हमने यह भी देखा कि किसी संपत्ति की एक मात्रा को कैसे नष्ट किया जाता है और यह प्रक्रिया reissuance token के कब्जे से नियंत्रित नहीं होती है।

# तत्व संघ

<partId>173a2440-0203-4dcc-8e2b-f8fa2cc8d3ca</partId>

## मुझे खेद है, लेकिन "block signing" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया इसके बारे में अधिक जानकारी दे सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

<chapterId>c47b217e-db14-4843-a66f-3e5f3a00a808</chapterId>

![Video](https://youtu.be/kxWX91fCnus?si=KItm_Am3_RrBcLBN)

Elements एक संघीय हस्ताक्षर मॉडल का समर्थन करता है, जो आपको यह निर्धारित करने की अनुमति देता है कि किसी प्रस्तावित ब्लॉक को मान्य ब्लॉक बनाने के लिए कितने Strong Federation सदस्यों को हस्ताक्षर करना आवश्यक है।

पहले, और उदाहरण को सरल बनाने के लिए, हम `generate` कमांड का उपयोग करके ब्लॉक बना रहे थे, जिसे नेटवर्क द्वारा वैध माने जाने के लिए मल्टीसिग्नेचर आवश्यकता को पूरा नहीं करना पड़ता था।

हम अपने नोड्स को 2-में-2 Multisig ब्लॉक निर्माण की आवश्यकता के लिए सेट करेंगे। इसे signblockscript पैरामीटर का उपयोग करके सेटअप किया जाएगा, जिसे कॉन्फ़िग फाइल में जोड़ा जा सकता है या नोड को स्टार्टअप पर पास किया जा सकता है। इस पैरामीटर के साथ चेन को प्रारंभ करने के लिए, हमें पहले उस स्क्रिप्ट को बनाना होगा जिससे यह बना है।

हम कुछ मौजूदा नोड्स का उपयोग करके यह काम करेंगे, उनके द्वारा उत्पन्न डेटा को सहेजेंगे और फिर चेन को मिटा देंगे ताकि हम इसे अपने signblockscript पैरामीटर का उपयोग करके फिर से शुरू कर सकें। यह आवश्यक है क्योंकि स्क्रिप्ट नेटवर्क के सहमति नियमों का हिस्सा बनती है और इसे on chain प्रारंभिकरण के समय सेट करना होगा। इसे पहले से मौजूद चेन में बाद में नहीं जोड़ा जा सकता।

हमें दो Elements नोड्स की आवश्यकता होगी, जिन्हें हम e1 और e2 कहेंगे। इन नोड्स की ब्लॉकचेन को रीसेट कर दिया गया है और default asset को इनके बीच विभाजित कर दिया गया है।

सुनिश्चित करें कि आपके Elements.conf फाइल में con_max_block_sig_size पैरामीटर को उच्च मान पर सेट किया गया है, नहीं तो इस सेक्शन में बाद में block signing फेल हो जाएगा। इस ट्यूटोरियल के लिए हमने con_max_block_sig_size=2000 सेट किया है।

हम Blockchain को रीसेट करने जा रहे हैं और e1 और e2 से जुड़े वॉलेट्स को मिटाने वाले हैं। इसलिए हमें उन पतों, सार्वजनिक कुंजियों और निजी कुंजियों की एक प्रति लेनी होगी जो हम generate के लिए block signing स्क्रिप्ट में उपयोग करते हैं, ताकि हम उन्हें बाद में इस्तेमाल कर सकें।

पहले, हमें हर block signing नोड को generate में बदलना होगा और फिर एक नया Address बनाना होगा, जिसकी आपको एक कॉपी लेनी होगी।

```
e1-cli getnewaddress
e2-cli getnewaddress
```

फिर हमें पतों से सार्वजनिक कुंजियाँ निकालनी होंगी और उन्हें बाद में उपयोग के लिए नोट करना होगा।

```
e1-cli getaddressinfo <e1-address>
e2-cli getaddressinfo <e2-address>
```

फिर निजी कुंजियों को निकालें, जिन्हें हम बाद में फिर से आयात करेंगे ताकि नोड्स ब्लॉकों पर हस्ताक्षर कर सकें जब हम अपने Blockchain और Wallet डेटा को फिर से प्रारंभ करें।

```
e1-cli dumpprivkey <e1-address>
e2-cli dumpprivkey <e2-address>
```

अब हमें generate को Redeem स्क्रिप्ट के साथ 2 में से 2 मल्टी-सिग्नेचर आवश्यकताओं के साथ सेट करना है। हम यह createmultisig कमांड का उपयोग करके करते हैं, जिसमें पहला पैरामीटर 2 होता है और फिर दो पब्लिक कीज़ प्रदान करते हैं। यही वे कीज़ हैं जिन्हें Ownership को बाद में ब्लॉक बनने पर साबित करना होता है।

या तो नोड, e1 या e2, generate को Multisig कर सकता है।

```
e1-cli createmultisig 2 '["<e1-pubkey>", "<e2-pubkey>"]'
```

यह हमें हमारा redeemscript देता है, जिसे आप बाद में उपयोग के लिए कॉपी कर सकते हैं।

अब हमें मौजूदा Blockchain और Wallet डेटा को मिटाना होगा ताकि हम नए signblockscript के साथ फिर से शुरुआत कर सकें, जो कि चेन के सहमति नियमों का हिस्सा है। इसी वजह से हमें पहले कुछ डेटा की कॉपी लेनी पड़ी थी, जैसे कि प्राइवेट कीज़ जो नई चेन में ब्लॉक्स को साइन करने के लिए इस्तेमाल होंगी। आगे बढ़ने से पहले आपको यह करना जरूरी है।

हमारे मौजूदा Wallet और चेन डेटा को हटाने के बाद, अब हम अपने नोड्स को शुरू कर सकते हैं और उन्हें signblockscript पैरामीटर का उपयोग करके एक नई चेन को प्रारंभ करने दे सकते हैं। चलिए -evbparams=dynafed:0::: को पास करते हैं ताकि dynafed सक्रियण को निष्क्रिय किया जा सके, क्योंकि इस उदाहरण के लिए हमें उस उन्नत फीचर की आवश्यकता नहीं है।

```
e1-dae -signblockscript=<redeem-script> -evbparams=dynafed:0:::
e2-dae -signblockscript=<redeem-script> -evbparams=dynafed:0:::
```

अब हमें उन निजी कुंजियों को आयात करने की ज़रूरत है जिन्हें हमने पहले सहेजा था, ताकि हमारे नोड्स हस्ताक्षर कर सकें और किसी भी प्रस्तावित ब्लॉक्स को पूरा करने में मदद कर सकें।

```
e1-cli importprivkey <e1-priv-key>
e2-cli importprivkey <e2-priv-key>
```

अब generate कमांड का उपयोग करने पर त्रुटि होगी क्योंकि यह हमारे नोड्स द्वारा लागू किए गए आवश्यक block signing नियमों का पालन नहीं करता है।

```
e1-cli -generate 1
```

एक नया ब्लॉक प्रस्तावित करने के लिए, कोई भी नोड getnewblockhex कमांड का उपयोग कर सकता है। यह एक नए ब्लॉक का हेक्स लौटाता है, जिसे हमारे नेटवर्क पर किसी भी नोड द्वारा स्वीकार किए जाने से पहले साइन करना आवश्यक होगा।

```
e1-cli getnewblockhex
```

याद रखें कि यह कमांड सिर्फ एक प्रस्तावित ब्लॉक बनाता है, यह generate नहीं करता है।

इसकी पुष्टि करने के लिए हम देख सकते हैं कि हमारे Blockchain में फिलहाल कोई ब्लॉक नहीं हैं।

```
e1-cli getblockcount
```

अगर हम ब्लॉक हेक्स को बिना साइन किए सबमिट करने की कोशिश करें।

```
e1-cli submitblock <block-hex>
```

हमें एक संदेश मिलता है जो बताता है कि ब्लॉक प्रूफ अमान्य है। ऐसा इसलिए है क्योंकि इसे अभी तक आवश्यक 2 में से 2 पार्टियों द्वारा हस्ताक्षरित नहीं किया गया है।

तो चलो e1 से प्रस्तावित ब्लॉक पर हस्ताक्षर करवाते हैं।

```
e1-cli signblock <block-hex>
```

e2 से हेक्स पर साइन करवाओ।

```
e2-cli signblock <block-hex>
```

ध्यान दें कि e2 उस आउटपुट पर हस्ताक्षर नहीं करता जो e1 द्वारा प्रस्तावित ब्लॉक पर हस्ताक्षर करने से उत्पन्न होता है। वे दोनों प्रस्तावित ब्लॉक के हेक्स पर एक-दूसरे के परिणामों से स्वतंत्र रूप से हस्ताक्षर करते हैं।

अब हमें e1 और e2 के ब्लॉक सिग्नेचर को मिलाना है। कोई भी नोड यह कर सकता है, उन्हें बस दूसरे नोड से साइन किया हुआ ब्लॉक हेक्स चाहिए।

```
e1-cli combineblocksigs <block-hex> '["<signed-hex-from-e1>", "<signed-hex-from-e2>"]'
```

आप देख सकते हैं कि combineblocksigs कमांड साइन किए गए ब्लॉक का हेक्स आउटपुट करता है और साथ ही एक स्थिति "पूर्ण" दिखाता है, जो हमें बताता है कि ब्लॉक हेक्स सबमिट करने के लिए तैयार है।

अब कोई भी नोड पूरा किया हुआ ब्लॉक हेक्स सबमिट कर सकता है। चलिए, हम e1 से यह काम करवाते हैं।

```
e1-cli submitblock <combined-signed-hex>
```

जांच कर रहे हैं कि सबमिशन वैध था या नहीं।

```
e1-cli getblockcount
e2-cli getblockcount
```

आप देख सकते हैं कि e1 और e2 दोनों ने ब्लॉक को मान्य मान लिया है और इसे अपने स्थानीय Blockchain प्रतियों के अंत में जोड़ लिया है।

प्रक्रिया का सारांश प्रस्तुत करने के लिए। इस खंड में हमने:


- एक ब्लॉक का प्रस्ताव दिया।
- प्रत्येक नोड से इसे साइन करवाया।
- हस्ताक्षर को मिला दिया।
- सुनिश्चित कर लिया कि हस्ताक्षर मान्य हैं और चेन के redeemscript थ्रेशोल्ड को पूरा करते हैं।
- ब्लॉक जमा कर दिया।

नेटवर्क के प्रत्येक नोड ने ब्लॉक को सत्यापित किया और उसे अपनी स्थानीय Blockchain की प्रति में जोड़ लिया।

### मुझे खेद है, लेकिन "block signing" से संबंधित कोई विशेष जानकारी उपलब्ध नहीं है। क्या आप कृपया अधिक संदर्भ या विवरण प्रदान कर सकते हैं ताकि मैं आपकी बेहतर मदद कर सकूं?

हालांकि यह प्रक्रिया शुरू में जटिल लग सकती है, लेकिन block signing में Elements का क्रम हमेशा एक जैसा होता है और प्रारंभिक सेटअप केवल एक बार ही करना होता है।

1. प्रारंभिक सेटअप (केवल एक बार किया जाता है)

2. एक मल्टीसिग्नेचर Address बनाया गया है जिसे `signblockscript` कहा जाता है, जो फेडरेटेड ब्लॉक साइनर्स की सार्वजनिक कुंजियों का उपयोग करके बनाया गया है।

Redeem स्क्रिप्ट का उपयोग एक नया Blockchain शुरू करने के लिए किया जाता है।

4. ब्लॉक उत्पादन (चल रहा है)

5. प्रस्तावित ब्लॉक बनाए जाते हैं और हस्ताक्षर के लिए आदान-प्रदान किए जाते हैं।

जब एक निश्चित संख्या में हस्ताक्षरकर्ताओं ने प्रस्तावित ब्लॉक पर हस्ताक्षर कर दिए होते हैं, तो इसे मिलाकर नेटवर्क में जमा कर दिया जाता है। अगर यह चेन के `signblockscript` मानदंडों को पूरा करता है, तो नोड्स इसे एक वैध ब्लॉक के रूप में स्वीकार कर लेते हैं।

## साइड चेन के रूप में तत्व

<chapterId>432d7a65-255f-44a3-8b38-78508202cb37</chapterId>

![Video](https://youtu.be/egYzj4N8CB8?si=v7_-IXsjHPE-ARDe)

Elements एक ओपन-सोर्स, सामान्य उपयोग का Blockchain प्लेटफॉर्म है जिसे किसी मौजूदा Blockchain, जैसे कि Bitcoin से जोड़ा जा सकता है। जब इसे किसी अन्य Blockchain से जोड़ा जाता है, तो Elements को `Sidechain` के रूप में कार्यरत कहा जाता है। साइडचेन एक चेन से दूसरी चेन में संपत्तियों के दो-तरफा हस्तांतरण को सक्षम बनाते हैं। Elements को Sidechain के रूप में लागू करने से आप mainchain की कुछ अंतर्निहित सीमाओं को पार कर सकते हैं, जबकि mainchain पर सुरक्षित संपत्तियों द्वारा प्रदान की गई सुरक्षा के अच्छे स्तर को बनाए रखते हैं।

Sidechain को mainchain और उसकी लेन-देन की जानकारी होती है, लेकिन mainchain को Sidechain के बारे में कोई जानकारी नहीं होती और इसकी जरूरत भी नहीं होती। इससे साइडचेन को बिना किसी रुकावट या mainchain प्रोटोकॉल सुधार प्रस्तावों से जुड़ी देरी के बिना नवाचार करने की सुविधा मिलती है। मुख्य प्रोटोकॉल को सीधे बदलने की कोशिश करने के बजाय, इसे बढ़ाने से mainchain सुरक्षित और विशेषीकृत बना रहता है, जो Sidechain के सुचारू संचालन का आधार बनता है।

Bitcoin की कार्यक्षमता को बढ़ाकर और इसकी सुरक्षा का लाभ उठाकर, Elements आधारित Sidechain नई कार्यक्षमता प्रदान करने में सक्षम है जो पहले mainchain के उपयोगकर्ताओं के लिए उपलब्ध नहीं थी। उत्पादन में उपयोग किए जा रहे Elements आधारित Sidechain का एक उदाहरण Liquid Network है।

Elements या Blockchain को Sidechain के रूप में प्रारंभ करने के लिए, हमें federated peg script पैरामीटर का उपयोग करना होगा। इस पैरामीटर को किसी नोड की कॉन्फ़िग फाइल में सेट किया जा सकता है या स्टार्ट अप के समय पास किया जा सकता है।

federated peg script यह निर्धारित करता है कि Strong Federation के कौन से सदस्य peg-in और peg-out कार्य कर सकते हैं। इन कार्यकर्ताओं को `watchmen` कहा जाता है क्योंकि वे mainchain और Sidechain पर नजर रखते हैं ताकि वैध peg-in और peg-out लेनदेन की पहचान कर सकें और उन्हें क्रियान्वित कर सकें। `Peg-out` का मतलब है कि Sidechain से संपत्तियों को निकालकर mainchain में स्थानांतरित करना और `peg-in` का मतलब है कि mainchain से संपत्तियों को Sidechain में लाना। जब हम कहते हैं `Sidechain में लाना`, तो हमारा मतलब है कि धनराशि mainchain पर एक बहु-हस्ताक्षर Address में लॉक हो जाती है और Elements Sidechain पर संपत्ति की एक समान राशि बनाई जाती है। जब हम कहते हैं `Sidechain से बाहर ले जाना`, तो हमारा मतलब है कि Elements Sidechain पर संपत्तियां नष्ट हो जाती हैं और mainchain पर लॉक की गई धनराशि से समान राशि जारी की जाती है। Peg-in और peg-out कार्य करने की अनुमति के लिए कार्यकर्ताओं को federated peg script में उपयोग किए गए सार्वजनिक कुंजियों के Ownership को साबित करना होता है। यह संबंधित निजी कुंजियों के उपयोग से किया जाता है।

federated peg script बनाने के लिए, सबसे पहले हमें अपने हर नोड generate को एक सार्वजनिक कुंजी देनी होगी। इसके साथ ही, हमें संबंधित निजी कुंजियों को भी सुरक्षित रखना होगा ताकि बाद में उनका उपयोग किया जा सके। ऐसा इसलिए करना जरूरी है क्योंकि हमें किसी भी मौजूदा चेन डेटा को मिटाकर एक नई चेन को federated peg script के साथ प्रारंभ करना होगा। ऐसा इसलिए है क्योंकि federated peg script, Sidechain के सहमति नियमों का हिस्सा होता है और इसे बाद में किसी मौजूदा, गैर-पेग्ड, Blockchain पर लागू नहीं किया जा सकता।

हमारे हर नोड के साथ generate और Address करें, और बाद में उपयोग के लिए संबंधित डेटा स्टोर करें। फिर federated peg script को generate करें, जिसे हम बाद में अपने Sidechain को प्रारंभ करने के लिए उपयोग करेंगे।

सबसे पहले, हमें अपने नेटवर्क में प्रत्येक नोड की आवश्यकता है, जो watchmen के रूप में कार्य करेगा, ताकि वह एक नया Address बना सके।

```
e1-cli getnewaddress
e2-cli getnewaddress
```

फिर हम Address को मान्य करते हैं ताकि सार्वजनिक कुंजियाँ प्राप्त कर सकें।

```
e1-cli getaddressinfo <e1-address>
e2-cli getaddressinfo <e2-address>
```

और फिर प्रत्येक Address से जुड़े निजी कुंजियों को प्राप्त करें।

```
e1-cli dumpprivkey <e1-address>
e2-cli dumpprivkey <e2-address>
```

प्राइवेट और पब्लिक कीज़ को बाद में उपयोग के लिए सुरक्षित रखें।

अब हमें मौजूदा Blockchain और Wallet डेटा को हटाना होगा क्योंकि हम एक नई चेन को federated peg script का उपयोग करके शुरू करने जा रहे हैं। आप इसे अभी कर सकते हैं। यह मत भूलिए कि हमें Bitcoin और daemon को शुरू करना है, क्योंकि हमें इन्हें पेग-इन करने की आवश्यकता होगी।

अब हम पहले से संग्रहीत सार्वजनिक कुंजियों का उपयोग करके federated peg script के साथ एक नई चेन को प्रारंभ कर सकते हैं। जो संख्याएँ हम दर्ज करते हैं और जो हमारी सार्वजनिक कुंजियों के चारों ओर होती हैं, वे उपयोग की गई कुंजियों की संख्या को परिभाषित और सीमित करती हैं, और Ownership कुंजी को साबित करना आवश्यक होता है ताकि हम Sidechain में प्रवेश और बाहर कर सकें।

```
e1-dae -fedpegscript=5221<e1-pubkey>21<e2-pubkey>52ae
e2-dae -fedpegscript=5221<e1-pubkey>21<e2-pubkey>52ae
```

अब हम उन प्राइवेट कीज़ को इम्पोर्ट करेंगे जिन्हें हमने पहले सेव किया था, ताकि हमारे नोड्स बाद में चेन के बीच एसेट्स के ट्रांसफर को साइन और पूरा कर सकें और federated peg script की आवश्यकताओं को पूरा कर सकें।

```
e1-cli importprivkey <priv-key-1>
e2-cli importprivkey <priv-key-1>
```

अब हमें दोनों चेन पर कुछ ब्लॉक्स को परिपक्व करना होगा। ब्लॉक्स की परिपक्वता पेग प्रक्रिया की एक आवश्यकता है क्योंकि यह mainchain पर ब्लॉक पुनर्गठन के खिलाफ सुरक्षा प्रदान करती है, जिससे Sidechain के भीतर pegged asset Supply की मुद्रास्फीति हो सकती है।

इस खंड को संघीय पेग पर केंद्रित रखने के लिए, हम पिछले खंड में देखे गए block signing मॉडल का उपयोग किए बिना ब्लॉक बनाएंगे, और नए ब्लॉक बनाने के लिए 'generate' कमांड का उपयोग करेंगे।

```
b-cli generate 101
e1-cli generate 1
```

हमें अभी Elements के लिए generate ब्लॉक्स की ज़रूरत नहीं है। लेकिन, चलो फिर भी एक generate कर लेते हैं। यह संभावित असंगतियों से बचने के लिए अच्छी प्रैक्टिस है।

अब हमारी चेन पेग-इन के लिए तैयार है। पेग-इन करने के लिए हमें getpeginaddress कमांड का उपयोग करके एक विशेष प्रकार का Address, जिसे generate कहते हैं, तैयार करना होगा। ध्यान दें कि getpeginaddress से पेग-इन Address बनाने और claimpegin से इसे क्लेम करने के बीच का समय जितना कम हो सके, उतना ही अच्छा है। पेग-इन एड्रेस लंबे समय तक टिकाऊ नहीं होते और इन्हें दोबारा इस्तेमाल नहीं करना चाहिए।

```
e1-cli getpeginaddress
```

आप देख सकते हैं कि यह कमांड एक नया mainchain Address बनाता है, साथ ही एक नया स्क्रिप्ट भी बनाता है जिसे पेग-इन फंड्स का दावा करने के लिए पूरा करना होगा। mainchain Address एक `पे टू स्क्रिप्ट Hash` Address है, जिसका उपयोग Elements नेटवर्क के भीतर watchmen भूमिका निभाने वाले कार्यकर्ता करेंगे।

getnewaddress की तरह, getpeginaddress भी कॉलिंग नोड के Wallet में एक नया सीक्रेट जोड़ता है, इसलिए आपके नोड प्रबंधन प्रक्रिया में Wallet फाइल का बैकअप लेना महत्वपूर्ण है।

हम अब mainchain से कुछ Bitcoin को Sidechain में भेजेंगे। हमारे mainchain के रिग्रेशन टेस्ट Wallet में पहले से ही कुछ फंड्स हैं।

```
b-cli getwalletinfo
```

हम देख सकते हैं कि Wallet में 50 Bitcoin होते हैं। हम एक Bitcoin को mainchain से Sidechain में भेजेंगे। हमें mainchain Address को फंड भेजने की ज़रूरत है, जो हमारे नोड ने पहले जनरेट किया था।

```
b-cli sendtoaddress <e1-pegin-address>
```

हमें इस लेन-देन का आईडी संभाल कर रखना होगा क्योंकि बाद में फंडिंग के प्रमाण के लिए इसकी जरूरत पड़ेगी।

अब हम देख सकते हैं कि mainchain और Wallet का बैलेंस उस राशि से कम हो गया है जो हमने भेजी थी, साथ ही लेन-देन शुल्क को कवर करने के लिए एक अतिरिक्त छोटी राशि भी शामिल है।

```
b-cli getwalletinfo
```

हमें लेन-देन को फिर से परिपक्व करना होगा।

```
b-cli generate 101
```

हमारे Elements नोड को peg-in फंड्स का दावा करने के लिए, हमें यह `प्रमाण` प्राप्त करना होगा कि peg-in लेन-देन किया गया है। यह क्रिप्टोग्राफिक प्रमाण transaction ID फंडिंग का उपयोग करके मर्कल पथ की गणना करता है और यह साबित करता है कि लेन-देन एक पुष्टि किए गए ब्लॉक में मौजूद है।

```
b-cli gettxoutproof '["<tx-id>"]'
```

हमें कच्चे लेन-देन का डेटा भी चाहिए।

```
b-cli getrawtransaction <tx-id>
```

पेग-इन लेनदेन के प्रमाण और कच्चे डेटा के साथ, हमारा Elements नोड अब कच्चे लेनदेन और लेनदेन प्रमाण का उपयोग करके पेग-इन का दावा कर सकता है।

```
e1-cli claimpegin <raw> <proof>
```

ध्यान दें कि claimpegin को एक वैकल्पिक तीसरा तर्क दिया जा सकता है। इस तीसरे पैरामीटर का उपयोग यह निर्दिष्ट करने के लिए किया जा सकता है कि दावा की गई राशि को Sidechain Address पर कहाँ भेजना है। हमारे उदाहरण में इसकी आवश्यकता नहीं थी क्योंकि हम उसी नोड से कमांड चला रहे थे जो Address का मालिक है, जहाँ दावा की गई राशि जा रही है।

e1 का बैलेंस चेक करना।

```
e1-cli getwalletinfo
```

दावे की पुष्टि के लिए एक ब्लॉक तैयार किया जा रहा है।

```
e1-cli generate 1
```

e1 का बैलेंस चेक करना।

```
e1-cli getwalletinfo
```

हम देख सकते हैं कि पेग-इन को सफलतापूर्वक दावा कर लिया गया है।

पेग-आउट करने की प्रक्रिया भी लगभग वैसी ही होती है। इसमें एक Address जनरेट किया जाता है, उसमें फंड भेजे जाते हैं और अगर लेन-देन वैध होता है तो फंड रिलीज़ कर दिए जाते हैं। हम पूरे पेग-आउट प्रक्रिया को नहीं समझाएंगे क्योंकि इसमें mainchain पर काम शामिल होता है, जो इस कोर्स के दायरे से बाहर है। Elements घटनाओं के संदर्भ में, mainchain पर एक Address जनरेट किया जाता है।

```
b-cli getnewaddress
```

फंड्स को Elements नोड से mainchain और Address पर sendtomainchain कमांड का उपयोग करके भेजा जाता है।

```
e1-cli sendtomainchain <new-address> 1
```

लेन-देन की पुष्टि के लिए एक ब्लॉक तैयार किया जा रहा है।

```
e1-cli generate 1
```

नोड Wallet का बैलेंस चेक करें।

```
e1-cli getwalletinfo
```

और देखो कि बैलेंस कम हो गया है।

इस खंड में हमने देखा कि कैसे:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- एक नई चेन को प्रारंभ करें जो स्क्रिप्ट को नेटवर्क सहमति पैरामीटर नियम के रूप में उपयोग करती है।
- mainchain से Sidechain में पैसे भेजें।
- Elements और Sidechain के भीतर धनराशि का दावा करें।
- mainchain को फंड वापस भेजने की प्रक्रिया कैसे शुरू होती है, यह समझें।

### फेडरेटेडपेगस्क्रिप्ट

Elements को Sidechain की तरह काम करने के लिए, उसके Blockchain में Genesis ब्लॉक को `fedpegscript` के साथ बनाना होगा। यह तब होता है जब नोड शुरू करते समय `fedpegscript` पैरामीटर पास किया जाता है। यह स्क्रिप्ट फिर Elements के Blockchain के सहमति नियमों का हिस्सा बन जाएगी और पेग-इन और पेग-आउट अनुरोधों को मान्य और क्रियान्वित करने की अनुमति देगी।

`फेडपेगस्क्रिप्ट` उन सार्वजनिक कुंजियों से बना होता है जिन्हें पेग क्रियाएं करने के लिए अधिकृत लोगों द्वारा नियंत्रित किया जाता है। नीचे 2-ऑफ-2 मल्टीसिग्नेचर फेडपेगस्क्रिप्ट का उदाहरण प्रारूप दिखाया गया है:

```
fedpegscript=5221<public key 1>21<public key 2>52ae
```

ध्यान दें: सार्वजनिक कुंजियों के बाहर के अक्षर सीमांकक होते हैं जो सार्वजनिक कुंजी और `n में से m` आवश्यकताओं को दर्शाते हैं। उदाहरण के लिए, 1-का-1 फेडपेगस्क्रिप्ट के लिए टेम्पलेट '5121<पब्लिक की 1>51ae' होगा।

### पेग-इन

Elements Sidechain द्वारा किसी पेग-इन को स्वीकार करने से पहले, उसे mainchain पर पर्याप्त पुष्टि होनी चाहिए। यह इसलिए जरूरी है ताकि Elements Sidechain पर pegged asset के Supply में महंगाई से बचा जा सके, जो mainchain के पुनर्गठन के कारण हो सकती है।

Bitcoin Blockchain के सिरे पर छोटे पुनर्गठन की उम्मीद की जाती है, जो Proof of Work (PoW) सहमति तंत्र के सामान्य संचालन का हिस्सा है। इसलिए, Elements केवल तभी एक पेग-इन को मान्य मानता है जब वह Bitcoin Blockchain के भीतर पर्याप्त गहराई में हो। यह इसलिए किया जाता है ताकि Elements एक ही पेग-इन को एक से अधिक बार स्वीकार न कर सके।

### पेग-आउट

जब एक Elements नोड `sendtomainchain` कमांड को कॉल करता है, तो उसे एक mainchain Address (जो कि पेग-आउट गंतव्य है) और pegged asset की वह राशि चाहिए होती है जिसे `निकाला` जाना है। इससे Sidechain पर एक पेग-आउट लेन-देन बनता है। जब watchmen के रूप में कार्य कर रहे फंक्शनरीज़ यह पता लगाते हैं कि पेग-आउट लेन-देन Sidechain पर पुष्टि हो चुका है, तो वे वास्तव में mainchain पर संपत्ति को पेग-आउट गंतव्य पर जारी करने का ध्यान रखते हैं, जैसा कि हमने पाठ्यक्रम के पिछले भागों में सीखा था।

## Elements को एक स्वतंत्र Blockchain के रूप में समझा जा सकता है।

<chapterId>50dff39b-2702-47d7-9c15-0b54b845e99f</chapterId>

![Video](https://youtu.be/u-3rV7DGtD0?si=G1__H0Uelf4sTUDM)

अब तक, हमने देखा है कि कैसे Elements को Sidechain की तरह चलाया जा सकता है। हालांकि, यह अपने खुद के डिफ़ॉल्ट नेटिव एसेट के साथ एक स्वतंत्र Blockchain समाधान के रूप में भी काम कर सकता है। इस सेटअप में, Elements Blockchain में अभी भी Sidechain के सभी फीचर्स होते हैं, जैसे Confidential Transactions और Issued Assets, लेकिन इसे सर्कुलेशन से default asset की मात्रा जोड़ने या हटाने के लिए पेग-इन या पेग-आउट की आवश्यकता नहीं होती।

इस भाग में हम:

एक नए Elements Blockchain को एक default asset के साथ `newasset` नाम से प्रारंभ करें।

1,000,000 `newasset` बनाने के लिए निर्दिष्ट करें और इसके साथ 2 पुनः जारी करने वाले टोकन भी बनाएँ।

सभी anyone-can-spend `newasset` सिक्के प्राप्त करें।

'newasset' के लिए सभी anyone-can-spend पुनः जारी किए गए टोकन का दावा करें।

संपत्ति और उसका reissuance token दूसरे नोड के Wallet पर भेजें।

दोनों नोड्स से और 'newasset' फिर से जारी करें।

Elements नेटवर्क को एक स्वतंत्र Blockchain के रूप में चलाने के लिए, हर नोड को कुछ बुनियादी पैरामीटर के साथ शुरू करना होता है। ये पैरामीटर नोड को यह बताने के लिए होते हैं कि वह किसी अन्य Blockchain से पेग-इन को मान्य करने की कोशिश न करे। इसके अलावा, नेटवर्क के default asset का नाम और default asset तथा संबंधित reissuance token की मात्रा को भी सेट करना होता है।

हम अब इन पैरामीटर्स का उपयोग करके हमारे दो जुड़े हुए Elements नोड्स पर एक नई चेन शुरू करेंगे। हम default asset को `newasset` नाम देंगे और एक मिलियन `newasset` जारी करेंगे और दो `newasset` पुनः जारी करने वाले टोकन जारी करेंगे।

```
e1-dae -validatepegin=0 -defaultpeggedassetname=newasset -initialfreecoins=100000000000000 -initialreissuancetokens=200000000
e2-dae -validatepegin=0 -defaultpeggedassetname=newasset -initialfreecoins=100000000000000 -initialreissuancetokens=200000000
```

यहाँ पर जो राशि का उपयोग किया गया है, वह नेटवर्क द्वारा स्वीकार की जाने वाली सबसे छोटी इकाई में है। इसलिए, दो सौ मिलियन पुनः जारी किए गए टोकन वास्तव में दो पूरे टोकन के बराबर हैं। यही बात प्रारंभिक मुफ्त सिक्कों की इकाई के लिए भी सही है।

हमारे नोड के वर्तमान Wallet बैलेंस की जांच करें।

```
e1-cli getwalletinfo
e2-cli getwalletinfo
```

हम देख सकते हैं कि प्रारंभिकरण सही तरीके से काम कर रहा है।

जब प्रारंभिक संपत्तियों का निर्माण किया जाता है, तो उन्हें 'कोई भी खर्च कर सकता है' के रूप में बनाया जाता है। इसलिए हम e1 को उन्हें सभी का दावा करने देंगे ताकि हम e2 की उन तक पहुंच हटा सकें।

```
e1-cli getnewaddress
e1-cli sendtoaddress <e1-address> 1000000 "" "" true
```

ध्यान दें कि हमें 'newasset' को भेजने वाली संपत्ति के रूप में निर्दिष्ट करने की आवश्यकता नहीं है क्योंकि यह पहले से ही default asset है। और इसलिए नेटवर्क शुल्क का भुगतान करने के लिए भी default asset का उपयोग किया जाता है।

Elements के अंदर, आप कई प्रकार की संपत्तियाँ एक ही Address को भेज सकते हैं, इसलिए हम अभी जो Address बनाया है, उसे फिर से उपयोग कर सकते हैं ताकि default asset प्राप्त कर सकें, और इसे पुनः जारी किए जाने वाले टोकन के लिए गंतव्य Address के रूप में उपयोग कर सकें।

```
e1-cli sendtoaddress <e1-address> 1 "" "" false false 1 UNSET false <reissuance-token-id>
```

लेन-देन की पुष्टि करें।

```
e1-cli generate 101
```

हम यह जांचेंगे कि e1 ही उस संपत्ति का एकमात्र धारक है और यह अब reissuance token है।

```
e1-cli getwalletinfo
e2-cli getwalletinfo
```

जो हम देख सकते हैं, वास्तव में ऐसा ही है।

अब हम 'newasset' का कुछ हिस्सा e2 को भेजेंगे, जिसके पास फिलहाल शून्य बैलेंस है।

```
e2-cli getnewaddress
e1-cli sendtoaddress <e2-address> 500 "" "" false
```

ध्यान दें कि हमें भेजे जाने वाले संपत्ति के प्रकार को निर्दिष्ट करने की आवश्यकता नहीं थी, क्योंकि `newasset` को नेटवर्क के default asset के रूप में बनाया गया है।

चलो `newasset` के कुछ पुनः जारीकरण टोकन e2 को भी भेज देते हैं।

```
e1-cli sendtoaddress <e2-address> 1 "" "" false false 1 UNSET false <reissuance-token-id>
```

लेन-देन की पुष्टि करें।

```
e1-cli generate 101
```

हम यह जांच सकते हैं कि वॉलेट्स ने सही तरीके से अपडेट हो गए हैं या नहीं।

```
e1-cli getwalletinfo
e2-cli getwalletinfo
```

अब हम e1 से कुछ default asset को फिर से जारी करेंगे। ध्यान दें कि ऐसा करने की क्षमता initialreissuancetokens स्टार्टअप पैरामीटर द्वारा सक्षम होती है। अगर इसे छोड़ दिया जाए या शून्य पर सेट किया जाए, तो इसका परिणाम यह होगा कि default asset को बाद में फिर से जारी नहीं किया जा सकता।

```
e1-cli reissueasset newasset 100
```

हम `newasset` लेबल का उपयोग कर पाए, बिना hex id मान देने की ज़रूरत के, क्योंकि एक Elements चेन हमेशा अपने default asset को लेबल करता है।

यह सुनिश्चित करना कि default asset का पुनः जारी होना सफल रहा:

```
e1-cli generate 101
e1-cli getwalletinfo
```

अब हम यह साबित करेंगे कि चूंकि e2 के पास कुछ `newasset` पुनः जारी करने वाले टोकन हैं, इसलिए वह default asset को भी पुनः जारी कर सकता है।

```
e2-cli reissueasset newasset 100
```

यह जांचना कि e2 द्वारा default asset का पुनः जारी होना सफल रहा।

```
e2-cli generate 101
e2-cli getwalletinfo
```

इस भाग में, हमने Elements को एक स्वतंत्र Blockchain के रूप में सेट किया है और यह सुनिश्चित किया है कि इसकी बुनियादी कार्यक्षमता हमारी उम्मीदों के अनुसार काम कर रही है।

हमने स्टार्टअप पैरामीटर्स का उपयोग इन उद्देश्यों के लिए किया:

एक नए Elements Blockchain को एक default asset के साथ 'newasset' नाम से प्रारंभ करें।

on chain की शुरुआत के लिए कितनी मात्रा में default asset की आवश्यकता है, यह बताएं।

default asset के लिए कुछ पुनः जारी करने वाले टोकन बनाएं और दोनों नोड्स से default asset को और अधिक पुनः जारी करें।

हमारे स्वतंत्र Blockchain Elements नेटवर्क पर, सभी अन्य लेन-देन संबंधी कार्य उसी तरह से संचालित होंगे जैसे कि कोर्स के मुख्य भागों में दिए गए उदाहरणों में बताया गया है। लेकिन यहाँ 'newasset' का उपयोग 'Bitcoin' के बजाय डिफ़ॉल्ट और शुल्क संपत्ति के रूप में किया जाएगा।

### नोड स्टार्टअप और चेन इनिशियलाइज़ेशन पैरामीटर्स

Elements नोड को एक स्वतंत्र Blockchain के रूप में काम करने के लिए कुछ विशेष पैरामीटर का उपयोग करना होता है। आइए अब हम इन पैरामीटरों को देखें और समझें कि वे क्या करते हैं।

#### `validatepegin=0` एक कोड या सेटिंग का हिस्सा लगता है। इसका हिंदी में अनुवाद करने की बजाय, इसे उसी रूप में समझना बेहतर होगा क्योंकि यह तकनीकी शब्दावली है।

Blockchain को अकेले काम करने के लिए किसी भी पेग-इन या पेग-आउट लेन-देन को मान्य करने की आवश्यकता नहीं होती है, इसलिए हमें उन जाँचों को बंद करना होगा। इस सेटिंग के साथ, आपको Bitcoin क्लाइंट सॉफ़्टवेयर चलाने या Bitcoin की एक प्रति Blockchain में रखने की आवश्यकता नहीं है, क्योंकि Elements नेटवर्क स्वतंत्र रूप से काम करेगा।

#### `डिफॉल्टपेग्डएसेटनाम`

यह आपको Blockchain के आरंभ होने पर बनाए गए default asset का नाम निर्दिष्ट करने की अनुमति देता है।

#### `initialfreecoins` का मतलब है "प्रारंभिक मुफ्त सिक्के"। यह आमतौर पर उन ऐप्स या गेम्स में उपयोग होता है जहां नए उपयोगकर्ताओं को शुरुआत में कुछ मुफ्त सिक्के दिए जाते हैं ताकि वे ऐप या गेम का अनुभव कर सकें।

default asset की संख्या (Bitcoin की Satoshi इकाई के समकक्ष) जो बनानी है।

#### `initialreissuancetokens` का हिंदी में अनुवाद होगा "प्रारंभिक पुनः जारीकरण टोकन"। यह शब्द तकनीकी संदर्भ में उपयोग होता है, जैसे कि ब्लॉकचेन या क्रिप्टोकरेंसी में, जहां टोकन को पुनः जारी किया जाता है।

default asset को बनाने के लिए Bitcoin की Satoshi यूनिट के बराबर जितने रीइश्यूअन्स टोकन की संख्या होती है, वह जरूरी है। इसके बिना default asset को और बनाना असंभव होगा। अगर आप नहीं चाहते कि default asset को और बनाया जा सके, तो इस संख्या को शून्य पर सेट कर सकते हैं या इसे छोड़ सकते हैं।

इन मानकों का उपयोग करते हुए, एक नोड शुरू करने का सामान्य तरीका कुछ इस प्रकार दिखेगा:

```
e1-dae -validatepegin=0 -defaultpeggedassetname=newasset -initialfreecoins=100000000000000 -initialreissuancetokens=200000000
```

### मूलभूत क्रियाएँ

`defaultpeggedassetname` पैरामीटर default asset को एक लेबल देता है। इस सेटिंग के बिना, default asset को स्वचालित रूप से `Bitcoin` नाम दिया जाएगा। पिछले सेक्शनों में, जब हमने खुद द्वारा जारी की गई संपत्तियों को किसी अन्य नोड पर भेजा, तो हमें या तो संपत्ति का हेक्स या स्थानीय रूप से लागू संपत्ति लेबल निर्दिष्ट करना पड़ता था ताकि Elements को पता चले कि हम कौन सी संपत्ति भेज रहे हैं। चूंकि `defaultpeggedassetname` सभी नोड्स पर लागू होता है, हमें इसे भेजते समय नाम देने की आवश्यकता नहीं होती, भले ही इसका नाम `Bitcoin` न हो। हर वह फंक्शन जो पहले डिफ़ॉल्ट रूप से `Bitcoin` भेजता था, अब वही भेजेगा जो आपने default asset को लेबल किया है।

तो 10 नए default asset को Address में भेजना उतना ही आसान है जितना कि:

```
e1-cli sendtoaddress <destination address> 10 "" "" true
```

यदि आपने `initialreissuancetokens` के लिए कोई मान दिया है जो शून्य से अधिक है, तो आप default asset के और टोकन फिर से जारी कर सकेंगे। यह कुछ ऐसा है जो संभव नहीं है यदि आप Elements को Sidechain के रूप में चलाते हैं।

इसको करने के लिए, default asset से जुड़े टोकन की कुछ मात्रा रखने वाला कोई भी नोड बस एक कमांड इस रूप में जारी कर सकता है:

```
e1-cli reissueasset <default asset name> <amount>
```

उपरोक्त पैरामीटर्स का उपयोग करके, आप Elements को एक स्वतंत्र Blockchain के रूप में चला सकते हैं, जिसमें इसका अपना default asset होगा, और यह Bitcoin और अन्य ब्लॉकचेन से अलग होगा।

## निष्कर्ष

<chapterId>7e2c916d-8114-424c-97f5-cbff9d73b8e3</chapterId>

![Video](https://youtu.be/CTMdamTZBBM?si=16LBcXvN4pBfC7lr)

इस पाठ्यक्रम में हमने सीखा है कि Elements एक ओपन-सोर्स नेटवर्क प्रोटोकॉल है जिसे Sidechain के रूप में दूसरे Blockchain के साथ या एक स्वतंत्र Blockchain समाधान के रूप में लागू किया जा सकता है।

हमने देखा है कि Elements का सोर्स कोड और वेबसाइट GitHub पर होस्ट किए गए हैं (https://github.com/ElementsProject/Elements) और कुछ सामुदायिक चर्चा मंच भी हैं, जैसे कि Build On L2 (https://community.Liquid.net/c/developers/) या Liquid Developers Telegram (https://t.me/liquid_devel), जिनका उपयोग Elements और Liquid पर एप्लिकेशन को तैनात और विकसित करने के बारे में अधिक जानने के लिए किया जा सकता है। मुख्य विशेषताएं जैसे Confidential Transactions और Issued Assets को कवर किया गया है, साथ ही यह भी बताया गया है कि Strong Federation के सदस्य कैसे फेडरेटेड block signing और 2-वे पेग मैकेनिज्म को सक्षम करते हैं।

अगला कदम है कि आप खुद को चुनौती दें एक समग्र क्विज़ के साथ जो सभी पिछले हिस्सों को कवर करता है, फिर अपनी Elements यात्रा शुरू करें...शुभकामनाएँ!

# निष्कर्ष

<partId>d5dbd616-e291-42bc-aae3-6c44599dbd06</partId>

## समीक्षाएँ और रेटिंग्स

<chapterId>beae23bd-2fd1-49fe-8f38-ed169acde51d</chapterId>

<isCourseReview>true</isCourseReview>
## निष्कर्ष

<chapterId>15f62056-c69c-467e-9565-af48d439a1f5</chapterId>

इस कोर्स को पूरा करने पर बधाई!

हम बहुत खुश हैं कि आपने अपनी सीखने की यात्रा में इस महत्वपूर्ण पड़ाव को सफलतापूर्वक पार कर लिया है। आपकी मेहनत और लगन के चलते आपने महत्वपूर्ण ज्ञान और कौशल हासिल किए हैं, जो आपके पेशेवर विकास में आपके लिए बहुत फायदेमंद साबित होंगे।