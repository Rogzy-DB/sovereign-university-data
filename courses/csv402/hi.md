---
name: RGB प्रोटोकॉल सिद्धांत से व्यवहार तक
goal: RGB को समझने और उपयोग करने के लिए आवश्यक कौशल प्राप्त करें।
objectives: 
  - RGB प्रोटोकॉल की मूलभूत अवधारणाओं को समझें
  - क्लाइंट-साइड सत्यापन और बिटकॉइन प्रतिबद्धताओं के सिद्धांतों में महारत हासिल करें
  - RGB अनुबंधों को बनाने, प्रबंधित करने और स्थानांतरित करने का तरीका जानें
  - RGB-संगत लाइटनिंग नोड को कैसे संचालित करें
---
# RGB प्रोटोकॉल की खोज करना

RGB की दुनिया में प्रवेश करें, जो एक प्रोटोकॉल है जिसे डिजिटल अधिकारों को लागू और सुनिश्चित करने के लिए डिज़ाइन किया गया है। यह Bitcoin और Blockchain के सहमति नियमों और संचालन के आधार पर अनुबंधों और संपत्तियों के रूप में होता है। यह व्यापक प्रशिक्षण पाठ्यक्रम आपको RGB की तकनीकी और व्यावहारिक नींवों के माध्यम से मार्गदर्शन करता है, जिसमें "Client-side Validation" और "सिंगल-यूज़ सील्स" की अवधारणाओं से लेकर उन्नत स्मार्ट अनुबंधों के कार्यान्वयन तक शामिल है।

एक संरचित, चरण-दर-चरण कार्यक्रम के माध्यम से, आप Client-side Validation के तंत्र, Bitcoin पर निश्चित प्रतिबद्धताओं और उपयोगकर्ताओं के बीच बातचीत के पैटर्न को जानेंगे। जानें कि कैसे Bitcoin या Lightning Network पर RGB टोकन बनाएं, प्रबंधित करें और स्थानांतरित करें।

चाहे आप एक डेवलपर हों, Bitcoin के शौकीन हों, या बस इस तकनीक के बारे में और जानने के इच्छुक हों, यह प्रशिक्षण कोर्स आपको RGB में महारत हासिल करने और Bitcoin पर नवीन समाधान बनाने के लिए आवश्यक उपकरण और ज्ञान प्रदान करेगा।

यह कोर्स Fulgur'Ventures द्वारा आयोजित एक लाइव सेमिनार पर आधारित है और इसे तीन प्रसिद्ध शिक्षकों और RGB विशेषज्ञों द्वारा सिखाया जाता है।

+++
# परिचय

<partId>c6f7a70f-d894-595f-8c0a-b54759778839</partId>

## कोर्स प्रस्तुति

<chapterId>cf2f087b-6c6b-5037-8f98-94fc9f1d7f46</chapterId>

नमस्ते सभी को, और इस प्रशिक्षण पाठ्यक्रम में आपका स्वागत है जो RGB पर केंद्रित है। यह एक क्लाइंट-साइड वैलिडेटेड Smart contract सिस्टम है जो Bitcoin और Lightning Network पर चलता है। इस पाठ्यक्रम की संरचना इस जटिल विषय की गहन खोज को सक्षम करने के लिए बनाई गई है। यहाँ बताया गया है कि यह पाठ्यक्रम कैसे संगठित है:

**अनुभाग 1: सिद्धांत

पहला भाग Client-side Validation और RGB की मूलभूत समझ के लिए आवश्यक सैद्धांतिक अवधारणाओं को समर्पित है। इस कोर्स में, आप जानेंगे कि RGB कई तकनीकी अवधारणाएं प्रस्तुत करता है जो आमतौर पर Bitcoin में नहीं देखी जातीं। इस भाग में, आपको RGB प्रोटोकॉल से संबंधित सभी विशेष शब्दों की परिभाषाएं देने वाली एक शब्दावली भी मिलेगी।

**अनुभाग 2: अभ्यास

दूसरा भाग पहले भाग में देखे गए सैद्धांतिक अवधारणाओं के अनुप्रयोग पर केंद्रित होगा। हम सीखेंगे कि RGB अनुबंध कैसे बनाएं और उन्हें कैसे प्रबंधित करें। हम यह भी देखेंगे कि इन उपकरणों के साथ प्रोग्रामिंग कैसे की जाती है। ये पहले दो भाग मैक्सिम ऑरलोव्स्की द्वारा प्रस्तुत किए जाएंगे।

**अनुभाग 3: अनुप्रयोग

अंतिम खंड में अन्य वक्ता होते हैं जो RGB आधारित ठोस अनुप्रयोगों को प्रस्तुत करते हैं, ताकि वास्तविक जीवन के उपयोग के मामलों को उजागर किया जा सके।

---
यह प्रशिक्षण पाठ्यक्रम मूल रूप से एक दो-सप्ताह के उन्नत विकास बूटकैंप से विकसित हुआ, जो वियारेज्जो, टस्कनी में [Fulgur'Ventures](https://fulgur.ventures/) द्वारा आयोजित किया गया था। पहले सप्ताह में, जो Rust और SDKs पर केंद्रित था, उसे इस अन्य पाठ्यक्रम में पाया जा सकता है:

https://planb.network/courses/9fbd8b57-f278-4304-8d88-a2d384eaff58
इस कोर्स में, हम बूटकैम्प के दूसरे हफ्ते पर ध्यान केंद्रित करते हैं, जो RGB पर केंद्रित है।

**सप्ताह 1 - LNP402:**

![RGB-Bitcoin](assets/fr/001.webp)

**सप्ताह 2 - वर्तमान प्रशिक्षण CSV402:**

![RGB-Bitcoin](assets/fr/002.webp)

इन लाइव कोर्स के आयोजकों और उन 3 शिक्षकों का बहुत-बहुत धन्यवाद जिन्होंने इसमें हिस्सा लिया।


- मैक्सिम ऑरलोव्स्की: *अंधकार से ज्ञान की रोशनी में तारों पर बुद्धिमान शासन करेगा। साइफर, एआई, रोबोटिक्स, ट्रांसह्यूमनिज्म। RGB, प्राइम, रेडिएंट और lnp_bp, mycitadel_io और cyphernet_io के निर्माता।*
- हंटर ट्रुजिलो: *डेवलपर, Rust, Bitcoin, लाइटनिंग, RGB* ;
- फेडेरिको टेंगा: *मैं दुनिया को Cypherpunk डिस्टोपिया में बदलने के लिए अपना योगदान दे रहा हूँ। फिलहाल Bitfinex पर RGB पर काम कर रहा हूँ*।

इस प्रशिक्षण पाठ्यक्रम के लिखित संस्करण को तैयार करने के लिए दो मुख्य संसाधनों का उपयोग किया गया था:


- लाइटनिंग बूटकैंप में मैक्सिम ऑरलोव्स्की, हंटर ट्रुजिलो और फेडेरिको टेंगा के सेमिनार के वीडियो;
- RGB दस्तावेज़, जिसका निर्माण [Bitfinex](https://www.bitfinex.com/) द्वारा प्रायोजित किया गया था।

# सिद्धांत में RGB

<partId>80e797ee-3f33-599f-ab82-e82eeee08219</partId>

## वितरित कंप्यूटिंग की अवधारणाओं का परिचय

<chapterId>f52f8af5-5d7c-588b-b56d-99b97176204b</chapterId>

![video](https://youtu.be/AF2XbifPGXM)

RGB एक प्रोटोकॉल है जिसे डिजिटल अधिकारों (जैसे अनुबंध और संपत्तियों) को बड़े पैमाने पर और गोपनीय तरीके से लागू और लागू करने के लिए डिज़ाइन किया गया है। यह Bitcoin और Blockchain के सहमति नियमों और संचालन पर आधारित है। इस पहले अध्याय का उद्देश्य RGB प्रोटोकॉल के आसपास के बुनियादी अवधारणाओं और शब्दावली को प्रस्तुत करना है, विशेष रूप से इसके निकट संबंधों को उजागर करना है, जैसे Client-side Validation और सिंगल-यूज़ सील्स जैसे बुनियादी वितरित कंप्यूटिंग अवधारणाओं के साथ।

इस अध्याय में, हम **वितरित सहमति प्रणालियों** की मूल बातें जानेंगे और देखेंगे कि RGB इस तकनीकी परिवार में कैसे फिट बैठता है। हम उन मुख्य सिद्धांतों का भी परिचय देंगे जो हमें यह समझने में मदद करते हैं कि RGB क्यों विस्तार योग्य और Bitcoin की अपनी सहमति प्रणाली से स्वतंत्र होने का लक्ष्य रखता है, जबकि आवश्यक होने पर उस पर निर्भर भी करता है।

### परिचय

वितरित कंप्यूटिंग, जो कंप्यूटर विज्ञान की एक विशेष शाखा है, उन प्रोटोकॉल का अध्ययन करती है जो सूचना को एक नेटवर्क के नोड्स पर प्रसारित और संसाधित करने के लिए उपयोग किए जाते हैं। ये नोड्स और प्रोटोकॉल नियम मिलकर जो बनाते हैं उसे वितरित प्रणाली कहा जाता है। ऐसी प्रणाली की कुछ मुख्य विशेषताएँ हैं:


- प्रत्येक नोड द्वारा कुछ डेटा की **स्वतंत्र सत्यापन और मान्यता** की क्षमता;
- नोड्स के लिए (प्रोटोकॉल के आधार पर) जानकारी का पूरा या आंशिक दृश्य बनाने की संभावना होती है। ये दृश्य वितरित प्रणाली की **स्थितियाँ** होती हैं।
- ऑपरेशनों का **कालानुक्रमिक क्रम** इस तरह से होता है कि डेटा को विश्वसनीय रूप से समय-चिह्नित किया जा सके और घटनाओं के क्रम (राज्यों के क्रम) पर एक सहमति हो।

विशेष रूप से, एक वितरित प्रणाली में **सहमति** की अवधारणा दो पहलुओं को शामिल करती है:


- राज्य परिवर्तनों की वैधता की पहचान (प्रोटोकॉल नियमों के अनुसार);
- इन राज्य परिवर्तनों के क्रम पर **समझौता** यह सुनिश्चित करता है कि एक बार सत्यापित किए गए कार्यों को बाद में फिर से लिखा या उलट नहीं जा सकता (इसे Bitcoin में "डबल-स्पेंड सुरक्षा" के रूप में भी जाना जाता है)।

पहली बार एक कार्यशील और बिना अनुमति के वितरित सहमति तंत्र को Satoshi नाकामोटो ने Bitcoin के साथ पेश किया, जो Blockchain डेटा संरचना और Proof-of-Work (PoW) एल्गोरिदम के संयुक्त उपयोग के कारण संभव हुआ। इस प्रणाली में, ब्लॉक इतिहास की विश्वसनीयता उन नोड्स (माइनर्स) द्वारा इसे समर्पित कंप्यूटिंग शक्ति पर निर्भर करती है। इसलिए, Bitcoin एक प्रमुख और ऐतिहासिक उदाहरण है एक वितरित सहमति प्रणाली का जो सभी के लिए खुला है (*बिना अनुमति के*)।

Blockchain और वितरित कंप्यूटिंग की दुनिया में, हम दो बुनियादी दृष्टिकोणों को पहचान सकते हैं: ***Blockchain*** पारंपरिक अर्थ में, और ***स्टेट चैनल्स***, जिसका सबसे अच्छा उदाहरण उत्पादन में Lightning Network है। Blockchain को समयानुसार क्रमबद्ध घटनाओं के रजिस्टर के रूप में परिभाषित किया जाता है, जिसे एक खुली, अनुमति-मुक्त नेटवर्क में सहमति द्वारा दोहराया जाता है। दूसरी ओर, स्टेट चैनल्स पीयर-टू-पीयर चैनल्स होते हैं जो दो (या अधिक) प्रतिभागियों को एक अद्यतन स्थिति off-chain बनाए रखने की अनुमति देते हैं, और ये Blockchain का उपयोग केवल इन चैनलों को खोलने और बंद करने के समय करते हैं।

Bitcoin के संदर्भ में, आप निश्चित रूप से Mining के सिद्धांतों से परिचित हैं, जैसे कि Blockchain पर लेन-देन का विकेंद्रीकरण और अंतिमता, और भुगतान चैनल कैसे काम करते हैं। अब RGB के साथ, हम एक नई अवधारणा **Client-side Validation** पेश कर रहे हैं, जो Blockchain या लाइटनिंग के विपरीत, स्थानीय रूप से (क्लाइंट-साइड) Smart contract की स्थिति परिवर्तन को संग्रहीत और सत्यापित करने में शामिल है। यह अन्य "DeFi" तकनीकों (_rollups_, _plasma_, _ARK_, आदि) से भी अलग है, क्योंकि Client-side Validation Double-spending को रोकने और एक समय-स्टैम्पिंग प्रणाली के लिए Blockchain पर निर्भर करता है, जबकि off-chain की अवस्थाओं और परिवर्तनों का रजिस्टर केवल संबंधित प्रतिभागियों के साथ रखता है।

![RGB-Bitcoin](assets/fr/003.webp)

बाद में, हम एक महत्वपूर्ण शब्द "**Stash**" का परिचय देंगे, जो उस क्लाइंट-साइड डेटा के सेट को संदर्भित करता है जो Contract की स्थिति को बनाए रखने के लिए आवश्यक होता है, क्योंकि यह डेटा नेटवर्क में वैश्विक रूप से प्रतिलिपि नहीं किया जाता है। अंत में, हम RGB के पीछे के तर्क को देखेंगे, जो Client-side Validation का लाभ उठाने वाला एक प्रोटोकॉल है, और यह क्यों मौजूदा तरीकों (Blockchain और स्टेट चैनल्स) के साथ मेल खाता है।

### वितरित कंप्यूटिंग में त्रिलेम्मा

यह समझने के लिए कि Client-side Validation और RGB की समस्याएँ, जिन्हें Blockchain और लाइटनिंग द्वारा हल नहीं किया गया, कैसे हैं, आइए वितरित कंप्यूटिंग में तीन प्रमुख "त्रिलेमाओं" को जानें:


- स्केलेबिलिटी, विकेंद्रीकरण, गोपनीयता।
- CAP प्रमेय (संगतता, उपलब्धता, विभाजन सहिष्णुता) ;
- CIA त्रिलेम्मा (गोपनीयता, अखंडता, उपलब्धता)।

#### 1. विस्तार क्षमता, विकेंद्रीकरण और गोपनीयता


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Blockchain बहुत विकेंद्रीकृत है, लेकिन यह बहुत अधिक स्केलेबल नहीं है। इसके अलावा, क्योंकि सब कुछ एक वैश्विक, सार्वजनिक रजिस्टर में है, गोपनीयता सीमित है। हम जीरो-नॉलेज तकनीकों (जैसे Confidential Transactions, मिम्बलविम्बल योजनाएं आदि) के साथ गोपनीयता को सुधारने की कोशिश कर सकते हैं, लेकिन सार्वजनिक चेन लेन-देन के ग्राफ को छिपा नहीं सकती।


- लाइटनिंग/स्टेट चैनल्स**

स्टेट चैनल (जैसे कि Lightning Network) अधिक स्केलेबल और अधिक निजी होते हैं Blockchain की तुलना में, क्योंकि लेन-देन off-chain पर होते हैं। हालांकि, कुछ Elements (फंडिंग लेन-देन, नेटवर्क टोपोलॉजी) को सार्वजनिक रूप से घोषित करने की बाध्यता और नेटवर्क ट्रैफिक की निगरानी गोपनीयता को आंशिक रूप से प्रभावित कर सकती है। विकेंद्रीकरण भी प्रभावित होता है: रूटिंग में अधिक नकदी की आवश्यकता होती है, और प्रमुख नोड्स केंद्रीकरण के बिंदु बन सकते हैं। यही वह घटना है जिसे हम लाइटनिंग पर देखना शुरू कर रहे हैं।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

यह नया दृष्टिकोण और भी अधिक स्केलेबल और गोपनीय है, क्योंकि हम न केवल शून्य-प्रकटीकरण ज्ञान-प्रमाण तकनीकों को एकीकृत कर सकते हैं, बल्कि कोई वैश्विक लेन-देन ग्राफ नहीं है, क्योंकि कोई भी पूरा रजिस्टर नहीं रखता। दूसरी ओर, यह विकेंद्रीकरण पर एक निश्चित समझौता भी दर्शाता है: Smart contract का जारीकर्ता एक केंद्रीय भूमिका निभा सकता है (जैसे Ethereum में "Contract डिप्लॉयर")। हालांकि, Blockchain के विपरीत, Client-side Validation के साथ, आप केवल उन्हीं अनुबंधों को संग्रहीत और सत्यापित करते हैं जिनमें आपकी रुचि है, जो सभी मौजूदा राज्यों को डाउनलोड और सत्यापित करने की आवश्यकता से बचकर स्केलेबिलिटी में सुधार करता है।

![RGB-Bitcoin](assets/fr/004.webp)

#### 2. CAP प्रमेय (संगतता, उपलब्धता, विभाजन सहिष्णुता)

CAP प्रमेय यह बताता है कि किसी वितरित प्रणाली के लिए एक साथ संगति (*Consistency*), उपलब्धता (*Availability*) और विभाजन सहिष्णुता (*Partition tolerance*) को पूरा करना असंभव है।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Blockchain प्रणाली स्थिरता और उपलब्धता को प्राथमिकता देती है, लेकिन नेटवर्क विभाजन के मामले में अच्छा प्रदर्शन नहीं करती: अगर आप किसी ब्लॉक को नहीं देख सकते, तो आप कार्य नहीं कर सकते और पूरे नेटवर्क के समान दृश्य नहीं प्राप्त कर सकते।


- बिजली** (फ्रेंच में)

एक राज्य चैनल प्रणाली में उपलब्धता और विभाजन सहनशीलता होती है (क्योंकि दो नोड्स एक-दूसरे से जुड़े रह सकते हैं, भले ही नेटवर्क खंडित हो जाए), लेकिन समग्र स्थिरता Blockchain पर चैनलों के खोलने और बंद करने पर निर्भर करती है।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

RGB जैसे सिस्टम में एकरूपता होती है (हर भागीदार अपने डेटा को स्थानीय रूप से सत्यापित करता है, बिना किसी अस्पष्टता के) और विभाजन सहनशीलता होती है (आप अपने डेटा को स्वतंत्र रूप से रखते हैं), लेकिन यह वैश्विक उपलब्धता की गारंटी नहीं देता है (हर किसी को यह सुनिश्चित करना होता है कि उनके पास इतिहास के संबंधित टुकड़े हैं, और कुछ भागीदार कुछ भी प्रकाशित नहीं कर सकते या कुछ जानकारी साझा करना बंद कर सकते हैं)।

![RGB-Bitcoin](assets/fr/005.webp)

#### 3. सीआईए त्रिलेम्मा (गोपनीयता, अखंडता, उपलब्धता)

यह त्रिलेम्मा हमें याद दिलाता है कि गोपनीयता, अखंडता और उपलब्धता को एक साथ पूरी तरह से अनुकूलित नहीं किया जा सकता। Blockchain, लाइटनिंग और Client-side Validation इस संतुलन में अलग-अलग तरीके से आते हैं। विचार यह है कि कोई भी एकल प्रणाली सब कुछ प्रदान नहीं कर सकती; एक सुसंगत पैकेज प्राप्त करने के लिए कई दृष्टिकोणों को मिलाना आवश्यक है, जो प्रत्येक आयाम में अच्छी गारंटी प्रदान करता है। जैसे Blockchain का समय-चिह्नन, लाइटनिंग का समकालिक दृष्टिकोण, और RGB के साथ स्थानीय सत्यापन।

![RGB-Bitcoin](assets/fr/006.webp)

### Blockchain की भूमिका और शार्डिंग की अवधारणा

Blockchain (इस मामले में, Bitcoin) मुख्य रूप से एक _समय-चिह्नित_ तंत्र और दोहरी खर्च से सुरक्षा के रूप में कार्य करता है। Smart contract या विकेंद्रीकृत प्रणाली के पूर्ण डेटा को शामिल करने के बजाय, हम केवल लेन-देन के लिए **क्रिप्टोग्राफिक प्रतिबद्धताएँ** (_प्रतिबद्धताएँ_) शामिल करते हैं (Client-side Validation के अर्थ में, जिसे हम "राज्य संक्रमण" कहेंगे)। इस प्रकार:


- हमने Blockchain को बड़ी मात्रा में डेटा और तर्क से मुक्त कर दिया है।
- प्रत्येक उपयोगकर्ता केवल अपने हिस्से के लिए आवश्यक इतिहास को Contract में संग्रहीत करता है (जिसे वह अपना "*Shard*" कहता है), बजाय इसके कि वह Global State की नकल करे।

शार्डिंग एक अवधारणा है जो वितरित डेटाबेस (जैसे कि फेसबुक या ट्विटर जैसे सोशल नेटवर्क्स के लिए MySQL) में उत्पन्न हुई। डेटा की मात्रा और समकालिकता विलंबता की समस्या को हल करने के लिए, डेटाबेस को _शार्ड्स_ (जैसे अमेरिका, यूरोप, एशिया आदि) में विभाजित किया जाता है। प्रत्येक खंड स्थानीय रूप से संगत होता है और अन्य के साथ केवल आंशिक रूप से समकालिक होता है।

RGB प्रकार के स्मार्ट कॉन्ट्रैक्ट्स के लिए, हम Shard का पालन करते हैं जो खुद कॉन्ट्रैक्ट्स के अनुसार होता है। हर Contract एक स्वतंत्र _शार्ड_ होता है। उदाहरण के लिए, अगर आपके पास केवल USDT टोकन हैं, तो आपको किसी अन्य टोकन जैसे USDC का पूरा इतिहास स्टोर या वैलिडेट करने की जरूरत नहीं है। Bitcoin पर, Blockchain _शार्डिंग_ नहीं करता है: आपके पास UTXOs का एक वैश्विक सेट होता है। Client-side Validation के साथ, हर प्रतिभागी केवल वही Contract डेटा रखता है जो वह उपयोग करता है या उसके पास होता है।

हम इस प्रकार से पारिस्थितिकी तंत्र की कल्पना कर सकते हैं:


- Blockchain (Bitcoin)** एक ऐसा आधार है जो एक न्यूनतम रजिस्टर की पूरी प्रतिकृति सुनिश्चित करता है और एक समय-स्टैम्पिंग Layer के रूप में कार्य करता है।
- Lightning Network** को तेज़ी से काम करने के लिए तैयार किया गया है, जबकि Confidential Transactions अभी भी Bitcoin और Blockchain की सुरक्षा और अंतिम निपटान पर आधारित है।
- RGB और Client-side Validation का उपयोग करके अधिक जटिल Smart contract लॉजिक जोड़ें, बिना Blockchain को उलझाए या गोपनीयता खोए।

![RGB-Bitcoin](assets/fr/007.webp)

ये तीन Elements एक त्रिकोणीय संरचना बनाते हैं, बजाय इसके कि वे "Layer 2", "Layer 3" आदि की एक सीधी कतार में हों। बिजली सीधे Bitcoin से जुड़ सकती है, या Bitcoin लेनदेन से संबंधित हो सकती है जो RGB डेटा को शामिल करते हैं। इसी तरह, "BiFi" उपयोग (Bitcoin पर वित्त) Blockchain के साथ, बिजली के साथ और RGB के साथ गोपनीयता, विस्तार क्षमता या Contract तर्क की जरूरतों के अनुसार संयोजित हो सकता है।

![RGB-Bitcoin](assets/fr/008.webp)

### राज्य परिवर्तन की अवधारणा

किसी भी वितरित प्रणाली में, सत्यापन तंत्र का उद्देश्य यह सुनिश्चित करना होता है कि **स्थिति परिवर्तनों की वैधता और कालानुक्रमिक क्रम** निर्धारित किया जा सके। इसका उद्देश्य यह जांचना होता है कि प्रोटोकॉल के नियमों का पालन किया गया है, और यह साबित करना होता है कि ये स्थिति परिवर्तन एक निश्चित, अडिग क्रम में एक-दूसरे के बाद आते हैं।

**Bitcoin** के संदर्भ में इस सत्यापन को कैसे समझा जाता है और सामान्य रूप से **Client-side Validation** के पीछे की सोच को समझने के लिए, पहले हम Bitcoin और Blockchain के तंत्र पर एक नज़र डालते हैं। इसके बाद हम देखेंगे कि Client-side Validation उनसे कैसे अलग है और यह कौन-कौन से सुधार संभव बनाता है।

![RGB-Bitcoin](assets/fr/009.webp)

Bitcoin और Blockchain के मामले में, लेन-देन की पुष्टि एक सरल नियम पर आधारित होती है:


- सभी नेटवर्क नोड्स हर ब्लॉक और लेन-देन को डाउनलोड करते हैं।
- वे इन लेन-देन को सत्यापित करते हैं ताकि यह सुनिश्चित किया जा सके कि UTXO सेट (सभी अप्रयुक्त आउटपुट) सही तरीके से विकसित हो रहा है।
- वे इस डेटा को (ब्लॉक्स के रूप में) इस तरह से स्टोर करते हैं ताकि ज़रूरत पड़ने पर इतिहास को फिर से देखा जा सके।

![RGB-Bitcoin](assets/fr/010.webp)

हालांकि, इस मॉडल में दो मुख्य कमियाँ हैं:


- स्केलेबिलिटी**: चूंकि हर नोड को सभी के लेन-देन को प्रोसेस, सत्यापित और संग्रहित करना होता है, इसलिए लेन-देन की क्षमता पर एक स्पष्ट सीमा होती है, जो विशेष रूप से अधिकतम ब्लॉक साइज से जुड़ी होती है (Bitcoin के लिए औसतन 10 मिनट में 1 MB, कुकीज़ को छोड़कर);
- गोपनीयता: सब कुछ सार्वजनिक रूप से प्रसारित और संग्रहीत किया जाता है (जैसे राशि, गंतव्य पते आदि), जो लेन-देन की गोपनीयता को सीमित करता है।

![RGB-Bitcoin](assets/fr/012.webp)

व्यवहार में, यह मॉडल Bitcoin के लिए Layer (Layer 1) के आधार के रूप में काम करता है, लेकिन यह अधिक जटिल उपयोगों के लिए अपर्याप्त हो सकता है, जो एक साथ उच्च लेन-देन की गति और एक निश्चित स्तर की गोपनीयता की आवश्यकता रखते हैं।

Client-side Validation एक विपरीत विचार पर आधारित है: इसमें पूरे नेटवर्क को सभी लेन-देन को सत्यापित और संग्रहीत करने की आवश्यकता नहीं होती है। इसके बजाय, प्रत्येक भागीदार (क्लाइंट) केवल उस इतिहास के हिस्से को सत्यापित करेगा जो उससे संबंधित है।


- जब कोई व्यक्ति एक संपत्ति (या कोई अन्य डिजिटल संपत्ति) प्राप्त करता है, तो उसे केवल उन क्रियाओं की श्रृंखला (स्थिति परिवर्तन) को जानना और सत्यापित करना होता है जो उस संपत्ति तक पहुंचाती हैं और उसकी वैधता को साबित करना होता है।
- यह संचालन की श्रृंखला, ***Genesis*** (प्रारंभिक मुद्दा) से लेकर सबसे हालिया लेन-देन तक, एक गैर-चक्रीय निर्देशित ग्राफ (DAG) या Shard बनाती है, यानी समग्र इतिहास का एक अंश।

![RGB-Bitcoin](assets/fr/013.webp)

उसी समय, ताकि नेटवर्क के बाकी हिस्से (या अधिक सटीक रूप से, Layer जैसे Bitcoin) इस डेटा के विवरण को देखे बिना अंतिम स्थिति को लॉक कर सकें, Client-side Validation ***Commitment*** की अवधारणा पर निर्भर करता है।

*Commitment* एक क्रिप्टोग्राफिक Commitment है, जो आमतौर पर एक _हैश_ (जैसे SHA-256) होता है, जिसे Bitcoin लेन-देन में डाला जाता है। यह साबित करता है कि निजी डेटा शामिल किया गया है, बिना इस डेटा को उजागर किए।

इन _प्रतिबद्धताओं_ के लिए धन्यवाद, हम यह साबित कर सकते हैं:


- जानकारी का अस्तित्व (क्योंकि यह Hash के लिए प्रतिबद्ध है);
- इस जानकारी की प्राथमिकता (क्योंकि यह Blockchain में दर्ज और समय-चिह्नित है, जिसमें तारीख और ब्लॉक क्रम शामिल है)।

हालांकि, सटीक सामग्री का खुलासा नहीं किया गया है, जिससे इसकी गोपनीयता बनी रहती है।

ठोस रूप से कहें तो, RGB और State Transition इस तरह काम करते हैं:


- आप एक नया State Transition तैयार करते हैं (जैसे कि RGB टोकन का स्थानांतरण);
- आप generate को एक क्रिप्टोग्राफिक Commitment में इस परिवर्तन के लिए प्रशिक्षित करते हैं और इसे Bitcoin लेनदेन में डालते हैं (इन प्रतिबद्धताओं को RGB प्रोटोकॉल में "*एंकर*" कहा जाता है);
- प्रतिपक्ष (प्राप्तकर्ता) इस संपत्ति से जुड़ी ग्राहक-पक्ष की इतिहास को प्राप्त करता है और Genesis से Smart contract तक की पूरी प्रक्रिया की सुसंगतता की जांच करता है, और उस बदलाव को सत्यापित करता है जिसे आप उसे भेजते हैं।

![RGB-Bitcoin](assets/fr/014.webp)

Client-side Validation दो मुख्य लाभ प्रदान करता है:


- स्केलेबिलिटी: **

Blockchain में शामिल प्रतिबद्धताएँ (*commitments*) बहुत छोटी होती हैं (कुछ दर्जन बाइट्स के आकार की)। इससे यह सुनिश्चित होता है कि ब्लॉक स्पेस भरा नहीं जाता, क्योंकि केवल Hash को शामिल करना होता है। यह off-chain प्रोटोकॉल को विकसित करने में भी मदद करता है, क्योंकि प्रत्येक उपयोगकर्ता को केवल अपनी इतिहास खंड (अपना _stash_) ही स्टोर करना होता है।


- गोपनीयता:

लेन-देन की जानकारी (यानी उनकी विस्तृत सामग्री) प्रकाशित नहीं की जाती है। केवल उनके फिंगरप्रिंट्स प्रकाशित होते हैं। इसलिए, राशि, पते और अन्य विवरण निजी रहते हैं, और प्राप्तकर्ता अपने लेन-देन की वैधता की जांच सभी पिछले लेन-देन को देखकर कर सकता है। प्राप्तकर्ता के लिए इस जानकारी को सार्वजनिक करने की कोई आवश्यकता नहीं होती, सिवाय विवाद की स्थिति में या जब प्रमाण की आवश्यकता हो।

RGB जैसे सिस्टम में, विभिन्न कॉन्ट्रैक्ट्स (या विभिन्न संपत्तियों) से होने वाले कई स्टेट ट्रांज़िशन को एकल Bitcoin ट्रांज़ैक्शन में एक _कमिटमेंट_ के माध्यम से जोड़ा जा सकता है। यह प्रक्रिया On-Chain ट्रांज़ैक्शन और off-chain डेटा (जो क्लाइंट-साइड पर सत्यापित ट्रांज़िशन होते हैं) के बीच एक निश्चित, समय-चिह्नित लिंक स्थापित करती है। इससे कई शार्ड्स को एक साथ एकल Anchor पॉइंट में रिकॉर्ड किया जा सकता है, जिससे On-Chain की लागत और आकार को और कम किया जा सकता है।

व्यवहार में, जब यह Bitcoin लेन-देन सत्यापित होता है, तो यह अंतर्निहित अनुबंधों की स्थिति को स्थायी रूप से "लॉक" कर देता है, क्योंकि Hash को जो पहले से ही Blockchain में दर्ज है, उसे संशोधित करना असंभव हो जाता है।

![RGB-Bitcoin](assets/fr/015.webp)

### Stash अवधारणा

**Stash** एक ऐसा सेट है जिसमें क्लाइंट-साइड डेटा होता है, जिसे एक प्रतिभागी को बिल्कुल सुरक्षित रखना होता है ताकि RGB Smart contract की अखंडता और इतिहास को बनाए रखा जा सके। यह एक लाइटनिंग चैनल से अलग है, जहां कुछ अवस्थाओं को साझा जानकारी से स्थानीय रूप से पुनर्निर्मित किया जा सकता है। RGB Contract के Stash को कहीं और प्रतिलिपि नहीं बनाया जाता है: अगर आप इसे खो देते हैं, तो कोई भी इसे आपके लिए पुनर्स्थापित नहीं कर पाएगा, क्योंकि आप अपने हिस्से के इतिहास के लिए जिम्मेदार हैं। इसलिए आपको RGB में एक विश्वसनीय बैकअप प्रक्रिया के साथ एक प्रणाली अपनाने की आवश्यकता है।

![RGB-Bitcoin](assets/fr/016.webp)

### Single-Use Seal: उत्पत्ति और संचालन

जब किसी संपत्ति जैसे मुद्रा को स्वीकार करते हैं, तो दो गारंटियाँ आवश्यक होती हैं:


- मिले हुए सामान की प्रामाणिकता;
- मिलने वाली वस्तु की विशिष्टता, ताकि दोहरी खर्च से बचा जा सके।

भौतिक संपत्तियों के लिए, जैसे कि एक बैंकनोट, उसकी भौतिक उपस्थिति यह साबित करने के लिए पर्याप्त होती है कि उसकी नकल नहीं की गई है। लेकिन डिजिटल दुनिया में, जहां संपत्तियां पूरी तरह से सूचनात्मक होती हैं, यह सत्यापन अधिक जटिल होता है, क्योंकि जानकारी आसानी से बढ़ सकती है और उसकी नकल की जा सकती है।

जैसा कि हमने पहले देखा, प्रेषक द्वारा राज्य परिवर्तन के इतिहास का खुलासा करने से हमें RGB टोकन की प्रामाणिकता सुनिश्चित करने में मदद मिलती है। Genesis लेन-देन के बाद से सभी लेन-देन की जानकारी होने पर, हम टोकन की प्रामाणिकता की पुष्टि कर सकते हैं। यह सिद्धांत Bitcoin के समान है, जहां सिक्कों के इतिहास को मूल Coinbase Transaction तक वापस ट्रेस किया जा सकता है ताकि उनकी वैधता की पुष्टि की जा सके। हालांकि, Bitcoin के विपरीत, RGB में राज्य परिवर्तन का यह इतिहास निजी होता है और इसे क्लाइंट साइड पर रखा जाता है।

Double-spending और RGB टोकन को रोकने के लिए, हम एक प्रणाली का उपयोग करते हैं जिसे "**Single-Use Seal**" कहा जाता है। यह प्रणाली सुनिश्चित करती है कि एक बार उपयोग किए गए टोकन को धोखाधड़ी से दोबारा इस्तेमाल नहीं किया जा सकता।

सिंगल-यूज़ सील्स क्रिप्टोग्राफिक प्रिमिटिव्स हैं, जिन्हें 2016 में पीटर टॉड द्वारा प्रस्तावित किया गया था। ये भौतिक सील्स के विचार के समान हैं: जैसे ही एक Seal को किसी कंटेनर पर लगाया जाता है, उसे खोले या संशोधित किए बिना इसे तोड़ना असंभव हो जाता है।

![RGB-Bitcoin](assets/fr/018.webp)

इस तरीके को जब डिजिटल दुनिया में लागू किया जाता है, तो यह साबित करना संभव हो जाता है कि घटनाओं की एक श्रृंखला वास्तव में घटित हुई है, और इसे बाद में बदला नहीं जा सकता। एक बार इस्तेमाल होने वाले सील्स इस तरह से `Hash + Timestamp` की साधारण सोच से आगे बढ़ते हैं, और एक Seal की अवधारणा जोड़ते हैं जिसे **केवल एक बार** बंद किया जा सकता है।

![RGB-Bitcoin](assets/fr/017.webp)

सिंगल-यूज़ सील्स के काम करने के लिए, आपको एक ऐसा माध्यम चाहिए जो किसी प्रकाशन के अस्तित्व या अनुपस्थिति को साबित कर सके, और जिसे एक बार जानकारी प्रसारित हो जाने के बाद बदलना मुश्किल (अगर असंभव नहीं) हो। **Blockchain** (जैसे Bitcoin) इस भूमिका को निभा सकता है, जैसे कि एक पेपर अखबार जो सार्वजनिक रूप से वितरित होता है। विचार कुछ इस प्रकार है:


- हम यह साबित करना चाहते हैं कि एक विशेष Commitment को संदेश `h(m)` पर एक दर्शक के सामने प्रकाशित किया गया है, बिना संदेश `m` की सामग्री को प्रकट किए।
- हम यह साबित करना चाहते हैं कि `h(m)` संदेश की जगह कोई और प्रतिस्पर्धी `h(m')` संदेश Commitment प्रकाशित नहीं हुआ है।
- हम यह भी सुनिश्चित करना चाहते हैं कि संदेश `m` एक निश्चित तारीख से पहले मौजूद है।

Blockchain इस भूमिका के लिए आदर्श रूप से उपयुक्त है: जैसे ही कोई लेन-देन एक ब्लॉक में शामिल होता है, पूरे नेटवर्क के पास उसके अस्तित्व और सामग्री का एक ऐसा प्रमाण होता है जिसे झुठलाया नहीं जा सकता (कम से कम आंशिक रूप से, क्योंकि _प्रतिबद्धता_ संदेश की प्रामाणिकता को साबित करते हुए विवरण छुपा सकती है)।

Single-Use Seal को इस प्रकार देखा जा सकता है कि यह एक औपचारिक वादा है कि एक संदेश (जो इस समय अज्ञात है) को एक बार और केवल एक बार प्रकाशित किया जाएगा, और इसे सभी इच्छुक पक्षों द्वारा सत्यापित किया जा सकता है।

साधारण _प्रतिबद्धताओं_ (Hash) या समय-चिह्नों के विपरीत, जो केवल अस्तित्व की तारीख की पुष्टि करते हैं, एक Single-Use Seal अतिरिक्त गारंटी देता है कि **कोई वैकल्पिक Commitment** सह-अस्तित्व में नहीं हो सकता: आप एक ही Seal को दो बार बंद नहीं कर सकते, या सील किए गए संदेश को बदलने का प्रयास नहीं कर सकते।

इस सिद्धांत को समझने के लिए निम्नलिखित तुलना मदद करती है:


- क्रिप्टोग्राफिक Commitment (Hash)**: Hash फंक्शन के साथ, आप किसी डेटा (जैसे एक संख्या) को उसके Hash को प्रकाशित करके सुरक्षित कर सकते हैं। डेटा तब तक गुप्त रहता है जब तक आप उसका प्री-इमेज नहीं दिखाते, लेकिन आप यह साबित कर सकते हैं कि आपको पहले से ही इसका पता था।
- Timestamp (Blockchain)**: इस Hash को Blockchain में डालकर, हम यह भी साबित करते हैं कि हमें यह एक विशेष क्षण में पता था (जब इसे एक ब्लॉक में शामिल किया गया था);
- Single-Use Seal**: एकल-उपयोग सील के साथ, हम Commitment को अद्वितीय बनाकर एक कदम आगे बढ़ते हैं। एकल Hash के साथ, आप समानांतर में कई विरोधाभासी प्रतिबद्धताएँ बना सकते हैं (जैसे डॉक्टर जो परिवार को "*यह लड़का है*" कहता है और अपनी निजी डायरी में "*यह लड़की है*" लिखता है)। Single-Use Seal इस संभावना को समाप्त करता है Commitment को एक प्रकाशन-सबूत माध्यम, जैसे Bitcoin Blockchain, से जोड़कर, ताकि UTXO का खर्च निश्चित रूप से Commitment को सील कर दे। एक बार खर्च हो जाने पर, वही UTXO को फिर से खर्च नहीं किया जा सकता है ताकि Commitment को बदला जा सके।

|                                                                                  | सरल Commitment (डाइजेस्ट/Hash) | समय चिह्न | एकल-उपयोग सील |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

| Commitment को प्रकाशित करने से संदेश का खुलासा नहीं होता है | हाँ | हाँ | हाँ |

| Commitment तारीख / एक निश्चित तारीख से पहले संदेश के अस्तित्व का प्रमाण | असंभव | संभव | संभव |

| यह प्रमाण कि कोई वैकल्पिक Commitment मौजूद नहीं हो सकता | असंभव | असंभव | संभव |

सिंगल-यूज़ सील्स तीन मुख्य चरणों में काम करती हैं:

**Seal Definition :**


- एलिस पहले से ही Seal के प्रकाशन के नियम तय करती है (कब, कहाँ और कैसे संदेश प्रकाशित किया जाएगा);
- बॉब इन शर्तों को स्वीकार या मानता है।

![RGB-Bitcoin](assets/fr/021.webp)

**Seal समापन:**


- रनटाइम पर, एलिस Seal को बंद करती है असली संदेश प्रकाशित करके (आमतौर पर एक _प्रतिबद्धता_ के रूप में, जैसे कि Hash);
- यह एक **गवाह** (क्रिप्टोग्राफिक प्रमाण) भी प्रदान करता है जो यह साबित करता है कि Seal बंद और अपरिवर्तनीय है।

![RGB-Bitcoin](assets/fr/019.webp)

**Seal सत्यापन:**


- जब Seal बंद हो जाता है, तो बॉब उसे फिर से नहीं खोल सकता: वह केवल यह जांच सकता है कि यह बंद हो चुका है।
- बॉब Seal, **गवाह** और संदेश (या उसका Commitment) इकट्ठा करता है ताकि यह सुनिश्चित किया जा सके कि सब कुछ मेल खाता है और कोई प्रतिस्पर्धी सील या अलग-अलग संस्करण नहीं हैं।

इस प्रक्रिया को निम्नलिखित रूप में संक्षेपित किया जा सकता है:

```txt
# Défini par Alice, validé ou accepté par Bob
seal <- Define()
# Fermeture du sceau par Alice avec le message
witness <- Close(seal, message)
# Vérification par Bob
bool <- Verify(seal, witness, message)
```

Client-side Validation एक कदम और आगे बढ़ता है: अगर Seal की परिभाषा खुद Blockchain के बाहर रहती है, तो (सिद्धांत रूप में) किसी के लिए उस Seal के अस्तित्व या वैधता को चुनौती देना संभव हो सकता है। इस समस्या को हल करने के लिए, एक श्रृंखला का उपयोग किया जाता है जिसमें आपस में जुड़े हुए एकल-उपयोग सील होते हैं।


- प्रत्येक बंद Seal में अगले Seal की परिभाषा शामिल होती है।
- हम इन बंदों (और उनके _प्रतिबद्धताओं_) को Blockchain में (Bitcoin लेनदेन के तहत) पंजीकृत करते हैं।
- इसलिए, Seal में किसी भी तरह का बदलाव करने की कोशिश Bitcoin में दर्ज इतिहास के खिलाफ होगी।

यही तो RGB सिस्टम करता है:


- प्रकाशित संदेश क्लाइंट-साइड द्वारा सत्यापित डेटा के लिए _प्रतिबद्धताएँ_ हैं।
- Seal Definition का संबंध Bitcoin और UTXO से है।
- Seal तब बंद हो जाता है जब UTXO खर्च हो जाता है या जब उसी Commitment में एक नया आउटपुट जमा होता है।
- इन UTXOs को खर्च करने वाली लेन-देन श्रृंखला प्रकाशन के प्रमाण से मेल खाती है: RGB पर हर परिवर्तन या स्थिति में बदलाव इस प्रकार Bitcoin में जुड़ा होता है।

संक्षेप में:


- _सील परिभाषा_ वह UTXO है जिसे आप भविष्य में Commitment के लिए Seal करना चाहते हैं;
- "_सील बंद करना_" तब होता है जब आप इस UTXO को खर्च करते हैं, जिससे एक लेन-देन बनता है जिसमें Commitment शामिल होता है।
- _गवाह_ खुद लेन-देन है, जो यह साबित करता है कि आपने इस सामग्री के साथ Seal को बंद कर दिया है।
- आप यह साबित नहीं कर सकते कि Seal बंद नहीं हुआ है (आप पूरी तरह से यह सुनिश्चित नहीं कर सकते कि UTXO पहले ही खर्च नहीं हो चुका है या किसी ऐसे ब्लॉक में खर्च नहीं होगा जिसे आपने अभी तक नहीं देखा है), लेकिन आप यह साबित कर सकते हैं कि यह वास्तव में बंद हो चुका है।

यह विशेषता Client-side Validation के लिए महत्वपूर्ण है: जब आप एक State Transition को सत्यापित करते हैं, तो आप यह सुनिश्चित करते हैं कि यह एक अद्वितीय UTXO से मेल खाता है, जो पहले किसी प्रतिस्पर्धी Commitment में खर्च नहीं हुआ है। यही वह चीज़ है जो off-chain स्मार्ट कॉन्ट्रैक्ट्स में दोहरी खर्च की अनुपस्थिति की गारंटी देती है।

### कई प्रतिबद्धताएँ और जड़ें

RGB और Smart contract को कई बार एक साथ कई Single-use Seals (कई UTXOs) का उपयोग करना पड़ सकता है। इसके अलावा, एक अकेला Bitcoin लेन-देन कई अलग-अलग अनुबंधों का संदर्भ दे सकता है, जिनमें से प्रत्येक अपने स्वयं के State Transition को सील करता है। इसके लिए एक **multi-Commitment** तंत्र की आवश्यकता होती है, जो यह साबित कर सके कि कोई भी प्रतिबद्धता डुप्लिकेट में मौजूद नहीं है। यहीं पर RGB में **Anchor** की अवधारणा आती है: एक विशेष संरचना जो एक Bitcoin लेन-देन और एक या अधिक क्लाइंट-साइड प्रतिबद्धताओं (राज्य संक्रमण) को जोड़ती है, जिनमें से प्रत्येक संभवतः एक अलग Contract से संबंधित हो सकता है। हम अगले अध्याय में इस अवधारणा पर और गहराई से नज़र डालेंगे।

![RGB-Bitcoin](assets/fr/023.webp)

इस परियोजना के दो मुख्य GitHub रिपॉजिटरी (LNPBP संगठन के अंतर्गत) उन बुनियादी कार्यान्वयनों को एक साथ लाते हैं जिनकी पहले अध्याय में अध्ययन किया गया है।


- client_side_validation** : स्थानीय सत्यापन के लिए Rust प्राइमिटिव्स शामिल हैं;
- **सिंगल यूज़ सील्स**: इन सील्स को सुरक्षित रूप से परिभाषित और बंद करने की प्रक्रिया को लागू करता है।

![RGB-Bitcoin](assets/fr/020.webp)

ध्यान दें कि ये सॉफ़्टवेयर ब्रिक्स Bitcoin पर निर्भर नहीं हैं; सिद्धांत रूप में, इन्हें किसी भी अन्य प्रकाशन प्रमाण माध्यम (जैसे कोई और रजिस्ट्री, जर्नल आदि) पर लागू किया जा सकता है। व्यवहार में, RGB अपनी मजबूती और व्यापक सहमति के लिए Bitcoin पर निर्भर करता है।

![RGB-Bitcoin](assets/fr/021.webp)

### जनता के सवाल

#### एकल-उपयोग सील के व्यापक उपयोग की ओर

पीटर टॉड ने _ओपन टाइमस्टैम्प्स_ प्रोटोकॉल भी बनाया था, और Single-Use Seal की अवधारणा इन विचारों का एक स्वाभाविक विस्तार है। RGB से आगे, अन्य उपयोग के मामले भी सोचे जा सकते हैं, जैसे कि _साइडचेन_ का निर्माण बिना _मर्ज माइनिंग_ या ड्राइवचेन से संबंधित प्रस्तावों जैसे BIP300 का सहारा लिए। कोई भी सिस्टम जिसे एकल Commitment की आवश्यकता होती है, सिद्धांत रूप में, इस क्रिप्टोग्राफिक प्रिमिटिव का उपयोग कर सकता है। आज, RGB पहला प्रमुख पूर्ण पैमाने पर कार्यान्वयन है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Client-side Validation में, हर उपयोगकर्ता अपने हिस्से का इतिहास खुद स्टोर करता है, इसलिए डेटा की उपलब्धता वैश्विक स्तर पर सुनिश्चित नहीं होती। अगर कोई Contract जारीकर्ता कुछ जानकारी छुपा लेता है या वापस ले लेता है, तो आपको ऑफर के वास्तविक विकास के बारे में पता नहीं चल सकता। कुछ मामलों में (जैसे स्थिर मुद्रा), जारीकर्ता से उम्मीद की जाती है कि वह सार्वजनिक डेटा बनाए रखे ताकि प्रचलन में मात्रा को साबित किया जा सके, लेकिन ऐसा करने की कोई तकनीकी बाध्यता नहीं है। इसलिए, यह संभव है कि जानबूझकर अपारदर्शी अनुबंध डिज़ाइन किए जाएं जिनमें असीमित Supply हो, जिससे विश्वास के सवाल उठते हैं।

#### शार्डिंग और Contract अलगाव

प्रत्येक Contract एक अलग _शार्ड_ का प्रतिनिधित्व करता है: उदाहरण के लिए, USDT और USDC को अपनी इतिहास साझा करने की ज़रूरत नहीं होती। एटॉमिक स्वैप्स अभी भी संभव हैं, लेकिन इसके लिए उनके रजिस्टरों को मिलाने की आवश्यकता नहीं होती। यह सब क्रिप्टोग्राफिक Commitment द्वारा किया जाता है, बिना प्रत्येक प्रतिभागी को पूरा इतिहास ग्राफ़ दिखाए।

### निष्कर्ष

हमने देखा है कि Client-side Validation का विचार Blockchain और _स्टेट चैनल्स_ के साथ कैसे मेल खाता है, यह वितरित कंप्यूटिंग की त्रिलेमाओं का कैसे जवाब देता है, और यह Bitcoin Blockchain का अनोखे तरीके से उपयोग कैसे करता है ताकि Double-spending से बचा जा सके और *टाइम-स्टैम्पिंग* के लिए। यह विचार **Single-Use Seal** की अवधारणा पर आधारित है, जो ऐसे अनोखे प्रतिबद्धताओं का निर्माण करने में सक्षम बनाता है जिन्हें आप मनमाने ढंग से फिर से खर्च नहीं कर सकते। इस तरह, प्रत्येक प्रतिभागी केवल वही इतिहास अपलोड करता है जो सख्ती से आवश्यक है, जिससे स्मार्ट कॉन्ट्रैक्ट्स की स्केलेबिलिटी और गोपनीयता बढ़ती है, जबकि Bitcoin की सुरक्षा को पृष्ठभूमि के रूप में बनाए रखता है।

अगला कदम यह होगा कि हम विस्तार से समझाएं कि यह Single-Use Seal मैकेनिज्म Bitcoin में (UTXOs के माध्यम से) कैसे लागू होता है, एंकर कैसे बनाए और सत्यापित किए जाते हैं, और फिर RGB में पूर्ण स्मार्ट कॉन्ट्रैक्ट्स कैसे तैयार किए जाते हैं। विशेष रूप से, हम कई प्रतिबद्धताओं के मुद्दे पर ध्यान देंगे, और यह तकनीकी चुनौती कि कैसे एक Bitcoin लेन-देन विभिन्न कॉन्ट्रैक्ट्स में कई स्टेट ट्रांजिशन्स को एक साथ सील करता है, बिना किसी कमजोरी या दोहरी प्रतिबद्धताओं को पेश किए।

दूसरे अध्याय के तकनीकी विवरणों में जाने से पहले, आप चाहें तो मुख्य परिभाषाओं (Client-side Validation, Single-Use Seal, एंकर आदि) को फिर से पढ़ सकते हैं और समग्र तर्क को ध्यान में रखें: हम Bitcoin और Blockchain की ताकतों (सुरक्षा, विकेंद्रीकरण, समय-चिह्नन) को off-chain समाधानों (गति, गोपनीयता, विस्तार क्षमता) के साथ मिलाने की कोशिश कर रहे हैं, और यही RGB और Client-side Validation हासिल करने की कोशिश कर रहे हैं।

## Commitment और Layer

<chapterId>cc2fe85a-9cc7-5b8c-a00a-c0a867241061</chapterId>

![video](https://youtu.be/FS6PDprWl5Q)

इस अध्याय में, हम Client-side Validation और सिंगल-यूज़ सील्स के Bitcoin Blockchain के भीतर कार्यान्वयन को देखेंगे। हम RGB के मुख्य सिद्धांतों को प्रस्तुत करेंगे, विशेष रूप से **TxO2** योजना पर ध्यान केंद्रित करते हुए, जिसे RGB एक Bitcoin लेन-देन में Seal को परिभाषित और बंद करने के लिए उपयोग करता है। इसके बाद, हम दो महत्वपूर्ण बिंदुओं पर चर्चा करेंगे जिन्हें अभी तक विस्तार से नहीं कवर किया गया है:


- _निश्चित Bitcoin प्रतिबद्धताएँ_;
- मल्टी-प्रोटोकॉल प्रतिबद्धताएँ।

इन अवधारणाओं का संयोजन हमें यह सक्षम बनाता है कि हम कई सिस्टम या अनुबंधों को एक ही UTXO और इसलिए एक ही Blockchain पर सुपरइम्पोज़ कर सकें।

यह याद रखना चाहिए कि जो क्रिप्टोग्राफिक ऑपरेशन्स बताए गए हैं, उन्हें अन्य ब्लॉकचेन या प्रकाशन माध्यमों पर भी लागू किया जा सकता है। लेकिन Bitcoin की विशेषताएँ (जैसे विकेंद्रीकरण, सेंसरशिप के प्रति प्रतिरोध और सभी के लिए खुलापन) इसे उन्नत प्रोग्रामेबिलिटी विकसित करने के लिए आदर्श आधार बनाती हैं, जैसे कि **RGB** के लिए आवश्यक है।

### Commitment योजनाएँ Bitcoin में और उनका उपयोग RGB द्वारा

जैसा कि हमने पाठ्यक्रम के पहले अध्याय में देखा, सिंगल-यूज़ सील्स एक सामान्य अवधारणा है: हम एक लेन-देन के विशेष स्थान पर Commitment (_प्रतिबद्धता_) शामिल करने का वादा करते हैं, और यह स्थान एक संदेश पर बंद होने वाले Seal की तरह कार्य करता है। हालांकि, Bitcoin Blockchain पर, इस _प्रतिबद्धता_ को रखने के लिए कई विकल्प होते हैं।

तर्क को समझने के लिए, आइए बुनियादी सिद्धांत को याद करें: एक _सिंगल-यूज़ सील_ को बंद करने के लिए, हम दिए गए संदेश पर _प्रतिबद्धता_ डालकर सील किए गए क्षेत्र को खर्च करते हैं। Bitcoin में, इसे कई तरीकों से किया जा सकता है:


- आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं। सार्वजनिक कुंजी या Address** का उपयोग करें।

हम यह तय कर सकते हैं कि कोई विशेष सार्वजनिक कुंजी या Address एक _एकल-उपयोग मुहर_ है। जैसे ही यह कुंजी या Address किसी लेन-देन में On-Chain के साथ दिखाई देती है, इसका मतलब है कि Seal एक निश्चित संदेश के साथ बंद हो गया है।


- आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं। Bitcoin** लेन-देन के आउटपुट का उपयोग करें।

इसका मतलब है कि एक _सिंगल-यूज़ सील_ को एक सटीक _आउटपॉइंट_ (txid + आउटपुट नंबर जोड़ी) के रूप में परिभाषित किया गया है। जैसे ही यह _आउटपॉइंट_ खर्च हो जाता है, Seal बंद हो जाता है।

RGB पर काम करते समय, हमने कम से कम 4 अलग-अलग तरीके पहचाने जिनसे इन सील्स को Bitcoin पर लागू किया जा सकता है:


- Seal को एक सार्वजनिक कुंजी के माध्यम से परिभाषित करें, और इसे एक _आउटपुट_ में बंद करें;
- Seal को एक _आउटपॉइंट_ के साथ परिभाषित करें और इसे एक _आउटपुट_ के साथ बंद करें।
- Seal को एक सार्वजनिक कुंजी के मूल्य के माध्यम से परिभाषित करें, और इसे _इनपुट_ में बंद करें।
- Seal को एक _आउटपॉइंट_ के माध्यम से परिभाषित करें, और इसे एक _इनपुट_ में बंद करें।

| Schema नाम | Seal Definition           | Seal समापन               | अतिरिक्त आवश्यकताएँ                                            | मुख्य आवेदन                 | संभावित Commitment योजनाएँ     |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

| PkO         | सार्वजनिक कुंजी मूल्य     | लेन-देन आउटपुट           | P2(W)PKH                                                       | फिलहाल कोई नहीं             | कीट्वीक, टैपट्वीक, ऑपरेट       |

| TxO2        | लेन-देन आउटपुट        | लेन-देन आउटपुट        | Bitcoin पर निश्चित प्रतिबद्धताओं की आवश्यकता है                  | RGBv1 (सार्वभौमिक)           | कीट्वीक, टैप्रेट, ऑपरेट         |

| PkI         | सार्वजनिक कुंजी मूल्य     | लेन-देन इनपुट            | केवल Taproot और पुराने वॉलेट्स के साथ संगत नहीं              | Bitcoin आधारित पहचानें     | सिगट्वीक, विट्वीक               |

| TxO1        | लेन-देन आउटपुट          | लेन-देन इनपुट            | केवल Taproot के लिए और पुराने वॉलेट्स के साथ संगत नहीं है | फिलहाल कोई नहीं            | सिगट्वीक, विट्वीक               |

हम इन सभी विन्यासों के बारे में विस्तार से नहीं बताएंगे, क्योंकि RGB में हमने Seal की परिभाषा के रूप में **एक _आउटपॉइंट_ का उपयोग करने** का निर्णय लिया है, और इस _आउटपॉइंट_ को खर्च करने वाले लेन-देन के आउटपुट में _प्रतिबद्धता_ को रखने का निर्णय लिया है। इसलिए, हम आगे के लिए निम्नलिखित अवधारणाओं को प्रस्तुत कर सकते हैं:


- "Seal Definition" **: एक दिए गए _आउटपॉइंट_ (जिसकी पहचान txid + आउटपुट नंबर से होती है);
- "Seal बंद हो रहा है"**: यह लेन-देन उस _आउटपॉइंट_ को खर्च करता है, जिसमें एक _प्रतिबद्धता_ संदेश में जोड़ी जाती है।

इस योजना को RGB आर्किटेक्चर के साथ संगतता के लिए चुना गया है, लेकिन अन्य उपयोगों के लिए अन्य विन्यास भी उपयोगी हो सकते हैं।

"TxO2" में "O2" हमें यह याद दिलाता है कि परिभाषा और समापन दोनों ही लेन-देन के आउटपुट के खर्च (या निर्माण) पर आधारित हैं।

### TxO2 आरेख का उदाहरण

याद दिलाने के लिए, एक _सिंगल-यूज़ सील_ को परिभाषित करने के लिए जरूरी नहीं है कि On-Chain लेन-देन को प्रकाशित किया जाए। उदाहरण के लिए, अगर एलिस के पास पहले से ही एक अप्रयुक्त UTXO है, तो यह काफी है। वह तय कर सकती है: "यह _आउटपॉइंट_ (जो पहले से मौजूद है) अब मेरा Seal है"। वह इसे स्थानीय रूप से (_क्लाइंट-साइड_) नोट कर लेती है, और जब तक यह UTXO खर्च नहीं होता, तब तक Seal को खुला माना जाता है।

![RGB-Bitcoin](assets/fr/024.webp)

जिस दिन यह Seal को बंद करना चाहता है (किसी घटना का संकेत देने के लिए, या Anchor को कोई विशेष संदेश देने के लिए), यह UTXO को एक नई लेन-देन में खर्च करता है। इस लेन-देन को अक्सर "_गवाह लेन-देन_" कहा जाता है (यह _सेगविट_ से संबंधित नहीं है, यह बस एक शब्द है जो हम इसे देते हैं)। इस नई लेन-देन में संदेश के प्रति _प्रतिबद्धता_ शामिल होगी।

![RGB-Bitcoin](assets/fr/025.webp)

ध्यान दें कि इस उदाहरण में:


- इस लेन-देन में एक खास संदेश छुपा है, यह बात सिर्फ बॉब को या उन लोगों को पता होगी जिन्हें एलिस खुद पूरी जानकारी देने का फैसला करेगी।
- हर कोई देख सकता है कि _आउटपॉइंट_ खर्च हो चुका है, लेकिन केवल बॉब के पास यह सबूत है कि संदेश वास्तव में लेन-देन में जुड़ा हुआ है।

इस TxO2 योजना को समझाने के लिए, हम एक _एकल-उपयोग सील_ का उपयोग कर सकते हैं जो PGP कुंजी को रद्द करने का तरीका है। सर्वरों पर रद्दीकरण प्रमाणपत्र प्रकाशित करने के बजाय, एलिस कह सकती है: "यदि यह Bitcoin आउटपुट खर्च किया जाता है, तो इसका मतलब है कि मेरी PGP कुंजी रद्द कर दी गई है"।

एलिस के पास एक विशेष UTXO है, जिसके साथ एक विशेष स्थिति या डेटा जुड़ा हुआ है, जो केवल उसे ही पता है और यह स्थानीय रूप से (क्लाइंट साइड पर) संग्रहीत है।

एलिस बॉब को बताती है कि अगर यह UTXO खर्च किया जाता है, तो एक विशेष घटना को घटित माना जाएगा। बाहर से देखने पर, हमें सिर्फ एक Bitcoin लेन-देन दिखाई देता है; लेकिन बॉब जानता है कि इस खर्च का एक छुपा हुआ मतलब है।

![RGB-Bitcoin](assets/fr/026.webp)

जब एलिस UTXO का उपयोग करती है, तो वह Seal पर एक संदेश छोड़ती है जो उसके नए कुंजी की जानकारी देता है, या बस पुराने कुंजी के रद्दीकरण की सूचना देता है। इस तरह, जो भी On-Chain की निगरानी कर रहा है, वह देखेगा कि UTXO का उपयोग हो चुका है, लेकिन केवल वही लोग जिनके पास पूरा प्रमाण है, जान पाएंगे कि यह वास्तव में PGP कुंजी का रद्दीकरण है।

![RGB-Bitcoin](assets/fr/027.webp)

बॉब या किसी और को छुपा हुआ संदेश जांचने के लिए, एलिस को उसे off-chain जानकारी देनी होगी।

![RGB-Bitcoin](assets/fr/028.webp)

इसलिए एलिस को बॉब को यह प्रदान करना होगा:


- संदेश खुद (जैसे, नया PGP कुंजी);
- क्रिप्टोग्राफिक प्रमाण कि संदेश लेन-देन में शामिल था (जिसे _अतिरिक्त लेन-देन प्रमाण_ या _एंकर_ कहा जाता है)।

![RGB-Bitcoin](assets/fr/029.webp)

तीसरे पक्ष के पास यह जानकारी नहीं होती है। वे केवल यह देख सकते हैं कि एक UTXO खर्च किया गया है। इसलिए गोपनीयता सुनिश्चित की जाती है।

संरचना को स्पष्ट करने के लिए, चलिए इस प्रक्रिया को दो लेन-देन में संक्षेपित करते हैं:


- लेन-देन 1**: इसमें _सील परिभाषा_ शामिल है, यानी _आउटपॉइंट_ जो Seal के रूप में काम करेगा।

![RGB-Bitcoin](assets/fr/031.webp)


- लेन-देन 2**: इस _आउटपॉइंट_ को खर्च करता है। इससे Seal बंद हो जाता है और उसी लेन-देन में संदेश पर _प्रतिबद्धता_ डाल दी जाती है।

![RGB-Bitcoin](assets/fr/033.webp)

इसलिए हम दूसरी लेन-देन को "_गवाह लेन-देन_" कहते हैं।

इसको एक और दृष्टिकोण से समझाने के लिए, हम दो स्तरों को दर्शा सकते हैं:


- आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं। शीर्ष Layer (Blockchain, सार्वजनिक)**: हर कोई लेन-देन देखता है और जानता है कि एक _आउटपॉइंट_ खर्च किया गया है;
- निचला Layer (क्लाइंट-साइड, निजी)** : केवल एलिस (या संबंधित व्यक्ति) को पता होता है कि यह खर्च किस संदेश से संबंधित है, क्रिप्टोग्राफिक प्रमाण और वह संदेश जो वह स्थानीय रूप से रखती है, के माध्यम से।

![RGB-Bitcoin](assets/fr/034.webp)

लेकिन जब Seal को बंद किया जा रहा है, तो सवाल उठता है कि _प्रतिबद्धता_ को कहाँ डाला जाना चाहिए।

पिछले भाग में, हमने संक्षेप में बताया कि Client-side Validation मॉडल को RGB और अन्य प्रणालियों पर कैसे लागू किया जा सकता है। यहाँ, हम **निश्चित Bitcoin प्रतिबद्धताओं** के बारे में बात करेंगे और उन्हें लेन-देन में कैसे जोड़ा जाए। विचार यह समझने का है कि हम _गवाह लेन-देन_ में एकल Commitment क्यों डालने की कोशिश कर रहे हैं, और सबसे महत्वपूर्ण यह सुनिश्चित करना है कि कोई अन्य अघोषित प्रतिस्पर्धी प्रतिबद्धताएँ न हो सकें।

### लेन-देन में Commitment स्थानों का उल्लेख

जब आप किसी को यह प्रमाण देते हैं कि कोई विशेष संदेश एक लेन-देन में समाहित है, तो आपको यह सुनिश्चित करने की आवश्यकता होती है कि उसी लेन-देन में Commitment (एक दूसरा, छुपा हुआ संदेश) का कोई और रूप नहीं है जो आपको नहीं दिखाया गया है। Client-side Validation को मजबूत बनाए रखने के लिए, आपको एक **निश्चित** तंत्र की आवश्यकता होती है जो लेन-देन में एकल _प्रतिबद्धता_ को स्थापित करता है जो _एकल-उपयोग सील_ को बंद करता है।

_गवाह लेन-देन_ प्रसिद्ध UTXO (या _सील परिभाषा_) को खर्च करता है और यह खर्च Seal के समापन के अनुरूप होता है। तकनीकी रूप से कहें तो, हम जानते हैं कि प्रत्येक आउटपॉइंट को केवल एक बार ही खर्च किया जा सकता है। यही बात Bitcoin की डबल खर्च करने के खिलाफ प्रतिरोध को मजबूत करती है। लेकिन खर्च करने वाली लेन-देन में कई _इनपुट_, कई _आउटपुट_ हो सकते हैं, या यह जटिल तरीके से बनी हो सकती है (जैसे कि कॉइनजॉइन, लाइटनिंग चैनल आदि)। इसलिए हमें इस संरचना में _प्रतिबद्धता_ को स्पष्ट रूप से और समान रूप से कहां डालना है, यह परिभाषित करने की आवश्यकता है।

चाहे जो भी तरीका हो (PkO, TxO2, आदि), _प्रतिबद्धता_ को डाला जा सकता है:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
    - Sigtweak** (ECDSA हस्ताक्षर के `r` घटक को संशोधित करता है, जैसे "Sign-to-Contract" सिद्धांत) ;
    - Witweak** (लेन-देन के _विभाजित गवाह_ डेटा को संशोधित किया जाता है)।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
    - Keytweak** (प्राप्तकर्ता की सार्वजनिक कुंजी को संदेश के साथ "बदल" दिया जाता है);
    - आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
    - Tapret (या _Taptweak_) एक प्रक्रिया है जो Taproot का उपयोग करके Commitment को Taproot कुंजी के स्क्रिप्ट भाग में डालती है, जिससे सार्वजनिक कुंजी को निश्चित रूप से संशोधित किया जाता है।

![RGB-Bitcoin](assets/fr/035.webp)

यहाँ प्रत्येक विधि के विवरण दिए गए हैं:

![RGB-Bitcoin](assets/fr/038.webp)

***सिग ट्वीक (साइन-टू-Contract) :***

पहले की एक योजना में हस्ताक्षर (ECDSA या Schnorr) के रैंडम हिस्से का उपयोग करके _प्रतिबद्धता_ को शामिल करना शामिल था: इसे "**Sign-to-Contract**" तकनीक के रूप में जाना जाता है। आप रैंडमली जनरेट किए गए Nonce को Hash से बदल देते हैं जिसमें डेटा होता है। इस तरह, हस्ताक्षर आपके Commitment को बिना किसी अतिरिक्त स्थान के लेन-देन में प्रकट कर देता है। इस दृष्टिकोण के कई फायदे हैं:


- On-Chain का अधिक लोड नहीं होना चाहिए (आप इसे उसी जगह इस्तेमाल करें जैसे कि बेसिक Nonce)।
- सिद्धांत रूप में, यह काफी अलग हो सकता है, क्योंकि Nonce शुरू में एक यादृच्छिक डेटा है।

हालांकि, दो मुख्य कमियाँ सामने आई हैं:


- Multisig से पहले Taproot: जब आपके पास कई हस्ताक्षरकर्ता होते हैं, तो आपको यह तय करना होता है कि कौन सा हस्ताक्षर _प्रतिबद्धता_ को पूरा करेगा। हस्ताक्षरों को अलग-अलग क्रम में रखा जा सकता है, और अगर कोई हस्ताक्षरकर्ता मना कर देता है, तो आप _प्रतिबद्धता_ के परिणाम पर नियंत्रण खो देते हैं।
- MuSig और साझा Nonce: Schnorr Multisig (*MuSig*) के साथ, Nonce का निर्माण एक बहुपक्षीय एल्गोरिदम है, और इसे व्यक्तिगत रूप से बदलना लगभग असंभव हो जाता है।

व्यवहार में, **सिग ट्वीक** मौजूदा हार्डवेयर (जैसे हार्डवेयर वॉलेट) और फॉर्मेट्स (जैसे लाइटनिंग) के साथ बहुत संगत नहीं है। इसलिए इस बेहतरीन विचार को अमल में लाने के लिए Hard है।

***मुख्य बदलाव (पे-टू-Contract) :***

मुख्य बदलाव ऐतिहासिक अवधारणा _pay-to-contract_ को अपनाता है। हम सार्वजनिक कुंजी `X` लेते हैं और इसे `H(message)` मान जोड़कर बदलते हैं। विशेष रूप से, यदि `X = x * G` और `h = H(message)` है, तो नई कुंजी `X' = X + h * G` होगी। यह बदली गई कुंजी `message` के लिए Commitment को छुपाती है। मूल निजी कुंजी के धारक, अपनी निजी कुंजी `x` में `h` जोड़कर, यह साबित कर सकते हैं कि उनके पास आउटपुट खर्च करने की कुंजी है। सिद्धांत रूप में, यह सुरुचिपूर्ण है, क्योंकि:


- प्रतिबद्धता बिना किसी अतिरिक्त फ़ील्ड जोड़े दर्ज की जाती है;
- आप कोई अतिरिक्त On-Chain डेटा स्टोर नहीं करते हैं।

हालांकि, व्यवहार में हमें निम्नलिखित कठिनाइयों का सामना करना पड़ता है:


- वॉलेट अब मानक सार्वजनिक कुंजी को नहीं पहचानते हैं, क्योंकि इसे "बदल" दिया गया है, इसलिए वे आसानी से UTXO को आपकी सामान्य कुंजी के साथ नहीं जोड़ सकते हैं।
- हार्डवेयर वॉलेट इस तरह से नहीं बनाए जाते हैं कि वे किसी ऐसे कुंजी के साथ साइन कर सकें जो उनके मानक व्युत्पत्ति से नहीं निकली हो।
- आपको अपने स्क्रिप्ट्स, विवरण आदि को अनुकूलित करने की आवश्यकता है।

RGB के संदर्भ में, इस रास्ते की योजना 2021 तक बनाई गई थी, लेकिन यह वर्तमान मानकों और बुनियादी ढांचे के साथ काम करने के लिए बहुत जटिल साबित हुआ।

***गवाह में बदलाव :***

एक और विचार, जिसे कुछ प्रोटोकॉल जैसे _inscriptions Ordinals_ ने लागू किया है, वह यह है कि डेटा को सीधे लेन-देन के `witness` सेक्शन में रखा जाए (इसलिए इसे "witness tweak" कहा जाता है)। हालांकि, यह तरीका:


- सगाई को तुरंत दिखाई देने योग्य बनाता है (आप सचमुच कच्चे डेटा को गवाह में चिपका देते हैं);
- यह सेंसरशिप के अधीन हो सकता है (यदि यह बहुत बड़ा है या किसी अन्य मनमाने विशेषता के कारण, तो खनिक या नोड्स इसे प्रसारित करने से मना कर सकते हैं);
- यह ब्लॉक्स में जगह घेरता है, जो RGB के गोपनीयता और हल्केपन के उद्देश्य के विपरीत है।

इसके अलावा, गवाह को कुछ संदर्भों में काट-छांट करने योग्य बनाया गया है, जिससे मजबूत प्रमाण रखना और भी जटिल हो सकता है।

***ओपन-रिटर्न (ओप्रेट) :***

`OP_RETURN` का संचालन बहुत ही सरल है। यह आपको एक Hash या संदेश को लेन-देन के एक विशेष क्षेत्र में संग्रहीत करने की अनुमति देता है। लेकिन यह तुरंत पता चल जाता है: हर कोई देख सकता है कि लेन-देन में एक _प्रतिबद्धता_ है, और इसे सेंसर या हटा भी सकते हैं, साथ ही अतिरिक्त आउटपुट भी जोड़ सकते हैं। चूंकि इससे पारदर्शिता और आकार बढ़ता है, इसे Client-side Validation समाधान के दृष्टिकोण से कम संतोषजनक माना जाता है।

```txt
34-byte_Opret_Commitment =
OP_RETURN   OP_PUSHBYTE_32   <mpc::Commitment>
|_________| |______________| |_________________|
1-byte       1-byte         32 bytes
```

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

अंतिम विकल्प **Taproot** का उपयोग है (जो BIP341 के साथ पेश किया गया है) *Tapret* योजना के साथ। *Tapret* एक अधिक जटिल रूप है जो निर्धारक Commitment का है, जो Blockchain पर प्रभाव को कम करता है और Contract ऑपरेशनों के लिए गोपनीयता में सुधार लाता है। मुख्य विचार यह है कि Commitment को [Taproot लेनदेन](https://github.com/Bitcoin/bips/blob/master/bip-0341.mediawiki) के `Script Path Spend` भाग में छिपाया जाए।

![RGB-Bitcoin](assets/fr/036.webp)

Commitment को Taproot लेन-देन में कैसे डाला जाता है, यह बताने से पहले, चलिए Commitment के **सटीक रूप** पर नज़र डालते हैं। यह **अनिवार्य रूप से** 64-बाइट स्ट्रिंग के रूप में होना चाहिए, जो इस प्रकार [निर्मित](https://github.com/BP-WG/bp-core/blob/master/dbc/src/tapret/mod.rs#L179-L196) होती है:

```txt
64-byte_Tapret_Commitment =
OP_RESERVED ...  ... .. OP_RESERVED   OP_RETURN   OP_PUSHBYTE_33  <mpc::Commitment>  <Nonce>
|___________________________________| |_________| |______________| |_______________|  |______|
OP_RESERVED x 29 times = 29 bytes      1 byte         1 byte          32 bytes        1 byte
|________________________________________________________________| |_________________________|
TAPRET_SCRIPT_COMMITMENT_PREFIX = 31 bytes                    MPC commitment + NONCE = 33 bytes
```


- 29 बाइट्स `OP_RESERVED`, उसके बाद `OP_RETURN`, फिर `OP_PUSHBYTE_33`, मिलकर 31-बाइट का _प्रारंभिक_ हिस्सा बनाते हैं।
- इसके बाद आता है 32-बाइट का _कमिटमेंट_ (आमतौर पर **MPC** से Merkle Root), जिसमें हम 1 बाइट का **Nonce** जोड़ते हैं (इस दूसरे हिस्से के लिए कुल 33 बाइट्स)।

तो 64-बाइट का `Tapret` मेथड एक `Opret` जैसा दिखता है, जिसमें हमने 29 बाइट्स का `OP_RESERVED` पहले जोड़ा है और एक अतिरिक्त बाइट Nonce के रूप में जोड़ी है।

लचीलापन बनाए रखने के लिए, कार्यान्वयन, गोपनीयता और विस्तार के मामले में, टापरेट योजना विभिन्न उपयोग मामलों को ध्यान में रखती है, जो आवश्यकताओं पर निर्भर करते हैं।


- Tapret Commitment को Taproot लेनदेन में अनोखे तरीके से शामिल करना, बिना किसी पहले से मौजूद स्क्रिप्ट पाथ संरचना के;
- Tapret Commitment को एक Taproot लेन-देन में जोड़ना, जो पहले से ही एक स्क्रिप्ट पाथ से लैस है।

आइए इन दोनों स्थितियों पर करीब से नज़र डालते हैं।

#### टैप्रेट इंकॉरपोरेशन बिना मौजूदा स्क्रिप्ट पथ के

इस पहले मामले में, हम Taproot आउटपुट कुंजी (*Taproot Output Key*) `Q` से शुरू करते हैं, जिसमें केवल आंतरिक सार्वजनिक कुंजी `P` (*Internal Key*) होती है, और इसके साथ कोई स्क्रिप्ट पथ (*Script Path*) नहीं जुड़ा होता है।

![RGB-Bitcoin](assets/fr/047.webp)


- `P`: _Key Path Spend_ के लिए आंतरिक सार्वजनिक कुंजी।
- `G`: एलिप्टिक कर्व [secp256k1](https://en.Bitcoin.it/wiki/Secp256k1) का जनरेटिंग पॉइंट है।
- `t = tH_TWEAK(P)` एक ट्वीक फैक्टर है, जिसे एक _टैग्ड हैश_ (जैसे `SHA-256(SHA-256(TapTweak) || P)`) के माध्यम से गणना की जाती है, जैसा कि [BIP86](https://github.com/Bitcoin/bips/blob/master/bip-0086.mediawiki#Address-derivation) में बताया गया है। यह साबित करता है कि कोई छुपी हुई स्क्रिप्ट नहीं है।

**Tapret** Commitment को शामिल करने के लिए, एक **स्क्रिप्ट पाथ स्पेंड** जोड़ें जिसमें एक **अद्वितीय स्क्रिप्ट** हो, इस प्रकार:

![RGB-Bitcoin](assets/fr/048.webp)


- `t = tH_TWEAK(P || Script_root)` अब नया ट्वीक फैक्टर बन जाता है, जिसमें **Script_root** शामिल है।
- `Script_root = tH_BRANCH(64-byte_Tapret_Commitment)` इस **स्क्रिप्ट** की जड़ को दर्शाता है, जो कि एक प्रकार का Hash है। यह `SHA-256(SHA-256(TapBranch) || 64-byte_Tapret_Commitment)` के रूप में होता है।

Taproot पेड़ में समावेश और विशिष्टता का प्रमाण यहाँ एकल आंतरिक सार्वजनिक कुंजी `P` पर निर्भर करता है।

#### टैप्रेट को पहले से मौजूद स्क्रिप्ट पाथ में कैसे जोड़ा जाए

दूसरा परिदृश्य एक अधिक जटिल `Q` Taproot** आउटपुट से संबंधित है, जिसमें पहले से ही कई स्क्रिप्ट्स शामिल हैं। उदाहरण के लिए, हमारे पास 3 स्क्रिप्ट्स का एक पेड़ है:

![RGB-Bitcoin](assets/fr/049.webp)


- `tH_LEAF(x)` एक पत्ते की स्क्रिप्ट के सामान्यीकृत टैग किए गए Hash फ़ंक्शन को दर्शाता है।
- a, B, C` वे स्क्रिप्ट्स हैं जो पहले से ही Taproot संरचना में शामिल हैं।

Tapret Commitment को जोड़ने के लिए, हमें पेड़ के पहले स्तर पर एक *अव्ययनीय स्क्रिप्ट* डालनी होगी, जिससे मौजूदा स्क्रिप्ट्स एक स्तर नीचे खिसक जाएंगी। देखने में, पेड़ कुछ इस तरह दिखेगा:

![RGB-Bitcoin](assets/fr/050.webp)


- `tHABC` शीर्ष स्तर के समूह `A, B, C` के टैग किए गए Hash का प्रतिनिधित्व करता है।
- `tHT` स्क्रिप्ट के Hash का प्रतिनिधित्व करता है, जो 64-बाइट के `Tapret` से संबंधित है।

Taproot नियमों के अनुसार, प्रत्येक शाखा/पत्ती को एक वर्णानुक्रमिक Hash क्रम में जोड़ा जाना चाहिए। इसके दो संभावित मामले हैं:


- `tHT` > `tHABC`: Tapret Commitment पेड़ के दाईं ओर चलता है। विशिष्टता का प्रमाण केवल `tHABC` और `P` की आवश्यकता है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। tHT < tHABC: Tapret Commitment को बाईं ओर रखा गया है। यह साबित करने के लिए कि दाईं ओर कोई और Tapret Commitment नहीं है, tHAB और tHC को उजागर करना होगा ताकि यह दिखाया जा सके कि ऐसा कोई और स्क्रिप्ट मौजूद नहीं है।

पहले मामले के लिए दृश्य उदाहरण (`tHABC < tHT`):

![RGB-Bitcoin](assets/fr/051.webp)

दूसरे मामले के उदाहरण के लिए (`tHABC > tHT`):

![RGB-Bitcoin](assets/fr/052.webp)

#### Nonce के साथ अनुकूलन

गोपनीयता को बेहतर बनाने के लिए, हम `<Nonce>` के मूल्य को "माइन" कर सकते हैं (अधिक सटीक शब्द होगा "ब्रूटफोर्सिंग")। यह 64-बाइट `Tapret` का अंतिम बाइट है, जिसे हम इस प्रयास में करते हैं कि हमें Hash `tHT` प्राप्त हो सके ताकि `tHABC < tHT` हो। इस स्थिति में, Commitment को दाईं ओर रखा जाता है, जिससे उपयोगकर्ता को मौजूदा स्क्रिप्ट्स की पूरी सामग्री को प्रकट किए बिना Tapret की विशिष्टता साबित करने में मदद मिलती है।

संक्षेप में, `Tapret` एक स्पष्ट और निश्चित तरीका प्रदान करता है जिससे Commitment को Taproot लेन-देन में शामिल किया जा सकता है, जबकि RGB के Client-side Validation और Single-Use Seal तर्क के लिए आवश्यक विशिष्टता और स्पष्टता की आवश्यकता का सम्मान किया जाता है।

#### मान्य निकास

RGB और Commitment लेन-देन के लिए, एक वैध Bitcoin Commitment योजना की मुख्य आवश्यकता इस प्रकार है: लेन-देन (*Witness Transaction*) में एकल Commitment होना चाहिए, जिसे प्रमाणित किया जा सके। इस आवश्यकता के कारण, एक ही लेन-देन के भीतर ग्राहक-पक्ष द्वारा सत्यापित डेटा के लिए एक वैकल्पिक इतिहास बनाना असंभव हो जाता है। इसका मतलब है कि जिस संदेश के चारों ओर _सिंगल-यूज़ सील_ बंद होती है, वह अद्वितीय होता है।

इस सिद्धांत को पूरा करने के लिए, और लेन-देन में आउटपुट की संख्या चाहे जितनी भी हो, हम यह सुनिश्चित करते हैं कि **केवल एक और सिर्फ एक आउटपुट** में Commitment (*Commitment*) हो सकता है। जिन योजनाओं का उपयोग किया जाता है (*Opret* या *Tapret*), उनके लिए केवल वही आउटपुट मान्य हैं जिनमें RGB _प्रतिबद्धता_ हो सकती है:


- *Opret* योजना के लिए पहला आउटपुट `OP_RETURN` (यदि मौजूद हो);
- *Tapret* योजना के लिए पहला Taproot आउटपुट (यदि मौजूद हो)।

ध्यान दें कि यह पूरी तरह से संभव है कि एक लेन-देन में दो अलग-अलग आउटपुट में एक `Opret` Commitment और एक `Tapret` Commitment शामिल हो। Seal Definition की निर्धारक प्रकृति के कारण, ये दो प्रतिबद्धताएँ फिर क्लाइंट साइड पर सत्यापित किए गए दो अलग-अलग डेटा टुकड़ों से मेल खाती हैं।

### RGB में विश्लेषण और व्यावहारिक विकल्प

जब हमने RGB शुरू किया, तो हमने इन सभी तरीकों की समीक्षा की ताकि यह तय कर सकें कि किसी लेन-देन में _प्रतिबद्धता_ को एक निश्चित तरीके से कहाँ और कैसे रखा जाए। हमने कुछ मानदंड तय किए:


- विभिन्न परिस्थितियों के साथ संगतता (जैसे Multisig, लाइटनिंग, हार्डवेयर वॉलेट, आदि);
- On-Chain अंतरिक्ष पर प्रभाव;
- कार्यान्वयन और रखरखाव की कठिनाई;
- गोपनीयता और सेंसरशिप के प्रति प्रतिरोध।

| विधि                                               | On-Chain ट्रेस और आकार | क्लाइंट-साइड आकार | Wallet एकीकरण | हार्डवेयर संगतता | लाइटनिंग संगतता | Taproot संगतता |

| -------------------------------------------------- | --------------------- | ---------------- | ------------------ | ---------------------- | ---------------------- | --------------------- |

| कीट्वीक (निर्धारित P2C)                           | 🟢                     | 🟡                 | 🔴                   | 🟠                     | 🔴 Bolt, 🔴 बिफ्रोस्ट     | 🟠 Taproot, 🟢 म्यूसिग  |

| सिगट्वीक (निर्धारित S2C)                         | 🟢                     | 🟢                 | 🟠                   | 🔴                     | 🔴 Bolt, 🔴 बिफ्रोस्ट     | 🟠 Taproot, 🔴 म्यूसिग  |

| ओप्रेट (OP_RETURN)                                | 🔴                     | 🟢                 | 🟢                   | 🟠                     | 🔴 Bolt, 🟠 बिफ्रोस्ट   | -                     |

| टापरेट एल्गोरिदम: ऊपर-बाएँ नोड | 🟠 | 🔴 | 🟠 | 🟢 | 🔴 Bolt, 🟢 बिफ्रोस्ट | 🟢 Taproot, 🟢 म्यूसिग |

आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं। 

| टापरेट एल्गोरिदम #4: कोई भी नोड + प्रमाण | 🟢 | 🟠 | 🟠 | 🟢 | 🔴 Bolt, 🟢 बिफ्रोस्ट | 🟢 Taproot, 🟢 म्यूसिग |

| निर्धारक Commitment योजना                               | मानक       | On-Chain लागत                                                                                                          | ग्राहक पक्ष पर प्रमाण का आकार                                                                                       |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

| कीट्वीक (निर्धारित P2C)                                  | LNPBP-1, 2     | 0 बाइट्स                                                                                                                | 33 बाइट्स (गैर-ट्वीक की)                                                                                       |

| सिगट्वीक (निर्धारित S2C)                                  | कार्य प्रगति पर (LNPBP-39) | 0 बाइट्स                                                                                                                | 0 बाइट्स                                                                                                          |

| ओप्रेट (OP_RETURN)                                             | -              | 36 (v)बाइट्स (अतिरिक्त TxOut)                                                                                         | 0 बाइट्स                                                                                                          |

टैप्रेट एल्गोरिदम: ऊपर-बाएँ नोड | LNPBP-6 | किसी भी n-of-m Multisig के लिए गवाह में 32 बाइट्स (8 वर्चुअल बाइट्स) और स्क्रिप्ट पथ के माध्यम से खर्च करना | स्क्रिप्टलेस स्क्रिप्ट्स Taproot पर 0 बाइट्स ~एकल स्क्रिप्ट मामले में लगभग 270 बाइट्स, ~यदि कई स्क्रिप्ट्स हैं तो 128 बाइट्स |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

टैप्रेट एल्गोरिदम #4: किसी भी नोड + विशिष्टता प्रमाण | LNPBP-6 | एकल स्क्रिप्ट मामलों के लिए गवाह में 32 बाइट्स (8 वर्चुअल बाइट्स), अधिकांश अन्य मामलों में गवाह में 0 बाइट्स | स्क्रिप्टलेस स्क्रिप्ट्स Taproot पर 0 बाइट्स, जब तक टैपट्री में दर्जन भर स्क्रिप्ट्स नहीं होतीं, तब तक 65 बाइट्स |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

| **प्रकार**                     | **टैप्रेट**                  | **टैप्रेट #4**               | **कीट्वीक**                  | **सिगट्वीक**                 | **ओप्रेट**                   | **टैप्रेट**              | **टैप्रेट #4**           | **कीट्वीक**              | **सिगट्वीक**             | **ओप्रेट**               |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। 

MuSig (n-of-n) के लिए तालिका में दिए गए आंकड़े इस प्रकार हैं: 
- पहले चार कॉलम में 0 है।
- पाँचवें कॉलम में 32 है।
- छठे से आठवें कॉलम में 0 है।
- नौवें कॉलम में 32 है।
- दसवें कॉलम में ? > 0 है।
- ग्यारहवें कॉलम में 0 है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

| multi-sig 3-का-5               | 32/8                         | 32/8 या 0                    | 0                            | लागू नहीं                    | 32                           | ~340                     | 65                       | 32                       | लागू नहीं                | 0                        |

| multi-sig 2-का-3 टाइमआउट के साथ | 32/8                         | 0                            | 0                            | लागू नहीं                     | 32                           | 64                       | 65                       | 32                       | लागू नहीं                 | 0                        |

आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं।

| -------------------------------- | ---------------------- | ---------------------- | ---------------------- | ------------------------ | ------------------------ |

| **प्रकार**                      | **आधार**              | **टैप्रेट #2**         | **टैप्रेट #4**         | **टैप्रेट #2**           | **टैप्रेट #4**           |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

| फ्रॉस्ट (n-of-m)                | ?                      | 0                      | 0                      | 0                        | 0                        |

| Multi_a (n-of-m)                 | 1+16n+8m               | 8                      | 8                      | 33 * m                   | 65                       |

| शाखा MuSig / Multi_a (n-of-m)  | 1+16n+8n+8xlog(n)      | 8                      | 0                      | 64                       | 65                       |

| टाइमआउट्स (n-of-m) के साथ       | 1+16n+8n+8xlog(n)      | 8                      | 0                      | 64                       | 65                       |

| विधि                                      | गोपनीयता और विस्तारशीलता | अंतरसंचालनीयता | संगतता | पोर्टेबिलिटी | जटिलता |

| ----------------------------------------- | ---------------------- | ---------------- | ------------- | ----------- | ---------- |

| कीट्वीक (निर्धारित P2C)                  | 🟢                      | 🔴               | 🔴            | 🟡          | 🟡         |

| सिगट्वीक (निर्धारित S2C)                  | 🟢                      | 🔴               | 🔴            | 🟢          | 🔴         |

| ओप्रेट (OP_RETURN)                         | 🔴                      | 🟠               | 🔴            | 🟢          | 🟢         |

| एल्गो टेपरेट: ऊपर-बाएँ कोना | 🟠 | 🟢 | 🟢 | 🔴 | 🟠 |

| एल्गो टेपरेट #4: कोई भी नोड + प्रमाण | 🟢                      | 🟢               | 🟢            | 🟠          | 🔴         |

अध्ययन के दौरान यह स्पष्ट हो गया कि Commitment योजनाओं में से कोई भी वर्तमान लाइटनिंग मानक के साथ पूरी तरह से संगत नहीं थी (जो Taproot, _muSig2_ या अतिरिक्त _प्रतिबद्धता_ समर्थन का उपयोग नहीं करता)। लाइटनिंग के चैनल निर्माण (*BiFrost*) को संशोधित करने के प्रयास जारी हैं ताकि RGB प्रतिबद्धताओं को शामिल किया जा सके। यह एक और क्षेत्र है जहां हमें लेन-देन की संरचना, कुंजियों और चैनल अपडेट के हस्ताक्षर करने के तरीके की समीक्षा करने की आवश्यकता है।

विश्लेषण से पता चला कि वास्तव में, अन्य तरीकों (जैसे कि कुंजी में बदलाव, हस्ताक्षर में बदलाव, गवाह में बदलाव आदि) ने अन्य प्रकार की जटिलताएँ पेश कीं।


- या तो हमारे पास एक बड़ा On-Chain वॉल्यूम है;
- या तो मौजूदा Wallet कोड के साथ एक बुनियादी असंगति है;
- या तो समाधान गैर-सहकारी Multisig में संभव नहीं है।

RGB के लिए, दो विशेष तरीके उभर कर सामने आते हैं: ***Opret*** और ***Tapret***। दोनों को "लेन-देन आउटपुट" के रूप में वर्गीकृत किया गया है और ये प्रोटोकॉल द्वारा उपयोग किए जाने वाले TxO2 मोड के साथ संगत हैं।

### मल्टी प्रोटोकॉल कमिटमेंट्स - एमपीसी

इस खंड में, हम देखते हैं कि **RGB** कैसे एकल Commitment (*Commitment*) के भीतर कई अनुबंधों (या, अधिक सटीक रूप से, उनके _ट्रांज़िशन बंडल्स_) के समेकन को एक निर्धारक योजना के माध्यम से संभालता है (जैसा कि `Opret` या `Tapret` के अनुसार)। इसे प्राप्त करने के लिए, विभिन्न अनुबंधों का मर्केलाइजेशन एक संरचना में होता है जिसे **MPC ट्री** (_मल्टी प्रोटोकॉल Commitment ट्री_) कहा जाता है। इस खंड में, हम इस MPC ट्री के निर्माण, इसकी जड़ को कैसे प्राप्त करें, और कैसे कई अनुबंध एक ही लेनदेन को गोपनीय और स्पष्ट रूप से साझा कर सकते हैं, इस पर चर्चा करेंगे।

Multi Protocol Commitment (MPC) को दो आवश्यकताओं को पूरा करने के लिए डिज़ाइन किया गया है:


- `mpc::Commitment` Hash का निर्माण: इसे Bitcoin Blockchain में `Opret` या `Tapret` योजना के अनुसार शामिल किया जाएगा, और इसमें सभी राज्य परिवर्तनों को दर्शाना होगा ताकि उन्हें सत्यापित किया जा सके।
- एक ही _प्रतिबद्धता_ में कई अनुबंधों का एक साथ भंडारण, जिससे कई संपत्तियों या RGB अनुबंधों पर अलग-अलग अपडेट को एक ही Bitcoin लेनदेन में प्रबंधित किया जा सके।

सीधे शब्दों में कहें तो, प्रत्येक _transition bundle_ एक विशेष Contract से संबंधित होता है। यह सारी जानकारी एक **MPC Tree** में डाली जाती है, जिसकी जड़ (`mpc::Root`) को फिर से हैश किया जाता है ताकि `mpc::Commitment` प्राप्त हो सके। यह अंतिम Hash है जिसे Bitcoin लेन-देन (_witness transaction_) में रखा जाता है, जो कि चुनी गई निश्चित विधि के अनुसार होता है।

![RGB-Bitcoin](assets/fr/042.webp)

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

जो मूल्य वास्तव में On-Chain (`Opret` या `Tapret` में) लिखा गया है, उसे `mpc::Commitment` कहा जाता है। इसे [BIP-341](https://github.com/Bitcoin/bips/blob/master/bip-0341.mediawiki) के रूप में, निम्नलिखित सूत्र के अनुसार, गणना किया जाता है:

```txt
mpc::Commitment = SHA-256(SHA-256(mpc_tag) || SHA-256(mpc_tag) || depth || cofactor || mpc::Root )
```

आपका प्रशिक्षण अक्टूबर 2023 तक के डेटा पर आधारित है।


- `mpc_tag` एक टैग है: `urn:ubideco:mpc:Commitment#2024-01-31`, जिसे [RGB टैगिंग नियमों](https://github.com/RGB-WG/RGB-core/blob/master/doc/Commitments.md) के अनुसार चुना गया है।
- `depth` (1 बाइट) *MPC ट्री* की गहराई को दर्शाता है;
- कोफैक्टर (16 बिट्स, लिटिल एंडियन में) एक पैरामीटर है जिसका उपयोग पेड़ में प्रत्येक Contract को असाइन की गई स्थितियों की विशिष्टता को बढ़ावा देने के लिए किया जाता है।
- `mpc::Root` *MPC ट्री* की जड़ है, जिसे अगले खंड में वर्णित प्रक्रिया के अनुसार गणना की जाती है।

![RGB-Bitcoin](assets/fr/044.webp)

#### एमपीसी ट्री निर्माण

इस MPC ट्री को बनाने के लिए, हमें यह सुनिश्चित करना होगा कि प्रत्येक Contract का एक अनोखा पत्ती स्थान हो। मान लीजिए हमारे पास है:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। `c` अनुबंधों को शामिल किया जाना है, जिन्हें `i` द्वारा सूचीबद्ध किया गया है, जहाँ `i = {0,1,..,C-1}` है।
- प्रत्येक Contract `c_i` के लिए, हमारे पास एक पहचानकर्ता है `ContractId(i) = c_i`।

हम फिर एक पेड़ बनाते हैं जिसकी चौड़ाई `w` और गहराई `d` होती है, इस तरह कि `2^d = w`, और `w > C` हो, ताकि प्रत्येक Contract को एक अलग _पत्ती_ में रखा जा सके। पेड़ में प्रत्येक Contract की स्थिति `pos(c_i)` इस प्रकार निर्धारित की जाती है:

```txt
pos(c_i) = c_i mod (w - cofactor)
```

आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं। यहाँ `कोफैक्टर` एक पूर्णांक है जो प्रत्येक Contract के लिए अलग-अलग स्थितियाँ प्राप्त करने की संभावना को बढ़ाता है। व्यवहार में, निर्माण एक क्रमिक प्रक्रिया का पालन करता है:


- हम आमतौर पर न्यूनतम गहराई से शुरू करते हैं (`d=3` ताकि अनुबंधों की सही संख्या छिपी रहे);
- हम विभिन्न `सहगुणकों` को आज़माते हैं (अधिकतम `w/2` तक, या प्रदर्शन कारणों से अधिकतम 500 तक);
- अगर हम सभी अनुबंधों को बिना टकराव के सही जगह पर नहीं रख पाते हैं, तो हम `d` को बढ़ाते हैं और फिर से शुरू करते हैं।

उद्देश्य यह है कि बहुत ऊँचे पेड़ों से बचा जाए, जबकि टकराव के जोखिम को न्यूनतम रखा जाए। ध्यान दें कि टकराव की घटना एक यादृच्छिक वितरण तर्क का पालन करती है, जो [जन्मदिन की समस्या](https://en.wikipedia.org/wiki/Birthday_problem) से जुड़ी है।

#### बसे हुए पत्ते

जब `C` अलग-अलग स्थान `pos(c_i)` अनुबंधों के लिए प्राप्त कर लिए जाते हैं `i = {0,1,..,C-1}`, तो प्रत्येक शीट को Hash फ़ंक्शन से भरा जाता है (*टैग किया गया Hash*):

```txt
tH_MPC_LEAF(c_i) = SHA-256(SHA-256(merkle_tag) || SHA-256(merkle_tag) || 0x10 || c_i || BundleId(c_i))
```

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।


- `merkle_tag = urn:ubideco:merkle:node#2024-01-31`, हमेशा RGB के Merkle नियमों के अनुसार चुना जाता है।
- `0x10` एक _कॉन्ट्रैक्ट लीफ_ को पहचानता है।
- `c_i` 32-बाइट का Contract पहचानकर्ता है (जो Genesis और Hash से प्राप्त होता है);
- `bundleId(c_i)` एक 32-बाइट Hash है जो `c_i` के सापेक्ष `State Transitions` के सेट का वर्णन करता है (जिसे *Transition Bundle* में इकट्ठा किया गया है)।

#### निर्जन पत्ते

जो पत्तियाँ Contract को नहीं सौंपी गई हैं (यानी `w - C` पत्तियाँ), उन्हें एक "डमी" मान (_एंट्रॉपी पत्ता_) से भरा जाता है।

```txt
tH_MPC_LEAF(j) = SHA-256(SHA-256(merkle_tag) || SHA-256(merkle_tag) || 0x11 || entropy || j )
```

आपका प्रशिक्षण अक्टूबर 2023 तक के डेटा पर आधारित है।


- `merkle_tag = urn:ubideco:merkle:node#2024-01-31`, हमेशा RGB के मर्कल नियमों के अनुसार चुना जाता है।
- `0x11` एक _एंट्रॉपी लीफ_ को दर्शाता है।
- `एंट्रोपी` 64 बाइट्स का एक रैंडम मान होता है, जिसे वह व्यक्ति चुनता है जो पेड़ बना रहा होता है।
- `j` इस पेड़ में इस पत्ती की स्थिति है (32 बिट्स लिटिल एंडियन में)।

#### एमपीसी नोड्स

`w` पत्तियों (चाहे वे भरी हुई हों या नहीं) को बनाने के बाद, हम मर्केलाइजेशन की प्रक्रिया शुरू करते हैं। किसी भी आंतरिक नोड्स को इस प्रकार हैश किया जाता है:

```txt
tH_MPC_BRANCH(tH1 || tH2) = SHA-256(SHA-256(merkle_tag) || SHA-256(merkle_tag) || b || d || w || tH1 || tH2)
```

आपका प्रशिक्षण अक्टूबर 2023 तक के डेटा पर आधारित है।


- `merkle_tag = urn:ubideco:merkle:node#2024-01-31`, हमेशा RGB के मर्कल नियमों के अनुसार चुना जाता है।
- `b` को _ब्रांचिंग फैक्टर_ (8 बिट्स) कहा जाता है। अधिकतर मामलों में, `b=0x02` होता है क्योंकि पेड़ बाइनरी और पूर्ण होता है।
- 'd' पेड़ में नोड की गहराई है।
- `w` एक पेड़ की चौड़ाई है (256-बिट लिटिल एंडियन बाइनरी में);
- `tH1` और `tH2` बच्चे नोड्स (या पत्तियों) के हैश हैं, जिन्हें पहले से ही ऊपर दिखाए गए अनुसार गणना किया गया है।

इस तरह से आगे बढ़ते हुए, हमें `mpc::Root` प्राप्त होता है। इसके बाद हम `mpc::Commitment` की गणना कर सकते हैं (जैसा कि ऊपर समझाया गया है) और इसे On-Chain में डाल सकते हैं।

इसे समझाने के लिए, चलिए एक उदाहरण की कल्पना करते हैं जहाँ `C=3` (तीन अनुबंध) हैं। उनकी स्थितियाँ मानी जाती हैं `pos(c_0)=7`, `pos(c_1)=4`, `pos(c_2)=2`। अन्य पत्तियाँ (स्थितियाँ 0, 1, 3, 5, 6) _एंट्रॉपी पत्तियाँ_ हैं। नीचे दिया गया चित्र जड़ों तक हैश के अनुक्रम को दर्शाता है:


- `BUNDLE_i` जो `BundleId(c_i)` को दर्शाता है;
- `tH_MPC_LEAF(A)` और इसी तरह के अन्य नाम, जो पत्तियों का प्रतिनिधित्व करते हैं (कुछ अनुबंधों के लिए, अन्य एंट्रॉपी के लिए);
- प्रत्येक शाखा `tH_MPC_BRANCH(...)` अपने दो बच्चों के हैश को मिलाती है।

अंतिम परिणाम **mpc::Root** है, उसके बाद `mpc::Commitment` आता है।

![RGB-Bitcoin](assets/fr/053.webp)

#### एमपीसी शाफ्ट की जाँच

जब एक सत्यापनकर्ता यह सुनिश्चित करना चाहता है कि `c_i` Contract (और उसका `BundleId`) अंतिम `mpc::Commitment` में शामिल है, तो वह बस एक मर्कल प्रूफ प्राप्त करता है। यह प्रूफ उन नोड्स को दर्शाता है जो पत्तियों (इस मामले में, `c_i` की _कॉन्ट्रैक्ट लीफ_) को जड़ तक वापस ट्रेस करने के लिए आवश्यक हैं। पूरे *MPC ट्री* को प्रकट करने की कोई आवश्यकता नहीं है: यह अन्य कॉन्ट्रैक्ट्स की गोपनीयता की रक्षा करता है।

उदाहरण में, एक `c_2` सत्यापनकर्ता को केवल एक मध्यवर्ती Hash (`tH_MPC_LEAF(D)`), दो `tH_MPC_BRANCH(...)`, `pos(c_2)` स्थिति प्रमाण और `cofactor` मान की आवश्यकता होती है। इसके बाद वह स्थानीय रूप से जड़ का पुनर्निर्माण कर सकता है, फिर `mpc::Commitment` की पुनर्गणना कर सकता है और इसकी तुलना Bitcoin लेनदेन में लिखे गए से कर सकता है (जो `Opret` या `Tapret` के भीतर होता है)।

![RGB-Bitcoin](assets/fr/054.webp)

यह तंत्र यह सुनिश्चित करता है कि:


- `c_2` की स्थिति वास्तव में समग्र जानकारी ब्लॉक (क्लाइंट-साइड) में शामिल है।
- कोई भी व्यक्ति उसी लेन-देन के साथ एक वैकल्पिक इतिहास नहीं बना सकता, क्योंकि On-Chain _प्रतिबद्धता_ एक ही MPC रूट की ओर इशारा करती है।

#### MPC संरचना का सारांश

MPC, यानी मौद्रिक नीति समिति, एक महत्वपूर्ण निकाय है जो देश की मौद्रिक नीति तय करती है। इसमें आमतौर पर छह सदस्य होते हैं, जिनमें से तीन भारतीय रिजर्व बैंक (RBI) के होते हैं और तीन सरकार द्वारा नामित होते हैं। इसका मुख्य उद्देश्य मुद्रास्फीति को नियंत्रित करना और आर्थिक विकास को बढ़ावा देना होता है। समिति नियमित रूप से बैठक करती है और ब्याज दरों जैसे नीतिगत निर्णय लेती है। इस तरह, MPC देश की आर्थिक स्थिरता और विकास में महत्वपूर्ण भूमिका निभाती है।

Multi Protocol Commitment* (MPC) वह सिद्धांत है जो RGB को कई अनुबंधों को एकल Bitcoin लेनदेन में समेकित करने की अनुमति देता है, जबकि अन्य प्रतिभागियों के प्रति प्रतिबद्धताओं की विशिष्टता और गोपनीयता बनाए रखता है। पेड़ की पूर्वनिर्धारित संरचना के कारण, प्रत्येक Contract को एक अद्वितीय स्थान सौंपा जाता है, और "डमी" पत्तियों (*एंट्रॉपी पत्तियाँ*) की उपस्थिति लेनदेन में भाग लेने वाले कुल अनुबंधों की संख्या को आंशिक रूप से छुपाती है।

पूरे Merkle Tree को कभी भी क्लाइंट पर स्टोर नहीं किया जाता है। हम केवल प्रत्येक संबंधित Contract के लिए एक _Merkle पथ_ generate करते हैं, जिसे प्राप्तकर्ता को भेजा जाता है (जो फिर Commitment को सत्यापित कर सकता है)। कुछ मामलों में, आपके पास कई संपत्तियाँ हो सकती हैं जो एक ही UTXO से गुज़री हैं। तब आप कई _Merkle पथों_ को एक _मल्टी-प्रोटोकॉल Commitment ब्लॉक_ में मिला सकते हैं, ताकि बहुत अधिक डेटा की पुनरावृत्ति से बचा जा सके।

प्रत्येक _Merkle प्रमाण_ इसलिए हल्का होता है, खासकर जब पेड़ की गहराई RGB में 32 से अधिक नहीं होगी। इसके अलावा "Merkle ब्लॉक" का एक विचार भी है, जो अधिक जानकारी (क्रॉस-सेक्शन, एंट्रॉपी, आदि) बनाए रखता है, जो कई शाखाओं को जोड़ने या अलग करने के लिए उपयोगी होता है।

यही कारण है कि RGB को अंतिम रूप देने में इतना समय लगा। हमारे पास 2019 से समग्र दृष्टिकोण था: सब कुछ क्लाइंट-साइड पर रखना, टोकन off-chain को प्रसारित करना। लेकिन कई कॉन्ट्रैक्ट्स के लिए शार्डिंग जैसी विवरण, Merkle Tree की संरचना, टकरावों को कैसे संभालना और मर्ज प्रूफ्स... इन सबके लिए कई बार पुनरावृत्ति की आवश्यकता थी।

### एंकर: एक वैश्विक सभा

हमारे प्रतिबद्धताओं (`Opret` या `Tapret`) और हमारे MPC (*Multi Protocol Commitment*) के निर्माण के बाद, हमें RGB प्रोटोकॉल में **Anchor** की अवधारणा को Address करना होगा। एक Anchor एक क्लाइंट-साइड सत्यापित संरचना है जो उस Elements को एक साथ लाती है जो यह सत्यापित करने के लिए आवश्यक है कि एक Bitcoin Commitment वास्तव में विशिष्ट संविदात्मक जानकारी रखता है। दूसरे शब्दों में, एक Anchor उपरोक्त वर्णित _प्रतिबद्धताओं_ को सत्यापित करने के लिए आवश्यक सभी डेटा का सारांश प्रस्तुत करता है।

Anchor में तीन क्रमबद्ध क्षेत्र होते हैं:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- `एमपीसी प्रमाण`
- अतिरिक्त लेन-देन प्रमाण - ईटीपी

इनमें से प्रत्येक क्षेत्र सत्यापन प्रक्रिया में एक भूमिका निभाता है, चाहे वह Bitcoin लेन-देन को पुनर्निर्मित करने का मामला हो या छिपे हुए Commitment के अस्तित्व को साबित करने का, विशेष रूप से `Tapret` के मामले में।

#### मुझे खेद है, लेकिन "txid" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया अधिक जानकारी या संदर्भ प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

`txid` फ़ील्ड `Bitcoin` लेन-देन के 32-बाइट पहचानकर्ता से संबंधित है, जिसमें `Opret` या `Tapret` Commitment शामिल होता है।

सिद्धांत रूप में, यह संभव होगा कि `txid` को खोजा जा सके, प्रत्येक Witness Transaction की ओर इशारा करने वाले राज्य संक्रमणों की श्रृंखला का पता लगाकर, जो कि सिंगल-यूज़ सील्स के तर्क का पालन करते हैं। हालांकि, सत्यापन को आसान और तेज़ बनाने के लिए, इस `txid` को सीधे Anchor में शामिल कर दिया जाता है, जिससे सत्यापनकर्ता को पूरे off-chain के इतिहास में वापस जाने की ज़रूरत नहीं पड़ती।

#### एमपीसी प्रमाण

दूसरा क्षेत्र, `MPC प्रूफ`, इस बात का प्रमाण है कि यह विशेष Contract (जैसे `c_i`) _मल्टी प्रोटोकॉल कमिटमेंट_ में शामिल है। यह निम्नलिखित का संयोजन है:


- `pos_i`, इस Contract की स्थिति MPC पेड़ में;
- कोफैक्टर`, वह मान जो स्थिति टकराव को हल करने के लिए परिभाषित किया गया है;
- `मर्कल प्रूफ` वह प्रक्रिया है जिसमें नोड्स और हैश का सेट इस्तेमाल होता है ताकि एमपीसी रूट को फिर से बनाया जा सके और यह सुनिश्चित किया जा सके कि Contract पहचानकर्ता और उसका `Transition Bundle` रूट में शामिल हैं।

इस प्रक्रिया को *MPC ट्री* बनाने वाले पिछले खंड में वर्णित किया गया था, जहाँ प्रत्येक Contract को एक अनोखा पत्ता मिलता है, इसके लिए धन्यवाद:

```txt
pos(c_i) = c_i mod (w - cofactor)
```

फिर, एक निश्चित मर्कलाइजेशन योजना का उपयोग सभी पत्तियों (अनुबंध + एंट्रॉपी) को एकत्रित करने के लिए किया जाता है। अंत में, `MPC Proof` जड़ को स्थानीय रूप से पुनर्निर्मित करने और `mpc::Commitment` में शामिल On-Chain के साथ तुलना करने की अनुमति देता है।

#### अतिरिक्त लेन-देन प्रमाण - ईटीपी

तीसरा क्षेत्र, **ETP**, इस बात पर निर्भर करता है कि किस प्रकार का Commitment उपयोग किया गया है। अगर Commitment का प्रकार `Opret` है, तो कोई अतिरिक्त प्रमाण की आवश्यकता नहीं होती। सत्यापनकर्ता लेन-देन के पहले `OP_RETURN` आउटपुट की जांच करता है और वहां सीधे `mpc::Commitment` को पाता है।

**यदि Commitment `Tapret` प्रकार का है**, तो एक अतिरिक्त प्रमाण जिसे *अतिरिक्त लेन-देन प्रमाण - ETP* कहा जाता है, प्रदान करना आवश्यक है। इसमें शामिल होता है:


- Taproot के आउटपुट में जो *Commitment* डाला गया है, उसका आंतरिक सार्वजनिक कुंजी (`P`) है।
- जब `Script Path Spend` के पार्टनर नोड्स (जब Tapret *Commitment* को एक स्क्रिप्ट में डाला जाता है) का उपयोग किया जाता है, तो Taproot ट्री में इस स्क्रिप्ट की सटीक स्थिति साबित करने के लिए:
 - अगर `Tapret` *Commitment* दाएँ शाखा पर है, तो हम बाएँ हाथ की नोड (जैसे `tHABC`) को प्रकट करते हैं।
 - यदि `Tapret` *Commitment* बाईं ओर है, तो आपको यह साबित करने के लिए 2 नोड्स (जैसे `tHAB` और `tHC`) को उजागर करना होगा कि दाईं ओर कोई और *Commitment* मौजूद नहीं है।
- `Nonce` का उपयोग सबसे अच्छी संरचना को "खोजने" के लिए किया जा सकता है, जिससे *Commitment* को पेड़ के दाईं ओर रखा जा सके (प्रमाण अनुकूलन)।

यह अतिरिक्त प्रमाण आवश्यक है क्योंकि, `Opret` के विपरीत, `Tapret` Commitment को Taproot स्क्रिप्ट की संरचना में शामिल किया गया है। इसे सही ढंग से मान्य करने के लिए Taproot पेड़ के कुछ हिस्से को उजागर करना पड़ता है ताकि *Commitment* के स्थान की पुष्टि की जा सके।

![RGB-Bitcoin](assets/fr/045.webp)

**एंकर** इसलिए RGB के संदर्भ में Bitcoin और Commitment को मान्य करने के लिए आवश्यक सभी जानकारी को समाहित करते हैं। वे संबंधित लेन-देन (`txid`) और Contract की स्थिति का प्रमाण (`MPC प्रूफ`) दोनों को दर्शाते हैं, जबकि `Tapret` के मामले में अतिरिक्त प्रमाण (`ETP`) का प्रबंधन करते हैं। इस तरह, एक Anchor यह सुनिश्चित करके off-chain की अखंडता और विशिष्टता की रक्षा करता है कि उसी लेन-देन को अन्य संविदात्मक डेटा के लिए पुनः व्याख्या नहीं किया जा सकता।

### निष्कर्ष

इस अध्याय में, हम शामिल करेंगे:


- Bitcoin में Single-use Seals की अवधारणा को कैसे लागू करें (विशेष रूप से _outpoint_ के माध्यम से);
- लेन-देन में एक _प्रतिबद्धता_ को निश्चित रूप से डालने के विभिन्न तरीके होते हैं, जैसे सिग्नेचर ट्वीक, की ट्वीक, विटनेस ट्वीक, OP_RETURN, और Taproot/Tapret।
- RGB टापरेट प्रतिबद्धताओं पर ध्यान केंद्रित करने के कई कारण हैं।
- आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं। Multi-Contract का प्रबंधन _मल्टी-प्रोटोकॉल कमिटमेंट्स_ के माध्यम से किया जाता है, जो तब आवश्यक होता है जब आप किसी विशेष बिंदु को साबित करना चाहते हैं बिना पूरे राज्य या अन्य अनुबंधों को उजागर किए।
- हमने _एंकरों_ की भूमिका भी देखी है, जो सब कुछ एक साथ लाते हैं (लेन-देन txid, Merkle Tree प्रमाण और Taproot प्रमाण) को एक ही पैकेज में।

व्यवहार में, तकनीकी कार्यान्वयन को कई समर्पित Rust _क्रेट्स_ (जैसे _क्लाइंट_साइड_वैलिडेशन_, _कमिट-वेरिफाई_, _बीपी_कोर_, आदि) के बीच विभाजित किया गया है। बुनियादी अवधारणाएँ वहाँ मौजूद हैं:

![RGB-Bitcoin](assets/fr/046.webp)

अगले अध्याय में, हम RGB के केवल off-chain घटक, अर्थात् Contract लॉजिक पर नज़र डालेंगे। हम देखेंगे कि कैसे RGB अनुबंध, जो आंशिक रूप से प्रतिकृत _ससीम अवस्था मशीनों_ के रूप में संगठित होते हैं, Bitcoin स्क्रिप्ट्स की तुलना में कहीं अधिक अभिव्यक्तिपूर्ण होते हैं, जबकि उनके डेटा की गोपनीयता को बनाए रखते हैं।

## स्मार्ट कॉन्ट्रैक्ट्स और उनकी अवस्थाओं का परिचय

<chapterId>04a9569f-3563-5382-bf53-0c7069343ba0</chapterId>

![video](https://youtu.be/tmAVdyXGmj4)

इस और अगले अध्याय में, हम **Smart contract** की अवधारणा को RGB वातावरण के भीतर देखेंगे और यह जानेंगे कि ये अनुबंध अपने *स्थिति* को कैसे परिभाषित और विकसित कर सकते हैं। हम देखेंगे कि RGB आर्किटेक्चर, सिंगल-यूज़ सील्स के क्रमबद्ध अनुक्रम का उपयोग करके, विभिन्न प्रकार के ***Contract ऑपरेशन्स*** को एक स्केलेबल तरीके से और बिना किसी केंद्रीकृत रजिस्ट्रि के कैसे निष्पादित करना संभव बनाता है। हम ***Business Logic*** की मौलिक भूमिका को भी देखेंगे, जो Contract State के विकास को आकार देने में महत्वपूर्ण है।

### स्मार्ट कॉन्ट्रैक्ट्स और डिजिटल धारक अधिकार

RGB का उद्देश्य Bitcoin पर स्मार्ट कॉन्ट्रैक्ट्स को लागू करने के लिए एक आधारभूत संरचना प्रदान करना है। "Smart contract" से हमारा मतलब है कि यह एक ऐसा समझौता है जो कई पक्षों के बीच होता है और इसे स्वचालित रूप से और कम्प्यूटेशनल तरीके से लागू किया जाता है, बिना किसी मानव हस्तक्षेप के। दूसरे शब्दों में, Contract का कानून सॉफ्टवेयर द्वारा लागू किया जाता है, न कि किसी विश्वसनीय तीसरे पक्ष द्वारा।

इस स्वचालन से विकेंद्रीकरण का सवाल उठता है: हम खुद को एक केंद्रीकृत रजिस्ट्ररी (जैसे कि एक केंद्रीय प्लेटफॉर्म या डेटाबेस) से कैसे मुक्त कर सकते हैं ताकि Ownership और Contract के प्रदर्शन को प्रबंधित किया जा सके? मूल विचार, जिसे RGB ने अपनाया, यह है कि Ownership के एक मोड में वापस लौटें जिसे "बेयरर इंस्ट्रूमेंट्स" कहा जाता है। ऐतिहासिक रूप से, कुछ प्रतिभूतियाँ (बॉन्ड, शेयर आदि) बेयरर रूप में जारी की जाती थीं, जिससे किसी भी व्यक्ति को जो भौतिक रूप से दस्तावेज़ का मालिक होता था, अपने अधिकारों को लागू करने की अनुमति मिलती थी।

![RGB-Bitcoin](assets/fr/055.webp)

RGB इस अवधारणा को डिजिटल दुनिया में लागू करता है: अधिकार (और दायित्व) डेटा में समाहित होते हैं जिन्हें off-chain द्वारा संचालित किया जाता है, और इस डेटा की स्थिति को प्रतिभागियों द्वारा स्वयं सत्यापित किया जाता है। यह, पहले से ही, सार्वजनिक रजिस्टरों पर आधारित अन्य दृष्टिकोणों की तुलना में कहीं अधिक गोपनीयता और स्वतंत्रता की अनुमति देता है।

### Smart contract और RGB की स्थिति का परिचय

Smart contract में RGB को एक स्टेट मशीन के रूप में देखा जा सकता है, जिसे इस प्रकार परिभाषित किया गया है:


- **राज्य**, यानी Contract की वर्तमान स्थिति को दर्शाने वाली जानकारी का सेट;
- **Business Logic** (नियमों का सेट) यह बताता है कि किन परिस्थितियों में और किसके द्वारा राज्य को बदला जा सकता है।

![RGB-Bitcoin](assets/fr/056.webp)

यह समझना महत्वपूर्ण है कि ये अनुबंध केवल टोकन के साधारण हस्तांतरण तक सीमित नहीं हैं। ये कई प्रकार के अनुप्रयोगों को समाहित कर सकते हैं: पारंपरिक संपत्तियों (टोकन, स्टॉक्स, बॉन्ड्स) से लेकर अधिक जटिल यांत्रिकी (उपयोग अधिकार, व्यावसायिक शर्तें, आदि) तक। अन्य ब्लॉकचेन के विपरीत, जहां Contract कोड सभी के लिए सुलभ और निष्पादन योग्य होता है, RGB का दृष्टिकोण Contract की पहुंच और ज्ञान को प्रतिभागियों ("***Contract प्रतिभागी***") तक सीमित करता है। इसमें कई भूमिकाएँ होती हैं:


- Contract के जारीकर्ता या निर्माता, जो Contract के Genesis और उसकी प्रारंभिक चर (वेरिएबल्स) को परिभाषित करता है;
- अधिकारों वाली पार्टियाँ (जैसे Ownership) या अन्य प्रवर्तन क्षमताएँ;
- पर्यवेक्षक**, जो संभवतः कुछ विशेष जानकारी देखने तक सीमित होते हैं, लेकिन जो किसी भी प्रकार के बदलाव को शुरू नहीं कर सकते।

इस भूमिकाओं के विभाजन से सेंसरशिप के खिलाफ सुरक्षा मिलती है, क्योंकि यह सुनिश्चित करता है कि केवल अधिकृत व्यक्ति ही संविदात्मक स्थिति के साथ बातचीत कर सकते हैं। यह RGB को क्षैतिज रूप से विस्तार करने की क्षमता भी देता है: अधिकांश सत्यापन Blockchain के बाहर होते हैं, और केवल क्रिप्टोग्राफिक एंकर (जिन्हें *प्रतिबद्धताएं* कहते हैं) Bitcoin पर अंकित होते हैं।

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। Business Logic की स्थिति RGB में है।

व्यावहारिक दृष्टिकोण से, Contract का **Business Logic** नियमों और स्क्रिप्ट्स के रूप में होता है, जिसे RGB **Schema** कहता है। Schema में निम्नलिखित शामिल होते हैं:


- राज्य की संरचना में यह देखा जाता है कि कौन से क्षेत्र सार्वजनिक हैं और कौन से क्षेत्र किस पार्टी के स्वामित्व में हैं। सार्वजनिक क्षेत्र वे होते हैं जो सरकार या जनता के लिए खुले होते हैं, जैसे पार्क, सड़कें, और सरकारी इमारतें। वहीं, कुछ क्षेत्र निजी स्वामित्व में होते हैं, जो किसी विशेष पार्टी या व्यक्ति के अधिकार में होते हैं। यह जानकारी आमतौर पर सरकारी दस्तावेजों या स्थानीय प्रशासन के रिकॉर्ड में उपलब्ध होती है।
- वैधता की शर्तें (राज्य अपडेट को मंजूरी देने से पहले क्या जांचना आवश्यक है?)
- अधिकार (कौन *State Transition* शुरू कर सकता है? कौन केवल देख सकता है?)

उसी समय, **Contract State** अक्सर दो हिस्सों में टूट जाता है:


- **Global State**: सार्वजनिक हिस्सा, जो सभी के द्वारा देखा जा सकता है (कॉन्फ़िगरेशन पर निर्भर करता है);
- स्वामित्व वाली अवस्थाएँ**: निजी हिस्से, जिन्हें विशेष रूप से मालिकों को UTXOs के माध्यम से Contract तर्क में संदर्भित किया गया है।

जैसा कि हम अगले अध्यायों में देखेंगे, कोई भी स्थिति अपडेट (*Contract Operation*) को Bitcoin _प्रतिबद्धता_ से जोड़ना होगा (या तो `Opret` या `Tapret` के माध्यम से) और *Business Logic* स्क्रिप्ट्स का पालन करना होगा ताकि उसे मान्य माना जा सके।

### Contract संचालन: राज्य का निर्माण और विकास

RGB ब्रह्मांड में, ***Contract Operation*** वह घटना होती है जो Contract को **पुरानी स्थिति** से **नई स्थिति** में बदल देती है। ये प्रक्रियाएँ निम्नलिखित तर्क का पालन करती हैं:


- हम Contract की वर्तमान स्थिति पर ध्यान देते हैं;
- हम इस नियम या प्रक्रिया को लागू करते हैं (अगर यह पहली स्थिति है तो ***Genesis***, या अगर कोई सार्वजनिक *Valency* है जिसे फिर से शुरू करना है तो ***State Extension***);
- हमने Anchor पर एक नए _प्रतिबद्धता_ के माध्यम से संशोधन किया है, जिसमें Blockchain पर एक _एकल-उपयोग सील_ को बंद किया और एक नई सील बनाई।
- संबंधित अधिकार धारक स्थानीय स्तर पर (*क्लाइंट-साइड*) यह सुनिश्चित करते हैं कि परिवर्तन *Schema* के अनुरूप है और यह कि संबंधित Bitcoin लेन-देन को On-Chain के रूप में पंजीकृत किया गया है।

![RGB-Bitcoin](assets/fr/057.webp)

अंतिम परिणाम एक अपडेटेड Contract है, जो अब एक अलग स्थिति में है। इस बदलाव के लिए पूरे Bitcoin नेटवर्क को विवरणों की चिंता करने की आवश्यकता नहीं है, क्योंकि केवल एक छोटा क्रिप्टोग्राफिक फिंगरप्रिंट (जिसे _कमिटमेंट_ कहा जाता है) Blockchain में दर्ज किया जाता है। सिंगल-यूज़ सील्स की श्रृंखला किसी भी Double-spending या स्टेट के दोहरे उपयोग को रोकती है।

### ऑपरेशन्स चेन: Genesis से टर्मिनल स्टेट तक

इसे समझने के लिए, एक RGB Smart contract की शुरुआत **Genesis** से होती है, जो सबसे पहला चरण है। इसके बाद, विभिन्न Contract ऑपरेशन्स एक के बाद एक होते हैं, जो ऑपरेशन्स का एक DAG (*Directed Acyclic Graph*) बनाते हैं।


- प्रत्येक परिवर्तन एक पिछले स्थिति पर आधारित होता है (या कई स्थितियों पर, अगर हम संगम परिवर्तनों की बात करें);
- क्रमानुसार व्यवस्था इस बात से सुनिश्चित होती है कि प्रत्येक परिवर्तन को Bitcoin और Anchor में शामिल किया जाता है, जो समय-चिह्नित होते हैं और Proof-of-Work के सहमति के कारण अपरिवर्तनीय होते हैं।
- जब कोई और ऑपरेशन प्रगति में नहीं होता है, तो एक **टर्मिनल स्टेट** तक पहुंचा जाता है: Contract की सबसे हालिया और पूर्ण स्थिति।

![RGB-Bitcoin](assets/fr/012.webp)

यह DAG टोपोलॉजी (साधारण रेखीय श्रृंखला के बजाय) इस संभावना को दर्शाती है कि Contract के विभिन्न हिस्से समानांतर रूप से विकसित हो सकते हैं, जब तक कि वे एक-दूसरे का विरोध नहीं करते। फिर RGB प्रत्येक भागीदार की *क्लाइंट-साइड* सत्यापन के माध्यम से किसी भी असंगति से बचने का ध्यान रखता है।

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

RGB में स्मार्ट कॉन्ट्रैक्ट्स डिजिटल बेयरर इंस्ट्रूमेंट्स का एक मॉडल पेश करते हैं, जो विकेंद्रीकृत होते हैं लेकिन लेन-देन के समय-चिह्नन और क्रम की गारंटी के लिए Bitcoin में एंकर किए जाते हैं। इन कॉन्ट्रैक्ट्स का स्वचालित निष्पादन आधारित होता है:


- **Contract State* वर्तमान में Contract की स्थिति को दर्शाता है (जैसे अधिकार, बैलेंस, वेरिएबल्स आदि)।
- **Business Logic** (*Schema*) यह निर्धारित करता है कि कौन-कौन से परिवर्तन मान्य हैं और उन्हें कैसे सत्यापित किया जाना चाहिए।
- Contract ऑपरेशन्स**, जो इस स्थिति को चरणबद्ध तरीके से अपडेट करते हैं, Bitcoin लेनदेन में निहित प्रतिबद्धताओं के लिए धन्यवाद।

अगले अध्याय में, हम off-chain स्तर पर इन ***स्थितियों*** और ***स्थिति संक्रमणों*** के ठोस प्रतिनिधित्व के बारे में अधिक विस्तार से जानेंगे, और यह कैसे Bitcoin में एम्बेडेड UTXOs और सिंगल-यूज़ सील्स से संबंधित हैं। यह देखने का एक अवसर होगा कि RGB की आंतरिक यांत्रिकी, जो Client-side Validation पर आधारित है, स्मार्ट कॉन्ट्रैक्ट्स की संगति को बनाए रखते हुए डेटा गोपनीयता को कैसे संरक्षित करती है।

## RGB और Contract संचालन

<chapterId>78c44e88-50c4-5ec4-befe-456c1a9f080b</chapterId>

![video](https://youtu.be/lUTjeuM0oTA)

इस अध्याय में, हम देखेंगे कि स्मार्ट कॉन्ट्रैक्ट्स में ऑपरेशन्स और स्टेट ट्रांज़िशन्स कैसे काम करते हैं, खासकर RGB प्रोटोकॉल के तहत। हमारा उद्देश्य यह भी होगा कि कैसे कई प्रतिभागी मिलकर किसी संपत्ति के Ownership को ट्रांसफर करने में सहयोग करते हैं।

### राज्य परिवर्तन और उनके यांत्रिकी

सामान्य सिद्धांत अभी भी Client-side Validation का ही है, जहाँ राज्य डेटा को मालिक द्वारा रखा जाता है और प्राप्तकर्ता द्वारा सत्यापित किया जाता है। हालाँकि, RGB में विशेषता यह है कि बॉब, जो प्राप्तकर्ता है, एलिस से कहता है कि वह Contract डेटा में कुछ जानकारी शामिल करे ताकि उसे प्राप्त संपत्ति पर वास्तविक नियंत्रण मिल सके, जो उसके एक UTXO के छिपे हुए संदर्भ के माध्यम से होता है।

*State Transition* प्रक्रिया को समझाने के लिए, जो कि *Contract ऑपरेशन्स* में से एक बुनियादी प्रक्रिया है, चलिए एक उदाहरण लेते हैं जिसमें एसेट का ट्रांसफर एलिस और बॉब के बीच होता है। आइए इसे चरणबद्ध तरीके से समझते हैं:

**प्रारंभिक स्थिति:**

एलिस के पास ***Stash RGB*** का स्थानीय रूप से सत्यापित डेटा (*क्लाइंट-साइड*) है। यह Stash उसके एक UTXO को Bitcoin पर संदर्भित करता है। इसका मतलब है कि इस डेटा में एक _सील परिभाषा_ है जो एलिस के UTXO की ओर इशारा करती है। इसका उद्देश्य यह है कि वह एक संपत्ति से जुड़े कुछ डिजिटल अधिकार (जैसे RGB टोकन) बॉब को स्थानांतरित कर सके।

![RGB-Bitcoin](assets/fr/058.webp)

**बॉब के पास भी UTXOs हैं:**

दूसरी ओर, बॉब के पास कम से कम एक UTXO है, जिसका ऐलिस के साथ कोई सीधा संबंध नहीं है। अगर बॉब के पास कोई UTXO नहीं है, तो भी उसे *Witness Transaction* का उपयोग करके ट्रांसफर किया जा सकता है: इस लेन-देन का आउटपुट तब Commitment (_प्रतिबद्धता_) को शामिल करेगा और नए Contract के Ownership को बॉब के साथ अप्रत्यक्ष रूप से जोड़ देगा।

![RGB-Bitcoin](assets/fr/059.webp)

**नई संपत्ति (*न्यू स्टेट*) का निर्माण:**

बॉब ऐलिस को जानकारी भेजता है जो ***Invoice*** के रूप में एन्कोड की गई होती है (हम Invoice के निर्माण के बारे में अधिक जानकारी बाद के अध्यायों में देंगे), और उससे कहता है कि वह एक नया स्टेट बनाए जो Contract के नियमों के अनुसार हो। इस स्टेट में एक नया *Seal Definition* शामिल होगा जो बॉब के एक UTXO की ओर इशारा करेगा। इस तरह, बॉब को इस नए स्टेट में परिभाषित संपत्तियों का Ownership दिया जाता है, जैसे कि एक निश्चित मात्रा में RGB टोकन।

![RGB-Bitcoin](assets/fr/060.webp)

**नमूना लेन-देन की तैयारी:**

एलिस फिर एक Bitcoin लेन-देन बनाती है जिसमें वह पिछले Seal में संदर्भित UTXO को खर्च करती है (जो उसे धारक के रूप में वैध बनाता है)। इस लेन-देन के आउटपुट में, एक *Commitment* (ओप्रेट या टैप्रेट के माध्यम से) Anchor में नए RGB स्थिति के लिए डाला जाता है। ओप्रेट या टैप्रेट प्रतिबद्धताएँ *MPC पेड़* से प्राप्त होती हैं (जैसा कि पिछले अध्यायों में देखा गया है), जो विभिन्न अनुबंधों से कई संक्रमणों को एकत्रित कर सकता है।

***Consignment* का बॉब को स्थानांतरण:**

लेन-देन प्रसारित करने से पहले, एलिस बॉब को एक ***Consignment*** भेजती है जिसमें सभी आवश्यक *क्लाइंट-साइड* डेटा (उसका *Stash*) और बॉब के पक्ष में नई स्थिति की जानकारी होती है। इस समय, बॉब RGB सहमति नियम लागू करता है:


- यह *Consignment* में शामिल सभी RGB डेटा को सत्यापित करता है, जिसमें नई स्थिति भी शामिल है जो इसे संपत्ति का Ownership प्रदान करती है;
- *Consignment* में शामिल *एंकरों* पर निर्भर करते हुए, यह गवाह लेन-देन की समयावली की पुष्टि करता है (Genesis से लेकर सबसे हाल की लेन-देन तक) और Blockchain में संबंधित प्रतिबद्धताओं को सत्यापित करता है।

**परिवर्तन पूरा होना:**

अगर बॉब संतुष्ट हैं, तो वह अपनी मंजूरी दे सकते हैं (उदाहरण के लिए, *Consignment* पर हस्ताक्षर करके)। इसके बाद एलिस तैयार नमूना लेन-देन को प्रसारित कर सकती है। एक बार पुष्टि हो जाने पर, यह एलिस द्वारा पहले से रखे गए Seal को बंद कर देता है और बॉब द्वारा Ownership को औपचारिक रूप देता है। इसके बाद एंटी-Double-spending सुरक्षा उसी तंत्र पर आधारित होती है जैसे Bitcoin में: UTXO खर्च किया जाता है, यह साबित करते हुए कि एलिस अब इसे पुनः उपयोग नहीं कर सकती।

![RGB-Bitcoin](assets/fr/061.webp)

अब नए राज्य में बॉब के UTXO का संदर्भ दिया गया है, जिससे बॉब को वह Ownership मिल गया है जो पहले एलिस के पास था। Bitcoin का आउटपुट, जहां RGB डेटा जुड़ा हुआ है, Ownership के हस्तांतरण का अटल प्रमाण बन जाता है।

एक साधारण DAG (*Directed Acyclic Graph*) का उदाहरण, जिसमें दो Contract ऑपरेशन्स शामिल हैं (पहले एक **Genesis** और फिर एक ***State Transition***), यह दिखा सकता है कि RGB स्थिति (*क्लाइंट-साइड* Layer, लाल रंग में) कैसे Bitcoin Blockchain (*Commitment* Layer, नारंगी रंग में) से जुड़ती है।

![RGB-Bitcoin](assets/fr/062.webp)

यह दिखाता है कि एक Genesis एक Seal (*Seal Definition*) को परिभाषित करता है, फिर एक *State Transition* इस Seal को बंद करके एक नए UTXO में बनाता है।

इस संदर्भ में, यहाँ कुछ शब्दावली की याद दिलाई जा रही है:


- ***Assignment*** में निम्नलिखित का संयोजन होता है:
    - ***Seal Definition*** (जो UTXO की ओर इशारा करता है);
    - स्वामित्व वाले राज्य**, यानी Ownership से जुड़े डेटा (जैसे, स्थानांतरित किए गए टोकन की मात्रा)।
- **Global State** में Contract की सामान्य विशेषताएँ शामिल होती हैं, जो सभी के लिए दिखाई देती हैं, और यह सुनिश्चित करती हैं कि विकास में वैश्विक स्थिरता बनी रहे।

पिछले अध्याय में वर्णित "स्टेट ट्रांज़िशन्स" Contract Operation का मुख्य रूप हैं। ये एक या अधिक पिछले स्टेट्स (Genesis या किसी अन्य State Transition से) का उल्लेख करते हैं और उन्हें एक नए स्टेट में अपडेट करते हैं।

![RGB-Bitcoin](assets/fr/063.webp)

यह चित्र दिखाता है कि *State Transition Bundle* में, एक ही नमूना लेन-देन में कई सीलें बंद की जा सकती हैं, जबकि एक साथ नई सीलें खोली जा सकती हैं। वास्तव में, RGB प्रोटोकॉल की एक दिलचस्प विशेषता इसकी क्षमता है कि यह कई संक्रमणों को Transition Bundle में समेकित कर सकता है, प्रत्येक समेकन को *MPC पेड़* की एक विशिष्ट पत्ती (एक अद्वितीय बंडल पहचानकर्ता) के साथ जोड़ा जाता है। *Deterministic Bitcoin Commitment* (DBC) तंत्र के कारण, पूरा संदेश `Tapret` या `Opret` आउटपुट में डाला जाता है, जबकि पिछली सीलों को बंद करते हुए और संभवतः नई सीलें परिभाषित करते हुए। `Anchor* सीधे Commitment को Blockchain में संग्रहीत और Client-side Validation संरचना (*क्लाइंट-साइड*) के बीच एक सीधा लिंक के रूप में कार्य करता है।

आने वाले अध्यायों में, हम State Transition के निर्माण और सत्यापन में शामिल सभी घटकों और प्रक्रियाओं पर नज़र डालेंगे। इनमें से अधिकांश Elements, RGB सहमति का हिस्सा हैं, जो **RGB कोर लाइब्रेरी** में लागू किए गए हैं।

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

RGB पर, यह संभव है कि विभिन्न राज्य परिवर्तन जो एक ही Contract से संबंधित हैं (यानी, जो एक ही **ContractId** साझा करते हैं, जो Genesis **OpId** से प्राप्त होता है) को एक साथ जोड़ा जा सके। सबसे सरल स्थिति में, जैसे कि ऊपर दिए गए उदाहरण में एलिस और बॉब के बीच, एक **Transition Bundle** में केवल एक ही परिवर्तन होता है। लेकिन मल्टी-पेयर ऑपरेशन्स (जैसे कि कॉइनजॉइन, लाइटनिंग चैनल ओपनिंग आदि) के लिए समर्थन का मतलब है कि कई उपयोगकर्ता अपने राज्य परिवर्तन को एक ही बंडल में जोड़ सकते हैं।

एक बार जब इन ट्रांज़िशन को इकट्ठा कर लिया जाता है, तो इन्हें एकल Bitcoin लेन-देन में (MPC + DBC मैकेनिज्म द्वारा) स्थिर कर दिया जाता है।


- प्रत्येक State Transition को हैश किया जाता है और फिर उसे Transition Bundle में समूहित किया जाता है।
- Transition Bundle को हैश किया जाता है और इसे उस MPC पेड़ की पत्ती में डाला जाता है जो इस Contract (एक बंडल आईडी) से संबंधित है।
- MPC पेड़ को अंततः Witness Transaction में `Opret` या `Tapret` के माध्यम से सक्रिय किया जाता है, जिससे उपयोग किए गए सील बंद हो जाते हैं और नए सील निर्धारित होते हैं।

तकनीकी रूप से कहें तो, MPC शीट में डाला गया **BundleId** एक टैग किए गए Hash से प्राप्त होता है, जो बंडल के *InputMap* फील्ड की सख्त क्रमबद्धता पर लागू होता है।

```txt
BundleId = SHA256( SHA256(bundle_tag) || SHA256(bundle_tag) || InputMap )
```

उदाहरण के लिए, `bundle_tag = urn:lnp-bp:RGB:bundle#2024-02-03` में।

*इनपुटमैप* एक डेटा संरचना है जो प्रत्येक नमूना लेन-देन के इनपुट `i` के लिए, संबंधित State Transition के *OpId* का संदर्भ सूचीबद्ध करती है। उदाहरण के लिए:

```txt
InputMap =
N               input_0    OpId(input_0)    input_1    OpId(input_1)   ...    input_N-1  OpId(input_N-1)
|____________________| |_________||______________| |_________||______________|       |__________||_______________|
16-bit Little Endian   32-bit LE   32-byte hash
|_________________________| |_________________________|  ...  |___________________________|
MapElement1                MapElement2                       MapElementN
```


- `N` उस लेन-देन में प्रविष्टियों की कुल संख्या है जो एक `OpId` का संदर्भ देती हैं।
- `opId(input_j)` बंडल में मौजूद स्टेट ट्रांज़िशन में से एक का ऑपरेशन पहचानकर्ता है।

प्रत्येक प्रविष्टि का केवल एक बार और व्यवस्थित तरीके से संदर्भ देकर, हम यह सुनिश्चित करते हैं कि एक ही Seal को दो समानांतर राज्य संक्रमणों में दो बार खर्च न किया जाए।

### राज्य निर्माण और सक्रिय राज्य

स्टेट ट्रांज़िशन का उपयोग इसलिए किया जा सकता है कि किसी संपत्ति के Ownership को एक व्यक्ति से दूसरे व्यक्ति को स्थानांतरित किया जा सके। हालांकि, ये RGB प्रोटोकॉल में संभव ऑपरेशनों में से केवल एक नहीं हैं। इस प्रोटोकॉल में तीन **Contract ऑपरेशन्स** परिभाषित किए गए हैं:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- मुझे खेद है, लेकिन आपके द्वारा दिए गए "State Extension**" के संदर्भ में मेरे पास कोई जानकारी नहीं है। अगर आप कुछ और जानकारी या संदर्भ प्रदान कर सकते हैं, तो मैं आपकी मदद करने की कोशिश कर सकता हूँ।

इनमें से **Genesis** और **State Extension** को कभी-कभी "*स्टेट जनरेशन ऑपरेशन्स*" कहा जाता है, क्योंकि ये नए स्टेट्स बनाते हैं बिना किसी को तुरंत बंद किए। यह एक बहुत महत्वपूर्ण बात है: **Genesis** और **State Extension** में Seal को बंद करना शामिल नहीं होता। बल्कि, ये एक नया Seal परिभाषित करते हैं, जिसे फिर बाद में एक **State Transition** द्वारा खर्च किया जाना चाहिए ताकि इसे Blockchain के इतिहास में सही मायने में मान्यता मिल सके।

![RGB-Bitcoin](assets/fr/064.webp)

Contract की **सक्रिय स्थिति** अक्सर उन नवीनतम स्थितियों के समूह के रूप में परिभाषित की जाती है जो लेन-देन के इतिहास (DAG) से उत्पन्न होती हैं, जो Genesis से शुरू होती हैं और Bitcoin Blockchain में सभी एंकरों का अनुसरण करती हैं। कोई भी पुरानी स्थितियाँ जो पहले से ही अप्रचलित हो चुकी हैं (जैसे कि खर्च किए गए UTXOs से जुड़ी हुई) अब सक्रिय नहीं मानी जातीं, लेकिन इतिहास की संगति की जांच के लिए आवश्यक बनी रहती हैं।

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Genesis हर RGB और Contract की शुरुआत का बिंदु है। इसे Contract जारीकर्ता द्वारा बनाया जाता है और यह प्रारंभिक मापदंडों को परिभाषित करता है, जो **Schema** के अनुसार होते हैं। अगर हम RGB टोकन की बात करें, तो Genesis में उदाहरण के लिए निम्नलिखित बातें शामिल हो सकती हैं:


- मूल रूप से बनाए गए टोकन की संख्या और उनके मालिकों की जानकारी।
- कुल संभावित मुद्दों की सीमा।
- किसी भी पुनः जारी करने के नियम और कौन से प्रतिभागी इसके लिए पात्र हैं।

Contract में पहली लेन-देन होने के नाते, Genesis किसी भी पिछले स्थिति का संदर्भ नहीं देता है, और न ही यह किसी Seal को बंद करता है। हालांकि, इतिहास में दिखाई देने और मान्य होने के लिए, Genesis को एक पहले State Transition द्वारा **उपयोग** (बंद) किया जाना चाहिए (अक्सर यह एक स्कैन/स्वतः-खर्च लेन-देन होता है जो जारीकर्ता को ही होता है, या उपयोगकर्ताओं को प्रारंभिक वितरण)।

### मुझे खेद है, लेकिन "State Extension" से संबंधित कोई जानकारी मेरे पास नहीं है। क्या आप कुछ और जानकारी या संदर्भ दे सकते हैं जिससे मैं आपकी मदद कर सकूं?

राज्य एक्सटेंशन्स** स्मार्ट कॉन्ट्रैक्ट्स के लिए एक अनोखी विशेषता पेश करते हैं। ये Redeem के तहत कुछ डिजिटल अधिकारों (*वैलेन्सीज़*) को संभव बनाते हैं, जो Contract की परिभाषा में दिए गए हैं, बिना Seal को तुरंत बंद किए। अक्सर, यह इस बारे में होता है:


- वितरित टोकन समस्याएँ।
- एसेट स्वैप तंत्र;
- सशर्त पुनः जारी करना (जिसमें अन्य संपत्तियों का विनाश शामिल हो सकता है, आदि)।

तकनीकी रूप से कहें तो, एक State Extension एक *Redeem* का संदर्भ देता है (जो कि RGB इनपुट का एक विशेष प्रकार है) जो पहले से परिभाषित *Valency* से मेल खाता है (उदाहरण के लिए, Genesis या किसी अन्य State Transition में)। यह एक नया Seal परिभाषित करता है, जो उस व्यक्ति या स्थिति के लिए उपलब्ध होता है जो इससे लाभान्वित हो रही है। इस Seal को प्रभावी होने के लिए, इसे बाद के State Transition द्वारा खर्च किया जाना चाहिए।

![RGB-Bitcoin](assets/fr/065.webp)

उदाहरण के लिए: Genesis एक जारी करने का अधिकार (*Valency*) बनाता है। इसे एक अधिकृत व्यक्ति द्वारा प्रयोग किया जा सकता है, जो फिर State Extension बनाता है।


- यह Valency (Redeem) की ओर इशारा करता है।
- यह एक नया *Assignment* (नया *Owned State* डेटा) बनाता है जो UTXO की ओर इशारा करता है।
- भविष्य में जारी किया गया State Transition, इस नए UTXO के मालिक द्वारा, वास्तव में नए जारी किए गए टोकन को स्थानांतरित या वितरित करेगा।

### Contract Operation के घटक

अब मैं RGB में एक **Contract Operation** के प्रत्येक घटक Elements पर विस्तार से नज़र डालना चाहूँगा। एक Contract Operation वह क्रिया है जो Contract की स्थिति को बदलती है, और जिसे वैध प्राप्तकर्ता द्वारा, एक निश्चित तरीके से, क्लाइंट साइड पर सत्यापित किया जाता है। विशेष रूप से, हम देखेंगे कि Contract Operation कैसे एक तरफ Contract की **पुरानी स्थिति** (*Old State*) को ध्यान में रखता है, और दूसरी तरफ, **नई स्थिति** (*New State*) की परिभाषा को।

```txt
+---------------------------------------------------------------------------------------------------------------------+
|  Contract Operation                                                                                                 |
|                                                                                                                     |
|  +-----+     +-----------------------+      +--------------------------------+      +---------+     +------------+  |
|  | Ffv |     | ContractId | SchemaId |      | TransitionType | ExtensionType |      | Testnet |     | AltLayers1 |  |
|  +-----+     +-----------------------+      +--------------------------------+      +---------+     +------------+  |
|                                                                                                                     |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |
|  | Metadata                                      |  | Global State                                               |  |
|  |                                               |  | +----------------------------------+                       |  |
|  | +-------------------------------------+       |  | | +-------------------+ +--------+ |                       |  |
|  | |          Structured Data            |       |  | | |  GlobalStateType  | |  Data  | |     ...     ...       |  |
|  | +-------------------------------------+       |  | | +-------------------+ +--------+ |                       |  |
|  |                                               |  | +----------------------------------+                       |  |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |         +------+
|                                                                                                                     +---------> OpId |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |         +------+
|  | Inputs                                        |  | Assignments                                                |  |
|  |                                               |  |                                                            |  |
|  | +-------------------------------------------+ |  | +--------------------------------------------------------+ |  |
|  | | Input #1                                  | |  | | Assignment #1                                          | |  |
+------+       |  | | +----------+ +----------------+ +-------+ | |  | | +----------------+ +-------------+ +-----------------+ | |  |       +--------------+
| OpId +--------------> PrevOpId | | AssignmentType | | Index | | |  | | | AssignmentType | | Owned State | | Seal Definition +--------------> Bitcoin UTXO |
+------+       |  | | +----------+ + ---------------+ +-------+ | |  | | +----------------+ +-------------+ +-----------------+ | |  |       +--------------+
|  | +-------------------------------------------+ |  | +--------------------------------------------------------+ |  |
|  |                                               |  |                                                            |  |
|  | +-------------------------------------------+ |  | +--------------------------------------------------------+ |  |
|  | | Input #2                                  | |  | | Assignment #2                                          | |  |
+------+       |  | | +----------+ +----------------+ +-------+ | |  | | +----------------+ +-------------+ +-----------------+ | |  |       +--------------+
| OpId +--------------> PrevOpId | | AssignmentType | | Index | | |  | | | AssignmentType | | Owned State | | Seal Definition +--------------> Bitcoin UTXO |
+------+       |  | | +----------+ +----------------+ +-------+ | |  | | +----------------+ +-------------+ +-----------------+ | |  |       +--------------+
|  | +-------------------------------------------+ |  | +--------------------------------------------------------+ |  |
|  |                                               |  |                                                            |  |
|  |       ...           ...          ...          |  |     ...          ...             ...                       |  |
|  |                                               |  |                                                            |  |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |
|                                                                                                                     |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |
|  | Redeems                                       |  | Valencies                                                  |  |
|  |                                               |  |                                                            |  |
|  | +------------------------------+              |  |                                                            |  |
+------+       |  | | +----------+ +-------------+ |              |  |  +-------------+  +-------------+                          |  |
| OpId +--------------> PrevOpId | | ValencyType | |  ...   ...   |  |  | ValencyType |  | ValencyType |         ...              |  |
+------+       |  | | +----------+ +-------------+ |              |  |  +-------------+  +-------------+                          |  |
|  | +------------------------------+              |  |                                                            |  |
|  |                                               |  |                                                            |  |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |
|                                                                                                                     |
+---------------------------------------------------------------------------------------------------------------------+
```

अगर हम ऊपर दिए गए चित्र को देखें, तो हम देख सकते हैं कि Contract Operation में Elements शामिल है, जो **नई स्थिति** को संदर्भित करता है और अन्य जो अपडेटेड **पुरानी स्थिति** को संदर्भित करते हैं।

**न्यू स्टेट** के Elements हैं:


- अक्टूबर 2023 तक के डेटा पर आपका प्रशिक्षण हुआ है।  
असाइनमेंट्स**, जिनमें परिभाषित हैं:
 - **Seal Definition**;
 - **Owned State**।
- **Global State**, जिसे संशोधित या समृद्ध किया जा सकता है;
- संभवतः State Transition या Genesis में परिभाषित वैलेंसियाँ।

**पुराना राज्य** का उल्लेख इस प्रकार किया गया है:


- इनपुट**, जो पिछले स्थिति परिवर्तन के *असाइनमेंट्स* की ओर इशारा करते हैं (Genesis में मौजूद नहीं हैं);
- **रिडीम्स**, जो पहले से परिभाषित वैलेंसीज (केवल स्टेट एक्सटेंशन्स में) को संदर्भित करते हैं।

इसके अलावा, Contract Operation में संचालन से संबंधित कुछ सामान्य क्षेत्र भी शामिल होते हैं:


- ffv` (*फास्ट-फॉरवर्ड वर्जन*): 2-बाइट इंटीजर जो Contract वर्जन को दर्शाता है;
- `transitionType` या `ExtensionType`: 16-बिट पूर्णांक जो Business Logic के अनुसार ट्रांज़िशन या एक्सटेंशन प्रकार को निर्दिष्ट करता है।
- `ContractId`: 32-बाइट संख्या जो Contract Genesis के *OpId* को संदर्भित करती है। यह ट्रांज़िशन और एक्सटेंशन में शामिल होती है, लेकिन Genesis में नहीं होती।
- schemaId: केवल Genesis में मौजूद है, यह 32-बाइट Hash है जो Contract की संरचना (*Schema*) को दर्शाता है;
- Testnet`: यह एक बूलियन संकेतक है जो यह बताता है कि आप Testnet या Mainnet नेटवर्क पर हैं या नहीं। यह केवल Genesis के लिए है।
- `altlayers1`: यह एक वेरिएबल है जो वैकल्पिक Layer (Sidechain या अन्य) को पहचानता है, जिसका उपयोग Bitcoin के अलावा Anchor डेटा में किया जाता है। यह केवल Genesis में मौजूद है।
- मेटाडेटा: यह एक ऐसा फ़ील्ड है जिसमें अस्थायी जानकारी संग्रहीत की जा सकती है। यह जटिल Contract को सत्यापित करने में सहायक होता है, लेकिन इसे अंतिम स्थिति इतिहास में दर्ज नहीं किया जाना चाहिए।

अंत में, इन सभी क्षेत्रों को एक विशेष हैशिंग प्रक्रिया द्वारा संक्षिप्त किया जाता है, जिससे एक अनोखा फिंगरप्रिंट, `OpId` तैयार होता है। फिर इस `OpId` को Transition Bundle में शामिल किया जाता है, जिससे इसे प्रोटोकॉल के भीतर प्रमाणित और सत्यापित किया जा सके।

प्रत्येक *Contract Operation* को 32-बाइट के Hash द्वारा `OpId` नाम से पहचाना जाता है। यह Hash सभी Elements का SHA256 Hash के माध्यम से गणना की जाती है जो ऑपरेशन का हिस्सा होते हैं। दूसरे शब्दों में, प्रत्येक *Contract Operation* का अपना एक क्रिप्टोग्राफिक Commitment होता है, जिसमें ऑपरेशन की प्रामाणिकता और संगति की पुष्टि के लिए आवश्यक सभी डेटा शामिल होते हैं।

RGB Contract को फिर `ContractId` द्वारा पहचाना जाता है, जो Genesis `OpId` से लिया जाता है (क्योंकि Genesis से पहले कोई ऑपरेशन नहीं होता)। सरल शब्दों में, हम Genesis `OpId` लेते हैं, बाइट ऑर्डर को उलटते हैं और Base58 एन्कोडिंग लागू करते हैं। यह एन्कोडिंग `ContractId` को संभालने और पहचानने में आसान बनाती है।

### स्थिति अपडेट के तरीके और नियम

**Contract State** उस जानकारी के सेट को दर्शाता है जिसे RGB प्रोटोकॉल को एक दिए गए Contract के लिए ट्रैक करना होता है। इसमें शामिल हैं:


- एकल Global State**: यह Contract का सार्वजनिक, वैश्विक हिस्सा है, जो सभी के लिए दिखाई देता है;
- एक या अधिक स्वामित्व वाले राज्य**: प्रत्येक Owned State का संबंध एक अद्वितीय Seal से होता है (और इसलिए Bitcoin पर एक UTXO से भी)। इसमें अंतर किया जाता है:
    - **सार्वजनिक** स्वामित्व वाले राज्य,
    - **निजी** स्वामित्व वाले राज्य।

![RGB-Bitcoin](assets/fr/066.webp)

*Global State* को सीधे *Contract Operation* में एकल ब्लॉक के रूप में शामिल किया गया है। *Owned States* को प्रत्येक *Assignment* में, *Seal Definition* के साथ परिभाषित किया गया है।

RGB की एक प्रमुख विशेषता यह है कि इसमें Global State और Owned States को कैसे संशोधित किया जाता है। आमतौर पर दो प्रकार के व्यवहार होते हैं:


- म्यूटेबल**: जब किसी स्थिति तत्व को म्यूटेबल कहा जाता है, तो हर नई क्रिया पिछले स्थिति को एक नई स्थिति से बदल देती है। पुराना डेटा तब अप्रचलित माना जाता है;
- संचयन**: जब किसी स्थिति तत्व को संचयन के रूप में परिभाषित किया जाता है, तो प्रत्येक नई क्रिया पिछले स्थिति में नई जानकारी जोड़ती है, बिना उसे ओवरराइट किए। इसका परिणाम एक प्रकार का संचित इतिहास होता है।

यदि Contract में किसी राज्य तत्व को परिवर्तनीय या संचयी के रूप में परिभाषित नहीं किया गया है, तो यह तत्व बाद की प्रक्रियाओं के लिए खाली रहेगा (दूसरे शब्दों में, इस क्षेत्र के लिए कोई नए संस्करण नहीं होंगे)। यह Contract Schema (अर्थात् कोडेड Business Logic) है जो यह निर्धारित करता है कि कोई राज्य (वैश्विक या स्वामित्व) परिवर्तनीय, संचयी या स्थिर है। एक बार जब Genesis को परिभाषित कर दिया जाता है, तो इन गुणों को केवल तभी संशोधित किया जा सकता है जब Contract स्वयं इसकी अनुमति देता है, उदाहरण के लिए एक विशेष State Extension के माध्यम से।

नीचे दी गई तालिका यह दर्शाती है कि प्रत्येक प्रकार का Contract Operation कैसे Global State और Owned State को प्रभावित कर सकता है (या नहीं कर सकता):

|                              | Genesis | State Extension | State Transition |

| ---------------------------- | :-----: | :-------------: | :--------------: |

| **Global State का जोड़** |    +    |        -        |        +         |

| **Global State का उत्परिवर्तन** |   लागू नहीं   |        -        |        +         |

| **Owned State का जोड़** |    +    |        -        |        +         |

| **Owned State का उत्परिवर्तन** |   लागू नहीं   |       नहीं        |        +         |

| **संयोजकताएँ जोड़ना**    |    +    |        +        |        +         |

**`+`** : कार्रवाई संभव है अगर Contract का Schema इसकी अनुमति देता है।

**`-`**: इस प्रक्रिया की पुष्टि बाद में एक State Transition द्वारा की जानी चाहिए (सिर्फ State Extension से Single-Use Seal बंद नहीं होता)।

इसके अलावा, प्रत्येक प्रकार के डेटा की समय सीमा और अपडेट अधिकार निम्नलिखित तालिका में अलग-अलग किए जा सकते हैं:

|                                 | मेटाडेटा                                | Global State                                  | Owned State                                                                                                |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

| **दायरा**                      | एकल Contract Operation के लिए परिभाषित | Contract के लिए वैश्विक रूप से परिभाषित | प्रत्येक Seal (*Assignment*) के लिए परिभाषित |

| **इसे कौन अपडेट कर सकता है?** | गैर-अपडेटेबल (क्षणिक डेटा) | अभिनेता द्वारा जारी किया गया ऑपरेशन (जारीकर्ता, आदि) | यह उस वैध धारक पर निर्भर करता है जो Seal का मालिक है (वह जो इसे अगले लेन-देन में खर्च कर सकता है) |

| **समय सीमा**                   | केवल वर्तमान ऑपरेशन के लिए            | ऑपरेशन के अंत में स्थिति स्थापित होती है | ऑपरेशन से पहले स्थिति परिभाषित होती है (पिछले ऑपरेशन के *Seal Definition* द्वारा)               |

### मुझे खेद है, लेकिन "Global State" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया इसे थोड़ा और स्पष्ट कर सकते हैं या संदर्भ दे सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

Global State को अक्सर "कोई इसका मालिक नहीं है, लेकिन सबको इसके बारे में पता है" के रूप में वर्णित किया जाता है। इसमें Contract के बारे में सामान्य जानकारी होती है, जो सार्वजनिक रूप से दिखाई देती है। उदाहरण के लिए, एक टोकन जारी करने वाले Contract में, यह संभावित रूप से शामिल हो सकता है:


- टिकर (टोकन का प्रतीकात्मक संक्षेप): `ticker` ;
- टोकन का पूरा नाम: `name`;
- सटीकता (दशमलव स्थानों की संख्या): `सटीकता` ;
- प्रारंभिक प्रस्ताव (और/या अधिकतम टोकन सीमा): `issuedSupply`;
- जारी करने की तारीख: `निर्मित` ;
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

इस Global State को सार्वजनिक संसाधनों (जैसे वेबसाइट्स, IPFS, Nostr, टोरेंट आदि) पर रखा जा सकता है और इसे समुदाय में वितरित किया जा सकता है। इसके अलावा, आर्थिक प्रोत्साहन (इन टोकनों को रखना और स्थानांतरित करने की आवश्यकता आदि) स्वाभाविक रूप से Contract उपयोगकर्ताओं को इस डेटा को खुद बनाए रखने और फैलाने के लिए प्रेरित करता है।

### असाइनमेंट्स

*Assignment* बुनियादी ढांचा है जिसे परिभाषित करने के लिए उपयोग किया जाता है:


- Seal (*Seal Definition*), जो एक विशेष UTXO की ओर इशारा करता है;
- *Owned State*, यानी इस Seal से जुड़ी संपत्ति या डेटा।

*Assignment* को एक तरह से Bitcoin लेन-देन के आउटपुट के समान देखा जा सकता है, लेकिन इसमें अधिक लचीलापन होता है। यहीं पर संपत्ति हस्तांतरण की तर्कशक्ति निहित है: *Assignment* एक विशेष प्रकार की संपत्ति या अधिकार (`AssignmentType`) को Seal के साथ जोड़ता है। जो भी व्यक्ति UTXO की निजी कुंजी रखता है जो इस Seal से जुड़ा है (या जो इस UTXO को खर्च कर सकता है), उसे इस *Owned State* का मालिक माना जाता है।

RGB की एक बड़ी ताकत यह है कि यह अपनी मर्जी से *Seal Definition* और *Owned State* क्षेत्रों को प्रकट (*reveal*) या छुपा (*conceal*) सकता है। यह गोपनीयता और चयनात्मकता का एक शक्तिशाली संयोजन प्रदान करता है। उदाहरण के लिए, आप यह साबित कर सकते हैं कि एक परिवर्तन वैध है बिना सभी डेटा का खुलासा किए, उस व्यक्ति को प्रकट संस्करण प्रदान करके जिसे इसे सत्यापित करना है, जबकि तीसरे पक्ष केवल छुपा हुआ संस्करण (Hash) देखते हैं। व्यवहार में, एक परिवर्तन का `OpId` हमेशा *छुपाए* गए डेटा से गणना किया जाता है।

![RGB-Bitcoin](assets/fr/067.webp)

#### मुझे खेद है, लेकिन "Seal Definition" से संबंधित कोई विशेष जानकारी मेरे पास नहीं है। क्या आप इसके बारे में कुछ और जानकारी दे सकते हैं या कोई और सवाल पूछना चाहेंगे? मैं मदद करने की कोशिश करूंगा।

*Seal Definition* के अपने प्रकट रूप में चार मुख्य क्षेत्र होते हैं: `txptr`, `vout`, `blinding` और `method`।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। 

txptr**: यह Bitcoin पर UTXO के संदर्भ में है।
    - **Genesis Seal** के मामले में, यह सीधे एक मौजूदा UTXO की ओर इशारा करता है (जो Genesis से जुड़ा हुआ है);
    - **ग्राफ Seal** के मामले में, हम यह कर सकते हैं:
        - एक साधारण `txid`, अगर किसी विशेष UTXO की ओर इशारा कर रहा है,
        - या एक `WitnessTx`, जो एक आत्म-संदर्भ को निर्दिष्ट करता है: Seal खुद लेन-देन की ओर इशारा करता है। यह विशेष रूप से तब उपयोगी होता है जब कोई बाहरी UTXO उपलब्ध नहीं होता, जैसे कि लाइटनिंग चैनल खोलने के लेन-देन में, या अगर प्राप्तकर्ता के पास कोई UTXO नहीं है।
- vout** : लेन-देन के आउटपुट नंबर को दर्शाता है जिसे `txptr` द्वारा इंगित किया गया है। यह केवल एक मानक ग्राफ Seal के लिए मौजूद है (यह `WitnessTx` के लिए नहीं है);
- ब्लाइंडिंग**: 8 बाइट्स का एक रैंडम नंबर, जो गोपनीयता को मजबूत करने और UTXO की पहचान पर ब्रूट फोर्स हमलों को रोकने के लिए होता है।
- विधि** : यह उस एंकरिंग विधि को दर्शाता है जो उपयोग की गई है (`Tapret` या `Opret`)।

Seal Definition का *छुपा हुआ* रूप इन 4 क्षेत्रों के संयोजन का SHA256 Hash (टैग किया हुआ) है, जिसमें RGB के लिए एक विशेष टैग होता है।

![RGB-Bitcoin](assets/fr/068.webp)

#### स्वामित्व वाले राज्य

*Assignment* का दूसरा घटक Owned State है। Global State के विपरीत, यह सार्वजनिक या निजी रूप में मौजूद हो सकता है।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। Public Owned State**: हर कोई Seal से जुड़े डेटा को जानता है। उदाहरण के लिए, एक सार्वजनिक छवि;
- प्राइवेट Owned State**: यह डेटा छुपा हुआ है, जिसे केवल मालिक (और अगर ज़रूरत पड़ी तो सत्यापनकर्ता) ही जानता है। उदाहरण के लिए, कितने टोकन रखे गए हैं।

RGB चार संभावित राज्य प्रकार (*StateTypes*) को परिभाषित करता है जो Owned State के लिए होते हैं:


- घोषणात्मक**: इसमें कोई संख्यात्मक डेटा नहीं होता, बस एक घोषणात्मक अधिकार होता है (जैसे, वोट देने का अधिकार)। छिपा हुआ और प्रकट रूप समान होते हैं;
- फंजिबल**: यह एक फंजिबल मात्रा का प्रतिनिधित्व करता है (जैसे टोकन)। जब इसे प्रकट किया जाता है, तो हमारे पास `मात्रा` और `ब्लाइंडिंग` होती है। जब इसे छुपाया जाता है, तो हमारे पास एक *Pedersen commitment* होता है जो मात्रा और ब्लाइंडिंग को छुपाता है।
- संरचित**: यह संरचित डेटा को संग्रहीत करता है (64 kB तक)। जब इसे प्रकट किया जाता है, तो यह डेटा ब्लॉब होता है। छिपे हुए रूप में, यह इस ब्लॉब का टैग किया हुआ Hash होता है।

```txt
SHA-256(SHA-256(tag_data) || SHA-256(tag_data) || blob)
```

उदाहरण के लिए:

```txt
tag_data = urn:lnp-bp:rgb:state-data#2024-02-12
```


- अटैचमेंट्स**: एक फाइल (ऑडियो, इमेज, बाइनरी, आदि) को Owned State से जोड़ता है, जिसमें फाइल का Hash `file_hash`, MIME टाइप `media type` और एक क्रिप्टोग्राफिक सॉल्ट `salt` शामिल होता है। फाइल खुद कहीं और होस्ट की जाती है। छुपे हुए रूप में, यह एक Hash है जो इन तीन डेटा आइटम्स के साथ टैग की गई है:

```txt
SHA-256(SHA-256(tag_attachment) || SHA-256(tag_attachment) || file_hash || media_type || salt)
```

उदाहरण के लिए:

```txt
tag_attachment = urn:rgb:state-attach#2024-02-12
```

संक्षेप में, सार्वजनिक और छिपे हुए रूप में राज्य के 4 संभावित प्रकार इस प्रकार हैं:

```txt
State                      Concealed form                              Revealed form
+---------------------------------------------------------------------------------------------------------
+--------------------------------------------------------------------------------+
|                                                                                |
Declarative        |                              < void >                                          |
|                                                                                |
+--------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------
+--------------------------+             +---------------------------------------+
| +----------------------+ |             |         +--------+ +----------+       |
Fungible           | | Pedersen Commitement | | <========== |         | Amount | | Blinding |       |
| +----------------------+ |             |         +--------+ +----------+       |
+--------------------------+             +---------------------------------------+
+---------------------------------------------------------------------------------------------------------
+--------------------------+             +---------------------------------------+
| +----------------------+ |             |         +--------------------+        |
Structured         | |     Tagged Hash      | | <========== |         |     Data Blob      |        |
| +----------------------+ |             |         +--------------------+        |
+--------------------------+             +---------------------------------------+
+---------------------------------------------------------------------------------------------------------
+--------------------------+             +---------------------------------------+
| +----------------------+ |             | +-----------+ +------------+ +------+ |
Attachments        | |     Tagged Hash      | | <========== | | File Hash | | Media Type | | Salt | |
| +----------------------+ |             | +-----------+ +------------+ +------+ |
+--------------------------+             +---------------------------------------+
```

| **तत्व**            | **घोषणात्मक**   | **विनिमेय**                         | **संरचित**                     | **संलग्नक**                    |

| ------------------- | -------------- | ------------------------------------ | ----------------------------- | ----------------------------- |

| **डेटा**          | कोई नहीं       | साइन या अनसाइन 64-बिट पूर्णांक    | कोई भी सख्त डेटा प्रकार      | कोई भी फ़ाइल                  |

| **जानकारी का प्रकार** | कोई नहीं        | हस्ताक्षरित या बिना हस्ताक्षरित | सख्त प्रकार                  | MIME प्रकार                    |

| **गोपनीयता**     | आवश्यक नहीं    | Pedersen commitment                  | ब्लाइंडिंग के साथ Hash       | हैश किया हुआ फाइल पहचानकर्ता  |

| **आकार सीमा**    | लागू नहीं      | 256 बाइट्स                           | 64 केबी तक                     | लगभग 500 जीबी तक               |

### आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं।

*Contract Operation* के इनपुट्स उन *असाइनमेंट्स* को दर्शाते हैं जो इस नए ऑपरेशन में खर्च किए जा रहे हैं। एक इनपुट यह संकेत देता है:


- `prevOpId`: पिछले ऑपरेशन का पहचानकर्ता (`OpId`) जहाँ *Assignment* स्थित था।
- `assignmentType`: *Assignment* का प्रकार (जैसे, किसी टोकन के लिए `assetOwner`)।
- `इंडेक्स`: पिछले `OpId` से जुड़े सूची में *Assignment* का इंडेक्स, जो छिपे हुए सील्स के वर्णानुक्रमिक क्रमबद्धता के बाद निर्धारित किया गया है।

Genesis में इनपुट्स कभी नहीं दिखाई देते, क्योंकि पहले कोई असाइनमेंट्स नहीं होते। और ये स्टेट एक्सटेंशन्स में भी नहीं दिखाई देते (क्योंकि स्टेट एक्सटेंशन्स सील्स को बंद नहीं करते; बल्कि, वे वैलेंसीज के आधार पर नए सील्स को फिर से परिभाषित करते हैं)।

जब हमारे पास `Fungible` प्रकार के Owned States होते हैं, तो सत्यापन तर्क (Schema में दिए गए AluVM स्क्रिप्ट के माध्यम से) योगों की संगति की जांच करता है: आने वाले टोकन (*Inputs*) का योग नए *Assignments* में जाने वाले टोकन के योग के बराबर होना चाहिए।

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

**मेटाडेटा** फ़ील्ड 64 KiB तक हो सकता है और इसका उपयोग अस्थायी डेटा को शामिल करने के लिए किया जाता है जो सत्यापन के लिए उपयोगी होता है, लेकिन इसे Contract की स्थायी स्थिति में शामिल नहीं किया जाता। उदाहरण के लिए, जटिल स्क्रिप्ट्स के लिए मध्यवर्ती गणना चर यहां संग्रहीत किए जा सकते हैं। यह स्थान वैश्विक इतिहास में संग्रहीत करने के लिए नहीं है, इसलिए यह ओन्ड स्टेट्स या Global State के दायरे से बाहर है।

### संयोजकताएँ

वैलेंसीज** एक मूल RGB प्रोटोकॉल मैकेनिज्म हैं। इन्हें Genesis, स्टेट ट्रांजिशन या स्टेट एक्सटेंशन में पाया जा सकता है। ये संख्यात्मक अधिकारों का प्रतिनिधित्व करते हैं जिन्हें State Extension के माध्यम से (*रिडीम्स* के जरिए) सक्रिय किया जा सकता है, और फिर एक बाद के ट्रांजिशन द्वारा अंतिम रूप दिया जाता है। प्रत्येक Valency को `ValencyType` (16 बिट्स) द्वारा पहचाना जाता है। इसका अर्थ (पुनः जारी करने का अधिकार, टोकन स्वैप, जलाने का अधिकार, आदि) Schema में परिभाषित किया गया है।

सीधे शब्दों में कहें तो, हम एक Genesis की कल्पना कर सकते हैं जो "पुनः जारी करने का अधिकार" Valency को परिभाषित करता है। अगर कुछ शर्तें पूरी होती हैं, तो एक State Extension इसे (*Redeem*) उपयोग करेगा ताकि नए टोकन की मात्रा पेश की जा सके। फिर, Seal के धारक से उत्पन्न एक State Transition इन नए टोकन को स्थानांतरित कर सकता है।

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

रिडीम्स असाइनमेंट्स के लिए इनपुट्स के समान Valency होते हैं। ये केवल स्टेट एक्सटेंशन्स में दिखाई देते हैं, क्योंकि यहीं पर पहले से परिभाषित Valency को सक्रिय किया जाता है। एक Redeem में दो फील्ड्स होते हैं:


- `PrevOpId`: वह `OpId` जिस ऑपरेशन में Valency का उल्लेख किया गया था;
- `ValencyType`: Valency का वह प्रकार जिसे आप सक्रिय करना चाहते हैं (प्रत्येक `ValencyType` को State Extension द्वारा केवल एक बार ही उपयोग किया जा सकता है)।

उदाहरण के लिए: एक Redeem CoinSwap निष्पादन से मेल खा सकता है, यह इस पर निर्भर करता है कि Valency में क्या कोड किया गया था।

### RGB की स्थिति विशेषताएँ

अब हम RGB में कई बुनियादी राज्य विशेषताओं पर नज़र डालने जा रहे हैं। खासकर, हम देखेंगे:


- **सख्त प्रकार प्रणाली** एक ऐसी प्रणाली है जो डेटा को एक सटीक और प्रकारित संगठन में व्यवस्थित करती है।
- **मान्यता** को **Ownership** से अलग करने का महत्व;
- RGB में **सहमति विकास** प्रणाली, जिसमें *फास्ट-फॉरवर्ड* और *पुश-बैक* की अवधारणाएँ शामिल हैं।

जैसा कि हमेशा होता है, ध्यान रखें कि Contract की स्थिति से जुड़ी हर चीज़ को क्लाइंट साइड पर प्रोटोकॉल में निर्धारित सहमति नियमों के अनुसार सत्यापित किया जाता है, और इसका अंतिम क्रिप्टोग्राफिक संदर्भ Bitcoin लेनदेन में निहित होता है।

#### सख्त प्रकार प्रणाली

RGB एक *सख्त प्रकार प्रणाली* और एक निश्चित क्रमबद्धता मोड (*सख्त एन्कोडिंग*) का उपयोग करता है। इस व्यवस्था को इस तरह से बनाया गया है कि यह Contract डेटा की परिभाषा, प्रबंधन और सत्यापन में पूर्ण पुनरुत्पादन और सटीकता की गारंटी दे सके।

कई प्रोग्रामिंग वातावरणों (जैसे JSON, YAML...) में डेटा संरचना लचीली हो सकती है, कभी-कभी तो बहुत अधिक अनुमति देने वाली भी। दूसरी ओर, RGB में प्रत्येक फ़ील्ड की संरचना और प्रकार स्पष्ट सीमाओं के साथ परिभाषित होते हैं। उदाहरण के लिए:


- प्रत्येक वेरिएबल का एक विशेष प्रकार होता है (जैसे, 8-बिट बिना चिन्ह वाला पूर्णांक `u8`, या 16-बिट चिन्हित पूर्णांक, आदि);
- प्रकारों को संयोजित किया जा सकता है (नेस्टेड प्रकार)। इसका मतलब है कि आप अन्य प्रकारों के आधार पर एक प्रकार को परिभाषित कर सकते हैं (जैसे कि एक समग्र प्रकार जिसमें `u8` फील्ड, एक `bool` फील्ड आदि शामिल हैं);
- आप संग्रहों को भी निर्दिष्ट कर सकते हैं: सूचियाँ (*list*), सेट्स (*set*) या शब्दकोश (*map*), जिनमें एक निश्चित क्रम में प्रगति होती है।
- प्रत्येक क्षेत्र की सीमाएँ होती हैं (निचली सीमा / ऊपरी सीमा)। हम संग्रहों में Elements की संख्या पर भी सीमाएँ लगाते हैं (अंतर्वेशन)।
- डेटा बाइट-अलाइंड है और सीरियलाइजेशन सख्ती से परिभाषित और स्पष्ट है।

इस सख्त एन्कोडिंग प्रोटोकॉल के लिए धन्यवाद:


- फील्ड्स का क्रम हमेशा एक जैसा रहता है, चाहे जो भी इम्प्लीमेंटेशन या प्रोग्रामिंग भाषा का उपयोग किया जाए।
- इसी डेटा सेट पर किए गए हैश इसलिए पुनरुत्पादित और समान होते हैं (सख्ती से पूर्वनिर्धारित *प्रतिबद्धताएँ*);
- सीमाएँ डेटा के आकार में अनियंत्रित वृद्धि को रोकती हैं (जैसे, बहुत अधिक फील्ड्स होना)।
- यह एन्कोडिंग का तरीका क्रिप्टोग्राफिक सत्यापन को आसान बनाता है, क्योंकि हर भागीदार को ठीक-ठीक पता होता है कि डेटा को कैसे सीरियलाइज़ और Hash करना है।

व्यवहार में, संरचना (*Schema*) और परिणामी कोड (*Interface* और संबंधित लॉजिक) को संकलित किया जाता है। Contract (प्रकार, क्षेत्र, नियम) को परिभाषित करने के लिए एक वर्णनात्मक भाषा का उपयोग किया जाता है और generate एक सख्त बाइनरी प्रारूप है। जब इसे संकलित किया जाता है, तो परिणाम होता है:


- प्रत्येक क्षेत्र के लिए एक *मेमोरी लेआउट*।
- सामान्य पहचानकर्ता (जो यह बताते हैं कि किसी वेरिएबल के नाम को बदलने से लॉजिक पर असर पड़ता है या नहीं, भले ही मेमोरी की संरचना वही रहे)।

सख्त प्रकार प्रणाली (strict type system) के कारण बदलावों की सटीक निगरानी करना संभव हो जाता है: संरचना में कोई भी बदलाव (यहां तक कि फील्ड नाम में बदलाव भी) पहचाना जा सकता है और इससे पूरे ढांचे में बदलाव हो सकता है।

अंत में, प्रत्येक संकलन एक फिंगरप्रिंट उत्पन्न करता है, जो एक क्रिप्टोग्राफिक पहचानकर्ता होता है जो कोड (डेटा, नियम, सत्यापन) के सटीक संस्करण की पुष्टि करता है। उदाहरण के लिए, एक पहचानकर्ता इस रूप में हो सकता है:

```txt
BEiLYE-am9WhTW1-oK8cpvw4-FEMtzMrf-mKocuGZn-qWK6YF#ginger-parking-nirvana
```

यह संभव बनाता है कि आप सहमति या कार्यान्वयन अपडेट्स को प्रबंधित कर सकें, साथ ही यह सुनिश्चित करते हुए कि नेटवर्क में उपयोग की गई संस्करणों का विस्तृत ट्रेसबिलिटी बनी रहे।

RGB और Contract की स्थिति को क्लाइंट साइड पर सत्यापित करने में बहुत जटिल होने से रोकने के लिए, एक सहमति नियम यह निर्धारित करता है कि सत्यापन गणनाओं में शामिल किसी भी डेटा का अधिकतम आकार `2^16` बाइट्स (64 Kio) हो सकता है। यह प्रत्येक वेरिएबल या संरचना पर लागू होता है: 65536 बाइट्स से अधिक नहीं, या संख्याओं के समकक्ष (जैसे 32768 16-बिट पूर्णांक)। यह संग्रहों (सूचियाँ, सेट, मानचित्र) पर भी लागू होता है, जो `2^16` Elements से अधिक नहीं हो सकते।

यह सीमा सुनिश्चित करती है:


- State Transition के दौरान डेटा को संभालने के लिए अधिकतम आकार को नियंत्रित करता है।
- वर्चुअल मशीन (*AluVM*) के साथ संगतता, जिसका उपयोग सत्यापन स्क्रिप्ट्स चलाने के लिए किया जाता है।

#### वैलिडेशन != Ownership का सिद्धांत

RGB की एक प्रमुख नवाचार यह है कि यह दो अवधारणाओं के बीच सख्त विभाजन करता है।


- मान्यता**: यह सुनिश्चित करना कि एक State Transition, Contract (Business Logic, इतिहास, आदि) के नियमों का पालन करता है;
- **Ownership** (Ownership, या नियंत्रण): Bitcoin और UTXO का मालिक होना, जो Single-Use Seal को खर्च करने (या बंद करने) की अनुमति देता है, और इस प्रकार State Transition को होने देता है।

**सत्यापन** RGB सॉफ़्टवेयर स्टैक (लाइब्रेरीज़, *प्रतिबद्धता* प्रोटोकॉल, आदि) के स्तर पर होता है। इसका काम यह सुनिश्चित करना है कि Contract के आंतरिक नियम (राशियाँ, अनुमतियाँ, आदि) का पालन हो रहा है। पर्यवेक्षक या अन्य प्रतिभागी भी डेटा इतिहास को सत्यापित कर सकते हैं।

Ownership** पूरी तरह से Bitcoin की सुरक्षा पर निर्भर करता है। अगर आपके पास UTXO की प्राइवेट की है, तो आप एक नई ट्रांज़िशन शुरू करने की क्षमता रखते हैं (यानि Single-Use Seal को बंद करना)। इसलिए, भले ही कोई डेटा देख या सत्यापित कर सके, वे स्थिति को नहीं बदल सकते अगर उनके पास संबंधित UTXO नहीं है।

![RGB-Bitcoin](assets/fr/069.webp)

यह तरीका उन पारंपरिक कमजोरियों को सीमित करता है जो अधिक जटिल ब्लॉकचेन में पाई जाती हैं (जहां Smart contract का पूरा कोड सार्वजनिक होता है और कोई भी उसे बदल सकता है, जिससे कभी-कभी हैकिंग की घटनाएं होती हैं)। RGB पर, एक हमलावर सीधे On-Chain की स्थिति के साथ इंटरैक्ट नहीं कर सकता, क्योंकि स्थिति पर कार्य करने का अधिकार (*Ownership*) Bitcoin Layer द्वारा सुरक्षित है।

इसके अलावा, यह अलगाव RGB को Lightning Network के साथ स्वाभाविक रूप से जुड़ने की अनुमति देता है। लाइटनिंग चैनलों का उपयोग करके RGB की संपत्तियों को सक्रिय और स्थानांतरित किया जा सकता है, बिना हर बार On-Chain *प्रतिबद्धताओं* को शामिल किए। हम इस पाठ्यक्रम के आगे के अध्यायों में लाइटनिंग पर RGB के इस एकीकरण पर गहराई से नज़र डालेंगे।

#### RGB में सहमति विकास

अक्टूबर 2023 तक के डेटा पर आपका प्रशिक्षण हुआ है। 

RGB में, सेमांटिक कोड वर्शनिंग के अलावा, Contract के सहमति नियमों को समय के साथ विकसित या अपडेट करने के लिए एक प्रणाली शामिल है। विकास के दो मुख्य रूप हैं:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- पुश-बैक** (फ्रेंच में)

जब कोई पहले से अमान्य नियम मान्य हो जाता है, तो उसे फास्ट-फॉरवर्ड कहा जाता है। उदाहरण के लिए, अगर Contract विकसित होकर एक नए प्रकार के `AssignmentType` या एक नए फ़ील्ड की अनुमति देने लगे:


- इसकी तुलना एक क्लासिक Blockchain हार्डफोर्क से नहीं की जा सकती, क्योंकि RGB, Client-side Validation में काम करता है और Blockchain की समग्र संगतता को प्रभावित नहीं करता है।
- व्यवहारिक रूप से, इस प्रकार के परिवर्तन को Contract Operation में `Ffv` (*फास्ट-फॉरवर्ड वर्जन*) फील्ड द्वारा दर्शाया जाता है।
- वर्तमान धारकों को कोई नुकसान नहीं होगा: उनकी स्थिति वैध बनी रहेगी।
- दूसरी ओर, नए लाभार्थियों (या नए उपयोगकर्ताओं) को अपने सॉफ़्टवेयर (उनके Wallet) को अपडेट करने की ज़रूरत है ताकि वे नए नियमों को पहचान सकें।

पुश-बैक का मतलब है कि पहले जो नियम मान्य था, वह अब अमान्य हो जाता है। इसलिए यह नियमों का "कठोर" बनना है, लेकिन इसे सॉफ्टफोर्क नहीं कहा जा सकता।


- मौजूदा धारकों पर असर पड़ सकता है (वे खुद को ऐसी संपत्तियों के साथ पा सकते हैं जो नए संस्करण में बेकार या अमान्य हो गई हैं);
- हम यह मान सकते हैं कि हम वास्तव में एक नया प्रोटोकॉल बना रहे हैं: जो भी नया नियम अपनाता है, वह पुराने से अलग हो जाता है।
- जारीकर्ता इस नए प्रोटोकॉल में संपत्तियों को फिर से जारी करने का निर्णय ले सकता है, जिससे उपयोगकर्ताओं को दोनों संस्करणों को प्रबंधित करने के लिए दो अलग-अलग वॉलेट्स (एक पुराने प्रोटोकॉल के लिए, दूसरा नए के लिए) बनाए रखने की आवश्यकता हो सकती है।

इस अध्याय में RGB और Contract संचालन के बारे में हमने इस प्रोटोकॉल के मूलभूत सिद्धांतों का अध्ययन किया है। जैसा कि आपने देखा होगा, RGB प्रोटोकॉल की जटिलता के कारण कई तकनीकी शब्दों का उपयोग करना पड़ता है। इसलिए, अगले अध्याय में, मैं आपको एक शब्दावली प्रदान करूंगा जो इस पहले सैद्धांतिक भाग में शामिल सभी अवधारणाओं का सारांश देगी, जिसमें RGB से संबंधित सभी तकनीकी शब्दों की परिभाषाएँ होंगी। फिर, अगले खंड में, हम RGB अनुबंधों की परिभाषा और कार्यान्वयन को व्यावहारिक दृष्टिकोण से देखेंगे।

## RGB शब्दावली

<chapterId>545e16a4-3cca-44a3-9fd5-dbc5868abf97</chapterId>

अगर आपको RGB दुनिया में इस्तेमाल होने वाले महत्वपूर्ण तकनीकी शब्दों की इस छोटी शब्दावली पर वापस आना हो, तो यह आपके लिए उपयोगी साबित होगी। ये शब्दावली वर्णानुक्रम में सूचीबद्ध है। अगर आपने पहले खंड में जो कुछ भी हमने कवर किया है, उसे पहले ही समझ लिया है, तो यह अध्याय आपके लिए जरूरी नहीं है।

#### मुझे खेद है, लेकिन "AluVM" से संबंधित कोई विशेष जानकारी मेरे पास नहीं है। अगर आप इसके बारे में कुछ और जानकारी देंगे, तो मैं आपकी मदद करने की कोशिश कर सकता हूँ।

AluVM का संक्षेप "_एल्गोरिदमिक लॉजिक यूनिट वर्चुअल मशीन_" के लिए होता है। यह एक रजिस्टर-आधारित वर्चुअल मशीन है, जिसे Smart contract के सत्यापन और वितरित कंप्यूटिंग के लिए डिज़ाइन किया गया है। इसका उपयोग (लेकिन विशेष रूप से आरक्षित नहीं) RGB अनुबंधों के सत्यापन के लिए किया जाता है। RGB Contract में शामिल स्क्रिप्ट या ऑपरेशन्स को AluVM वातावरण में निष्पादित किया जा सकता है।

अधिक जानकारी के लिए: [AluVM आधिकारिक वेबसाइट](https://www.AluVM.org/)

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Anchor एक प्रकार का क्लाइंट-साइड डेटा है जिसका उपयोग किसी लेन-देन में एक अद्वितीय _प्रतिबद्धता_ की समावेशिता को साबित करने के लिए किया जाता है। RGB प्रोटोकॉल में, एक Anchor में निम्नलिखित Elements शामिल होते हैं:


- **Witness Transaction** का Bitcoin लेन-देन पहचानकर्ता (txid) है।
- **Multi Protocol Commitment (MPC)** ;
- **Deterministic Bitcoin Commitment (DBC)**;
- यदि **Tapret** Commitment प्रणाली का उपयोग किया जाता है, तो **अतिरिक्त लेन-देन प्रमाण (ETP)** (इस मॉडल के लिए समर्पित अनुभाग देखें)।

Anchor का उपयोग एक विशेष Bitcoin लेन-देन और RGB प्रोटोकॉल द्वारा सत्यापित निजी डेटा के बीच एक सत्यापन योग्य लिंक स्थापित करने के लिए किया जाता है। यह सुनिश्चित करता है कि ये डेटा वास्तव में Blockchain में शामिल हैं, बिना उनके सटीक सामग्री को सार्वजनिक रूप से उजागर किए।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

RGB की तर्कशक्ति में, एक Assignment एक लेन-देन आउटपुट के बराबर होता है जो Contract की स्थिति के भीतर कुछ गुणों को संशोधित, अपडेट या बनाता है। एक Assignment में दो Elements शामिल होते हैं:


- **Seal Definition** (विशेष रूप से UTXO का संदर्भ) ;
- **Owned State** (इस नए मालिक से संबंधित राज्य का वर्णन करने वाला डेटा)।

Assignment का मतलब है कि राज्य का एक हिस्सा (जैसे कि कोई संपत्ति) अब एक विशेष धारक को आवंटित किया गया है, जिसे Single-Use Seal के माध्यम से UTXO से जोड़ा गया है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Business Logic में Contract के सभी नियम और आंतरिक प्रक्रियाएँ शामिल होती हैं, जो इसके **Schema** (यानी Contract की संरचना) द्वारा वर्णित होती हैं। यह निर्धारित करता है कि Contract की स्थिति कैसे बदल सकती है और किन परिस्थितियों में।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Client-side Validation उस प्रक्रिया को संदर्भित करता है जिसमें प्रत्येक पक्ष (क्लाइंट) एक प्रोटोकॉल के नियमों के अनुसार निजी रूप से आदान-प्रदान किए गए डेटा के सेट को सत्यापित करता है। RGB के मामले में, इस आदान-प्रदान किए गए डेटा को **कंसाइनमेंट्स** के रूप में समूहित किया जाता है। Bitcoin प्रोटोकॉल के विपरीत, जो सभी लेन-देन को On-Chain में प्रकाशित करने की आवश्यकता होती है, RGB केवल _प्रतिबद्धताओं_ (जो Bitcoin में एंकर की गई हैं) को सार्वजनिक रूप से संग्रहीत करने की अनुमति देता है, जबकि आवश्यक Contract जानकारी (संक्रमण, प्रमाणन, प्रमाण) off-chain रहती है, जो केवल संबंधित उपयोगकर्ताओं के बीच साझा की जाती है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Commitment (क्रिप्टोग्राफिक संदर्भ में) एक गणितीय वस्तु है, जिसे `C` के रूप में दर्शाया जाता है। यह एक संरचित डेटा `m` (संदेश) और एक यादृच्छिक मान `r` पर किए गए ऑपरेशन से निश्चित रूप से प्राप्त होता है। हम इसे इस प्रकार लिखते हैं:

$$
C = \text{commit}(m, r)
$$

इस प्रणाली में दो मुख्य कार्य शामिल होते हैं:


- प्रतिबद्धता**: एक क्रिप्टोग्राफिक फ़ंक्शन का उपयोग संदेश `m` और एक यादृच्छिक संख्या `r` पर किया जाता है ताकि `C` उत्पन्न हो सके;
- सत्यापन करें: हम `C`, `m` संदेश और `r` मान का उपयोग करके यह जांचते हैं कि यह Commitment सही है या नहीं। यह फ़ंक्शन `True` या `False` लौटाता है।

Commitment को दो गुणों का सम्मान करना चाहिए:


- बाइंडिंग: यह असंभव होना चाहिए कि दो अलग-अलग संदेश एक ही `C` उत्पन्न करें।

$$
m' : \, | \, : m' \neq m \quad \text{and} \quad r' : \, | \, : r' \neq r \quad
$$

जैसे कि:

$$
\text{verify}(m, r, C) = \text{verify}(m', r', C) \rightarrow \text{True}
$$


- छुपाना**: `C` की जानकारी से `m` की सामग्री का पता नहीं चलना चाहिए।

RGB प्रोटोकॉल में, एक Commitment को Bitcoin लेन-देन में शामिल किया जाता है ताकि यह साबित किया जा सके कि किसी विशेष जानकारी का एक निश्चित समय पर अस्तित्व था, बिना उस जानकारी को प्रकट किए।

#### मुझे खेद है, लेकिन "Consignment" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया इसे थोड़ा और स्पष्ट कर सकते हैं या इसके बारे में अधिक जानकारी दे सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

**Consignment** उन डेटा को एक साथ समूहित करता है जो पार्टियों के बीच आदान-प्रदान किए जाते हैं, जो Client-side Validation के अधीन RGB में आते हैं। Consignment की दो मुख्य श्रेणियाँ हैं:


- Contract Consignment**: यह *जारीकर्ता* (Contract जारीकर्ता) द्वारा प्रदान किया गया है, जिसमें प्रारंभिक जानकारी शामिल होती है जैसे कि Schema, Genesis, Interface और Interface Implementation।
- ट्रांसफर Consignment**: यह भुगतान करने वाले पक्ष (*payer*) द्वारा प्रदान किया गया है। इसमें उन सभी राज्य परिवर्तनों का पूरा इतिहास शामिल है जो Terminal Consignment तक पहुंचने के लिए हुए थे (यानी वह अंतिम स्थिति जो भुगतानकर्ता को प्राप्त हुई)।

इन खेपों को सार्वजनिक रूप से Blockchain पर दर्ज नहीं किया जाता है; इन्हें संबंधित पक्षों के बीच उनकी पसंद के संचार माध्यम के जरिए सीधे आदान-प्रदान किया जाता है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Contract कई पक्षों के बीच डिजिटल रूप से निष्पादित अधिकारों का एक सेट है, जो RGB प्रोटोकॉल के माध्यम से होता है। इसका एक सक्रिय स्थिति और Business Logic होता है, जिसे Schema द्वारा परिभाषित किया जाता है, जो यह निर्दिष्ट करता है कि कौन-कौन से ऑपरेशन अधिकृत हैं (जैसे ट्रांसफर, एक्सटेंशन आदि)। Contract की स्थिति और इसकी वैधता के नियम Schema में व्यक्त किए जाते हैं। किसी भी समय पर, Contract केवल उसी के अनुसार विकसित होता है जो इस Schema और वैलिडेशन स्क्रिप्ट्स (जैसे AluVM में चलाए गए) द्वारा अनुमति दी गई हो।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Contract Operation एक Contract स्थिति अपडेट है जो Schema नियमों के अनुसार किया जाता है। RGB में निम्नलिखित प्रक्रियाएँ होती हैं:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- मुझे खेद है, लेकिन आपके द्वारा दिए गए "State Extension**" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया अधिक जानकारी या संदर्भ प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

प्रत्येक ऑपरेशन स्थिति को संशोधित करता है, जिसमें कुछ डेटा (जैसे Global State, Owned State...) जोड़ा या बदला जाता है।

#### मुझे खेद है, लेकिन "Contract Participant" से संबंधित कोई जानकारी मेरे पास नहीं है। क्या आप कृपया अधिक संदर्भ या विवरण प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

Contract Participant एक अभिनेता है जो Contract से संबंधित कार्यों में भाग लेता है। RGB में, एक अंतर किया जाता है:


- Contract के जारीकर्ता, जो Genesis का निर्माण करता है (Contract की उत्पत्ति);
- Contract पार्टियों का मतलब है, वे लोग या समूह जिनके पास Contract राज्य के अधिकार हैं।
- अगर Contract सार्वजनिक रूप से उपलब्ध वैलेंसीज़ प्रदान करता है, तो सार्वजनिक पार्टियाँ राज्य विस्तार बना सकती हैं।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Contract Rights उन विभिन्न अधिकारों को संदर्भित करता है जिन्हें RGB Contract में शामिल लोग प्रयोग कर सकते हैं। ये कई श्रेणियों में विभाजित होते हैं:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। Ownership अधिकार**, जो कि एक विशेष UTXO के Ownership से जुड़े होते हैं (एक _सील परिभाषा_ के माध्यम से);
- कार्यकारी अधिकार**, यानी Schema के अनुसार एक या अधिक ट्रांज़िशन (स्टेट ट्रांज़िशन) बनाने की क्षमता;
- सार्वजनिक अधिकार**, जब Schema कुछ सार्वजनिक उपयोगों को अधिकृत करता है, जैसे कि Valency के रिडेम्प्शन के माध्यम से State Extension का निर्माण।

#### मुझे खेद है, लेकिन "Contract State" से संबंधित कोई जानकारी मेरे पास नहीं है। क्या आप कृपया अधिक जानकारी या संदर्भ प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

Contract State एक विशेष समय पर Contract की वर्तमान स्थिति के अनुरूप होता है। यह सार्वजनिक और निजी डेटा दोनों से मिलकर बन सकता है, जो Contract की स्थिति को दर्शाता है। RGB निम्नलिखित के बीच अंतर करता है:


- **Global State**, जिसमें Contract की सार्वजनिक विशेषताएँ शामिल हैं (जो Genesis में सेट की गई हैं या अधिकृत अपडेट्स के माध्यम से जोड़ी गई हैं);
- स्वामित्व वाली अवस्थाएँ**, जो विशेष मालिकों की होती हैं, उनके UTXOs द्वारा पहचानी जाती हैं।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Deterministic Bitcoin Commitment (DBC) नियमों का एक सेट है जिसका उपयोग एक _प्रतिबद्धता_ को Bitcoin लेनदेन में प्रमाणिक रूप से और विशिष्ट रूप से पंजीकृत करने के लिए किया जाता है। RGB प्रोटोकॉल में, DBC के दो मुख्य रूप होते हैं:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

ये तंत्र ठीक-ठीक बताते हैं कि Bitcoin लेन-देन के आउटपुट या संरचना में _प्रतिबद्धता_ कैसे दर्ज की जाती है, ताकि यह सुनिश्चित हो सके कि यह Commitment निश्चित रूप से पता लगाने योग्य और सत्यापनीय है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

DAG (या *एसीक्लिक गाइडेड ग्राफ*) एक ऐसा ग्राफ होता है जिसमें कोई चक्र नहीं होता, जिससे टोपोलॉजिकल शेड्यूलिंग संभव होती है। ब्लॉकचेन, जैसे RGB कॉन्ट्रैक्ट्स के _शार्ड्स_, को DAGs के रूप में दर्शाया जा सकता है।

अधिक जानकारी के लिए: [Directed Acyclic Graph](https://en.wikipedia.org/wiki/Directed_acyclic_graph)

#### उत्कीर्णन

उत्कीर्णन एक वैकल्पिक डेटा स्ट्रिंग है जिसे Contract के लगातार मालिक Contract के इतिहास में दर्ज कर सकते हैं। यह सुविधा, उदाहरण के लिए, **RGB21** Interface में मौजूद है और यह Contract के इतिहास में स्मरणीय या वर्णनात्मक जानकारी जोड़ने की अनुमति देती है।

#### अतिरिक्त लेन-देन प्रमाण - ईटीपी

ETP (*एक्स्ट्रा ट्रांजैक्शन प्रूफ*) Anchor का वह हिस्सा है जिसमें **Tapret** *Commitment* को सत्यापित करने के लिए अतिरिक्त डेटा होता है (टैप्रूट के संदर्भ में)। इसमें अन्य चीजों के साथ-साथ Taproot स्क्रिप्ट की आंतरिक सार्वजनिक कुंजी (_internal PubKey_) और _स्क्रिप्ट पाथ स्पेंड_ से संबंधित जानकारी शामिल होती है।

#### मुझे खेद है, लेकिन "Genesis" से संबंधित कोई जानकारी मेरे पास नहीं है। क्या आप कृपया अधिक जानकारी या संदर्भ प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

Genesis उस डेटा सेट को संदर्भित करता है, जो Schema द्वारा संचालित होता है और किसी भी Contract की प्रारंभिक स्थिति को RGB में बनाता है। इसे Bitcoin के _Genesis Block_ अवधारणा या Coinbase Transaction अवधारणा से तुलना की जा सकती है, लेकिन यहाँ यह _क्लाइंट-साइड_ और RGB टोकन स्तर पर होता है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Global State, Contract State में शामिल सार्वजनिक गुणों का सेट है। इसे Genesis पर परिभाषित किया गया है और Contract के नियमों के अनुसार, इसे अधिकृत परिवर्तनों द्वारा अपडेट किया जा सकता है। Owned States के विपरीत, Global State किसी विशेष इकाई से संबंधित नहीं है; यह Contract के भीतर एक सार्वजनिक रजिस्ट्र्री के समान है।

#### मुझे खेद है, लेकिन "Interface" से संबंधित कोई जानकारी मेरे पास नहीं है। क्या आप कुछ और जानकारी या संदर्भ दे सकते हैं जिससे मैं आपकी मदद कर सकूं?

Interface निर्देशों का एक सेट है जिसका उपयोग Schema या Contract ऑपरेशनों और उनकी अवस्थाओं में संकलित बाइनरी डेटा को डिकोड करने के लिए किया जाता है, ताकि उन्हें उपयोगकर्ता या उसके Wallet के लिए पढ़ने योग्य बनाया जा सके। यह एक व्याख्या Layer के रूप में कार्य करता है।

#### मुझे खेद है, लेकिन "Interface Implementation" से संबंधित कोई जानकारी मेरे पास नहीं है। क्या आप कृपया अधिक संदर्भ या विवरण प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

Interface Implementation वह घोषणाओं का सेट है जो एक **Interface** को **Schema** से जोड़ता है। यह Interface द्वारा किए गए अर्थपूर्ण अनुवाद को सक्षम बनाता है, ताकि Contract के कच्चे डेटा को उपयोगकर्ता या संबंधित सॉफ़्टवेयर (जैसे वॉलेट्स) द्वारा समझा जा सके।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Invoice एक URL के रूप में होता है जो [base58](https://en.wikipedia.org/wiki/Binary-to-text_encoding#Base58) में एन्कोड किया गया होता है। इसमें वह डेटा शामिल होता है जो **State Transition** के निर्माण के लिए आवश्यक होता है (भुगतानकर्ता द्वारा)। सरल शब्दों में, यह एक Invoice है जो दूसरी पार्टी (*भुगतानकर्ता*) को संबंधित ट्रांज़िशन बनाने की अनुमति देता है ताकि वह संपत्ति को ट्रांसफर कर सके या Contract की स्थिति को अपडेट कर सके।

#### मुझे खेद है, लेकिन "Lightning Network" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया अधिक जानकारी या संदर्भ प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

Lightning Network एक विकेंद्रीकृत नेटवर्क है जो भुगतान चैनलों (या _स्टेट चैनलों_) से बना है, जो Bitcoin पर आधारित है। इसमें 2/2 मल्टी-सिग्नेचर वॉलेट शामिल होते हैं। यह तेज़ और कम लागत वाले _ऑफ-चेन_ लेन-देन की सुविधा प्रदान करता है, जबकि जरूरत पड़ने पर मध्यस्थता (या समापन) के लिए Bitcoin के Layer 1 पर निर्भर करता है।

अगर आप जानना चाहते हैं कि लाइटनिंग कैसे काम करता है, तो मैं आपको सलाह दूंगा कि आप यह दूसरा कोर्स करें:

https://planb.network/courses/34bd43ef-6683-4a5c-b239-7cb1e40a4aeb
#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Multi Protocol Commitment (MPC) का मतलब है Merkle Tree संरचना का उपयोग जो RGB में किया जाता है, ताकि एक ही Bitcoin लेन-देन में विभिन्न अनुबंधों से कई **Transition Bundles** शामिल किए जा सकें। इसका विचार यह है कि कई प्रतिबद्धताओं (जो संभवतः विभिन्न अनुबंधों या विभिन्न संपत्तियों से संबंधित हो सकती हैं) को एक ही Anchor बिंदु में एक साथ समूहित किया जाए, ताकि ब्लॉक स्पेस के उपयोग को अनुकूलित किया जा सके।

#### मुझे खेद है, लेकिन "Owned State" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया अधिक संदर्भ या विवरण प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

Owned State एक Contract State का हिस्सा है जो Assignment में बंद होता है और एक विशेष धारक से जुड़ा होता है (Single-Use Seal के माध्यम से जो UTXO की ओर इशारा करता है)। यह उदाहरण के लिए, एक डिजिटल संपत्ति या उस व्यक्ति को सौंपा गया एक विशेष संविदात्मक अधिकार दर्शाता है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Ownership का मतलब है कि आप UTXO को नियंत्रित कर सकते हैं और खर्च कर सकते हैं, जिसे Seal Definition द्वारा संदर्भित किया गया है। जब एक Owned State को UTXO से जोड़ा जाता है, तो इस UTXO के मालिक को, संभवतः, Contract के नियमों के अनुसार संबंधित स्थिति को स्थानांतरित करने या विकसित करने का अधिकार होता है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

PSBT (_आंशिक रूप से हस्ताक्षरित Bitcoin लेनदेन_) एक ऐसा Bitcoin लेनदेन है जो अभी पूरी तरह से हस्ताक्षरित नहीं हुआ है। इसे कई संस्थाओं के बीच साझा किया जा सकता है, जिनमें से प्रत्येक कुछ Elements (हस्ताक्षर, स्क्रिप्ट...) जोड़ या सत्यापित कर सकती है, जब तक कि लेनदेन को On-Chain वितरण के लिए तैयार नहीं माना जाता।

अधिक जानकारी के लिए: [BIP-0174](https://github.com/Bitcoin/bips/blob/master/bip-0174.mediawiki) पर जाएं।

#### मुझे खेद है, लेकिन "Pedersen commitment" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया इसे थोड़ा और स्पष्ट कर सकते हैं या इसके बारे में अधिक जानकारी दे सकते हैं? मैं आपकी मदद करने की कोशिश करूंगा।

Pedersen commitment एक प्रकार का क्रिप्टोग्राफिक Commitment है, जिसमें जोड़ने की क्रिया के संदर्भ में **होमोमॉर्फिक** होने की विशेषता होती है। इसका मतलब यह है कि आप दो प्रतिबद्धताओं के योग को सत्यापित कर सकते हैं बिना व्यक्तिगत मानों को उजागर किए।

औपचारिक रूप से, यदि:

$$
C1=\text{commit}(m1,r1) \quad C2=\text{commit}(m2,r2)
$$

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

$$
C3=C1⋅C2=\text{commit}(m1+m2, r1+r2)
$$

यह विशेषता उपयोगी है, उदाहरण के लिए, टोकन के आदान-प्रदान की मात्रा को छुपाने के लिए, जबकि कुल योग को सत्यापित करने की क्षमता बनी रहती है।

अधिक जानकारी के लिए: [Pedersen commitment](https://link.springer.com/chapter/10.1007/3-540-46766-1_9)

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

State Extension में, Redeem उस क्रिया को संदर्भित करता है जिसमें पहले घोषित किए गए **Valency** को पुनः प्राप्त (या उपयोग) किया जाता है। चूंकि Valency एक सार्वजनिक अधिकार है, Redeem एक अधिकृत प्रतिभागी को एक विशेष Contract State Extension का दावा करने की अनुमति देता है।

#### मुझे खेद है, लेकिन "Schema" से संबंधित कोई जानकारी मेरे पास नहीं है। क्या आप कृपया अधिक जानकारी या संदर्भ प्रदान कर सकते हैं ताकि मैं आपकी मदद कर सकूं?

Schema और RGB में एक घोषणात्मक कोड का टुकड़ा है जो उन वेरिएबल्स, नियमों और Business Logic (*Business Logic*) का वर्णन करता है जो Contract के संचालन को नियंत्रित करते हैं। Schema राज्य संरचना, अनुमत संक्रमणों के प्रकार और सत्यापन शर्तों को परिभाषित करता है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Seal Definition, Assignment का वह हिस्सा है जो _प्रतिबद्धता_ को नए धारक द्वारा स्वामित्व वाले UTXO के साथ जोड़ता है। सरल शब्दों में, यह बताता है कि स्थिति कहाँ स्थित है (किस UTXO में), और एक संपत्ति या अधिकार के Ownership को स्थापित करता है।

#### मुझे खेद है, लेकिन "Shard" से संबंधित कोई जानकारी मेरे पास नहीं है। क्या आप कुछ और पूछना चाहेंगे?

Shard एक DAG (दिशात्मक चक्रीय ग्राफ) में एक शाखा का प्रतिनिधित्व करता है, जो RGB Contract के राज्य संक्रमण के इतिहास का हिस्सा है। सरल शब्दों में, यह Contract के पूरे इतिहास का एक संगठित हिस्सा है, जो उदाहरण के लिए, किसी दिए गए संपत्ति की वैधता को साबित करने के लिए आवश्यक संक्रमणों की श्रृंखला से मेल खाता है, जब से _Genesis_ (उद्गम) से।

#### मुझे खेद है, लेकिन "Single-Use Seal" से मेरा क्या मतलब है, यह स्पष्ट नहीं है। क्या आप कृपया अधिक जानकारी या संदर्भ प्रदान कर सकते हैं? ताकि मैं आपकी मदद कर सकूं।

Single-Use Seal एक क्रिप्टोग्राफिक वादा है Commitment का, जो एक अभी तक अज्ञात संदेश के लिए है। यह संदेश भविष्य में एक बार ही प्रकट किया जाएगा और इसे एक विशेष दर्शक समूह के सभी सदस्यों को जानना आवश्यक होगा। इसका उद्देश्य एक ही Seal के लिए कई प्रतिस्पर्धी प्रतिबद्धताओं के निर्माण को रोकना है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Stash वह डेटा सेट है जो उपयोगकर्ता एक या अधिक RGB अनुबंधों के लिए अपने पक्ष में स्टोर करता है, ताकि सत्यापन (*Client-side Validation*) किया जा सके। इसमें परिवर्तन इतिहास, माल की सूची, वैधता के प्रमाण आदि शामिल होते हैं। प्रत्येक धारक केवल उसी इतिहास के हिस्से को रखता है जिसकी उन्हें आवश्यकता होती है (*शार्ड्स*)।

#### मुझे खेद है, लेकिन "State Extension" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कुछ और जानकारी या संदर्भ प्रदान कर सकते हैं? मैं आपकी मदद करने की कोशिश करूंगा।

State Extension एक Contract Operation है जिसका उपयोग पहले से घोषित **Valencies** को फिर से सक्रिय करके राज्य अपडेट को फिर से शुरू करने के लिए किया जाता है। प्रभावी होने के लिए, State Extension को फिर State Transition द्वारा बंद किया जाना चाहिए (जो Contract की अंतिम स्थिति को अपडेट करता है)।

#### मुझे खेद है, लेकिन "State Transition" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया अधिक संदर्भ या विवरण प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

State Transition एक प्रक्रिया है जो RGB Contract की स्थिति को एक नई स्थिति में बदल देती है। यह Global State और/या Owned State डेटा को संशोधित कर सकती है। वास्तव में, प्रत्येक परिवर्तन को Schema नियमों द्वारा सत्यापित किया जाता है और Bitcoin Blockchain में एक _प्रतिबद्धता_ के माध्यम से स्थिर किया जाता है।

#### मुझे खेद है, लेकिन "Taproot" से आपका क्या मतलब है, यह स्पष्ट नहीं है। कृपया अधिक जानकारी दें ताकि मैं आपकी मदद कर सकूं।

Bitcoin के SegWit v1 ट्रांजेक्शन फॉर्मेट का जिक्र करता है, जिसे [BIP341](https://github.com/Bitcoin/bips/blob/master/bip-0341.mediawiki) और [BIP342](https://github.com/Bitcoin/bips/blob/master/bip-0342.mediawiki) द्वारा पेश किया गया है। Taproot स्क्रिप्ट्स की गोपनीयता और लचीलापन को बेहतर बनाता है, खासकर ट्रांजेक्शनों को अधिक कॉम्पैक्ट और एक-दूसरे से अलग पहचानना मुश्किल बनाकर।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Terminal Consignment (या _Consignment Endpoint_) एक *ट्रांसफर Consignment* है, जिसमें Contract की अंतिम स्थिति शामिल होती है, जिसमें प्राप्तकर्ता के Invoice (*भुगतानकर्ता*) से बना State Transition भी शामिल होता है। इसलिए, यह एक ट्रांसफर का अंतिम बिंदु होता है, जिसमें यह साबित करने के लिए आवश्यक डेटा होता है कि Ownership या स्थिति को स्थानांतरित कर दिया गया है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Transition Bundle एक RGB राज्य संक्रमणों का सेट है (जो उसी Contract से संबंधित हैं) और ये सभी एक ही ***Witness Transaction*** Bitcoin में शामिल होते हैं। इससे कई अपडेट्स या ट्रांसफर्स को एक ही On-Chain Anchor में समेटना संभव हो जाता है।

#### मुझे खेद है, लेकिन "UTXO" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया अधिक संदर्भ या विवरण प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

Bitcoin UTXO (*अव्यय लेन-देन आउटपुट*) को एक लेन-देन के Hash और आउटपुट इंडेक्स (*vout*) द्वारा परिभाषित किया जाता है। इसे कभी-कभी _आउटपॉइंट_ भी कहा जाता है। RGB प्रोटोकॉल में, UTXO का संदर्भ (एक **Seal Definition** के माध्यम से) **Owned State** के स्थान को सक्षम बनाता है, यानी Blockchain पर रखी गई संपत्ति।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Valency एक सार्वजनिक अधिकार है जिसे राज्य भंडारण की आवश्यकता नहीं होती, लेकिन इसे **State Extension** के माध्यम से भुनाया जा सकता है। इसलिए, यह एक संभावना का रूप है जो सभी (या कुछ खिलाड़ियों) के लिए खुला है, और इसे Contract की तर्कशास्त्र में घोषित किया जाता है, ताकि भविष्य में किसी विशेष विस्तार को पूरा किया जा सके।

#### मुझे खेद है, लेकिन "Witness Transaction" के बारे में मेरे पास कोई विशेष जानकारी नहीं है। क्या आप कृपया इसके बारे में अधिक जानकारी दे सकते हैं या यह किस संदर्भ में है? इससे मुझे आपकी मदद करने में आसानी होगी।

Witness Transaction एक प्रकार का लेन-देन है जो Bitcoin लेन-देन को बंद करता है और इसमें Multi Protocol Commitment (MPC) संदेश शामिल होता है। यह लेन-देन या तो UTXO खर्च करता है या एक नया बनाता है, ताकि Seal के माध्यम से Commitment को RGB प्रोटोकॉल से जोड़ा जा सके। यह एक प्रकार का On-Chain प्रमाण है कि किसी विशेष समय पर स्थिति को सेट किया गया है।

# RGB पर प्रोग्रामिंग करना

<partId>148a7436-d079-56d9-be08-aaa4c14c6b3a</partId>

## RGB अनुबंधों को लागू करना

<chapterId>8333ea5f-51c7-5dd5-b1d7-47d491e58e51</chapterId>

![video](https://youtu.be/Uo1UoxiImsI)

इस अध्याय में, हम RGB Contract को कैसे परिभाषित और लागू किया जाता है, इस पर गहराई से नज़र डालेंगे। हम देखेंगे कि RGB Contract के घटक क्या हैं, उनकी भूमिकाएँ क्या हैं और वे कैसे निर्मित होते हैं।

### RGB और Contract के घटक

अब तक, हमने **Genesis** के बारे में चर्चा की है, जो Contract की शुरुआत का प्रतिनिधित्व करता है, और हमने देखा है कि यह *Contract Operation* की तर्कशक्ति और प्रोटोकॉल की स्थिति के साथ कैसे मेल खाता है। हालांकि, एक RGB Contract की पूरी परिभाषा केवल Genesis तक सीमित नहीं है: इसमें तीन पूरक घटक शामिल होते हैं, जो मिलकर कार्यान्वयन का केंद्र बनाते हैं।

पहला घटक **Schema** कहलाता है। यह एक फाइल है जो Contract की बुनियादी संरचना और Business Logic (*Business Logic*) का वर्णन करती है। इसमें उपयोग किए गए डेटा प्रकार, सत्यापन नियम, अनुमत संचालन (जैसे प्रारंभिक टोकन जारी करना, स्थानांतरण, विशेष शर्तें आदि) निर्दिष्ट किए जाते हैं - संक्षेप में, यह सामान्य ढांचा है जो बताता है कि Contract कैसे काम करता है।

दूसरा घटक **Interface** है। यह इस बात पर केंद्रित है कि उपयोगकर्ता (और विस्तार में, पोर्टफोलियो सॉफ़्टवेयर) इस Contract के साथ कैसे इंटरैक्ट करेंगे। यह अर्थशास्त्र का वर्णन करता है, यानी विभिन्न क्षेत्रों और क्रियाओं का पठनीय प्रतिनिधित्व। तो, जबकि Schema यह परिभाषित करता है कि Contract तकनीकी रूप से कैसे काम करता है, Interface यह परिभाषित करता है कि इन कार्यात्मकताओं को कैसे प्रस्तुत और उजागर किया जाए: विधि के नाम, डेटा प्रदर्शन, आदि।

तीसरा घटक **Interface Implementation** है, जो पिछले दो घटकों के बीच एक प्रकार के पुल का काम करता है। यह Interface द्वारा व्यक्त अर्थ को Schema में परिभाषित नियमों के साथ जोड़ता है। इस कार्यान्वयन के माध्यम से, उदाहरण के लिए, Wallet में दर्ज किए गए किसी पैरामीटर और प्रोटोकॉल द्वारा लगाए गए बाइनरी संरचना के बीच परिवर्तन का प्रबंधन किया जाएगा, या मशीन भाषा में सत्यापन नियमों का संकलन किया जाएगा।

RGB की यह मॉड्यूलरिटी एक दिलचस्प विशेषता है, क्योंकि यह विभिन्न डेवलपर्स के समूहों को इन पहलुओं (*Schema*, *Interface*, *Implementation*) पर अलग-अलग काम करने की अनुमति देती है, बशर्ते वे प्रोटोकॉल के सहमति नियमों का पालन करें।

संक्षेप में, प्रत्येक Contract में शामिल होता है:


- Genesis** वह प्रारंभिक स्थिति है जो Contract की होती है (और इसे एक विशेष लेन-देन के रूप में देखा जा सकता है जो किसी संपत्ति, अधिकार, या किसी अन्य पैरामीटर योग्य डेटा के पहले Ownership को परिभाषित करता है);
- Schema**, जो Contract के Business Logic (डेटा प्रकार, सत्यापन नियम, आदि) का वर्णन करता है;
- Interface** एक ऐसा सिस्टम है जो Layer के लिए एक अर्थपूर्ण संदर्भ प्रदान करता है, जिससे दोनों वॉलेट और मानव उपयोगकर्ता लेनदेन को पढ़ने और निष्पादित करने में आसानी से समझ सकें।
- Interface का कार्यान्वयन, जो Business Logic और प्रस्तुति के बीच के अंतर को पाटता है, यह सुनिश्चित करने के लिए कि Contract की परिभाषा उपयोगकर्ता अनुभव के साथ संगत है।

![RGB-Bitcoin](assets/fr/070.webp)

यह ध्यान रखना महत्वपूर्ण है कि एक Wallet को RGB संपत्ति (चाहे वह एक फंजिबल टोकन हो या किसी भी प्रकार का अधिकार) प्रबंधित करने के लिए, उसके पास सभी Elements संकलित होने चाहिए: *Schema*, *Interface*, *Interface Implementation* और *Genesis*। यह एक ***Contract Consignment*** के माध्यम से प्रसारित होता है, यानी एक डेटा पैकेज जिसमें क्लाइंट-साइड Contract को मान्य करने के लिए आवश्यक सभी चीजें होती हैं।

इन विचारों को स्पष्ट करने के लिए, यहाँ एक सारणी दी गई है जो RGB और Contract के घटकों की तुलना उन अवधारणाओं से करती है जो या तो ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग (OOP) में या एथेरियम इकोसिस्टम में पहले से जानी जाती हैं:

| RGB Contract घटक            | अर्थ                                   | OOP समकक्ष                                  | एथेरियम समकक्ष                   |

| ---------------------------- | ------------------------------------- | ------------------------------------------ | --------------------------------- |

| **Genesis**                  | Contract की प्रारंभिक स्थिति        | क्लास कंस्ट्रक्टर                         | Contract कंस्ट्रक्टर              |

| **Schema**                   | Business Logic का Contract            | वर्ग                                      | Contract                          |

| **Interface**                | Contract का अर्थ                     | Interface (जावा) / विशेषता (Rust) / प्रोटोकॉल (स्विफ्ट) | ERC मानक                          |

| **Interface Implementation** | अर्थ और तर्क का मानचित्रण | कार्यान्वयन (Rust) / कार्यान्वित (जावा) | एप्लिकेशन बाइनरी Interface (ABI) |

बाएँ हाथ के कॉलम में RGB प्रोटोकॉल के लिए विशिष्ट Elements दिखाया गया है। बीच के कॉलम में प्रत्येक घटक का ठोस कार्य दिखाया गया है। फिर, "OOP समकक्ष" कॉलम में, हमें ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग में समकक्ष शब्द मिलता है।


- **Genesis** का काम कुछ वैसा ही है जैसा कि एक *क्लास कंस्ट्रक्टर* का होता है: यहीं पर Contract की स्थिति को प्रारंभ किया जाता है;
- **Schema** एक क्लास का विवरण है, यानी इसके गुण, विधियाँ और इसके पीछे की तर्कशक्ति की परिभाषा।
- **Interface** का संबंध *इंटरफेसेस* (जावा), *ट्रेट्स* (Rust) या *प्रोटोकॉल्स* (स्विफ्ट) से है: ये फंक्शन्स, इवेंट्स, फील्ड्स आदि की सार्वजनिक परिभाषाएँ होती हैं।
- **Interface Implementation** का मतलब है *Impl* जो कि Rust में होता है या *Implements* जो कि Java में होता है। इसमें हम यह बताते हैं कि Interface में घोषित किए गए तरीकों को असल में कैसे चलाया जाएगा।

एथेरियम के संदर्भ में, Genesis *Contract कंस्ट्रक्टर* के करीब है, Schema Contract की परिभाषा के करीब है, Interface एक मानक जैसे ERC-20 या ERC-721 के समान है, और Interface Implementation ABI (*एप्लिकेशन बाइनरी Interface*) के समान है, जो Contract के साथ इंटरैक्शन के फॉर्मेट को निर्दिष्ट करता है।

RGB की मॉड्यूलरिटी का फायदा यह है कि विभिन्न हितधारक, उदाहरण के लिए, अपना खुद का Interface Implementation लिख सकते हैं, बशर्ते वे *Schema* की लॉजिक और *Interface* के अर्थ का सम्मान करें। इस तरह, एक जारीकर्ता एक नया, अधिक उपयोगकर्ता-अनुकूल फ्रंट-एंड (Interface) विकसित कर सकता है, बिना Contract की लॉजिक को बदले, या इसके विपरीत, कोई Schema को बढ़ाकर नई कार्यक्षमता जोड़ सकता है, और अनुकूलित Interface Implementation का एक नया संस्करण प्रदान कर सकता है, जबकि पुरानी कार्यान्वयन बुनियादी कार्यक्षमता के लिए मान्य बनी रहेंगी।

जब हम एक नया Contract तैयार करते हैं, तो हम generate के साथ एक Genesis (जो संपत्ति जारी करने या वितरित करने का पहला कदम है) और इसके घटकों (Schema, Interface, Interface Implementation) को भी शामिल करते हैं। इसके बाद, Contract पूरी तरह से कार्यशील हो जाता है और इसे वॉलेट्स और उपयोगकर्ताओं तक पहुंचाया जा सकता है। इस विधि में, जहां Genesis को इन तीन घटकों के साथ जोड़ा जाता है, यह उच्च स्तर की अनुकूलन क्षमता (प्रत्येक Contract का अपना तर्क हो सकता है), विकेंद्रीकरण (हर कोई किसी दिए गए घटक में योगदान कर सकता है), और सुरक्षा (प्रमाणीकरण प्रोटोकॉल द्वारा सख्ती से परिभाषित रहता है, बिना किसी मनमाने On-Chain कोड पर निर्भर हुए, जैसा कि अक्सर अन्य ब्लॉकचेन पर होता है) की गारंटी देता है।

अब मैं इन घटकों पर करीब से नज़र डालना चाहूँगा: **Schema**, **Interface** और **Interface Implementation**।

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

पिछले भाग में, हमने देखा कि RGB इकोसिस्टम में, एक Contract कई Elements से बना होता है: Genesis, जो प्रारंभिक स्थिति स्थापित करता है, और कई अन्य पूरक घटक। Schema का उद्देश्य सभी Business Logic का घोषणात्मक रूप से वर्णन करना है, यानी डेटा संरचना, उपयोग किए गए प्रकार, अनुमत संचालन और उनकी शर्तें। इसलिए, यह Contract को क्लाइंट साइड पर संचालित करने के लिए एक बहुत ही महत्वपूर्ण तत्व है, क्योंकि प्रत्येक प्रतिभागी (जैसे कि एक Wallet) को यह सुनिश्चित करना होता है कि उसे प्राप्त होने वाले स्थिति परिवर्तन Schema में परिभाषित तर्क के अनुरूप हैं।

Schema को वस्तु-उन्मुख प्रोग्रामिंग (OOP) में "क्लास" के समान समझा जा सकता है। सामान्य रूप से, यह एक मॉडल के रूप में कार्य करता है जो Contract के घटकों को परिभाषित करता है, जैसे:


- स्वामित्व वाले राज्यों और असाइनमेंट्स के विभिन्न प्रकार;
- वैलेंसीज, यानी विशेष अधिकार जो कुछ खास कार्यों के लिए सक्रिय (*भुनाए*) किए जा सकते हैं;
- Global State क्षेत्र, जो Contract की वैश्विक, सार्वजनिक और साझा विशेषताओं का वर्णन करते हैं;
- Genesis संरचना (जो Contract को सक्रिय करने वाली सबसे पहली प्रक्रिया है);
- राज्य संक्रमण और राज्य विस्तार के अनुमत रूप, और ये ऑपरेशन कैसे संशोधित कर सकते हैं;
- प्रत्येक ऑपरेशन के साथ जुड़े मेटाडेटा का उपयोग अस्थायी या अतिरिक्त जानकारी को स्टोर करने के लिए किया जाता है।
- नियम जो यह निर्धारित करते हैं कि आंतरिक Contract डेटा कैसे विकसित हो सकता है (जैसे, क्या कोई फ़ील्ड परिवर्तनीय है या संचयी);
- ऑपरेशनों के अनुक्रम जो मान्य माने जाते हैं: जैसे, संक्रमणों के क्रम का पालन करना या कुछ तार्किक शर्तों को पूरा करना।

![RGB-Bitcoin](assets/fr/071.webp)

जब RGB पर किसी संपत्ति का *जारीकर्ता* Contract प्रकाशित करता है, तो वह इसके साथ जुड़े Genesis और Schema भी प्रदान करता है। जो उपयोगकर्ता या वॉलेट इस संपत्ति के साथ इंटरैक्ट करना चाहते हैं, वे इस Schema को प्राप्त करते हैं ताकि वे Contract के पीछे की तर्क को समझ सकें और बाद में यह सत्यापित कर सकें कि जिन लेन-देन में वे भाग लेंगे, वे वैध हैं।

पहला कदम, किसी भी व्यक्ति के लिए जो RGB संपत्ति (जैसे कि एक टोकन ट्रांसफर) के बारे में जानकारी प्राप्त कर रहा है, इस जानकारी को Schema के खिलाफ सत्यापित करना है। इसमें Schema संकलन का उपयोग करना शामिल है ताकि:


- सुनिश्चित करें कि Owned States, Assignments और अन्य Elements सही तरीके से परिभाषित हैं और वे निर्धारित प्रकारों का पालन करते हैं (जिसे *सख्त प्रकार प्रणाली* कहा जाता है);
- यह सुनिश्चित करें कि संक्रमण नियम (मान्यता स्क्रिप्ट्स) पूरे हो रहे हैं। ये स्क्रिप्ट्स AluVM के माध्यम से चलाई जा सकती हैं, जो क्लाइंट साइड पर मौजूद है और Business Logic (हस्तांतरण राशि, विशेष शर्तें, आदि) की संगति की जांच करने के लिए जिम्मेदार है।

व्यवहार में, Schema निष्पादन योग्य कोड नहीं है, जैसा कि उन ब्लॉकचेन में देखा जा सकता है जो On-Chain कोड (Ethereum पर EVM) संग्रहीत करते हैं। इसके विपरीत, RGB, Business Logic (घोषणात्मक) को Blockchain पर निष्पादन योग्य कोड से अलग करता है (जो कि क्रिप्टोग्राफिक एंकरों तक सीमित है)। इस प्रकार, Schema नियमों को निर्धारित करता है, लेकिन इन नियमों का अनुप्रयोग Blockchain के बाहर, प्रत्येक प्रतिभागी की साइट पर, Client-side Validation सिद्धांत के अनुसार होता है।

Schema को RGB एप्लिकेशनों द्वारा उपयोग किए जाने से पहले संकलित किया जाना चाहिए। इस संकलन से एक बाइनरी फाइल (जैसे `.RGB`) या एक एन्क्रिप्टेड बाइनरी फाइल (`.rgba`) बनती है। जब Wallet इस फाइल को आयात करता है, तो उसे पता होता है:


- प्रत्येक डेटा प्रकार (जैसे पूर्णांक, संरचनाएँ, ऐरे...) कैसा दिखता है, यह सख्त प्रकार प्रणाली के कारण स्पष्ट होता है।
- Genesis को कैसे संरचित किया जाना चाहिए (संपत्ति प्रारंभिकरण को समझने के लिए);
- विभिन्न प्रकार की प्रक्रियाएँ (जैसे स्टेट ट्रांज़िशन और स्टेट एक्सटेंशन) और वे कैसे स्थिति को बदल सकती हैं;
- Schema में पेश किए गए स्क्रिप्टिंग नियम, जिन्हें AluVM इंजन ऑपरेशनों की वैधता जांचने के लिए लागू करेगा।

जैसा कि पिछले अध्यायों में समझाया गया है, *सख्त प्रकार प्रणाली* हमें एक स्थिर और पूर्वानुमानित एन्कोडिंग प्रारूप देती है: सभी वेरिएबल्स, चाहे वे ओन्ड स्टेट्स हों, ग्लोबल स्टेट्स हों या वैलेंसीज हों, को सटीक रूप से वर्णित किया जाता है (आकार, निचली और ऊपरी सीमाएं यदि आवश्यक हो, साइन किया हुआ या अनसाइन किया हुआ प्रकार, आदि)। यह जटिल उपयोग मामलों का समर्थन करने के लिए नेस्टेड संरचनाओं को परिभाषित करना भी संभव बनाता है।

Schema एक मूल `SchemaId` का संदर्भ दे सकता है, जो एक मौजूदा बुनियादी संरचना (एक टेम्पलेट) के पुनः उपयोग को आसान बनाता है। इस तरह, आप Contract को विकसित कर सकते हैं या पहले से सिद्ध टेम्पलेट से विभिन्न प्रकार (जैसे एक नए प्रकार का टोकन) बना सकते हैं। यह मॉड्यूलरिटी पूरे अनुबंधों को फिर से बनाने की आवश्यकता को समाप्त करती है और सर्वोत्तम प्रथाओं के मानकीकरण को प्रोत्साहित करती है।

एक और महत्वपूर्ण बिंदु यह है कि राज्य के विकास की तर्कशक्ति (जैसे कि ट्रांसफर, अपडेट आदि) Schema में स्क्रिप्ट्स, नियमों और शर्तों के रूप में वर्णित की गई है। इसलिए, यदि Contract का डिज़ाइनर पुनः जारी करने की अनुमति देना चाहता है या बर्न मैकेनिज्म (टोकन का विनाश) लागू करना चाहता है, तो वह Schema के सत्यापन भाग में AluVM के लिए संबंधित स्क्रिप्ट्स निर्दिष्ट कर सकता है।

#### प्रोग्रामेबल On-Chain ब्लॉकचेन से अंतर क्या है? 

ब्लॉकचेन तकनीक में कई प्रकार के ब्लॉकचेन होते हैं, और हर एक की अपनी विशेषताएँ होती हैं। प्रोग्रामेबल On-Chain ब्लॉकचेन भी एक विशेष प्रकार का ब्लॉकचेन है। 

इसका मुख्य अंतर यह है कि यह प्रोग्रामेबल है, यानी इसमें स्मार्ट कॉन्ट्रैक्ट्स और अन्य प्रोग्रामेबल फीचर्स को शामिल किया जा सकता है। इसका मतलब है कि आप इसमें कोड लिख सकते हैं जो स्वचालित रूप से कुछ कार्य कर सकता है। 

इसके विपरीत, कुछ ब्लॉकचेन केवल लेन-देन को रिकॉर्ड करने के लिए होते हैं और उनमें प्रोग्रामिंग की सुविधा नहीं होती। 

इसलिए, अगर आप एक ऐसा ब्लॉकचेन चाहते हैं जिसमें आप प्रोग्रामिंग कर सकें और स्मार्ट कॉन्ट्रैक्ट्स का उपयोग कर सकें, तो प्रोग्रामेबल On-Chain ब्लॉकचेन आपके लिए उपयुक्त हो सकता है।

एथेरियम जैसे सिस्टम के विपरीत, जहां Smart contract कोड (जो निष्पादित होता है) सीधे Blockchain में लिखा जाता है, RGB अपने Contract (उसकी लॉजिक) off-chain को एक संकलित घोषणात्मक दस्तावेज़ के रूप में संग्रहीत करता है। इसका मतलब यह है कि:


- Bitcoin नेटवर्क के हर नोड में कोई ट्यूरिंग-कम्प्लीट वर्चुअल मशीन नहीं चल रही है। RGB और Contract के नियम Blockchain पर नहीं चलते, बल्कि हर उस उपयोगकर्ता में चलते हैं जो किसी स्थिति को मान्य करना चाहता है।
- Contract डेटा Blockchain को प्रदूषित नहीं करता है: केवल क्रिप्टोग्राफिक सबूत (*प्रतिबद्धताएँ*) Bitcoin लेनदेन में शामिल होते हैं (जैसे `Tapret` या `Opret` के माध्यम से);
- Schema को अपडेट या अस्वीकार किया जा सकता है (जैसे *फास्ट-फॉरवर्ड*, *पुश-बैक*, आदि) बिना Fork की आवश्यकता के Bitcoin Blockchain पर। वॉलेट्स को बस नए Schema को इम्पोर्ट करना होता है और सहमति में हुए बदलावों के अनुसार खुद को ढालना होता है।

#### जारीकर्ता और उपयोगकर्ताओं द्वारा उपयोग

जब एक *जारीकर्ता* एक संपत्ति बनाता है (उदाहरण के लिए, एक गैर-मुद्रास्फीति योग्य फंजिबल टोकन), तो वह तैयार करता है:


- Schema में उत्सर्जन, स्थानांतरण आदि के नियमों का वर्णन किया गया है।
- Genesis को Schema के अनुसार अनुकूलित किया गया है (जिसमें जारी किए गए टोकन की कुल संख्या, प्रारंभिक मालिक की पहचान, पुनः जारी करने के लिए कोई विशेष वैलेंसी आदि शामिल हैं)।

इसके बाद, यह संकलित Schema (एक `.RGB` फाइल) उपयोगकर्ताओं के लिए उपलब्ध कराता है, ताकि इस टोकन का स्थानांतरण प्राप्त करने वाला कोई भी व्यक्ति स्थानीय रूप से ऑपरेशन की संगति की जांच कर सके। बिना इस Schema के, कोई उपयोगकर्ता स्थिति डेटा की व्याख्या नहीं कर पाएगा या यह जांच नहीं कर पाएगा कि यह Contract नियमों का पालन करता है या नहीं।

जब कोई नया Wallet किसी संपत्ति का समर्थन करना चाहता है, तो उसे बस संबंधित Schema को एकीकृत करना होता है। इस प्रणाली के कारण नए RGB संपत्ति प्रकारों के साथ संगतता जोड़ना संभव हो जाता है, बिना Wallet के सॉफ़्टवेयर बेस में बड़े बदलाव किए: बस Schema बाइनरी को आयात करना और उसकी संरचना को समझना आवश्यक होता है।

Schema, RGB में Business Logic को परिभाषित करता है। यह Contract के विकास नियमों, इसके डेटा की संरचना (स्वामित्व वाले राज्य, Global State, वैलेंसीज) और संबंधित सत्यापन स्क्रिप्ट्स (जो AluVM द्वारा निष्पादित की जा सकती हैं) को सूचीबद्ध करता है। इस घोषणात्मक दस्तावेज़ की बदौलत, Contract (कंपाइल्ड फाइल) की परिभाषा को नियमों के वास्तविक निष्पादन (क्लाइंट-साइड) से स्पष्ट रूप से अलग किया गया है। यह अलगाव RGB को बड़ी लचीलापन प्रदान करता है, जिससे विभिन्न प्रकार के उपयोग मामलों (फंजिबल टोकन, NFT, अधिक जटिल अनुबंध) को सक्षम किया जा सकता है, जबकि प्रोग्रामेबल On-Chain ब्लॉकचेन की जटिलता और खामियों से बचा जा सकता है।

#### मुझे खेद है, लेकिन आपके द्वारा दिए गए "Schema" के संदर्भ में मेरे पास कोई विशेष जानकारी नहीं है। क्या आप कृपया इसे थोड़ा और स्पष्ट कर सकते हैं या इसके बारे में अधिक जानकारी दे सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

आइए Schema के एक ठोस उदाहरण पर नज़र डालते हैं, जो RGB और Contract के लिए है। यह Rust में `nia.rs` फाइल से एक अंश है (जिसका मतलब है "*गैर-फुलाने योग्य संपत्तियाँ*"), जो ऐसे फंजिबल टोकन के लिए एक मॉडल को परिभाषित करता है जिन्हें उनकी प्रारंभिक Supply से आगे पुनः जारी नहीं किया जा सकता (एक गैर-मुद्रास्फीति संपत्ति)। इस प्रकार के टोकन को RGB ब्रह्मांड में Ethereum पर ERC20 के समकक्ष के रूप में देखा जा सकता है, यानी ऐसे फंजिबल टोकन जो कुछ बुनियादी नियमों का पालन करते हैं (जैसे कि ट्रांसफर पर, Supply प्रारंभिकरण, आदि)।

कोड में जाने से पहले, RGB Schema की सामान्य संरचना को याद करना फायदेमंद होगा। इसमें घोषणाओं की एक श्रृंखला होती है जो इसे फ्रेम करती है:


- एक संभावित `SchemaId` जो यह दर्शाता है कि एक और बुनियादी Schema को टेम्पलेट के रूप में उपयोग किया जा रहा है;
- **वैश्विक अवस्थाएँ** और **स्वामित्व वाली अवस्थाएँ** (उनकी सख्त प्रकारों के साथ);
- संयोजकताएँ (यदि कोई हों);
- **ऑपरेशन्स** (Genesis, स्टेट ट्रांज़िशन्स, स्टेट एक्सटेंशन्स) जो इन स्टेट्स और वैलेंसीज़ का संदर्भ दे सकते हैं;
- **सख्त प्रकार प्रणाली** का उपयोग डेटा का वर्णन और सत्यापन करने के लिए किया जाता है;
- सत्यापन स्क्रिप्ट्स** (AluVM के माध्यम से चलाएं)।

![RGB-Bitcoin](assets/fr/072.webp)

नीचे दिया गया कोड Rust Schema की पूरी परिभाषा दिखाता है। हम इसे भाग-भाग में समझाएंगे, नीचे दिए गए टिप्पणियों (1) से (9) के अनुसार:

```rust
// ===== PART 1: Function Header and SubSchema =====
fn nia_schema() -> SubSchema {
// definitions of libraries and variables
// ===== PART 2: General Properties (ffv, subset_of, type_system) =====
Schema {
ffv: zero!(),
subset_of: None,
type_system: types.type_system(),
// ===== PART 3: Global States =====
global_types: tiny_bmap! {
GS_NOMINAL => GlobalStateSchema::once(types.get("RGBContract.DivisibleAssetSpec")),
GS_DATA => GlobalStateSchema::once(types.get("RGBContract.ContractData")),
GS_TIMESTAMP => GlobalStateSchema::once(types.get("RGBContract.Timestamp")),
GS_ISSUED_SUPPLY => GlobalStateSchema::once(types.get("RGBContract.Amount")),
},
// ===== PART 4: Owned Types =====
owned_types: tiny_bmap! {
OS_ASSET => StateSchema::Fungible(FungibleType::Unsigned64Bit),
},
// ===== PART 5: Valencies =====
valency_types: none!(),
// ===== PART 6: Genesis: Initial Operations =====
genesis: GenesisSchema {
metadata: Ty::<SemId>::UNIT.id(None),
globals: tiny_bmap! {
GS_NOMINAL => Occurrences::Once,
GS_DATA => Occurrences::Once,
GS_TIMESTAMP => Occurrences::Once,
GS_ISSUED_SUPPLY => Occurrences::Once,
},
assignments: tiny_bmap! {
OS_ASSET => Occurrences::OnceOrMore,
},
valencies: none!(),
},
// ===== PART 7: Extensions =====
extensions: none!(),
// ===== PART 8: Transitions: TS_TRANSFER =====
transitions: tiny_bmap! {
TS_TRANSFER => TransitionSchema {
metadata: Ty::<SemId>::UNIT.id(None),
globals: none!(),
inputs: tiny_bmap! {
OS_ASSET => Occurrences::OnceOrMore,
},
assignments: tiny_bmap! {
OS_ASSET => Occurrences::OnceOrMore,
},
valencies: none!(),
}
},
// ===== PART 9: Script AluVM and Entry Points =====
script: Script::AluVM(AluScript {
libs: confined_bmap! { alu_id => alu_lib },
entry_points: confined_bmap! {
EntryPoint::ValidateGenesis => LibSite::with(FN_GENESIS_OFFSET, alu_id),
EntryPoint::ValidateTransition(TS_TRANSFER) => LibSite::with(FN_TRANSFER_OFFSET, alu_id),
},
}),
}
}
```


- (1) - फ़ंक्शन हेडर और सबस्कीमा**

`nia_schema()` फ़ंक्शन एक `SubSchema` लौटाता है, जो यह दर्शाता है कि यह Schema आंशिक रूप से एक अधिक सामान्य Schema से विरासत में ले सकता है। RGB पारिस्थितिकी तंत्र में, यह लचीलापन कुछ मानक Elements को एक मुख्य Schema से पुनः उपयोग करने की अनुमति देता है, और फिर संबंधित Contract के लिए विशिष्ट नियमों को परिभाषित करता है। यहाँ, हम विरासत को सक्षम नहीं करने का निर्णय लेते हैं, क्योंकि `subset_of` `None` होगा।


- (2) - सामान्य गुणधर्म: ffv, subset_of, type_system**

`ffv` प्रॉपर्टी Contract के *फास्ट-फॉरवर्ड* वर्ज़न से संबंधित है। अगर यहाँ `zero!()` का मान है, तो इसका मतलब है कि हम वर्ज़न 0 या इस Schema के शुरुआती वर्ज़न पर हैं। अगर आप बाद में नई कार्यक्षमताएँ (जैसे नई प्रकार की ऑपरेशन आदि) जोड़ना चाहते हैं, तो आप इस वर्ज़न को बढ़ा सकते हैं ताकि यह दर्शाया जा सके कि कोई सहमति में बदलाव हुआ है।

`subset_of: None` प्रॉपर्टी यह पुष्टि करती है कि कोई विरासत नहीं है। `type_system` फ़ील्ड उस सख्त प्रकार प्रणाली का उल्लेख करता है जो पहले से ही `types` लाइब्रेरी में परिभाषित है। यह पंक्ति यह दर्शाती है कि Contract द्वारा उपयोग किया गया सारा डेटा उस लाइब्रेरी द्वारा प्रदान की गई सख्त सीरियलाइज़ेशन कार्यान्वयन का उपयोग करता है।


- (3) - वैश्विक राज्य

`global_types` खंड में, हम चार Elements घोषित करते हैं। हम बाद में उन्हें संदर्भित करने के लिए `GS_NOMINAL` या `GS_ISSUED_SUPPLY` जैसे कुंजी का उपयोग करते हैं।


- `GS_NOMINAL` एक `DivisibleAssetSpec` प्रकार को संदर्भित करता है, जो बनाए गए टोकन के विभिन्न क्षेत्रों का वर्णन करता है (पूरा नाम, टिकर, सटीकता आदि)।
- `GS_DATA` सामान्य डेटा का प्रतिनिधित्व करता है, जैसे कि एक अस्वीकरण, मेटाडेटा, या अन्य पाठ।
- `GS_TIMESTAMP` का मतलब है जारी होने की तारीख।
- `GS_ISSUED_SUPPLY` कुल Supply को निर्धारित करता है, यानी यह अधिकतम संख्या है जितने टोकन बनाए जा सकते हैं।

कुंजीशब्द `once(...)` का मतलब है कि इनमें से प्रत्येक फ़ील्ड केवल एक बार ही दिखाई दे सकता है।


- (4) - स्वामित्व वाले प्रकार

`owned_types` में, हम `OS_ASSET` को घोषित करते हैं, जो एक फंजिबल स्टेट को दर्शाता है। हम `StateSchema::Fungible(FungibleType::Unsigned64Bit)` का उपयोग करते हैं, जो यह दर्शाता है कि संपत्तियों (टोकन) की मात्रा 64-बिट अनसाइनड इंटीजर के रूप में संग्रहीत की जाती है। इस प्रकार, कोई भी लेन-देन इस टोकन की एक निश्चित मात्रा को भेजेगा, जिसे इस सख्त टाइप्ड संख्यात्मक संरचना के अनुसार सत्यापित किया जाएगा।


- (5) - संयोजकताएँ**

हमने `valency_types: none!()` का संकेत दिया है, जिसका मतलब है कि इस Schema में कोई वैलेंसी नहीं है, यानी कोई विशेष या अतिरिक्त अधिकार (जैसे पुनः जारी करना, शर्तीय जलाना, आदि) नहीं हैं। अगर किसी Schema में कोई होते, तो उन्हें इस खंड में घोषित किया जाता।


- (6) - Genesis: पहली कार्रवाइयाँ

यहाँ हम उस हिस्से में प्रवेश करते हैं जो Contract ऑपरेशन्स की घोषणा करता है। Genesis का वर्णन इस प्रकार है:


- `metadata` की अनुपस्थिति (फील्ड `metadata: Ty::<SemId>::UNIT.id(None)`) ;
- वैश्विक अवस्थाएँ जिन्हें प्रत्येक बार उपस्थित होना चाहिए (`एक बार`);
- एक असाइनमेंट सूची में `OS_ASSET` का कम से कम एक बार या अधिक बार आना आवश्यक है। इसका मतलब है कि Genesis को कम से कम एक `OS_ASSET` की आवश्यकता होती है, जैसे कि Assignment (एक प्रारंभिक धारक)।
- नहीं Valency: `valencies: none!()`.

हम प्रारंभिक टोकन जारी करने की परिभाषा को इस तरह सीमित करते हैं: हमें Supply जारी (`GS_ISSUED_SUPPLY`) घोषित करना होगा, साथ ही कम से कम एक धारक (प्रकार `OS_ASSET` का Owned State) भी होना चाहिए।


- (7) - एक्सटेंशन

`extensions: none!()` फ़ील्ड यह दर्शाता है कि इस Contract में कोई State Extension की योजना नहीं है। इसका मतलब है कि Redeem के लिए कोई डिजिटल अधिकार (Valency) का संचालन नहीं किया जाएगा और न ही किसी ट्रांज़िशन से पहले कोई State Extension किया जाएगा। सभी कार्य Genesis या स्टेट ट्रांज़िशन के माध्यम से किए जाते हैं।


- (8) - परिवर्तन: TS_TRANSFER

'ट्रांज़िशन्स' में, हम 'TS_TRANSFER' प्रकार के ऑपरेशन को परिभाषित करते हैं। हम यह समझाते हैं कि:


- इसमें कोई मेटाडेटा नहीं है।
- यह Global State को संशोधित नहीं करता है (जो पहले से ही Genesis में परिभाषित है);
- यह एक या अधिक `OS_ASSETs` को इनपुट के रूप में लेता है। इसका मतलब है कि इसे मौजूदा Owned States को खर्च करना होगा।
- यह कम से कम एक नया `OS_ASSET` बनाता है (दूसरे शब्दों में, प्राप्तकर्ता या प्राप्तकर्ताओं को टोकन मिलते हैं);
- यह कोई नया Valency उत्पन्न नहीं करता है।

यह एक बुनियादी ट्रांसफर के व्यवहार को दर्शाता है, जो UTXO पर टोकन का उपयोग करता है, फिर प्राप्तकर्ताओं के पक्ष में नए ओन्ड स्टेट्स बनाता है, और इस प्रकार इनपुट और आउटपुट के बीच कुल राशि की समानता को बनाए रखता है।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

अंत में, हम एक AluVM स्क्रिप्ट घोषित करते हैं (`Script::AluVM(AluScript { ... })`)। इस स्क्रिप्ट में शामिल हैं:


- सत्यापन के दौरान उपयोग के लिए एक या अधिक बाहरी पुस्तकालय (`लाइब्रेरीज़`)।
- AluVM कोड में एंट्री पॉइंट्स, जो फंक्शन ऑफसेट्स की ओर इशारा करते हैं, Genesis (`ValidateGenesis`) की वैलिडेशन और प्रत्येक घोषित ट्रांज़िशन (`ValidateTransition(TS_TRANSFER)`) के लिए हैं।

यह सत्यापन कोड Business Logic को लागू करने के लिए जिम्मेदार है। उदाहरण के लिए, यह जांच करेगा:


- यह सुनिश्चित करें कि `GS_ISSUED_SUPPLY` Genesis के दौरान पार नहीं हो।
- `TS_TRANSFER` के लिए `inputs` (खर्च किए गए टोकन) का योग `assignments` (प्राप्त किए गए टोकन) के योग के बराबर होता है।

अगर इन नियमों का पालन नहीं किया गया, तो यह परिवर्तन अमान्य माना जाएगा।

यह "*गैर-फुलने योग्य फंजिबल एसेट*" Schema का उदाहरण हमें एक साधारण RGB फंजिबल टोकन Contract की संरचना को बेहतर ढंग से समझने में मदद करता है। हम स्पष्ट रूप से देख सकते हैं कि डेटा विवरण (वैश्विक और स्वामित्व वाले राज्य), संचालन घोषणा (Genesis, ट्रांज़िशन, एक्सटेंशन) और सत्यापन कार्यान्वयन (AluVM स्क्रिप्ट्स) के बीच अलगाव है। इस मॉडल के कारण, एक टोकन एक क्लासिक फंजिबल टोकन की तरह व्यवहार करता है, लेकिन यह क्लाइंट साइड पर सत्यापित रहता है और अपने कोड को निष्पादित करने के लिए On-Chain इंफ्रास्ट्रक्चर पर निर्भर नहीं करता। केवल क्रिप्टोग्राफिक प्रतिबद्धताएं Bitcoin Blockchain में एंकर की जाती हैं।

### Interface एक प्रकार की दवा है जिसे अक्सर एथलीट्स और बॉडीबिल्डर्स द्वारा उपयोग किया जाता है। इसे आमतौर पर "कार्डारिन" के नाम से भी जाना जाता है। यह दवा शरीर में सहनशक्ति बढ़ाने और वसा को कम करने में मदद करती है। हालांकि, इसे कई खेल संगठनों द्वारा प्रतिबंधित किया गया है क्योंकि इसके दीर्घकालिक प्रभावों के बारे में पूरी जानकारी नहीं है और यह स्वास्थ्य के लिए हानिकारक हो सकता है। इसलिए, इसका उपयोग करने से पहले सावधानी बरतनी चाहिए और विशेषज्ञ की सलाह लेनी चाहिए।

Interface वास्तव में Layer का एक संस्करण है जिसे इस तरह से डिज़ाइन किया गया है कि वह Contract को पढ़ने और उसमें बदलाव करने योग्य बना सके, चाहे वह इंसान द्वारा पढ़ा जा रहा हो या सॉफ़्टवेयर द्वारा। इस प्रकार, Interface का काम कुछ वैसा ही है जैसा कि एक ऑब्जेक्ट-ओरिएंटेड प्रोग्रामिंग भाषा (जैसे Java, Rust trait आदि) में होता है। यह Contract की कार्यात्मक संरचना को उजागर और स्पष्ट करता है, बिना Business Logic के आंतरिक विवरणों को ज़रूरी तौर पर प्रकट किए।

Schema के विपरीत, जो पूरी तरह से घोषणात्मक है और एक बाइनरी फाइल में संकलित होता है जिसे सीधे उपयोग करना मुश्किल होता है, Interface वह पढ़ने की कुंजियाँ प्रदान करता है जिनकी आवश्यकता होती है ताकि:


- मुझे खेद है, लेकिन मेरे पास Contract के बारे में कोई विशेष जानकारी नहीं है। अगर आप इसके बारे में कुछ और जानकारी देंगे, तो मैं आपकी मदद करने की कोशिश कर सकता हूँ।
- प्रत्येक फ़ील्ड के नाम और मानों तक पहुँच प्राप्त करें, ताकि उन्हें प्रदर्शित किया जा सके (जैसे कि किसी टोकन के लिए, उसका टिकर, अधिकतम मात्रा आदि जानें);
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। Contract ऑपरेशन्स (जैसे Genesis, State Transition, या State Extension) को समझने और बनाने के लिए, डेटा को समझने योग्य नामों के साथ जोड़ें। उदाहरण के लिए, जब आप कोई ट्रांसफर कर रहे हों, तो बाइनरी पहचानकर्ता की बजाय स्पष्ट रूप से "राशि" का उल्लेख करें।

![RGB-Bitcoin](assets/fr/073.webp)

Interface की मदद से, आप उदाहरण के लिए, Wallet में कोड लिख सकते हैं जो फील्ड्स को मैनेज करने के बजाय सीधे "टोकन्स की संख्या", "एसेट का नाम" जैसे लेबल्स को मैनेज करता है। इस तरह, Contract को मैनेज करना ज्यादा आसान और समझने में सरल हो जाता है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

इस विधि के कई फायदे हैं:


- मानकीकरण:

Contract के उसी प्रकार को एक मानक Interface द्वारा समर्थित किया जा सकता है, जिसे कई Wallet कार्यान्वयनों के बीच साझा किया जाता है। इससे संगतता और कोड पुनः उपयोग में आसानी होती है।


- Schema और Interface के बीच स्पष्ट अंतर:

RGB डिज़ाइन में, Schema (Business Logic) और Interface (प्रस्तुति और हेरफेर) दो स्वतंत्र इकाइयाँ हैं। जो डेवलपर्स Contract लॉजिक लिखते हैं, वे Schema पर ध्यान केंद्रित कर सकते हैं, बिना एर्गोनॉमिक्स या डेटा प्रस्तुति की चिंता किए, जबकि दूसरी टीम (या वही टीम, लेकिन अलग समयरेखा पर) Interface विकसित कर सकती है।


- लचीला विकास:**

Interface को तब भी संशोधित या जोड़ा जा सकता है जब संपत्ति जारी कर दी गई हो, और इसके लिए Contract को बदलने की आवश्यकता नहीं होती। यह कुछ On-Chain और Smart contract सिस्टम से एक बड़ा अंतर है, जहां Interface (जो अक्सर निष्पादन कोड के साथ मिलाया जाता है) को Blockchain में स्थिर कर दिया जाता है।


- मल्टी-Interface क्षमता

Contract को विभिन्न इंटरफेस के माध्यम से प्रस्तुत किया जा सकता है, जो अलग-अलग जरूरतों के अनुसार अनुकूलित होते हैं: एक साधारण Interface जो अंतिम उपयोगकर्ता के लिए है, और एक अधिक उन्नत जो जारीकर्ता के लिए है जिसे जटिल कॉन्फ़िगरेशन संचालन को प्रबंधित करने की आवश्यकता होती है। फिर Wallet यह तय कर सकता है कि उसे किस Interface को उपयोग के अनुसार आयात करना है।

![RGB-Bitcoin](assets/fr/074.webp)

व्यवहार में, जब Wallet एक RGB Contract को प्राप्त करता है (एक `.RGB` या `.rgba` फाइल के माध्यम से), तो यह संबंधित Interface को भी आयात करता है, जिसे भी संकलित किया जाता है। रनटाइम पर, Wallet उदाहरण के लिए ऐसा कर सकता है:


- आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं। राज्यों की सूची को ब्राउज़ करें और उनके नाम पढ़ें, ताकि उपयोगकर्ता Interface पर टिकर, प्रारंभिक राशि, जारी करने की तारीख आदि को एक अपठनीय संख्यात्मक पहचानकर्ता के बजाय प्रदर्शित किया जा सके।
- एक ऑपरेशन (जैसे कि ट्रांसफर) बनाएं जिसमें स्पष्ट पैरामीटर नामों का उपयोग हो: जैसे कि `assignments { OS_ASSET => 1 }` लिखने के बजाय, यह उपयोगकर्ता को एक फॉर्म में "राशि" फ़ील्ड प्रदान कर सकता है, और इस जानकारी को Contract द्वारा अपेक्षित सख्त टाइप किए गए फ़ील्ड्स में अनुवाद कर सकता है।

#### एथेरियम और अन्य सिस्टम्स के बीच अंतर क्या है?

एथेरियम एक ब्लॉकचेन प्लेटफॉर्म है जो स्मार्ट कॉन्ट्रैक्ट्स को सपोर्ट करता है। इसका मतलब है कि यह सिर्फ एक डिजिटल करेंसी नहीं है, बल्कि एक पूरी प्रोग्रामेबल प्लेटफॉर्म है जहां डेवलपर्स अपने खुद के एप्लिकेशन बना सकते हैं। 

दूसरी ओर, बिटकॉइन जैसी अन्य क्रिप्टोकरेंसी मुख्य रूप से डिजिटल करेंसी के रूप में काम करती हैं और उनका मुख्य उद्देश्य लेन-देन को सुरक्षित और विकेंद्रीकृत तरीके से करना है। 

एथेरियम की खासियत यह है कि यह डेवलपर्स को अपने खुद के विकेंद्रीकृत एप्लिकेशन (dApps) बनाने की सुविधा देता है, जो कि पारंपरिक सिस्टम्स में संभव नहीं है। इसके अलावा, एथेरियम का अपना क्रिप्टो टोकन, ईथर (ETH), भी है जो नेटवर्क पर लेन-देन के लिए उपयोग होता है।

इस प्रकार, एथेरियम और अन्य सिस्टम्स के बीच मुख्य अंतर उनके उपयोग और कार्यक्षमता में है। एथेरियम एक बहुउद्देश्यीय प्लेटफॉर्म है, जबकि अन्य सिस्टम्स अक्सर एक विशेष उद्देश्य के लिए डिज़ाइन किए गए होते हैं।

एथेरियम पर, Interface (जिसे ABI, *एप्लिकेशन बाइनरी Interface* के माध्यम से वर्णित किया गया है) आमतौर पर On-Chain संग्रहीत कोड (Smart contract) से व्युत्पन्न होता है। Interface के किसी विशेष भाग को संशोधित करना महंगा या जटिल हो सकता है बिना Contract को छुए। हालांकि, RGB पूरी तरह से off-chain लॉजिक पर आधारित है, जिसमें डेटा Bitcoin पर *प्रतिबद्धताओं* में एंकर किया गया है। इस डिज़ाइन के कारण Interface (या इसके कार्यान्वयन) को संशोधित करना संभव हो जाता है बिना Contract की मौलिक सुरक्षा को प्रभावित किए, क्योंकि व्यापार नियमों का सत्यापन Schema और संदर्भित AluVM कोड में बना रहता है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

जैसे Schema के साथ होता है, वैसे ही Interface को भी स्रोत कोड में परिभाषित किया जाता है (अक्सर Rust में) और इसे एक `.RGB` या `.rgba` फाइल में संकलित किया जाता है। इस बाइनरी फाइल में Wallet द्वारा आवश्यक सभी जानकारी होती है ताकि:


- फील्ड्स को उनके नाम से पहचानें।
- Contract में परिभाषित सख्त सिस्टम प्रकार से प्रत्येक क्षेत्र (और उसकी मान्यता) को जोड़ें।
- विभिन्न ऑपरेशनों को जानें और उन्हें कैसे बनाना है।

जब Interface को आयात कर लिया जाता है, तो Wallet सही तरीके से Contract को प्रदर्शित कर सकता है और उपयोगकर्ता को इंटरैक्शन के सुझाव दे सकता है।

### LNP/BP एसोसिएशन द्वारा मानकीकृत इंटरफेस

RGB इकोसिस्टम में, एक Interface का उपयोग डेटा और Contract के संचालन को पढ़ने योग्य और संचालित करने योग्य अर्थ देने के लिए किया जाता है। इस तरह, Interface, Schema को पूरा करता है, जो आंतरिक रूप से Business Logic का वर्णन करता है (जैसे कि सख्त प्रकार, सत्यापन स्क्रिप्ट आदि)। इस खंड में, हम LNP/BP एसोसिएशन द्वारा विकसित मानक इंटरफेस पर नज़र डालेंगे, जो सामान्य Contract प्रकारों (फंजिबल टोकन, NFT आदि) के लिए हैं।

याद दिलाने के लिए, विचार यह है कि प्रत्येक Interface यह बताता है कि Contract को Wallet पक्ष पर कैसे प्रदर्शित और प्रबंधित किया जाए, जिसमें फील्ड्स (जैसे `spec`, `ticker`, `issuedSupply`...) को स्पष्ट रूप से नामित किया जाए और संभावित ऑपरेशन्स (जैसे `Transfer`, `Burn`, `Rename`...) को परिभाषित किया जाए। कई इंटरफेस पहले से ही काम कर रहे हैं, लेकिन भविष्य में और भी अधिक होंगे।

#### कुछ तैयार-प्रयोग करने योग्य इंटरफेस

**RGB20** एक प्रकार का Interface है जो फंजिबल एसेट्स के लिए है, जिसे आप Ethereum के ERC20 स्टैंडर्ड से तुलना कर सकते हैं। लेकिन यह उससे एक कदम आगे बढ़कर और भी अधिक कार्यक्षमता प्रदान करता है:


- उदाहरण के लिए, किसी संपत्ति का नाम बदलने की क्षमता (जैसे *टिकर* या पूरा नाम बदलना) जब वह जारी हो चुकी हो, या उसकी सटीकता को समायोजित करना (*स्टॉक विभाजन*);
- यह यह भी बता सकता है कि कैसे द्वितीयक पुनः जारी करने की प्रक्रियाएँ (सीमित या असीमित) और जलाने और फिर से बदलने की प्रक्रियाएँ काम करती हैं, ताकि जारीकर्ता को कुछ विशेष परिस्थितियों में संपत्तियों को नष्ट करने और फिर से बनाने की अनुमति दी जा सके।

उदाहरण के लिए, RGB20 Interface को **नॉन-इंफ्लेटेबल एसेट (NIA) योजना** से जोड़ा जा सकता है, जो एक नॉन-इंफ्लेटेबल प्रारंभिक Supply लागू करती है, या आवश्यकता के अनुसार अन्य अधिक उन्नत योजनाओं से जोड़ा जा सकता है।

**RGB21** एनएफटी-प्रकार के अनुबंधों से संबंधित है, या अधिक व्यापक रूप से, किसी भी अनोखे डिजिटल सामग्री से, जैसे कि डिजिटल मीडिया का प्रतिनिधित्व (छवियाँ, संगीत, आदि)। यह एकल संपत्ति के जारी करने और स्थानांतरण का वर्णन करने के अलावा, इसमें कुछ विशेषताएँ भी शामिल हैं, जैसे:


- Contract में सीधे फाइल (16 MB तक) को शामिल करने के लिए एकीकृत समर्थन (क्लाइंट-साइड से प्राप्त करने के लिए) उपलब्ध है।
- मालिक के लिए यह संभावना है कि वह इतिहास में "*उत्कीर्णन*" दर्ज कर सके ताकि NFT के पिछले Ownership को साबित किया जा सके।

**RGB25** एक हाइब्रिड मानक है जो फंजिबल और नॉन-फंजिबल पहलुओं को मिलाता है। इसे आंशिक रूप से फंजिबल संपत्तियों के लिए डिज़ाइन किया गया है, जैसे कि रियल एस्टेट टोकनाइजेशन, जहाँ आप एक संपत्ति को विभाजित करना चाहते हैं लेकिन एक मूल संपत्ति से जुड़े रहना चाहते हैं (दूसरे शब्दों में, आपके पास एक घर के फंजिबल टुकड़े हैं, जो एक नॉन-फंजिबल घर से जुड़े हैं)। तकनीकी रूप से, यह Interface **कलेक्टिबल फंजिबल एसेट (CFA)** Schema से जुड़ा हो सकता है, जो मूल संपत्ति का पता लगाते हुए विभाजन की अवधारणा को ध्यान में रखता है।

#### विकासाधीन इंटरफेस

अन्य इंटरफेस विशेष उपयोगों के लिए योजना में हैं, लेकिन वे अभी तक उपलब्ध नहीं हैं।


- RGB22** डिजिटल पहचान के लिए समर्पित है, जो RGB इकोसिस्टम में पहचानकर्ताओं और On-Chain प्रोफाइल्स को प्रबंधित करता है।
- RGB23** एक उन्नत समय मुहर प्रणाली है, जो *Opentimestamps* के कुछ विचारों का उपयोग करती है, लेकिन इसमें ट्रेसबिलिटी की विशेषताएँ भी शामिल हैं।
- RGB24** एक ऐसा प्रोजेक्ट है जो एक विकेंद्रीकृत डोमेन नाम प्रणाली (DNS) के समकक्ष बनने का लक्ष्य रखता है, जो *Ethereum Name Service* के समान है।
- RGB26** एक ऐसा सिस्टम है जिसे DAOs (डिसेंट्रलाइज्ड ऑटोनॉमस ऑर्गनाइजेशन) को अधिक जटिल प्रारूप में प्रबंधित करने के लिए डिज़ाइन किया गया है, जिसमें शासन, मतदान आदि शामिल हैं।
- RGB30** वास्तव में RGB20 के समान है, लेकिन इसमें एक विशेषता यह है कि यह विकेंद्रीकृत प्रारंभिक जारी करने को ध्यान में रखता है और स्टेट एक्सटेंशन्स का उपयोग करता है। इसका उपयोग उन संपत्तियों के लिए किया जाएगा जिनका पुनः जारी करना कई संस्थाओं द्वारा प्रबंधित किया जाता है, या जो अधिक सूक्ष्म शर्तों के अधीन होती हैं।

बिल्कुल, जिस तारीख को आप इस कोर्स को देख रहे हैं, उसके आधार पर ये इंटरफेस शायद पहले से ही चालू और उपलब्ध हो सकते हैं।

#### मुझे खेद है, लेकिन "Interface" के बारे में मेरे पास कोई विशेष जानकारी नहीं है। क्या आप कृपया इसके बारे में अधिक जानकारी दे सकते हैं या कोई संदर्भ प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

यह Rust कोड स्निपेट [RGB20](https://github.com/RGB-WG/RGB-std/blob/master/src/Interface/rgb20.rs) Interface (फंजिबल एसेट) को दिखाता है। यह कोड RGB लाइब्रेरी के `rgb20.rs` फाइल से लिया गया है। आइए इसे देखें ताकि हम Interface की संरचना को समझ सकें और यह कैसे एक पुल का काम करता है, एक तरफ Business Logic (जो Schema में परिभाषित है) और दूसरी तरफ वॉलेट्स और उपयोगकर्ताओं को प्रदान की जाने वाली सुविधाओं के बीच।

```rust
// ...
fn rgb20() -> Iface {
let types = StandardTypes::with(rgb20_stl());
Iface {
version: VerNo::V1,
name: tn!("RGB20"),
global_state: tiny_bmap! {
fname!("spec") => GlobalIface::required(types.get("RGBContract.DivisibleAssetSpec")),
fname!("data") => GlobalIface::required(types.get("RGBContract.ContractData")),
fname!("created") => GlobalIface::required(types.get("RGBContract.Timestamp")),
fname!("issuedSupply") => GlobalIface::one_or_many(types.get("RGBContract.Amount")),
fname!("burnedSupply") => GlobalIface::none_or_many(types.get("RGBContract.Amount")),
fname!("replacedSupply") => GlobalIface::none_or_many(types.get("RGBContract.Amount")),
},
assignments: tiny_bmap! {
fname!("inflationAllowance") => AssignIface::public(OwnedIface::Amount, Req::NoneOrMore),
fname!("updateRight") => AssignIface::public(OwnedIface::Rights, Req::Optional),
fname!("burnEpoch") => AssignIface::public(OwnedIface::Rights, Req::Optional),
fname!("burnRight") => AssignIface::public(OwnedIface::Rights, Req::NoneOrMore),
fname!("assetOwner") => AssignIface::private(OwnedIface::Amount, Req::NoneOrMore),
},
valencies: none!(),
genesis: GenesisIface {
metadata: Some(types.get("RGBContract.IssueMeta")),
global: tiny_bmap! {
fname!("spec") => ArgSpec::required(),
fname!("data") => ArgSpec::required(),
fname!("created") => ArgSpec::required(),
fname!("issuedSupply") => ArgSpec::required(),
},
assignments: tiny_bmap! {
fname!("assetOwner") => ArgSpec::many(),
fname!("inflationAllowance") => ArgSpec::many(),
fname!("updateRight") => ArgSpec::optional(),
fname!("burnEpoch") => ArgSpec::optional(),
},
valencies: none!(),
errors: tiny_bset! {
SUPPLY_MISMATCH,
INVALID_PROOF,
INSUFFICIENT_RESERVES
},
},
transitions: tiny_bmap! {
tn!("Transfer") => TransitionIface {
optional: false,
metadata: None,
globals: none!(),
inputs: tiny_bmap! {
fname!("previous") => ArgSpec::from_non_empty("assetOwner"),
},
assignments: tiny_bmap! {
fname!("beneficiary") => ArgSpec::from_non_empty("assetOwner"),
},
valencies: none!(),
errors: tiny_bset! {
NON_EQUAL_AMOUNTS
},
default_assignment: Some(fname!("beneficiary")),
},
tn!("Issue") => TransitionIface {
optional: true,
metadata: Some(types.get("RGBContract.IssueMeta")),
globals: tiny_bmap! {
fname!("issuedSupply") => ArgSpec::required(),
},
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_non_empty("inflationAllowance"),
},
assignments: tiny_bmap! {
fname!("beneficiary") => ArgSpec::from_many("assetOwner"),
fname!("future") => ArgSpec::from_many("inflationAllowance"),
},
valencies: none!(),
errors: tiny_bset! {
SUPPLY_MISMATCH,
INVALID_PROOF,
ISSUE_EXCEEDS_ALLOWANCE,
INSUFFICIENT_RESERVES
},
default_assignment: Some(fname!("beneficiary")),
},
tn!("OpenEpoch") => TransitionIface {
optional: true,
metadata: None,
globals: none!(),
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_required("burnEpoch"),
},
assignments: tiny_bmap! {
fname!("next") => ArgSpec::from_optional("burnEpoch"),
fname!("burnRight") => ArgSpec::required()
},
valencies: none!(),
errors: none!(),
default_assignment: Some(fname!("burnRight")),
},
tn!("Burn") => TransitionIface {
optional: true,
metadata: Some(types.get("RGBContract.BurnMeta")),
globals: tiny_bmap! {
fname!("burnedSupply") => ArgSpec::required(),
},
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_required("burnRight"),
},
assignments: tiny_bmap! {
fname!("future") => ArgSpec::from_optional("burnRight"),
},
valencies: none!(),
errors: tiny_bset! {
SUPPLY_MISMATCH,
INVALID_PROOF,
INSUFFICIENT_COVERAGE
},
default_assignment: None,
},
tn!("Replace") => TransitionIface {
optional: true,
metadata: Some(types.get("RGBContract.BurnMeta")),
globals: tiny_bmap! {
fname!("replacedSupply") => ArgSpec::required(),
},
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_required("burnRight"),
},
assignments: tiny_bmap! {
fname!("beneficiary") => ArgSpec::from_many("assetOwner"),
fname!("future") => ArgSpec::from_optional("burnRight"),
},
valencies: none!(),
errors: tiny_bset! {
NON_EQUAL_AMOUNTS,
SUPPLY_MISMATCH,
INVALID_PROOF,
INSUFFICIENT_COVERAGE
},
default_assignment: Some(fname!("beneficiary")),
},
tn!("Rename") => TransitionIface {
optional: true,
metadata: None,
globals: tiny_bmap! {
fname!("new") => ArgSpec::from_required("spec"),
},
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_required("updateRight"),
},
assignments: tiny_bmap! {
fname!("future") => ArgSpec::from_optional("updateRight"),
},
valencies: none!(),
errors: none!(),
default_assignment: Some(fname!("future")),
},
},
extensions: none!(),
error_type: types.get("RGB20.Error"),
default_operation: Some(tn!("Transfer")),
type_system: types.type_system(),
}
}
```

इस Interface में, हम Schema संरचना के साथ समानताएँ देखते हैं: हमें Global State की घोषणा मिलती है, Owned States, Contract ऑपरेशन्स (Genesis और ट्रांज़िशन्स), और साथ ही एरर हैंडलिंग। लेकिन Interface का मुख्य ध्यान इन Elements की प्रस्तुति और प्रबंधन पर है, चाहे वह Wallet हो या कोई अन्य एप्लिकेशन।

Schema की खासियत इसके प्रकारों की प्रकृति में है। Schema सख्त प्रकारों (जैसे `FungibleType::Unsigned64Bit`) और अधिक तकनीकी पहचानकर्ताओं का उपयोग करता है। जबकि Interface फील्ड नाम, मैक्रोज़ (`fname!()`, `tn!()`) और आर्गुमेंट क्लासेस के संदर्भ (`ArgSpec`, `OwnedIface::Rights`...) का उपयोग करता है। इसका उद्देश्य Elements की कार्यात्मक समझ और संगठन को Wallet के लिए आसान बनाना है।

इसके अलावा, Interface में Schema के बुनियादी कार्यों में अतिरिक्त सुविधाएँ जोड़ी जा सकती हैं (जैसे `burnEpoch` अधिकार का प्रबंधन), जब तक कि यह अंतिम सत्यापित क्लाइंट-साइड लॉजिक के साथ संगत रहता है। Schema में AluVM "स्क्रिप्ट" सेक्शन क्रिप्टोग्राफिक वैधता सुनिश्चित करेगा, जबकि Interface यह बताएगा कि उपयोगकर्ता (या Wallet) इन अवस्थाओं और संक्रमणों के साथ कैसे इंटरैक्ट करता है।

#### Global State और असाइनमेंट्स

`global_state` सेक्शन में हमें कुछ फील्ड्स मिलते हैं जैसे `spec` (एसेट का विवरण), `data`, `created`, `issuedSupply`, `burnedSupply`, `replacedSupply`। ये वो फील्ड्स हैं जिन्हें Wallet पढ़ सकता है और प्रस्तुत कर सकता है। उदाहरण के लिए:


- `spec` टोकन की संरचना दिखाएगा।
- `issuedSupply` या `burnedSupply` हमें जारी किए गए या जलाए गए टोकनों की कुल संख्या बताते हैं।

`असाइनमेंट्स` सेक्शन में, हम विभिन्न भूमिकाओं या अधिकारों को परिभाषित करते हैं। उदाहरण के लिए:


- `assetOwner` का मतलब है टोकन का मालिकाना हक (यह एक प्रकार का विनिमेय *Owned State* है);
- `burnRight` का मतलब टोकन को जलाने की क्षमता से है।
- `updateRight` का मतलब है संपत्ति का नाम बदलने का अधिकार।

`public` या `private` कीवर्ड (जैसे `AssignIface::public(...)`) यह दर्शाते हैं कि ये स्थितियाँ सार्वजनिक (`public`) हैं या गोपनीय (`private`) हैं। वहीं `Req::NoneOrMore`, `Req::Optional` यह दर्शाते हैं कि कितनी बार इनका होना अपेक्षित है।

#### Genesis और परिवर्तन

`Genesis` भाग यह बताता है कि संपत्ति को कैसे प्रारंभ किया जाता है:


- `spec`, `data`, `created`, `issuedSupply` फ़ील्ड अनिवार्य हैं (`ArgSpec::required()`) ;
- `assetOwner` जैसे असाइनमेंट्स कई प्रतियों में मौजूद हो सकते हैं (`ArgSpec::many()`), जिससे टोकन को कई शुरुआती धारकों में वितरित किया जा सकता है।
- ऐसे फ़ील्ड जैसे `inflationAllowance` या `burnEpoch` Genesis में शामिल हो सकते हैं (या नहीं भी हो सकते)।

फिर, प्रत्येक ट्रांज़िशन (`ट्रांसफर`, `इश्यू`, `बर्न`...) के लिए, Interface यह निर्धारित करता है कि ऑपरेशन को इनपुट के रूप में कौन-कौन से फील्ड्स की आवश्यकता होती है, ऑपरेशन आउटपुट के रूप में कौन-कौन से फील्ड्स उत्पन्न करेगा, और कौन-कौन सी गलतियाँ हो सकती हैं। उदाहरण के लिए:

**परिवर्तन:**


- इनपुट: `previous` → एक `assetOwner` होना चाहिए;
- असाइनमेंट्स: `beneficiary` → नया `assetOwner` होगा;
- त्रुटि: `NON_EQUAL_AMOUNTS` (इस प्रकार Wallet उन मामलों को संभालने में सक्षम होगा जहाँ इनपुट राशि आउटपुट राशि के बराबर नहीं होती)।

**संक्रमण `मुद्दा`:**


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। वैकल्पिक (`optional: true`) का मतलब है कि अतिरिक्त उत्सर्जन जरूरी नहीं कि सक्रिय हो।
- इनपुट: `used` → एक `महंगाई भत्ता`, यानी अधिक टोकन जोड़ने की अनुमति;
- असाइनमेंट्स: `लाभार्थी` (नए टोकन प्राप्त हुए) और `भविष्य` (बचे हुए `मुद्रास्फीति भत्ता`)।
- संभावित त्रुटियाँ: `SUPPLY_MISMATCH`, `ISSUE_EXCEEDS_ALLOWANCE`, आदि।

**जलने का परिवर्तन:**


- इनपुट: `used` → एक `burnRight` ;
- ग्लोबल्स: `burnedSupply` आवश्यक है;
- कार्य: `भविष्य` → `burnRight` का एक संभावित जारी रहना अगर हमने सब कुछ नहीं जलाया है;
- त्रुटियाँ: `SUPPLY_MISMATCH`, `INVALID_PROOF`, `INSUFFICIENT_COVERAGE`।

प्रत्येक ऑपरेशन को इस तरह से वर्णित किया गया है कि वह Wallet के लिए पढ़ने योग्य हो। इससे यह संभव हो जाता है कि एक ग्राफिकल Interface प्रदर्शित किया जा सके, जहां उपयोगकर्ता स्पष्ट रूप से देख सके: "आपको जलाने का अधिकार है। क्या आप एक निश्चित मात्रा जलाना चाहेंगे?" कोड जानता है कि `burnedSupply` फील्ड को भरना है और यह जांचना है कि `burnRight` वैध है।

संक्षेप में, यह ध्यान रखना महत्वपूर्ण है कि Interface, चाहे वह कितना भी पूर्ण क्यों न हो, अपने आप में Contract की आंतरिक तर्क को परिभाषित नहीं करता। काम का मुख्य हिस्सा **Schema** द्वारा किया जाता है, जिसमें सख्त प्रकार, Genesis संरचना, परिवर्तन आदि शामिल होते हैं। Interface बस इन Elements को एक अधिक सहज और नामित तरीके से प्रस्तुत करता है, ताकि उन्हें किसी एप्लिकेशन में उपयोग किया जा सके।

RGB की मॉड्यूलरिटी के कारण, Interface को आसानी से अपग्रेड किया जा सकता है (जैसे, `Rename` ट्रांज़िशन जोड़कर, किसी फील्ड के डिस्प्ले को सही करके, आदि) बिना पूरे Contract को फिर से लिखे। Interface के उपयोगकर्ता इन सुधारों का तुरंत लाभ उठा सकते हैं, जैसे ही वे `.RGB` या `.rgba` फाइल को अपडेट करते हैं।

जब आपने एक Interface घोषित कर दिया है, तो आपको इसे संबंधित Schema से जोड़ना होता है। यह ***Interface Implementation*** के माध्यम से किया जाता है, जो यह निर्दिष्ट करता है कि प्रत्येक नामित फील्ड (जैसे `fname!("assetOwner")`) को Schema में परिभाषित सख्त ID (जैसे `OS_ASSET`) से कैसे जोड़ा जाए। यह सुनिश्चित करता है, उदाहरण के लिए, कि जब एक Wallet `burnRight` फील्ड को संशोधित करता है, तो यह वही स्थिति है जो Schema में टोकन जलाने की क्षमता का वर्णन करती है।

### मुझे खेद है, लेकिन "Interface Implementation" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया अधिक जानकारी या संदर्भ प्रदान कर सकते हैं? इससे मुझे आपकी मदद करने में आसानी होगी।

RGB आर्किटेक्चर में, हमने देखा है कि प्रत्येक घटक (जैसे Schema, Interface आदि) को स्वतंत्र रूप से विकसित और संकलित किया जा सकता है। हालांकि, एक अनिवार्य तत्व है जो इन विभिन्न निर्माण खंडों को एक साथ जोड़ता है: ***Interface Implementation***। यह वह तत्व है जो स्पष्ट रूप से Schema में परिभाषित पहचानकर्ताओं या क्षेत्रों (Business Logic पक्ष पर) को Interface में घोषित नामों से जोड़ता है (प्रस्तुति और उपयोगकर्ता इंटरैक्शन पक्ष पर)। इसलिए जब एक Wallet, Contract को लोड करता है, तो वह ठीक-ठीक समझ सकता है कि कौन सा क्षेत्र किससे मेल खाता है, और Interface में नामित ऑपरेशन का Schema की तर्क से क्या संबंध है।

एक महत्वपूर्ण बात यह है कि Interface Implementation का उद्देश्य सभी Schema कार्यक्षमताओं या सभी Interface क्षेत्रों को उजागर करना जरूरी नहीं है: इसे एक उपसमूह तक सीमित किया जा सकता है। व्यवहार में, यह Schema के कुछ पहलुओं को प्रतिबंधित या फ़िल्टर करना संभव बनाता है। उदाहरण के लिए, आपके पास चार प्रकार के संचालन वाला Schema हो सकता है, लेकिन एक कार्यान्वयन Interface जो किसी दिए गए संदर्भ में उनमें से केवल दो को मैप करता है। इसके विपरीत, यदि कोई Interface अतिरिक्त एंडपॉइंट्स का प्रस्ताव करता है, तो हम उन्हें यहां लागू न करने का विकल्प चुन सकते हैं।

यहाँ Interface Implementation का एक क्लासिक उदाहरण है, जहाँ हम एक *गैर-फुलने योग्य संपत्ति* (NIA) Schema को RGB20 Interface के साथ जोड़ते हैं।

```rust
fn nia_rgb20() -> IfaceImpl {
let schema = nia_schema();
let iface = Rgb20::iface();
IfaceImpl {
version: VerNo::V1,
schema_id: schema.schema_id(),
iface_id: iface.iface_id(),
script: none!(),
global_state: tiny_bset! {
NamedField::with(GS_NOMINAL, fname!("spec")),
NamedField::with(GS_DATA, fname!("data")),
NamedField::with(GS_TIMESTAMP, fname!("created")),
NamedField::with(GS_ISSUED_SUPPLY, fname!("issuedSupply")),
},
assignments: tiny_bset! {
NamedField::with(OS_ASSET, fname!("assetOwner")),
},
valencies: none!(),
transitions: tiny_bset! {
NamedType::with(TS_TRANSFER, tn!("Transfer")),
},
extensions: none!(),
}
}
```

इस कार्यान्वयन Interface में:


- हमने Schema को `nia_schema()` के माध्यम से और Interface को `Rgb20::iface()` के माध्यम से स्पष्ट रूप से संदर्भित किया है। कॉल `Schema.schema_id()` और `iface.iface_id()` का उपयोग Anchor को Interface Implementation के साथ संकलन पक्ष पर किया जाता है (यह इन दो घटकों के क्रिप्टोग्राफिक पहचानकर्ताओं को जोड़ता है);
- एक मैपिंग स्थापित की गई है Schema, Elements और Interface, Elements के बीच। उदाहरण के लिए, Schema में `GS_NOMINAL` फील्ड को Interface में `"spec"` स्ट्रिंग से जोड़ा गया है (`NamedField::with(GS_NOMINAL, fname!("spec"))`)। हम इसी तरह से ऑपरेशन्स के लिए भी करते हैं, जैसे कि `TS_TRANSFER`, जिसे हम Interface में `"Transfer"` से जोड़ते हैं... ;
- हम देख सकते हैं कि यहाँ कोई वैलेंसीज़ (`valencies: none!()`) या एक्सटेंशन्स (`extensions: none!()`) नहीं हैं, जो यह दर्शाता है कि यह NIA Contract इन फीचर्स का उपयोग नहीं करता है।

कम्पाइल करने के बाद जो परिणाम मिलता है, वह एक अलग `.RGB` या `.rgba` फाइल होती है, जिसे Wallet में Schema और Interface के साथ इम्पोर्ट किया जाता है। इस तरह, सॉफ्टवेयर को यह पता होता है कि इस NIA Contract (जिसकी लॉजिक Schema द्वारा वर्णित है) को "RGB20" Interface (जो फंजिबल टोकन्स के लिए मानव नाम और इंटरैक्शन मोड प्रदान करता है) से कैसे जोड़ना है, और इसके लिए Interface Implementation को दोनों के बीच एक गेटवे के रूप में लागू किया जाता है।

#### Interface Implementation को अलग क्यों किया गया?

अलगाव से लचीलापन बढ़ता है। एक अकेला Schema कई अलग-अलग Interface कार्यान्वयन कर सकता है, जिनमें से प्रत्येक विभिन्न कार्यक्षमताओं का मानचित्रण करता है। इसके अलावा, Interface Implementation खुद को विकसित या फिर से लिखा जा सकता है बिना Schema या Interface में कोई बदलाव किए। यह RGB के मॉड्यूलरिटी के सिद्धांत को बनाए रखता है: प्रत्येक घटक (Schema, Interface, Interface Implementation) को स्वतंत्र रूप से संस्करणित और अपडेट किया जा सकता है, जब तक कि प्रोटोकॉल द्वारा लगाए गए संगतता नियमों का पालन किया जाता है (जैसे समान पहचानकर्ता, प्रकारों की संगति, आदि)।

व्यवहारिक उपयोग में, जब Wallet एक Contract को लोड करता है, तो उसे यह करना चाहिए:


- संकलित **Schema** को लोड करें (ताकि Business Logic की संरचना को समझ सकें);
- संकलित **Interface** को लोड करें (नामों और उपयोगकर्ता-साइड संचालन को समझने के लिए);
- **Interface Implementation** को लोड करें (ताकि Schema की लॉजिक को Interface के नामों से, ऑपरेशन दर ऑपरेशन, फील्ड दर फील्ड जोड़ा जा सके)।

यह मॉड्यूलर आर्किटेक्चर ऐसे उपयोग परिदृश्यों को संभव बनाता है जैसे:


- कुछ उपयोगकर्ताओं के लिए कुछ कार्यों को सीमित करें: Interface का एक आंशिक कार्यान्वयन प्रदान करें जो केवल बुनियादी ट्रांसफर की अनुमति देता है, जैसे कि बर्न या अपडेट फ़ंक्शन की पेशकश किए बिना।
- प्रस्तुति में बदलाव करें: Interface Implementation को इस तरह डिज़ाइन करें कि वह Interface में किसी फील्ड का नाम बदल दे या उसे अलग तरीके से मैप करे, लेकिन Contract के आधार को बदले बिना।
- कई योजनाओं का समर्थन करें: एक Wallet एक ही Interface प्रकार के लिए कई Interface कार्यान्वयन लोड कर सकता है, ताकि विभिन्न योजनाओं (विभिन्न टोकन तर्कों) को संभाला जा सके, बशर्ते उनकी संरचना संगत हो।

अगले अध्याय में, हम देखेंगे कि Contract ट्रांसफर कैसे काम करता है, और RGB इनवॉइस कैसे तैयार किए जाते हैं।

## Contract स्थानांतरण

<chapterId>f043a307-d420-5752-b0d7-ebfd845802c0</chapterId>

![video](https://youtu.be/sVoKIi-1XbY)

इस अध्याय में, हम Contract ट्रांसफर की प्रक्रिया का विश्लेषण करेंगे जो RGB इकोसिस्टम में होती है। इसे समझाने के लिए, हम अपने सामान्य पात्र, एलिस और बॉब, पर नजर डालेंगे, जो RGB संपत्ति को Exchange करना चाहते हैं। हम `RGB` कमांड-लाइन टूल से कुछ कमांड के उदाहरण भी दिखाएंगे, ताकि यह समझ सकें कि यह वास्तव में कैसे काम करता है।

### RGB और Contract ट्रांसफर को समझना

चलो एक उदाहरण लेते हैं जिसमें एलिस और बॉब के बीच ट्रांसफर होता है। इस उदाहरण में, हम मानते हैं कि बॉब अभी-अभी RGB का उपयोग शुरू कर रहा है, जबकि एलिस के पास पहले से ही Wallet में RGB संपत्तियाँ हैं। हम देखेंगे कि बॉब कैसे अपना सेटअप करता है, संबंधित Contract को इम्पोर्ट करता है, फिर एलिस से ट्रांसफर की रिक्वेस्ट करता है, और अंत में एलिस कैसे Bitcoin Blockchain पर वास्तविक लेन-देन को अंजाम देती है।

#### 1) RGB Wallet को स्थापित करना

सबसे पहले, बॉब को RGB Wallet इंस्टॉल करना होगा, यानी प्रोटोकॉल के साथ संगत सॉफ़्टवेयर। शुरुआत में इसमें कोई अनुबंध शामिल नहीं होता है। बॉब को इसके अलावा यह भी चाहिए:


- आपके UTXOs को प्रबंधित करने के लिए एक Bitcoin Wallet;
- आपको एक Bitcoin नोड या Electrum सर्वर से कनेक्शन की आवश्यकता होती है, ताकि आप अपने UTXOs की पहचान कर सकें और अपने लेन-देन को नेटवर्क पर प्रसारित कर सकें।

याद दिलाने के लिए, RGB में **Owned States** का मतलब Bitcoin UTXOs से है। इसलिए, हमें हमेशा इस बात का ध्यान रखना होगा कि हम Bitcoin लेन-देन में UTXOs को प्रबंधित और खर्च कर सकें, जिसमें क्रिप्टोग्राफिक कमिटमेंट्स (`Tapret` या `Opret`) शामिल हों, जो RGB डेटा की ओर इशारा करते हैं।

#### 2) Contract जानकारी प्राप्त करना

बॉब को फिर उस Contract डेटा को प्राप्त करना होता है जिसमें उसकी रुचि है। यह डेटा किसी भी माध्यम से प्रसारित हो सकता है: वेबसाइट, ई-मेल, मैसेजिंग एप्लिकेशन... व्यवहार में, इन्हें एक ***Consignment*** में एकत्रित किया जाता है, यानी एक छोटा डेटा पैकेट जिसमें शामिल होता है:


- **Genesis**, जो Contract की प्रारंभिक स्थिति को परिभाषित करता है;
- **Schema**, जो Business Logic (सख्त प्रकार, सत्यापन स्क्रिप्ट्स, आदि) का वर्णन करता है;
- **Interface**, जो प्रस्तुति Layer (फील्ड नाम, सुलभ संचालन) को परिभाषित करता है;
- **Interface Implementation**, जो ठोस रूप से Schema को Interface से जोड़ता है।

![RGB-Bitcoin](assets/fr/075.webp)

कुल आकार अक्सर कुछ किलोबाइट्स का होता है, क्योंकि प्रत्येक घटक आमतौर पर 200 बाइट्स से कम का होता है। इसे Base58 में, सेंसरशिप-प्रतिरोधी चैनलों (जैसे Nostr या Lightning Network के माध्यम से) या एक QR कोड के रूप में भी प्रसारित करना संभव हो सकता है।

#### 3) Contract आयात और सत्यापन

जैसे ही बॉब को Consignment मिल जाता है, वह इसे अपने RGB Wallet में इम्पोर्ट कर लेता है। इसके बाद यह:


- यह सुनिश्चित करें कि Genesis और Schema मान्य हैं।
- Interface और Interface Implementation को लोड करें।
- अपने क्लाइंट-साइड डेटा Stash को अपडेट करें।

बॉब अब अपने Wallet में उस संपत्ति को देख सकता है (भले ही वह अभी उसकी मालिक नहीं है) और समझ सकता है कि कौन-कौन से फील्ड उपलब्ध हैं, कौन-कौन से ऑपरेशन संभव हैं... इसके बाद उसे उस व्यक्ति से संपर्क करना होगा जो वास्तव में उस संपत्ति का मालिक है। हमारे उदाहरण में, यह एलिस है।

यह पता लगाने की प्रक्रिया कि कौन RGB संपत्ति का मालिक है, Bitcoin भुगतानकर्ता को खोजने के समान है। इस संबंध का विवरण इस बात पर निर्भर करता है कि इसका उपयोग कैसे किया जा रहा है (जैसे कि बाजार, निजी चैट चैनल, चालान, वस्तुओं और सेवाओं की बिक्री, वेतन आदि)।

#### 4) Invoice जारी करना

RGB संपत्ति के हस्तांतरण की प्रक्रिया शुरू करने के लिए, बॉब को पहले एक Invoice जारी करना होगा। यह Invoice का उपयोग किया जाता है:


- एलिस को यह बताएं कि किस प्रकार का ऑपरेशन किया जाना है (उदाहरण के लिए, एक `ट्रांसफर` RGB20 Interface से);
- एलिस को बॉब का *Seal Definition* प्रदान करें (यानी वह UTXO जहां वह संपत्ति प्राप्त करना चाहता है);
- सक्रिय घटक की कितनी मात्रा चाहिए (जैसे 100 यूनिट), यह बताएं।

बॉब कमांड लाइन पर `RGB` टूल का उपयोग करता है। मान लीजिए कि वह एक टोकन के 100 यूनिट चाहता है जिसका `ContractId` ज्ञात है, वह `Tapret` पर निर्भर करना चाहता है, और इसका UTXO (`456e3..dfe1:0`) निर्दिष्ट करता है:

```bash
bob$ rgb invoice RGB20 100 <ContractId> tapret1st:456e3..dfe1:0
```

हम इस अध्याय के अंत में RGB इनवॉइस की संरचना पर गहराई से नज़र डालेंगे।

#### 5) Invoice ट्रांसमिशन

जो Invoice तैयार किया गया है (जैसे कि URL: `RGB:2WBcas9.../RGB20/100+utxob:...`) उसमें वह सारी जानकारी होती है जो एलिस को ट्रांसफर तैयार करने के लिए चाहिए। जैसे Consignment के साथ होता है, इसे कॉम्पैक्ट रूप में (Base58 या किसी अन्य फॉर्मेट में) एन्कोड किया जा सकता है और मैसेजिंग एप्लिकेशन, ई-मेल, Nostr के माध्यम से भेजा जा सकता है।

![RGB-Bitcoin](assets/fr/076.webp)

#### 6) एलिस की तरफ से लेन-देन की तैयारी

एलिस को बॉब का Invoice प्राप्त होता है। अपनी RGB Wallet में, उसके पास एक Stash है जिसमें वह संपत्ति होती है जिसे स्थानांतरित किया जाना है। उस UTXO को खर्च करने के लिए जिसमें संपत्ति है, उसे पहले generate एक PSBT (*Partially Signed Bitcoin Transaction*), यानी एक अधूरी Bitcoin लेन-देन, का उपयोग करना होगा जो उसके पास है:

```bash
alice$ wallet construct tx.psbt
```

यह बुनियादी लेन-देन (फिलहाल बिना हस्ताक्षर के) का उपयोग किया जाएगा Anchor के लिए, जो कि बॉब को हस्तांतरण से जुड़े क्रिप्टोग्राफिक Commitment से संबंधित है। एलिस का UTXO इस प्रकार खर्च हो जाएगा, और आउटपुट में, हम बॉब के लिए `Tapret` या `Opret` Commitment रखेंगे।

#### 7) ट्रांसफर Consignment का निर्माण

इसके बाद, एलिस ***Terminal Consignment*** (जिसे कभी-कभी "ट्रांसफर Consignment" भी कहा जाता है) को कमांड के माध्यम से बनाती है:

```bash
alice$ rgb transfer tx.psbt <invoice> consignment.rgb
```

इस नए `Consignment.RGB` फाइल में शामिल है:


- Genesis से लेकर वर्तमान समय तक संपत्ति को मान्य करने के लिए आवश्यक सभी राज्य परिवर्तन का पूरा इतिहास।
- नया State Transition जो एसेट्स को एलिस से बॉब तक ट्रांसफर करता है, Invoice के अनुसार जिसे बॉब ने जारी किया है;
- अधूरी Bitcoin लेन-देन (*Witness Transaction*) (`tx.PSBT`), जो एलिस के Single-Use Seal को खर्च करती है, को बॉब के लिए क्रिप्टोग्राफिक Commitment शामिल करने के लिए संशोधित किया गया है।

इस समय, लेन-देन को अभी तक Bitcoin नेटवर्क पर प्रसारित नहीं किया गया है। Consignment एक साधारण Consignment से बड़ा है, क्योंकि इसमें संपत्ति की वैधता साबित करने के लिए पूरी इतिहास (*प्रमाण श्रृंखला*) शामिल होती है।

#### 8) बॉब Consignment की जांच करता है और उसे स्वीकार करता है।

एलिस इस **Terminal Consignment** को बॉब को भेजती है। इसके बाद बॉब:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। State Transition की वैधता की जांच करें (सुनिश्चित करें कि इतिहास सुसंगत है, Contract के नियमों का पालन हो रहा है, आदि);
- इसे अपने स्थानीय Stash में जोड़ें।
- संभवतः generate एक हस्ताक्षर (`sig:...`) है जो Consignment पर किया गया है, यह साबित करने के लिए कि इसे जांचा और मंजूर किया गया है (कभी-कभी इसे "*पेस्लिप*" भी कहा जाता है)।

```bash
bob$ rgb accept consignment.rgb
sig:DbwzvSu4BZU81jEpE9FVZ3xjcyuTKWWy2gmdnaxtACrS
```

![RGB-Bitcoin](assets/fr/077.webp)

#### 9) विकल्प: बॉब ऐलिस को पुष्टि वापस भेजता है (*वेतन पर्ची*)

अगर बॉब चाहे, तो वह इस हस्ताक्षर को ऐलिस को वापस भेज सकता है। इसका मतलब है:


- कि यह परिवर्तन को मान्य रूप से पहचानता है;
- वह इस बात से सहमत है कि Bitcoin लेन-देन का प्रसारण किया जाए।

यह अनिवार्य नहीं है, लेकिन यह एलिस को यह आश्वासन दे सकता है कि हस्तांतरण के बाद कोई विवाद नहीं होगा।

#### 10) एलिस लेन-देन पर हस्ताक्षर करती है और उसे प्रकाशित करती है।

इसके बाद एलिस यह कर सकती है:


- बॉब के हस्ताक्षर की जाँच करें (`RGB चेक <हस्ताक्षर>`) ;
- *Witness Transaction* पर हस्ताक्षर करें जो अभी भी PSBT है (`Wallet पर हस्ताक्षर करें`)।
- Witness Transaction को Bitcoin नेटवर्क पर प्रकाशित करें (`-publish`)।

```bash
alice$ rgb check <sig>
alice$ wallet sign —publish tx.psbt
```

![RGB-Bitcoin](assets/fr/078.webp)

एक बार पुष्टि हो जाने पर, यह लेन-देन हस्तांतरण के समापन को दर्शाता है। बॉब अब संपत्ति का नया मालिक बन जाता है: उसके पास अब Owned State है जो उसके द्वारा नियंत्रित UTXO की ओर इशारा करता है, जिसे लेन-देन में Commitment की उपस्थिति से साबित किया जाता है।

सारांश के रूप में, यहाँ पूरी ट्रांसफर प्रक्रिया दी गई है:

![RGB-Bitcoin](assets/fr/079.webp)

### RGB ट्रांसफर्स के फायदे कई हैं। सबसे पहले, ये ट्रांसफर्स तेज़ होते हैं, जिससे समय की बचत होती है। दूसरा, ये सुरक्षित होते हैं, जिससे आपके डेटा की सुरक्षा सुनिश्चित होती है। तीसरा, इनका उपयोग करना आसान होता है, जिससे किसी भी व्यक्ति को इन्हें समझने और इस्तेमाल करने में दिक्कत नहीं होती। चौथा, ये ट्रांसफर्स किफायती होते हैं, जिससे आपके पैसे भी बचते हैं। कुल मिलाकर, RGB ट्रांसफर्स एक सुविधाजनक और भरोसेमंद विकल्प हैं।


- गोपनीयता** :

केवल एलिस और बॉब के पास सभी State Transition डेटा का एक्सेस है। वे इस जानकारी को Blockchain के बाहर Exchange के माध्यम से भेजते हैं। Bitcoin लेनदेन में क्रिप्टोग्राफिक प्रतिबद्धताएँ संपत्ति के प्रकार या राशि को प्रकट नहीं करती हैं, जो अन्य On-Chain टोकन प्रणालियों की तुलना में कहीं अधिक गोपनीयता सुनिश्चित करती हैं।


- कस्टमर-साइड वेलिडेशन** :

बॉब *Consignment* को *Bitcoin* और *Blockchain* में मौजूद *anchors* के साथ तुलना करके ट्रांसफर की स्थिरता की जांच कर सकता है। उसे किसी तीसरे पक्ष की पुष्टि की आवश्यकता नहीं है। एलिस को *Blockchain* पर पूरी हिस्ट्री प्रकाशित करने की जरूरत नहीं है, जिससे बेस प्रोटोकॉल पर लोड कम होता है और गोपनीयता में सुधार होता है।


- सरल परमाणुता** :

जटिल लेन-देन (जैसे BTC और RGB संपत्ति के बीच परमाणु स्वैप) को एक ही लेन-देन के भीतर किया जा सकता है, जिससे HTLC या PTLC स्क्रिप्ट की आवश्यकता नहीं होती। अगर समझौता प्रसारित नहीं किया जाता है, तो हर कोई अपने UTXOs को अन्य तरीकों से फिर से उपयोग कर सकता है।

### स्थानांतरण सारांश चित्रण

इनवॉइस को विस्तार से देखने से पहले, यहाँ RGB ट्रांसफर के समग्र प्रवाह का एक सारांश चित्र है:


- बॉब ने एक RGB और Wallet स्थापित किया और उसे प्रारंभिक Contract और Consignment प्राप्त हुआ।
- बॉब एक Invoice जारी करता है जिसमें वह UTXO का उल्लेख करता है जहां संपत्ति प्राप्त की जानी है।
- एलिस को Invoice प्राप्त होता है, वह PSBT बनाती है और Terminal Consignment तैयार करती है।
- बॉब इसे स्वीकार करता है, जांचता है, डेटा अपने Stash में जोड़ता है, और अगर ज़रूरी हो तो (*पेस्लिप*) पर हस्ताक्षर करता है।
- एलिस ने लेन-देन को Bitcoin नेटवर्क पर प्रकाशित किया।
- लेन-देन की पुष्टि होने पर स्थानांतरण आधिकारिक हो जाता है।

![RGB-Bitcoin](assets/fr/080.webp)

यह ट्रांसफर RGB प्रोटोकॉल की पूरी ताकत और लचीलापन दिखाता है: एक निजी Exchange, जो क्लाइंट साइड पर सत्यापित है, और Bitcoin Blockchain पर न्यूनतम और गुप्त रूप से एंकर किया गया है, और प्रोटोकॉल की सुरक्षा का सबसे अच्छा हिस्सा बनाए रखता है (Double-spending का कोई जोखिम नहीं)। यह RGB को एक आशाजनक इकोसिस्टम बनाता है जो मूल्य ट्रांसफर के लिए अधिक गोपनीय और स्केलेबल है, On-Chain प्रोग्रामेबल ब्लॉकचेन की तुलना में।

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

इस खंड में, हम विस्तार से समझाएंगे कि RGB इकोसिस्टम में **इनवॉइस** कैसे काम करते हैं और वे Contract के साथ संचालन (विशेष रूप से ट्रांसफर) को कैसे सक्षम बनाते हैं। सबसे पहले, हम उन पहचानकर्ताओं को देखेंगे जो उपयोग किए जाते हैं, फिर यह देखेंगे कि उन्हें कैसे एन्कोड किया जाता है, और अंत में Invoice की संरचना को एक URL के रूप में समझेंगे (जो वॉलेट में उपयोग के लिए काफी सुविधाजनक प्रारूप है)।

#### पहचानकर्ता और एन्कोडिंग

प्रत्येक Elements के लिए एक विशिष्ट पहचानकर्ता निर्धारित किया गया है।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- यह Schema (Business Logic) है;
- यह Interface और Interface Implementation है।
- इसके संपत्तियाँ (टोकन, NFT, आदि)

यह विशिष्टता बहुत महत्वपूर्ण है, क्योंकि सिस्टम के प्रत्येक घटक को अलग-अलग पहचानना जरूरी है। उदाहरण के लिए, एक Contract X को किसी अन्य Contract Y के साथ भ्रमित नहीं होना चाहिए, और दो अलग-अलग इंटरफेस (जैसे RGB20 और RGB21) के पास अलग-अलग पहचानकर्ता होने चाहिए।

इन पहचानकर्ताओं को प्रभावी (छोटे आकार) और पठनीय बनाने के लिए, हम उपयोग करते हैं:


- Base58 एन्कोडिंग एक तरीका है जो भ्रमित करने वाले अक्षरों (जैसे `0` और अक्षर `O`) के उपयोग से बचता है और अपेक्षाकृत छोटे स्ट्रिंग्स प्रदान करता है।
- एक उपसर्ग जो पहचानकर्ता की प्रकृति को दर्शाता है, आमतौर पर `RGB:` या इसी तरह के URN के रूप में होता है।

उदाहरण के लिए, एक `ContractId` को इस तरह से दर्शाया जा सकता है:

```txt
rgb:2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX
```

`RGB:` उपसर्ग यह पुष्टि करता है कि यह एक RGB पहचानकर्ता है, न कि कोई HTTP लिंक या अन्य प्रोटोकॉल। इस उपसर्ग की वजह से, वॉलेट इस स्ट्रिंग को सही ढंग से समझने में सक्षम होते हैं।

#### पहचानकर्ता विभाजन

RGB पहचानकर्ता अक्सर काफी लंबे होते हैं, क्योंकि इनमें (क्रिप्टोग्राफिक) सुरक्षा के लिए 256 बिट्स या उससे अधिक के फील्ड की आवश्यकता हो सकती है। इंसानों के लिए इन्हें पढ़ने और सत्यापित करने में आसानी हो, इसके लिए हम इन स्ट्रिंग्स को कई ब्लॉक्स में बाँट देते हैं, जिन्हें हाइफ़न (`-`) से अलग किया जाता है। इस तरह, एक लंबी, बिना रुके चलने वाली कैरेक्टर स्ट्रिंग के बजाय, हम इसे छोटे ब्लॉक्स में विभाजित कर देते हैं। यह तरीका क्रेडिट कार्ड या टेलीफोन नंबरों के लिए आम है, और यहाँ भी सत्यापन में आसानी के लिए लागू होता है। उदाहरण के लिए, किसी उपयोगकर्ता या साझेदार को यह बताया जा सकता है: "*कृपया जाँचें कि तीसरा ब्लॉक `9GEgnyMj7` है*", बजाय इसके कि उन्हें पूरी स्ट्रिंग को एक साथ मिलाना पड़े। आखिरी ब्लॉक अक्सर **चेकसम** के रूप में उपयोग किया जाता है, ताकि त्रुटि या टाइपो का पता लगाने की प्रणाली हो सके।

उदाहरण के लिए, एक `ContractId` जो base58 में एन्कोडेड और विभाजित हो सकता है, इस प्रकार हो सकता है:

```txt
2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX
```

प्रत्येक डैश स्ट्रिंग को अलग-अलग हिस्सों में बांटता है। इससे कोड के अर्थ पर कोई असर नहीं पड़ता, बस उसकी प्रस्तुति पर असर पड़ता है।

#### इनवॉइस के लिए URLs का उपयोग करना

RGB Invoice को एक URL के रूप में प्रस्तुत किया गया है। इसका मतलब है कि इसे क्लिक किया जा सकता है या QR कोड के रूप में स्कैन किया जा सकता है, और Wallet इसे सीधे समझकर लेन-देन कर सकता है। यह इंटरैक्शन की सरलता कुछ अन्य सिस्टमों से अलग है, जहां आपको विभिन्न डेटा को कॉपी और पेस्ट करके सॉफ्टवेयर के अलग-अलग फील्ड्स में डालना पड़ता है।

एक Invoice एक फंजिबल टोकन (जैसे कि एक RGB20 टोकन) के लिए कुछ इस तरह दिख सकता है:

```txt
rgb:2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX/RGB20/100+utxob:egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb
```

आइए इस URL का विश्लेषण करें:


- `RGB:`** (प्रारंभिक): यह एक लिंक को इंगित करता है जो RGB प्रोटोकॉल को सक्रिय करता है (जैसे अन्य संदर्भों में `http:` या `Bitcoin:`)।
- `2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX`**: यह उस टोकन के `ContractId` को दर्शाता है जिसे आप बदलना चाहते हैं।
- `/RGB20/100` का मतलब है कि `RGB20` Interface का उपयोग किया जा रहा है और 100 यूनिट्स की मांग की गई है। इसका सिंटैक्स है: `/Interface/मात्रा` ;
- `+utxob:`**: यह दर्शाता है कि प्राप्तकर्ता UTXO के बारे में जानकारी (या, अधिक सटीक रूप से, Single-Use Seal की परिभाषा) जोड़ी गई है;
- आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं। `egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb`: यह *blinded* UTXO (या Seal Definition) है। दूसरे शब्दों में, बॉब ने अपने सही UTXO को छुपा दिया है, इसलिए भेजने वाले (एलिस) को यह नहीं पता कि सही Address क्या है। उसे केवल यह पता है कि एक वैध Seal है जो बॉब द्वारा नियंत्रित UTXO को संदर्भित करता है।

इस बात का कि सब कुछ एक ही URL में फिट हो जाता है, उपयोगकर्ता के लिए जीवन को आसान बना देता है: Wallet में एक साधारण क्लिक या स्कैन करें, और ऑपरेशन को अंजाम देने के लिए तैयार हो जाएं।

आप एक ऐसे सिस्टम की कल्पना कर सकते हैं जहाँ एक साधारण टिकर (जैसे `USDT`) का उपयोग `ContractId` की जगह किया जाता है। हालांकि, इससे विश्वास और सुरक्षा की बड़ी समस्याएँ उत्पन्न हो सकती हैं: एक टिकर एक अद्वितीय संदर्भ नहीं होता (कई अनुबंध खुद को `USDT` कह सकते हैं)। RGB के साथ, हम एक अद्वितीय, स्पष्ट क्रिप्टोग्राफिक पहचानकर्ता चाहते हैं। इसलिए 256-बिट स्ट्रिंग को अपनाया गया है, जिसे base58 में एन्कोड किया गया है और खंडित किया गया है। उपयोगकर्ता जानता है कि वह ठीक उसी Contract को संभाल रहा है जिसका आईडी `2WBcas9-yjz...` है और कोई अन्य नहीं।

#### अतिरिक्त URL पैरामीटर

आप URL में अतिरिक्त पैरामीटर भी जोड़ सकते हैं, जैसे कि HTTP के साथ करते हैं, जैसे:

```txt
rgb:2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX/RGB20/100+utxob:egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb?sig=6kzbKKffP6xftkxn9UP8gWqiC41W16wYKE5CYaVhmEve
```


- `?sig=...`: यह एक संकेत है, जैसे कि Invoice से जुड़ा एक हस्ताक्षर, जिसे कुछ वॉलेट्स सत्यापित कर सकते हैं।
- अगर Wallet इस हस्ताक्षर को प्रबंधित नहीं करता है, तो यह बस इस पैरामीटर को नजरअंदाज कर देता है।

आइए RGB21 Interface के माध्यम से एक NFT के मामले को देखें। उदाहरण के लिए, हमारे पास हो सकता है:

```txt
rgb:7BKsac8-beMNMWA8r-3GEprtFh7-bjzEvGufY-aNLuU4nSN-MRsLOIK/RGB21/DbwzvSu-4BZU81jEp-E9FVZ3xj-cyuTKWWy-2gmdnaxt-ACrS+utxob:egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb
```

यहाँ हम देखते हैं:


- `RGB:`**: URL प्रारंभिक भाग ;
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। rGB21**: Interface गैर-विनिमेय संपत्तियों (NFT) के लिए है।
- `DbwzvSu-4BZU81jEp-...`**: यह NFT के अनोखे हिस्से का एक स्पष्ट संदर्भ है, जैसे कि डेटा ब्लॉब (मीडिया, मेटाडेटा...) का एक Hash।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

विचार वही है: एक अनोखा लिंक भेजना जिसे Wallet समझ सके, और जो स्पष्ट रूप से उस विशेष संपत्ति की पहचान करे जिसे स्थानांतरित किया जाना है।

#### अन्य कार्य URL के माध्यम से

RGB URLs का उपयोग केवल डेटा ट्रांसफर के लिए अनुरोध करने में ही नहीं होता है। वे और भी जटिल कार्यों को एन्कोड कर सकते हैं, जैसे कि नए टोकन जारी करना (*इश्यूअन्स*)। उदाहरण के लिए:

```txt
rgb:2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX/RGB20/issue/100000+utxob:egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb
```

यहाँ हम पाते हैं:


- `RGB:` : प्रोटोकॉल ;
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- `/RGB20/issue/100000`: यह संकेत करता है कि आप "*Issue*" ट्रांज़िशन का उपयोग करके अतिरिक्त 100,000 टोकन बनाना चाहते हैं।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

उदाहरण के लिए, Wallet कुछ इस तरह पढ़ सकता है: "मुझे `RGB20` Interface से एक `इश्यू` ऑपरेशन करने के लिए कहा गया है, इस और उस Contract पर, 100,000 यूनिट्स के लिए, इस और उस Single-Use Seal के लाभ के लिए।*"

अब जब हमने Elements और RGB प्रोग्रामिंग के मुख्य बिंदुओं को देख लिया है, तो मैं आपको अगले अध्याय में ले चलूँगा, जहाँ हम सीखेंगे कि RGB Contract कैसे तैयार किया जाता है।

## स्मार्ट कॉन्ट्रैक्ट तैयार करना

<chapterId>0e0a645c-0049-588d-8965-b8c536590cc9</chapterId>

![video](https://youtu.be/GRwS-NvWF3I)

इस अध्याय में, हम `RGB` कमांड-लाइन टूल का उपयोग करके Contract लिखने की प्रक्रिया को चरण-दर-चरण समझेंगे। हमारा उद्देश्य है यह दिखाना कि CLI को कैसे इंस्टॉल और संचालित करें, **Schema** को संकलित करें, **Interface** और **Interface Implementation** को आयात करें, और फिर एक संपत्ति जारी करें। हम अंतर्निहित तर्क को भी देखेंगे, जिसमें संकलन और स्थिति सत्यापन शामिल हैं। इस अध्याय के अंत तक, आप इस प्रक्रिया को दोहराने और अपने स्वयं के RGB अनुबंध बनाने में सक्षम होंगे।

याद दिला दें कि RGB की आंतरिक लॉजिक Rust लाइब्रेरियों पर आधारित है, जिसे आप डेवलपर्स के रूप में अपने प्रोजेक्ट्स में Client-side Validation भाग को मैनेज करने के लिए इम्पोर्ट कर सकते हैं। इसके अलावा, LNP/BP एसोसिएशन टीम अन्य भाषाओं के लिए बाइंडिंग्स पर काम कर रही है, लेकिन यह अभी तक पूरा नहीं हुआ है। इसके अलावा, Bitfinex जैसी अन्य संस्थाएं अपनी खुद की इंटीग्रेशन स्टैक्स विकसित कर रही हैं (हम इन पर कोर्स के अंतिम 2 अध्यायों में बात करेंगे)। फिलहाल, `RGB` CLI आधिकारिक संदर्भ है, भले ही यह अभी भी पूरी तरह से परिष्कृत नहीं है।

### RGB टूल की स्थापना और प्रस्तुति

मुख्य कमांड को बस `RGB` कहा जाता है। इसे `git` की तरह डिज़ाइन किया गया है, जिसमें अनुबंधों को प्रबंधित करने, उन्हें लागू करने, संपत्तियों को जारी करने आदि के लिए उप-कमांड्स का सेट होता है। Bitcoin और Wallet फिलहाल एकीकृत नहीं हैं, लेकिन जल्द ही आने वाले संस्करण (0.11) में होंगे। यह अगला संस्करण उपयोगकर्ताओं को सीधे `RGB` से अपने वॉलेट्स (डिस्क्रिप्टर्स के माध्यम से) बनाने और प्रबंधित करने की सुविधा देगा, जिसमें PSBT जनरेशन, साइनिंग के लिए बाहरी हार्डवेयर (जैसे Hardware Wallet) के साथ संगतता, और Sparrow जैसे सॉफ़्टवेयर के साथ इंटरऑपरेबिलिटी शामिल होगी। इससे पूरी संपत्ति जारी करने और स्थानांतरण परिदृश्य को सरल बनाया जाएगा।

#### कार्गो के माध्यम से स्थापना

हम Rust में टूल को इस प्रकार इंस्टॉल करते हैं:

```bash
cargo install rgb-contracts --all-features
```

(नोट: इस क्रेट का नाम `RGB-contracts` है, और जो कमांड इंस्टॉल होगी उसका नाम `RGB` होगा। अगर पहले से कोई क्रेट `RGB` नाम से मौजूद होता, तो टकराव हो सकता था, इसलिए यह नाम रखा गया है।)

इंस्टॉलेशन में कई सारी निर्भरताएँ शामिल होती हैं, जैसे कि कमांड पार्सिंग, इलेक्ट्रम इंटीग्रेशन, ज़ीरो-नॉलेज प्रूफ्स मैनेजमेंट आदि।

एक बार स्थापना पूरी हो जाने के बाद, :

```bash
rgb
```

जब आप `RGB` (बिना किसी तर्क के) चलाते हैं, तो यह उपलब्ध सब-कमांड्स की एक सूची दिखाता है, जैसे कि `interfaces`, `Schema`, `import`, `export`, `issue`, `Invoice`, `transfer`, आदि। आप स्थानीय स्टोरेज डायरेक्टरी (एक Stash जो सभी लॉग्स, योजनाएं और कार्यान्वयन रखता है) बदल सकते हैं, नेटवर्क चुन सकते हैं (Testnet, Mainnet) या अपने Electrum सर्वर को कॉन्फ़िगर कर सकते हैं।

![RGB-Bitcoin](assets/fr/081.webp)

#### नियंत्रणों का पहला अवलोकन

जब आप निम्नलिखित कमांड चलाते हैं, तो आप देखेंगे कि एक `RGB20` Interface पहले से ही डिफ़ॉल्ट रूप से एकीकृत है।

```bash
rgb interfaces
```

अगर इस Interface को इंटीग्रेट नहीं किया गया है, तो इसे क्लोन करें:

```bash
git clone https://github.com/RGB-WG/rgb-interfaces
```

इसे संकलित करें:

```bash
cargo run
```

फिर अपनी पसंद का Interface आयात करें:

```bash
rgb import interfaces/RGB20.rgb
```

![RGB-Bitcoin](assets/fr/082.webp)

दूसरी ओर, हमें बताया गया है कि अभी तक कोई Schema सॉफ़्टवेयर में इम्पोर्ट नहीं किया गया है। और न ही Stash में कोई Contract है। इसे देखने के लिए, यह कमांड चलाएँ:

```bash
rgb schemata
```

आप फिर उस रिपॉजिटरी को क्लोन कर सकते हैं ताकि कुछ विशेष योजनाएं प्राप्त कर सकें:

```bash
git clone https://github.com/RGB-WG/rgb-schemata
```

![RGB-Bitcoin](assets/fr/083.webp)

इस संग्रह में `src/` डायरेक्टरी के अंदर कई Rust फाइलें हैं (जैसे `nia.rs`), जो स्कीमाओं को परिभाषित करती हैं (जैसे NIA जिसका मतलब है "*Non Inflatable Asset*", UDA जिसका मतलब है "*Unique Digital Asset*" आदि)। इन्हें संकलित करने के लिए, आप निम्नलिखित कमांड चला सकते हैं:

```bash
cd rgb-schemata
cargo run
```

यह कई `.RGB` और `.rgba` फाइलें उत्पन्न करता है जो संकलित योजनाओं से संबंधित होती हैं। उदाहरण के लिए, आपको `NonInflatableAsset.RGB` मिलेगी।

#### Schema और Interface Implementation का आयात करना

अब आप स्कीमैटिक को `RGB` में इम्पोर्ट कर सकते हैं।

```bash
rgb import schemata/NonInflatableAssets.rgb
```

![RGB-Bitcoin](assets/fr/084.webp)

यह इसे स्थानीय Stash में जोड़ देता है। अगर हम निम्नलिखित कमांड चलाते हैं, तो हम देखेंगे कि अब Schema दिखाई दे रहा है।

```bash
rgb schemata
```

### Contract का निर्माण (जारी करना)

एक नया संपत्ति बनाने के दो तरीके होते हैं:


- हम या तो Rust में एक स्क्रिप्ट या कोड का उपयोग करते हैं जो Schema के फील्ड्स (जैसे Global State, ओन्ड स्टेट्स, आदि) को भरकर Contract बनाता है और एक `.RGB` या `.rgba` फाइल तैयार करता है।
- या सीधे `issue` सब-कमांड का उपयोग करें, जिसमें एक YAML (या TOML) फ़ाइल हो जो टोकन की विशेषताओं का वर्णन करती हो।

आप Rust में `examples` फोल्डर में उदाहरण पा सकते हैं, जो यह दिखाते हैं कि आप एक `ContractBuilder` कैसे बनाते हैं, `Global State` (एसेट का नाम, टिकर, Supply, तारीख, आदि) कैसे भरते हैं, Owned State को कैसे परिभाषित करते हैं (जिसे UTXO में असाइन किया गया है), फिर इन सबको एक *Contract Consignment* में कैसे संकलित करते हैं जिसे आप Stash में निर्यात, सत्यापित और आयात कर सकते हैं।

दूसरा तरीका यह है कि आप एक YAML फाइल को मैन्युअली एडिट करके `ticker`, `name`, `Supply`, आदि को कस्टमाइज़ करें। मान लीजिए कि फाइल का नाम `RGB20-demo.yaml` है। आप इसमें यह निर्दिष्ट कर सकते हैं:


- `spec`: टिकर, नाम, सटीकता ;
- `शर्तें`: कानूनी सूचनाओं के लिए एक क्षेत्र;
- `issuedSupply`: जारी किए गए टोकन की मात्रा;
- `असाइनमेंट्स`: यह Single-Use Seal (*Seal Definition*) और अनलॉक की गई मात्रा को दर्शाता है।

यहाँ एक YAML फ़ाइल का उदाहरण दिया गया है जिसे बनाना है:

```yaml
interface: RGB20Fixed
globals:
spec:
ticker: PBN
name: Plan B Network
details: "Pay attention: the asset has no value"
precision: 2
terms:
text: >
SUBJECT TO, AND WITHOUT IN ANY WAY LIMITING, THE REPRESENTATIONS AND WARRANTIES OF ANY SELLER. PROPERTY IS BEING SOLD “AS IS”...
media: ~
issuedSupply: 100000000
assignments:
assetOwner:
seal: tapret1st:b449f7eaa3f98c145b27ad0eeb7b5679ceb567faef7a52479bc995792b65f804:1
amount: 100000000 # this is 1 million (we have two digits for cents)
```

![RGB-Bitcoin](assets/fr/085.webp)

फिर बस इस कमांड को चलाएं:

```bash
rgb issue '<SchemaID>' ssi:<Issuer> rgb20-demo.yaml
```

![RGB-Bitcoin](assets/fr/086.webp)

मेरे मामले में, अनोखा Schema पहचानकर्ता (जिसे एकल उद्धरणों में बंद किया जाना चाहिए) है `RDYhMTR!9gv8Y2GLv9UNBEK1hcrCmdLDFk9Qd5fnO8k` और मैंने कोई जारीकर्ता नहीं डाला है। तो मेरा आदेश है :

```txt
rgb issue 'RDYhMTR!9gv8Y2GLv9UNBEK1hcrCmdLDFk9Qd5fnO8k' ssi:anonymous rgb20-demo.yaml
```

अगर आपको Schema आईडी नहीं पता है, तो यह कमांड चलाएं:

```bash
rgb schemata
```

CLI जवाब देता है कि एक नया Contract जारी किया गया है और इसे Stash में जोड़ा गया है। अगर हम निम्नलिखित कमांड टाइप करते हैं, तो हम देख सकते हैं कि अब एक अतिरिक्त Contract है, जो अभी-अभी जारी किए गए के अनुरूप है।

```bash
rgb contracts
```

![RGB-Bitcoin](assets/fr/087.webp)

फिर, अगला कमांड वैश्विक राज्यों (जैसे नाम, टिकर, Supply...) और स्वामित्व वाले राज्यों की सूची, यानी आवंटन (उदाहरण के लिए, 1 मिलियन `PBN` टोकन जो UTXO `b449f7eaa3f98c145b27ad0eeb7b5679ceb567faef7a52479bc995792b65f804:1` में परिभाषित हैं) को प्रदर्शित करता है।

```bash
rgb state '<ContractId>'
```

![RGB-Bitcoin](assets/fr/088.webp)

### निर्यात, आयात और सत्यापन

इस Contract को अन्य उपयोगकर्ताओं के साथ साझा करने के लिए, इसे Stash से एक : में निर्यात किया जा सकता है।

```bash
rgb export '<ContractId>' myContractPBN.rgb
```

![RGB-Bitcoin](assets/fr/089.webp)

`myContractPBN.RGB` फाइल को किसी दूसरे उपयोगकर्ता को दिया जा सकता है, जो इसे अपने Stash में इस कमांड के साथ जोड़ सकता है:

```bash
rgb import myContractPBN.rgb
```

जब आप आयात करते हैं, अगर यह एक साधारण *Contract Consignment* है, तो हमें "`Importing Consignment RGB`" संदेश मिलेगा। अगर यह एक बड़ा *State Transition Consignment* है, तो कमांड अलग होगा (`RGB accept`)।

वैधता सुनिश्चित करने के लिए, आप स्थानीय सत्यापन फ़ंक्शन का भी उपयोग कर सकते हैं। उदाहरण के लिए, आप यह चला सकते हैं:

```bash
rgb validate myContract.rgb
```

#### Stash का उपयोग, सत्यापन और प्रदर्शन

याद दिला दें कि Stash एक स्थानीय सूची है जिसमें स्कीमा, इंटरफेस, कार्यान्वयन और अनुबंध (Genesis + संक्रमण) शामिल हैं। जब भी आप "import" चलाते हैं, तो आप Stash में एक तत्व जोड़ते हैं। इस Stash को विस्तार से देखने के लिए आप यह कमांड चला सकते हैं:

```bash
rgb dump
```

![RGB-Bitcoin](assets/fr/090.webp)

यह generate एक फोल्डर होगा जिसमें पूरे Stash की जानकारी होगी।

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

एक ट्रांसफर करने के लिए, आपको `Tapret` या `Opret` प्रतिबद्धताओं को प्रबंधित करने के लिए एक स्थानीय Bitcoin Wallet को संभालना होगा।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

अधिकतर मामलों में, Contract में प्रतिभागियों (जैसे एलिस और बॉब) के बीच बातचीत Invoice के निर्माण के माध्यम से होती है। अगर एलिस चाहती है कि बॉब कुछ कार्य करे (जैसे टोकन ट्रांसफर, पुनः जारी करना, DAO में कोई कार्रवाई, आदि), तो एलिस बॉब को अपने निर्देशों का विवरण देते हुए एक Invoice बनाती है। तो हमारे पास है:


- एलिस** (Invoice की जारीकर्ता);
- बॉब** (जो Invoice प्राप्त करता है और उसे लागू करता है)।

अन्य पारिस्थितिक तंत्रों के विपरीत, RGB Invoice केवल भुगतान की धारणा तक सीमित नहीं है। यह Contract से जुड़ी किसी भी अनुरोध को शामिल कर सकता है: जैसे कि एक कुंजी को रद्द करना, वोट देना, एक NFT पर एक नक़्क़ाशी (*engraving*) बनाना, आदि। संबंधित प्रक्रिया को Contract Interface में वर्णित किया जा सकता है। संबंधित प्रक्रिया को Contract Interface में वर्णित किया जा सकता है।

निम्नलिखित कमांड एक RGB Invoice उत्पन्न करता है:

```bash
$ rgb invoice $CONTRACT -i $INTERFACE $ACTION $STATE $SEAL
```

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।


- `$Contract`: Contract पहचानकर्ता (*ContractId*) ;
- `$Interface`: Interface का उपयोग किया जाना है (जैसे `RGB20`) ;
- `$ACTION`: यह उस ऑपरेशन का नाम है जो Interface में निर्दिष्ट किया गया है (उदाहरण के लिए, एक साधारण फंजिबल टोकन ट्रांसफर के लिए, यह "ट्रांसफर" हो सकता है)। अगर Interface पहले से ही एक डिफ़ॉल्ट एक्शन प्रदान करता है, तो आपको इसे यहां फिर से दर्ज करने की आवश्यकता नहीं है।
- `$STATE`: वह स्थिति डेटा जिसे स्थानांतरित किया जाना है (उदाहरण के लिए, अगर एक फंजिबल टोकन स्थानांतरित किया जा रहा है तो टोकन की मात्रा);
- `$Seal`: लाभार्थी (एलिस) का Single-Use Seal, यानी UTXO का एक स्पष्ट संदर्भ। बॉब इस जानकारी का उपयोग Witness Transaction बनाने के लिए करेगा, और फिर संबंधित आउटपुट एलिस का होगा (चाहे वह *blinded UTXO* रूप में हो या बिना एन्क्रिप्ट किया हुआ)।

उदाहरण के लिए, निम्नलिखित आदेशों के साथ

```bash
alice$ CONTRACT='iZgIN9EL-2H21UgQ-x!A3uJc-WwXhCSm-$9Lwcc1-v!mUkKY'
alice$ MY_UTXO=4960acc21c175c551af84114541eace09c14d3a1bb184809f7b80916f57f9ef8:1
alice$ rgb invoice $CONTRACT -i RGB20 --amount 100 $MY_UTXO
```

CLI, generate को Invoice की तरह करेगा:

```bash
rgb:iZgIN9EL-2H21UgQ-x!A3uJc-WwXhCSm-$9Lwcc1-v!mUkKY/RGB20/100+utxob:zlVS28Rb-...
```

इसे किसी भी माध्यम से बॉब को भेजा जा सकता है (जैसे टेक्स्ट, क्यूआर कोड आदि)।

#### स्थानांतरण करना

इस Invoice से स्थानांतरित करने के लिए:


- बॉब (जिसके पास उसके Stash में टोकन हैं) के पास एक Bitcoin और Wallet है। उसे एक Bitcoin लेन-देन तैयार करना है (PSBT के रूप में, जैसे `tx.PSBT`) जो उन UTXOs को खर्च करता है जहाँ आवश्यक RGB टोकन स्थित हैं, साथ ही मुद्रा (Exchange) के लिए एक UTXO भी शामिल है।
- बॉब निम्नलिखित कमांड चलाता है:

```bash
bob$ rgb transfer tx.psbt $INVOICE consignment.rgb
```


- यह एक `Consignment.RGB` फाइल बनाता है जिसमें शामिल होता है:
 - टोकन असली हैं, यह साबित करने के लिए एलिस को संक्रमण इतिहास दिखाना।
 - नया परिवर्तन जो टोकन को एलिस के Single-Use Seal में स्थानांतरित करता है;
 - Witness Transaction (अहस्ताक्षरित)।
- बॉब यह `Consignment.RGB` फाइल ऐलिस को भेजता है (ई-मेल, किसी शेयरिंग सर्वर या RGB-RPC प्रोटोकॉल, स्टॉर्म आदि के माध्यम से);
- एलिस को `Consignment.RGB` प्राप्त होता है और वह इसे अपने Stash में स्वीकार कर लेती है।

```bash
alice$ rgb accept consignment.rgb
```


- CLI यह जांचता है कि परिवर्तन सही है या नहीं और इसे एलिस के Stash में जोड़ता है। अगर यह गलत होता है, तो कमांड विफल हो जाता है और विस्तृत त्रुटि संदेश दिखाता है। अगर सही होता है, तो यह सफल होता है और बताता है कि नमूना लेन-देन अभी तक Bitcoin नेटवर्क पर प्रसारित नहीं हुआ है (बॉब एलिस के Green लाइट का इंतजार कर रहा है)।
- पुष्टि के रूप में, `accept` कमांड एक हस्ताक्षर (*पेस्लिप*) लौटाता है जिसे एलिस बॉब को भेज सकती है ताकि वह उसे दिखा सके कि उसने *Consignment* को मान्य कर दिया है;
- बॉब अब अपने Bitcoin लेन-देन पर हस्ताक्षर कर सकता है और उसे प्रकाशित (`--publish`) कर सकता है।

```bash
bob$ rgb check <sig> && wallet sign --publish tx.psbt
```


- जैसे ही यह लेन-देन On-Chain की पुष्टि होती है, Ownership संपत्ति को एलिस के नाम पर स्थानांतरित माना जाता है। एलिस का Wallet, जो लेन-देन के Mining की निगरानी कर रहा है, अपने Stash में नया Owned State देखता है।

अगले अध्याय में, हम RGB को Lightning Network में एकीकृत करने पर गहराई से नज़र डालेंगे।

## आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

<chapterId>0962980a-8f94-5d0f-9cd0-43d7f884a01d</chapterId>

![video](https://youtu.be/mqCupTlDbA0)

इस अध्याय में, मैं यह जांचने का प्रस्ताव करता हूँ कि कैसे RGB को Lightning Network के भीतर उपयोग किया जा सकता है, ताकि RGB की संपत्तियों (टोकन, NFTs, आदि) को off-chain भुगतान चैनलों के माध्यम से एकीकृत और स्थानांतरित किया जा सके।

मूल विचार यह है कि RGB State Transition (*State Transition*) को एक Bitcoin लेन-देन में शामिल किया जा सकता है, जो तब तक off-chain रह सकता है जब तक कि लाइटनिंग चैनल बंद नहीं हो जाता। इसलिए, हर बार जब चैनल अपडेट होता है, तो एक नया RGB State Transition नए कमिटिंग लेन-देन में शामिल किया जा सकता है, जो फिर पुराने ट्रांज़िशन को अमान्य कर देता है। इस तरह, लाइटनिंग चैनलों का उपयोग RGB संपत्तियों को स्थानांतरित करने के लिए किया जा सकता है, और इन्हें पारंपरिक लाइटनिंग भुगतानों की तरह ही रूट किया जा सकता है।

### चैनल बनाना और फंडिंग प्राप्त करना

RGB संपत्तियों को ले जाने वाला एक लाइटनिंग चैनल बनाने के लिए, हमें दो Elements की आवश्यकता होगी।


- Bitcoin की फंडिंग का उपयोग चैनल के 2/2 Multisig (चैनल के लिए बुनियादी UTXO) बनाने के लिए किया गया है।
- RGB फंडिंग, जो संपत्तियों को उसी Multisig में भेजती है।

Bitcoin के संदर्भ में, फंडिंग लेनदेन का अस्तित्व आवश्यक है ताकि UTXO को परिभाषित किया जा सके, भले ही उसमें केवल थोड़ी मात्रा में Sats हो (यह बस इस बात का मामला है कि भविष्य के Commitment लेनदेन में प्रत्येक आउटपुट Dust सीमा से ऊपर बना रहे)। उदाहरण के लिए, एलिस यह निर्णय ले सकती है कि वह 10k Sats और 500 USDT (जो RGB संपत्ति के रूप में जारी किया गया है) प्रदान करेगी। फंडिंग लेनदेन पर, हम एक Commitment (`Opret` या `Tapret`) जोड़ते हैं जो RGB State Transition को एंकर करता है।

![RGB-Bitcoin](assets/fr/091.webp)

जब फंडिंग लेन-देन तैयार हो जाता है (लेकिन अभी प्रसारित नहीं किया गया है), तो Commitment लेन-देन बनाए जाते हैं ताकि किसी भी पक्ष को चैनल को एकतरफा रूप से कभी भी बंद करने की अनुमति मिल सके। ये लेन-देन लाइटनिंग के क्लासिक Commitment लेन-देन की तरह होते हैं, बस इसमें हम एक अतिरिक्त आउटपुट जोड़ते हैं जिसमें RGB Anchor (OP_RETURN या Taproot) शामिल होता है, जो नए State Transition से जुड़ा होता है।

RGB State Transition फिर 2/2 Multisig से फंडिंग के एसेट्स को Commitment Transaction के आउटपुट में स्थानांतरित करता है। इस प्रक्रिया का लाभ यह है कि RGB की सुरक्षा बिल्कुल लाइटनिंग की दंडात्मक प्रणाली से मेल खाती है: अगर बॉब एक पुरानी चैनल स्थिति प्रसारित करता है, तो एलिस उसे दंडित कर सकती है और आउटपुट को खर्च कर सकती है, ताकि वह Sats और RGB दोनों टोकन को पुनः प्राप्त कर सके। इसलिए प्रोत्साहन लाइटनिंग चैनल की तुलना में और भी मजबूत है जिसमें RGB एसेट्स नहीं होते, क्योंकि एक हमलावर न केवल Sats खो सकता है, बल्कि चैनल के RGB एसेट्स भी खो सकता है।

अक्टूबर 2023 तक के डेटा पर आपका प्रशिक्षण हुआ है। इसलिए, अगर एलिस द्वारा हस्ताक्षरित और बॉब को भेजा गया Commitment Transaction कुछ इस तरह दिखेगा:

![RGB-Bitcoin](assets/fr/092.webp)

और साथ में भेजा गया Commitment Transaction, जिसे बॉब ने साइन किया और ऐलिस को भेजा, कुछ इस तरह दिखेगा:

![RGB-Bitcoin](assets/fr/093.webp)

### चैनल अपडेट

जब दो चैनल प्रतिभागियों के बीच भुगतान होता है (या वे संपत्ति आवंटन को बदलना चाहते हैं), तो वे एक नई Commitment लेन-देन की जोड़ी बनाते हैं। प्रत्येक आउटपुट में Sats की राशि अपरिवर्तित रह सकती है या नहीं भी रह सकती, यह कार्यान्वयन पर निर्भर करता है, क्योंकि इसका मुख्य कार्य मान्य UTXOs का निर्माण सक्षम करना है। दूसरी ओर, OP_RETURN (या Taproot) आउटपुट को संशोधित करना आवश्यक होता है ताकि उसमें नया RGB Anchor शामिल हो सके, जो चैनल में संपत्तियों के नए वितरण का प्रतिनिधित्व करता है।

उदाहरण के लिए, अगर एलिस बॉब को चैनल में 30 USDT ट्रांसफर करती है, तो नया State Transition एलिस के लिए 400 USDT और बॉब के लिए 100 USDT का बैलेंस दिखाएगा। इस लेन-देन को OP_RETURN/Taproot Anchor द्वारा जोड़ा या संशोधित किया जाता है ताकि इस बदलाव को शामिल किया जा सके। ध्यान दें कि RGB के दृष्टिकोण से, इस बदलाव के लिए इनपुट प्रारंभिक Multisig ही रहता है (जहां On-Chain की संपत्तियां वास्तव में तब तक आवंटित रहती हैं जब तक चैनल बंद नहीं हो जाता)। केवल RGB के आउटपुट (आवंटन) बदलते हैं, जो पुनर्वितरण के निर्णय पर निर्भर करता है।

Commitment Transaction जिसे एलिस ने साइन किया है, अब बॉब द्वारा वितरित करने के लिए तैयार है।

![RGB-Bitcoin](assets/fr/094.webp)

Commitment Transaction, जिसे बॉब ने साइन किया है, अब एलिस द्वारा वितरित करने के लिए तैयार है।

![RGB-Bitcoin](assets/fr/095.webp)

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

असल में, Lightning Network कई चैनलों के माध्यम से भुगतान को रूट करने की सुविधा देता है, HTLCs (*हैश्ड टाइम-लॉक्ड कॉन्ट्रैक्ट्स*) का उपयोग करके। RGB के साथ भी यही स्थिति है: चैनल के माध्यम से यात्रा कर रहे हर भुगतान के लिए, एक HTLC आउटपुट को कमिटिंग ट्रांजेक्शन में जोड़ा जाता है, और इस HTLC से जुड़ा एक RGB आवंटन होता है। इस प्रकार, जो भी व्यक्ति HTLC आउटपुट खर्च करता है (गुप्त जानकारी के कारण या टाइमलॉक की समाप्ति के बाद), वह Sats और संबंधित RGB संपत्तियों को पुनः प्राप्त कर लेता है। दूसरी ओर, आपको स्पष्ट रूप से सड़क पर पर्याप्त नकदी की आवश्यकता होती है, दोनों Sats और RGB संपत्तियों के संदर्भ में।

![RGB-Bitcoin](assets/fr/096.webp)

RGB का Lightning पर संचालन इसलिए Lightning Network के संचालन के साथ-साथ देखा जाना चाहिए। अगर आप इस विषय में और गहराई से जानना चाहते हैं, तो मैं आपको इस अन्य व्यापक प्रशिक्षण कोर्स को देखने की सिफारिश करता हूँ:

https://planb.network/courses/34bd43ef-6683-4a5c-b239-7cb1e40a4aeb
### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। RGB कोड मैप का कोई विशेष संदर्भ नहीं है, लेकिन अगर यह किसी प्रोजेक्ट, योजना या दस्तावेज़ से संबंधित है, तो कृपया अधिक जानकारी दें ताकि मैं आपकी मदद कर सकूं।

अंत में, अगले भाग पर जाने से पहले, मैं आपको RGB में उपयोग किए गए कोड का एक संक्षिप्त विवरण देना चाहूंगा। यह प्रोटोकॉल Rust लाइब्रेरीज़ और ओपन सोर्स स्पेसिफिकेशन्स के सेट पर आधारित है। यहाँ मुख्य रिपॉजिटरीज़ और क्रेट्स का एक संक्षिप्त विवरण दिया गया है:

![RGB-Bitcoin](assets/fr/097.webp)

#### मुझे खेद है, लेकिन "Client-side Validation" के बारे में मेरे पास कोई जानकारी नहीं है। क्या आप कृपया अधिक जानकारी या संदर्भ प्रदान कर सकते हैं ताकि मैं आपकी मदद कर सकूं?


- भंडार**: [क्लाइंट साइड वेलिडेशन](https://github.com/LNP-BP/client_side_validation)
- क्रेट्स** : [क्लाइंट साइड वेलिडेशन](https://crates.io/crates/client_side_validation), [सिंगल यूज़ सील्स](https://crates.io/crates/single_use_seals)

off-chain सत्यापन और सिंगल-यूज़ सील्स के प्रबंधन की प्रक्रिया।

#### नियतात्मक Bitcoin प्रतिबद्धताएँ (DBC)


- भंडार**: [bp-core](https://github.com/BP-WG/bp-core)
- क्रेट**: [bp-dbc](https://crates.io/crates/bp-dbc)

Bitcoin लेनदेन (जैसे Tapret, OP_RETURN आदि) में निश्चित एंकरिंग का प्रबंधन।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।


- भंडार**: [क्लाइंट साइड वैलिडेशन](https://github.com/LNP-BP/client_side_validation)
- क्रेट** : [commit_verify](https://crates.io/crates/commit_verify)

विभिन्न प्रोटोकॉल के साथ कई प्रकार की सहभागिता संयोजन और एकीकरण।

#### सख्त प्रकार और सख्त एन्कोडिंग


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- भंडार**: [स्ट्रिक्ट-टाइप्स](https://github.com/strict-types/strict-types), [स्ट्रिक्ट-एन्कोडिंग](https://github.com/strict-types/strict-encoding)
- क्रेट्स** : [स्ट्रिक्ट_टाइप्स](https://crates.io/crates/strict_types), [स्ट्रिक्ट_एन्कोडिंग](https://crates.io/crates/strict_encoding)

Client-side Validation के लिए इस्तेमाल किया गया सख्त टाइपिंग सिस्टम और निश्चित सीरियलाइजेशन।

#### RGB कोर


- भंडार**: [RGB-core](https://github.com/RGB-WG/RGB-core)
- क्रेट**: [RGB-core](https://crates.io/crates/RGB-core)

प्रोटोकॉल का मुख्य हिस्सा, जो RGB सत्यापन की मुख्य तर्कशक्ति को शामिल करता है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।


- भंडार**: [RGB-std](https://github.com/RGB-WG/RGB-std)
- क्रेट** : [RGB-std](https://crates.io/crates/RGB-std)

मानक कार्यान्वयन, Stash और Wallet प्रबंधन।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।


- भंडार**: [RGB](https://github.com/RGB-WG/RGB)
- क्रेट्स**: [RGB-CLI](https://crates.io/crates/RGB-CLI), [RGB-Wallet](https://crates.io/crates/RGB-Wallet)

`RGB`, `CLI`, और क्रेट `Wallet` का उपयोग कमांड-लाइन पर कॉन्ट्रैक्ट्स को मैनेज करने के लिए किया जाता है।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।


- भंडार**: [RGB-schemata](https://github.com/RGB-WG/RGB-schemata/)

इसमें स्कीमाओं (जैसे NIA, UDA आदि) के उदाहरण और उनके कार्यान्वयन शामिल हैं।

#### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- भंडार**: [AluVM-spec](https://github.com/AluVM/AluVM-spec), [alure](https://github.com/AluVM/alure)
- क्रेट्स**: [AluVM](https://crates.io/crates/AluVM), [aluasm](https://crates.io/crates/aluasm)

रजिस्ट्री-आधारित वर्चुअल मशीन का उपयोग सत्यापन स्क्रिप्ट चलाने के लिए किया जाता है।

#### Bitcoin प्रोटोकॉल - बीपी


- भंडार** : [bp-core](https://github.com/BP-WG/bp-core), [bp-std](https://github.com/BP-WG/bp-std), [bp-Wallet](https://github.com/BP-WG/bp-Wallet)

Bitcoin प्रोटोकॉल (लेन-देन, बाईपास आदि) को सपोर्ट करने के लिए ऐड-ऑन।

#### सर्वव्यापी निर्धारक कंप्यूटिंग - यूबीडीईसीओ


- भंडार**: [UBIDECO](https://github.com/UBIDECO)

ओपन-सोर्स निर्धारक विकास से जुड़े पारिस्थितिकी तंत्र।

# RGB पर आधारित निर्माण

<partId>3b4b0d66-0c1b-505a-b5ca-4b2e57dd73c2</partId>

## डीआईबीए और बिटमास्क प्रोजेक्ट

<chapterId>dc92a5e8-ed93-5a3f-bcd0-d433932842f4</chapterId>

![video](https://youtu.be/nbUtV8GOR_U)

कोर्स का यह अंतिम भाग RGB बूटकैंप में विभिन्न वक्ताओं द्वारा की गई प्रस्तुतियों पर आधारित है। इसमें RGB और उसके इकोसिस्टम पर विचार और अनुभव साझा किए गए हैं, साथ ही प्रोटोकॉल पर आधारित टूल्स और प्रोजेक्ट्स की प्रस्तुतियाँ भी शामिल हैं। इस पहले अध्याय का संचालन हंटर बीस्ट द्वारा किया गया है, और अगले दो अध्यायों का संचालन फेडरिको टेंगा करेंगे।

### जावा स्क्रिप्ट से लेकर Rust तक, और फिर Bitcoin इकोसिस्टम में

शुरुआत में, हंटर बीस्ट मुख्य रूप से जावास्क्रिप्ट में काम करते थे। फिर उन्होंने **Rust** की खोज की, जिसकी सिंटैक्स उन्हें पहले तो अप्रिय और निराशाजनक लगी। हालांकि, बाद में उन्होंने इस भाषा की ताकत, मेमोरी (*हीप* और *स्टैक*) पर नियंत्रण, और इसके साथ आने वाली सुरक्षा और प्रदर्शन की सराहना की। वह इस बात पर जोर देते हैं कि Rust कंप्यूटर के काम करने के तरीके की गहरी समझ के लिए एक बेहतरीन प्रशिक्षण का मैदान है।

हंटर बीस्ट अपने *Altcoin* इकोसिस्टम के विभिन्न प्रोजेक्ट्स में अपने अनुभव के बारे में बताते हैं, जैसे कि एथेरियम (सॉलिडिटी, टाइपस्क्रिप्ट आदि के साथ), और बाद में फाइलकोइन। वह बताते हैं कि शुरू में कुछ प्रोटोकॉल्स ने उन्हें प्रभावित किया था, लेकिन अंत में वह ज्यादातर से निराश हो गए, खासकर उनकी टोकनोमिक्स के कारण। वह संदिग्ध वित्तीय प्रोत्साहनों की आलोचना करते हैं, टोकन की मुद्रास्फीति वाली रचना जो निवेशकों को कमजोर करती है, और इन प्रोजेक्ट्स के संभावित शोषणकारी पहलुओं की भी। इसलिए उन्होंने **Bitcoin Maximalist** दृष्टिकोण अपनाया, खासकर क्योंकि कुछ लोगों ने उन्हें Bitcoin की मजबूत आर्थिक प्रणालियों और इस सिस्टम की मजबूती के बारे में जागरूक किया।

### RGB की अपील और परतों पर निर्माण करना

उसे Bitcoin की प्रासंगिकता के बारे में जो बात पूरी तरह से यकीन दिला गई, उसके शब्दों में, वह था RGB की खोज और लेयर्स का कॉन्सेप्ट। उसका मानना है कि अन्य ब्लॉकचेन पर मौजूद फंक्शनलिटीज़ को Bitcoin के ऊपर की लेयर्स पर दोबारा बनाया जा सकता है, बिना मूल प्रोटोकॉल को बदले।

फरवरी 2022 में, उन्होंने **DIBA** में शामिल होकर विशेष रूप से RGB पर काम करना शुरू किया, और खासकर **Bitmask** Wallet पर। उस समय, Bitmask अभी भी संस्करण 0.01 पर था और RGB को संस्करण 0.4 पर चला रहा था, केवल एकल टोकन के प्रबंधन के लिए। वह बताते हैं कि यह आज की तुलना में कम स्व-हिफाजती उन्मुख था, क्योंकि इसकी लॉजिक आंशिक रूप से सर्वर-आधारित थी। तब से, आर्किटेक्चर इस मॉडल की ओर विकसित हुआ है, जिसे बिटकॉइन धारकों द्वारा बहुत सराहा गया है।

### RGB प्रोटोकॉल की नींव

**RGB** प्रोटोकॉल _रंगीन सिक्कों_ की अवधारणा का सबसे नया और उन्नत रूप है, जिसे पहले 2012-2013 के आसपास खोजा गया था। उस समय, कई टीमें UTXOs पर विभिन्न Bitcoin मूल्य को जोड़ने की कोशिश कर रही थीं, जिससे कई बिखरी हुई कार्यान्वयनें हुईं। इस मानकीकरण की कमी और उस समय की कम मांग ने इन समाधानों को स्थायी रूप से स्थापित होने से रोक दिया।

आज, RGB अपनी अवधारणात्मक मजबूती और LNP/BP संघ के माध्यम से एकीकृत विनिर्देशों के लिए विशेष रूप से खड़ा है। इसका सिद्धांत Client-side Validation पर आधारित है। Bitcoin और Blockchain केवल क्रिप्टोग्राफिक प्रतिबद्धताओं (_commitments_, Taproot या OP_RETURN के माध्यम से) को संग्रहीत करते हैं, जबकि अधिकांश डेटा (Contract परिभाषाएँ, स्थानांतरण इतिहास, आदि) संबंधित उपयोगकर्ताओं द्वारा संग्रहीत किया जाता है। इस तरह, भंडारण का भार वितरित होता है और आदान-प्रदान की गोपनीयता को मजबूत किया जाता है, बिना Blockchain पर भार डाले। यह दृष्टिकोण एक मॉड्यूलर और स्केलेबल ढांचे के भीतर फंजिबल संपत्तियों (**RGB20** मानक) या अद्वितीय संपत्तियों (**RGB21** मानक) के निर्माण को सक्षम बनाता है।

### टोकन फ़ंक्शन (RGB20) और अद्वितीय संपत्तियाँ (RGB21)

**RGB20** के साथ, हम Bitcoin पर एक फंजिबल टोकन को परिभाषित करते हैं। जारीकर्ता एक _आपूर्ति_, एक _सटीकता_ चुनता है, और एक _अनुबंध_ बनाता है जिसमें वह तब स्थानांतरण कर सकता है। प्रत्येक स्थानांतरण को Bitcoin UTXO से संदर्भित किया जाता है, जो एक *Single-Use Seal* के रूप में कार्य करता है। यह तर्क सुनिश्चित करता है कि उपयोगकर्ता एक ही संपत्ति को दो बार खर्च नहीं कर पाएगा, क्योंकि केवल वही व्यक्ति जो UTXO को खर्च करने में सक्षम है, वास्तव में क्लाइंट-साइड Contract की स्थिति को अपडेट करने की कुंजी रखता है।

**RGB21** का उद्देश्य अनोखे संपत्तियों (या "NFT") को लक्षित करना है। इस संपत्ति का Supply मूल्य 1 है, और इसे एक विशेष फील्ड के माध्यम से मेटाडेटा (जैसे कि इमेज फाइल, ऑडियो आदि) के साथ जोड़ा जा सकता है। सार्वजनिक ब्लॉकचेन पर मौजूद NFTs के विपरीत, डेटा और उनके MIME पहचानकर्ता निजी रह सकते हैं और मालिक की इच्छा के अनुसार पीयर-टू-पीयर वितरित किए जा सकते हैं।

### बिटमास्क समाधान: Wallet के लिए RGB

RGB की क्षमताओं का व्यावहारिक रूप से उपयोग करने के लिए, **DIBA** परियोजना ने Wallet नामक [Bitmask](https://bitmask.app/) डिज़ाइन किया है। इसका उद्देश्य एक गैर-हिरासत, Taproot-आधारित उपकरण प्रदान करना है, जो वेब एप्लिकेशन या ब्राउज़र एक्सटेंशन के रूप में सुलभ हो। Bitmask RGB20 और RGB21 दोनों संपत्तियों का प्रबंधन करता है, और इसमें विभिन्न सुरक्षा तंत्र शामिल हैं:


- मुख्य कोड Rust में लिखा गया है, फिर इसे WebAssembly में संकलित किया जाता है ताकि यह जावा स्क्रिप्ट वातावरण (React) में चल सके।
- चाबियाँ स्थानीय रूप से बनाई जाती हैं, फिर उन्हें स्थानीय रूप से एन्क्रिप्ट करके रखा जाता है।
- राज्य डेटा (Stash) को मेमोरी में रखा जाता है, और इसे **Carbonado** लाइब्रेरी के माध्यम से सीरियलाइज़ और एन्क्रिप्ट किया जाता है। यह लाइब्रेरी डेटा को संपीड़ित (कंप्रेस), त्रुटि सुधार (एरर करेक्शन), एन्क्रिप्शन और ब्लेक3 का उपयोग करके स्ट्रीम सत्यापन करती है।

इस आर्किटेक्चर की वजह से, सभी संपत्ति लेन-देन क्लाइंट साइड पर होते हैं। बाहर से देखने पर, Bitcoin लेन-देन एक साधारण Taproot खर्च लेन-देन जैसा ही लगता है, जिससे कोई भी यह नहीं समझ सकता कि इसमें फंजिबल टोकन या NFTs का ट्रांसफर भी हो रहा है। On-Chain ओवरलोडिंग की अनुपस्थिति (कोई सार्वजनिक रूप से संग्रहीत मेटाडेटा नहीं) एक निश्चित स्तर की गोपनीयता की गारंटी देती है और संभावित सेंसरशिप प्रयासों का विरोध करना आसान बनाती है।

### सुरक्षा और वितरित वास्तुकला

RGB प्रोटोकॉल के अनुसार, हर प्रतिभागी को अपने लेन-देन के इतिहास को सुरक्षित रखना होता है ताकि वह प्राप्त होने वाले ट्रांसफर्स की वैधता साबित कर सके। इस स्थिति में, डेटा स्टोरेज का सवाल उठता है। Bitmask सुझाव देता है कि इस Stash को स्थानीय रूप से सीरियलाइज़ किया जाए, फिर इसे कई सर्वरों या क्लाउड्स पर भेजा जाए (यह वैकल्पिक है)। डेटा उपयोगकर्ता द्वारा **Carbonado** के माध्यम से एन्क्रिप्टेड रहता है, इसलिए सर्वर इसे पढ़ नहीं सकता। अगर डेटा का कुछ हिस्सा खराब हो जाता है, तो त्रुटि सुधार Layer सामग्री को फिर से बना सकता है।

CRDT (कंफ्लिक्ट-फ्री रेप्लिकेटेड डेटा टाइप) का उपयोग यह सुनिश्चित करता है कि अगर Stash के विभिन्न संस्करण अलग-अलग हो जाएं, तो उन्हें आसानी से मिलाया जा सके। हर कोई इस डेटा को अपनी पसंद की जगह पर होस्ट कर सकता है, क्योंकि कोई भी एकल Full node उस संपत्ति से जुड़ी सारी जानकारी नहीं रखता। यह ठीक उसी तरह है जैसे *Client-side Validation* का सिद्धांत, जहां हर मालिक अपने RGB संपत्ति की वैधता के सबूत को स्टोर करने के लिए जिम्मेदार होता है।

### एक व्यापक पारिस्थितिकी तंत्र की ओर: बाजार, आपसी संचालन क्षमता और नई कार्यक्षमताएँ

Bitmask के पीछे की कंपनी खुद को सिर्फ Wallet के साधारण विकास तक सीमित नहीं रख रही है। DIBA का इरादा है कि वे और भी चीजें विकसित करें:


- **RGB21** रूप में टोकन के आदान-प्रदान के लिए एक **बाज़ार**;
- अन्य वॉलेट्स के साथ संगतता (जैसे *Iris Wallet*);
- ट्रांसफर बैचिंग तकनीकें, यानी एक ही लेन-देन में कई लगातार RGB ट्रांसफर शामिल करने की संभावना।

हम एक साथ **WebBTC** या **WebLN** पर काम कर रहे हैं (ये ऐसे मानक हैं जो वेबसाइटों को Wallet से Bitcoin या लाइटनिंग लेनदेन पर हस्ताक्षर करने की अनुमति देते हैं), साथ ही "टेलीबर्न" ऑर्डिनल्स प्रविष्टियों की क्षमता पर भी काम कर रहे हैं (अगर हम ऑर्डिनल्स को एक अधिक गोपनीय और लचीले RGB प्रारूप में वापस लाना चाहते हैं)।

### निष्कर्ष

पूरा प्रक्रिया यह दिखाती है कि RGB इकोसिस्टम को कैसे लागू किया जा सकता है और इसे अंतिम उपयोगकर्ताओं के लिए मजबूत तकनीकी समाधानों के माध्यम से सुलभ बनाया जा सकता है। Altcoin दृष्टिकोण से Bitcoin-केंद्रित दृष्टि की ओर संक्रमण, और *Client-side Validation* की खोज के साथ, एक काफी तार्किक मार्ग को दर्शाता है: हम समझते हैं कि विभिन्न कार्यक्षमताओं (फंजिबल टोकन, NFT, स्मार्ट कॉन्ट्रैक्ट्स...) को Blockchain को फोर्क किए बिना लागू करना संभव है, बस Taproot लेनदेन या OP_RETURNs पर क्रिप्टोग्राफिक प्रतिबद्धताओं का लाभ उठाकर।

**बिटमास्क** Wallet इस दृष्टिकोण का हिस्सा है: Blockchain की तरफ से, आपको सिर्फ एक साधारण Bitcoin लेन-देन दिखाई देता है; जबकि उपयोगकर्ता की तरफ से, आप एक वेब Interface को संचालित करते हैं जहाँ आप विभिन्न प्रकार के off-chain संपत्तियों को बनाते, Exchange और संग्रहीत करते हैं। यह मॉडल स्पष्ट रूप से मौद्रिक बुनियादी ढांचे (Bitcoin) को जारी करने और स्थानांतरण तर्क (RGB) से अलग करता है, जबकि उच्च स्तर की गोपनीयता और बेहतर विस्तार क्षमता सुनिश्चित करता है।

## बिटफिनेक्स का RGB पर काम

<chapterId>d4d80e07-5eac-5b29-a93a-123180e97047</chapterId>

![vidéo](https://youtu.be/5iAhsgCSL3U)

इस अध्याय में, जो कि फ्रेडरिको टेंगा की प्रस्तुति पर आधारित है, हम उन उपकरणों और परियोजनाओं के सेट को देखते हैं जिन्हें बिटफिनेक्स टीम ने RGB के लिए बनाया है। इसका उद्देश्य इस प्रोटोकॉल के चारों ओर एक समृद्ध और विविध पारिस्थितिकी तंत्र के उदय को बढ़ावा देना है। टीम का प्रारंभिक उद्देश्य किसी विशेष व्यावसायिक उत्पाद को जारी करना नहीं है, बल्कि सॉफ्टवेयर निर्माण खंड प्रदान करना, RGB प्रोटोकॉल में योगदान देना और ठोस कार्यान्वयन संदर्भ प्रस्तावित करना है, जैसे कि एक मोबाइल Wallet (*Iris Wallet*) या RGB-संगत लाइटनिंग नोड।

### पृष्ठभूमि और उद्देश्य

लगभग 2022 से, Bitfinex RGB टीम उस तकनीकी ढांचे को विकसित करने पर ध्यान केंद्रित कर रही है जो RGB को प्रभावी ढंग से उपयोग और परीक्षण करने में सक्षम बनाता है। इस दिशा में कई योगदान दिए गए हैं:


- स्रोत कोड और प्रोटोकॉल विनिर्देशों में भागीदारी, जिसमें सुधार प्रस्ताव लिखना, बग्स को ठीक करना आदि शामिल हैं।
- डेवलपर्स के लिए टूल्स जो उनके एप्लिकेशन्स में RGB के इंटीग्रेशन को आसान बनाते हैं।
- Wallet नामक एक मोबाइल का डिज़ाइन, जिसे [Iris](https://iriswallet.com/) कहा जाता है, RGB के उपयोग के लिए सर्वोत्तम प्रथाओं का प्रयोग और प्रदर्शन करने के लिए बनाया गया है।
- एक कस्टमाइज्ड लाइटनिंग नोड का निर्माण, जो RGB संपत्तियों के साथ चैनलों को प्रबंधित करने में सक्षम हो;
- RGB पर समाधान बनाने वाली अन्य टीमों का समर्थन करना, ताकि विविधता और एक मजबूत पारिस्थितिकी तंत्र को प्रोत्साहित किया जा सके।

यह दृष्टिकोण सभी आवश्यकताओं की श्रृंखला को कवर करने का लक्ष्य रखता है: निम्न-स्तरीय लाइब्रेरी (*[RGBlib](https://github.com/RGB-Tools/RGB-lib)*) से लेकर, जो Wallet के कार्यान्वयन को सक्षम बनाता है, उत्पादन पहलू तक (जैसे एक लाइटनिंग नोड, एक एंड्रॉइड के लिए Wallet, आदि)।

### RGBlib लाइब्रेरी: RGB एप्लिकेशन के विकास को सरल बनाना

RGB वॉलेट्स और एप्लिकेशन्स के निर्माण को जनतांत्रिक बनाने का एक महत्वपूर्ण बिंदु यह है कि एक ऐसा सरल एब्स्ट्रैक्शन उपलब्ध कराया जाए जिससे डेवलपर्स को प्रोटोकॉल की आंतरिक लॉजिक के बारे में सब कुछ सीखने की जरूरत न पड़े। यही **RGBlib** का उद्देश्य है, जिसे Rust में लिखा गया है।

RGBlib एक पुल की तरह काम करता है जो RGB की अत्यधिक लचीली (लेकिन कभी-कभी जटिल) आवश्यकताओं और एक एप्लिकेशन डेवलपर की ठोस जरूरतों के बीच संबंध स्थापित करता है। सरल शब्दों में, अगर कोई Wallet (या सेवा) टोकन ट्रांसफर, एसेट जारी करना, सत्यापन आदि प्रबंधित करना चाहता है, तो वह RGBlib पर निर्भर कर सकता है, बिना हर क्रिप्टोग्राफिक विवरण या हर कस्टमाइज़ेबल RGB पैरामीटर को जाने।

बुकशॉप में ये चीज़ें मिलती हैं:


- संपत्तियों (फंजिबल या नॉन-फंजिबल) के जारी करने के लिए टर्नकी कार्य।
- साधारण वस्तुओं (जैसे पते, राशि, UTXOs आदि) को संभालकर संपत्तियों को स्थानांतरित (भेजने/प्राप्त करने) की क्षमता;
- Client-side Validation के लिए आवश्यक स्थिति जानकारी (*consignments*) को स्टोर और लोड करने की एक प्रणाली।

RGBlib इसलिए RGB (Client-side Validation, Tapret/Opret एंकर) से संबंधित जटिल अवधारणाओं पर निर्भर करता है, लेकिन इन्हें इस तरह से समेटता है कि अंतिम एप्लिकेशन को सब कुछ फिर से प्रोग्राम करने या जोखिम भरे निर्णय लेने की ज़रूरत नहीं होती। इसके अलावा, RGBlib पहले से ही कई भाषाओं (Kotlin और Python) में बंधा हुआ है, जिससे यह एक साधारण Rust ब्रह्मांड से परे उपयोग के लिए दरवाजे खोलता है।

### Iris Wallet: Android पर RGB Wallet का एक उदाहरण

RGBlib की प्रभावशीलता को साबित करने के लिए, Bitfinex टीम ने **Iris Wallet** विकसित किया है, जो फिलहाल केवल Android पर उपलब्ध है। यह एक मोबाइल Wallet है जो उपयोगकर्ता अनुभव को एक साधारण Bitcoin Wallet के समान दर्शाता है: आप एक संपत्ति जारी कर सकते हैं, उसे भेज सकते हैं, प्राप्त कर सकते हैं, और उसका इतिहास देख सकते हैं, जबकि आप स्व-हिरासत मॉडल पर बने रहते हैं।

आईरिस में कई दिलचस्प विशेषताएँ हैं:

**इलेक्ट्रम सर्वर का उपयोग करना:**

जैसे किसी भी Wallet के लिए होता है, Iris को Blockchain पर लेन-देन की पुष्टि के बारे में जानने की जरूरत होती है। एक पूरा नोड एम्बेड करने के बजाय, Iris डिफ़ॉल्ट रूप से Bitfinex टीम द्वारा बनाए गए Electrum सर्वर का उपयोग करता है। हालांकि, उपयोगकर्ता अपना खुद का सर्वर या किसी अन्य थर्ड-पार्टी सेवा को कॉन्फ़िगर कर सकते हैं। इस तरह, Bitcoin लेन-देन को एक मॉड्यूलर तरीके से सत्यापित किया जा सकता है और जानकारी (इंडेक्सिंग) प्राप्त की जा सकती है।

**RGB प्रॉक्सी सर्वर:**

Bitcoin के विपरीत, RGB को प्रेषक और प्राप्तकर्ता के बीच off-chain मेटाडेटा (*consignments*) के Exchange की आवश्यकता होती है। इस प्रक्रिया को सरल बनाने के लिए, आइरिस एक समाधान प्रदान करता है जहां संचार एक प्रॉक्सी सर्वर के माध्यम से होता है। प्राप्त करने वाला Wallet एक *Invoice* उत्पन्न करता है जो बताता है कि प्रेषक को *क्लाइंट-साइड* डेटा कहां भेजना चाहिए। डिफ़ॉल्ट रूप से, URL बिटफिनेक्स टीम द्वारा होस्ट किए गए प्रॉक्सी की ओर इशारा करता है, लेकिन आप इस प्रॉक्सी को बदल सकते हैं (या अपना खुद का होस्ट कर सकते हैं)। विचार यह है कि एक परिचित उपयोगकर्ता अनुभव पर लौटें जहां प्राप्तकर्ता एक QR कोड प्रदर्शित करता है, और प्रेषक इस कोड को लेन-देन के लिए स्कैन करता है, बिना किसी जटिल अतिरिक्त हेरफेर के।

**निरंतर बैकअप:**

Bitcoin के संदर्भ में, आमतौर पर आपके seed का बैकअप लेना पर्याप्त होता है (हालांकि आजकल हम seed और विवरणकों का बैकअप लेने की सलाह देते हैं)। लेकिन RGB के मामले में, यह पर्याप्त नहीं है: आपको स्थानीय इतिहास (जिसे *कंसाइनमेंट्स* कहते हैं) भी रखना होता है, जो यह साबित करता है कि आप वास्तव में RGB संपत्ति के मालिक हैं। हर बार जब आप एक रसीद प्राप्त करते हैं, तो डिवाइस नया डेटा स्टोर करता है, जो बाद के खर्च के लिए आवश्यक होता है। आइरिस स्वचालित रूप से उपयोगकर्ता के गूगल ड्राइव में एक एन्क्रिप्टेड बैकअप प्रबंधित करता है। इसके लिए गूगल पर विशेष भरोसे की आवश्यकता नहीं होती, क्योंकि बैकअप एन्क्रिप्टेड होता है, और भविष्य में अधिक मजबूत विकल्प (जैसे कि एक व्यक्तिगत सर्वर) की योजना बनाई गई है ताकि किसी तीसरे पक्ष के ऑपरेटर द्वारा सेंसरशिप या हटाने के किसी भी जोखिम से बचा जा सके।

**अन्य विशेषताएँ:**


- Faucet बनाएं ताकि आप जल्दी से टोकन का परीक्षण या प्रचार के लिए वितरण कर सकें।
- एक प्रमाणन प्रणाली (जो वर्तमान में केंद्रीकृत है) का उपयोग किया जाता है ताकि एक असली टोकन को किसी प्रसिद्ध टिकर की नकली कॉपी से अलग किया जा सके। भविष्य में, यह प्रमाणन प्रणाली अधिक विकेंद्रीकृत हो सकती है (DNS या अन्य तरीकों के माध्यम से)।

कुल मिलाकर, Iris एक उपयोगकर्ता अनुभव प्रदान करता है जो क्लासिक Bitcoin Wallet के समान है। यह RGBlib और एक प्रॉक्सी सर्वर के उपयोग के माध्यम से अतिरिक्त जटिलताओं (जैसे Stash प्रबंधन, *Consignment* इतिहास आदि) को छुपाता है।

### प्रॉक्सी सर्वर और उपयोगकर्ता अनुभव

प्रॉक्सी सर्वर एक ऐसा माध्यम है जो आपके कंप्यूटर और इंटरनेट के बीच में आता है। जब आप इंटरनेट पर कुछ खोजते हैं या किसी वेबसाइट पर जाते हैं, तो आपकी रिक्वेस्ट पहले प्रॉक्सी सर्वर के पास जाती है। यह सर्वर आपकी पहचान को छुपाकर आपकी रिक्वेस्ट को आगे बढ़ाता है। इससे आपकी गोपनीयता बनी रहती है और आप सुरक्षित रूप से इंटरनेट का उपयोग कर सकते हैं।

उपयोगकर्ता अनुभव की बात करें तो, प्रॉक्सी सर्वर कई तरीकों से इसे बेहतर बना सकता है। यह इंटरनेट की गति को बढ़ा सकता है क्योंकि यह कैशिंग तकनीक का उपयोग करता है, जिससे बार-बार एक ही डेटा को डाउनलोड करने की जरूरत नहीं पड़ती। इसके अलावा, यह आपको उन वेबसाइटों तक पहुंचने में मदद कर सकता है जो आपके क्षेत्र में प्रतिबंधित हैं।

हालांकि, कभी-कभी प्रॉक्सी सर्वर के कारण इंटरनेट की गति धीमी भी हो सकती है, खासकर जब सर्वर पर लोड ज्यादा हो। इसलिए, सही प्रॉक्सी सर्वर का चयन करना महत्वपूर्ण है ताकि आपका उपयोगकर्ता अनुभव सुगम और सुरक्षित बना रहे।

ऊपर बताए गए प्रॉक्सी सर्वर के बारे में विस्तार से बताना जरूरी है, क्योंकि यह एक सहज उपयोगकर्ता अनुभव की कुंजी है। इसके बजाय कि भेजने वाले को *सामान* को प्राप्तकर्ता को मैन्युअल रूप से भेजना पड़े, RGB लेन-देन पृष्ठभूमि में होता है एक:


- प्राप्तकर्ता एक *Invoice* उत्पन्न करता है (जिसमें अन्य चीजों के साथ-साथ प्रॉक्सी Address भी शामिल होता है);
- प्रेषक एक ट्रांज़िशन प्रोजेक्ट (*Consignment*) को प्रॉक्सी के पास भेजता है (HTTP अनुरोध के माध्यम से);
- प्राप्तकर्ता इस प्रोजेक्ट को प्राप्त करता है और *क्लाइंट-साइड* सत्यापन को स्थानीय रूप से निष्पादित करता है।
- प्राप्तकर्ता फिर प्रॉक्सी के माध्यम से State Transition की स्वीकृति (या संभवतः अस्वीकृति) को प्रकाशित करता है।
- प्रेषक सत्यापन स्थिति देख सकता है और अगर स्वीकार कर लिया जाता है, तो Bitcoin लेन-देन को प्रसारित करके स्थानांतरण को अंतिम रूप दे सकता है।

इस तरह, Wallet लगभग एक सामान्य Wallet की तरह ही काम करता है। उपयोगकर्ता को सभी मध्यवर्ती चरणों के बारे में पता नहीं होता है। यह मानना पड़ेगा कि वर्तमान प्रॉक्सी न तो एन्क्रिप्टेड है और न ही प्रमाणित (जिससे गोपनीयता और अखंडता को लेकर चिंताएँ बनी रहती हैं), लेकिन इन सुधारों को बाद के संस्करणों में किया जा सकता है। प्रॉक्सी की अवधारणा "मैं एक QR कोड भेजता हूँ, आप स्कैन करके भुगतान करते हैं" के अनुभव को फिर से बनाने के लिए बेहद उपयोगी है।

### RGB को Lightning Network में इंटीग्रेट करना

Bitfinex टीम के काम का एक और मुख्य ध्यान Lightning Network को RGB संपत्तियों के साथ संगत बनाना है। इसका उद्देश्य USDT (या किसी अन्य टोकन) में लाइटनिंग चैनल सक्षम करना है, और Bitcoin पर लाइटनिंग के समान लाभ प्राप्त करना है (जैसे लगभग तात्कालिक लेन-देन, रूटिंग, आदि)। व्यावहारिक रूप से, इसका मतलब है एक लाइटनिंग नोड बनाना जो इस तरह से संशोधित हो:


- एक चैनल खोलें जिसमें न केवल सतोशी शामिल हों, बल्कि एक या अधिक RGB संपत्तियाँ भी फंडिंग UTXO Multisig में डालें।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। generate लाइटनिंग Commitment लेनदेन (Bitcoin पक्ष) के साथ-साथ संबंधित RGB राज्य संक्रमण होते हैं। हर बार जब चैनल अपडेट होता है, तो एक RGB संक्रमण लाइटनिंग आउटपुट में संपत्ति वितरण को फिर से परिभाषित करता है।
- एकतरफा बंद करने की सुविधा प्रदान करें, जहां संपत्ति को विशेष UTXO में प्राप्त किया जाता है, जो Lightning Network नियमों (HTLC, समय लॉक, दंड, आदि) के अनुसार है।

इस समाधान को "**RGB लाइटनिंग नोड**" कहा जाता है, जो LDK (*लाइटनिंग डेवलपमेंट किट*) को आधार के रूप में उपयोग करता है और चैनलों में RGB टोकन डालने के लिए आवश्यक तंत्र जोड़ता है। लाइटनिंग कमिटमेंट्स अपनी पारंपरिक संरचना (पंचरेबल आउटपुट्स, टाइमलॉक...) को बनाए रखते हैं, और इसके अलावा Anchor और RGB State Transition (ओप्रेट या टैप्रेट के माध्यम से) भी शामिल होते हैं। उपयोगकर्ता के लिए, यह स्थिरकॉइन या RGB के माध्यम से जारी किसी अन्य संपत्ति में लाइटनिंग चैनलों का रास्ता खोलता है।

### DEX (डिसेंट्रलाइज्ड एक्सचेंज) का संभावित प्रभाव और Bitcoin पर इसका असर काफी महत्वपूर्ण हो सकता है। DEX, जो कि केंद्रीकृत एक्सचेंजों के विपरीत, बिना किसी मध्यस्थ के सीधे उपयोगकर्ताओं को व्यापार करने की सुविधा देता है, वित्तीय लेन-देन को अधिक सुरक्षित और पारदर्शी बनाता है। 

Bitcoin, जो कि एक नई तकनीक या प्रोजेक्ट हो सकता है, पर DEX का प्रभाव इस बात पर निर्भर करेगा कि यह प्रोजेक्ट किस प्रकार के वित्तीय लेन-देन या व्यापार में शामिल है। अगर Bitcoin ब्लॉकचेन या क्रिप्टोकरेंसी से संबंधित है, तो DEX के माध्यम से इसे अधिक उपयोगकर्ताओं तक पहुंचने और व्यापार करने में आसानी हो सकती है। 

इसके अलावा, DEX के माध्यम से Bitcoin को अधिक विकेंद्रीकृत और सुरक्षित प्लेटफॉर्म मिल सकता है, जिससे उपयोगकर्ताओं का विश्वास बढ़ेगा और प्रोजेक्ट की सफलता की संभावनाएं भी बढ़ेंगी। कुल मिलाकर, DEX का प्रभाव Bitcoin पर सकारात्मक हो सकता है, बशर्ते कि इसे सही तरीके से लागू किया जाए।

जब कई संपत्तियों को लाइटनिंग के माध्यम से प्रबंधित किया जाता है, तो यह कल्पना करना संभव हो जाता है कि एक ही लाइटनिंग रूटिंग पथ पर **एटॉमिक Exchange** का उपयोग किया जा सकता है, जिसमें रहस्यों और टाइमलॉक्स की वही तर्कशक्ति होती है। उदाहरण के लिए, उपयोगकर्ता A के पास एक लाइटनिंग चैनल पर Bitcoin है, और उपयोगकर्ता B के पास दूसरे लाइटनिंग चैनल पर USDT RGB है। वे अपने दोनों चैनलों को जोड़ने वाला एक पथ बना सकते हैं और एक साथ Exchange BTC को USDT के लिए स्वैप कर सकते हैं, बिना किसी विश्वास की आवश्यकता के। यह कुछ और नहीं बल्कि एक **एटॉमिक स्वैप** है जो कई हॉप्स में होता है, जिससे बाहरी प्रतिभागियों को लगभग यह पता नहीं चलता कि वे केवल रूटिंग नहीं, बल्कि एक व्यापार कर रहे हैं। इस दृष्टिकोण से यह लाभ मिलता है:


- बहुत कम विलंबता, क्योंकि सब कुछ लाइटनिंग पर off-chain रहता है।
- एक बेहतरीन **गोपनीयता**: कोई नहीं जानता कि यह एक व्यापार है, और यह सामान्य मार्ग नहीं है;
- On-Chain DEX के लिए फ्रंट-रनिंग से बचना एक बार-बार आने वाली समस्या है।
- कम लागत (आपको ब्लॉकस्पेस के लिए भुगतान नहीं करना पड़ता, सिर्फ लाइटनिंग रूटिंग फीस देनी होती है)।

हम एक ऐसे इकोसिस्टम की कल्पना कर सकते हैं जहाँ लाइटनिंग नोड्स स्वैप की कीमतें ऑफर करते हैं (लिक्विडिटी प्रदान करके)। हर नोड, अगर वह चाहे, तो _मार्केट मेकर_ की भूमिका निभा सकता है, लाइटनिंग पर विभिन्न संपत्तियों को खरीद और बेच सकता है। _लेयर-2_ DEX की यह संभावना इस विचार को मजबूत करती है कि विकेंद्रीकृत संपत्ति एक्सचेंज प्राप्त करने के लिए Fork या थर्ड-पार्टी ब्लॉकचेन का उपयोग करना आवश्यक नहीं है।

Bitcoin पर इसका प्रभाव सकारात्मक हो सकता है: लाइटनिंग की संरचना (नोड्स, चैनल और सेवाएं) इन *स्टेबलकॉइन्स*, डेरिवेटिव्स और अन्य टोकन्स द्वारा उत्पन्न मात्रा के कारण अधिक पूरी तरह से उपयोग की जाएगी। जो व्यापारी लाइटनिंग पर USDT भुगतान में रुचि रखते हैं, वे स्वचालित रूप से लाइटनिंग पर BTC भुगतान की खोज करेंगे (जो उसी स्टैक द्वारा प्रबंधित होते हैं)। Lightning Network संरचना के रखरखाव और वित्तपोषण को भी इन गैर-BTC प्रवाहों की वृद्धि से लाभ हो सकता है, जो अप्रत्यक्ष रूप से Bitcoin उपयोगकर्ताओं को लाभान्वित करेगा।

### निष्कर्ष और संसाधन

Bitfinex टीम ने RGB पर काम करके यह दिखाया है कि प्रोटोकॉल के ऊपर कितनी विविधता से काम किया जा सकता है। एक तरफ, RGBlib है, जो एक लाइब्रेरी है जो वॉलेट और एप्लिकेशन डिज़ाइन करने में मदद करती है। दूसरी तरफ, हमारे पास Iris Wallet है, जो एंड्रॉइड पर एक साफ-सुथरे एंड-यूज़र Interface का व्यावहारिक प्रदर्शन है। अंत में, RGB का लाइटनिंग के साथ एकीकरण यह दिखाता है कि स्थिरकॉइन चैनल संभव हैं, और यह लाइटनिंग पर एक संभावित विकेंद्रीकृत DEX के लिए रास्ता खोलता है।

यह तरीका अभी भी काफी हद तक प्रयोगात्मक है और लगातार विकसित हो रहा है: RGBlib लाइब्रेरी को हम जैसे-जैसे आगे बढ़ रहे हैं, सुधार रहे हैं, Iris Wallet को नियमित रूप से अपडेट मिल रहे हैं, और समर्पित लाइटनिंग नोड अभी तक मुख्यधारा का लाइटनिंग क्लाइंट नहीं बना है।

जो लोग अधिक जानना या योगदान करना चाहते हैं, उनके लिए कई संसाधन उपलब्ध हैं, जिनमें शामिल हैं:


- [GitHub RGB टूल्स रिपॉजिटरीज़](https://github.com/RGB-Tools);
- [आईरिस Wallet के लिए समर्पित एक जानकारी साइट](https://iriswallet.com/) जो एंड्रॉइड पर Wallet का परीक्षण करने के लिए है।

अगले अध्याय में, हम यह जानेंगे कि RGB लाइटनिंग नोड को कैसे लॉन्च किया जाए।

## आरएलएन - जीडब्ल्यू-2249 लाइटनिंग नोड

<chapterId>ecaabe32-20ba-5f8c-8ca1-a3f095792958</chapterId>

![vidéo](https://youtu.be/piQQH4Q2nr0)

इस अंतिम अध्याय में, फ्रेडरिको टेंगा आपको एक रेजटेस्ट वातावरण पर लाइटनिंग RGB नोड सेट करने की प्रक्रिया को चरण-दर-चरण समझाते हैं, और आपको इस पर RGB टोकन बनाने का तरीका दिखाते हैं। दो अलग-अलग नोड्स लॉन्च करके, आप यह भी जानेंगे कि उनके बीच एक लाइटनिंग चैनल कैसे खोला जाए और Exchange RGB संपत्तियों का उपयोग कैसे किया जाए।

यह वीडियो एक ट्यूटोरियल के रूप में काम करता है, जैसा कि हमने पिछले अध्याय में कवर किया था, लेकिन इस बार विशेष रूप से लाइटनिंग पर केंद्रित है!

इस वीडियो के लिए मुख्य संसाधन Github रिपॉजिटरी [RGB Lightning Node](https://github.com/RGB-Tools/RGB-lightning-node) है, जो आपको इस कॉन्फ़िगरेशन को Regtest में आसानी से लॉन्च करने में मदद करता है।

### RGB संगत लाइटनिंग नोड को तैनात करना

यह प्रक्रिया पिछले अध्यायों में शामिल सभी अवधारणाओं को उठाती है और उन्हें व्यवहार में लाती है।


- यह विचार कि **UTXO** एक 2/2 Multisig लाइटनिंग चैनल पर ब्लॉक हो सकता है, न केवल बिटकॉइन प्राप्त कर सकता है, बल्कि यह RGB संपत्तियों का Single-Use Seal भी हो सकता है (चाहे वे फंजिबल हों या नहीं);
- प्रत्येक लाइटनिंग एंगेजमेंट लेन-देन में, एक आउटपुट (`Tapret` या `Opret`) जोड़ा जाता है, जो RGB State Transition को एंकर करने के लिए समर्पित होता है।
- Bitcoin लेनदेन और Exchange *क्लाइंट-साइड* डेटा को मान्य करने के लिए संबंधित बुनियादी ढांचा (bitcoind/इंडेक्सर/प्रॉक्सी)।

### RGB-लाइटनिंग-नोड का परिचय

**`RGB-lightning-node`** परियोजना एक Rust daemon पर आधारित है, जो `Rust-lightning` (LDK) Fork को संशोधित करके बनाया गया है ताकि चैनल में RGB संपत्तियों के अस्तित्व को ध्यान में रखा जा सके। जब एक चैनल खोला जाता है, तो संपत्तियों की उपस्थिति को निर्दिष्ट किया जा सकता है, और हर बार जब चैनल की स्थिति अपडेट होती है, तो एक RGB संक्रमण बनाया जाता है, जो लाइटनिंग आउटपुट में संपत्ति के वितरण को दर्शाता है। इससे सक्षम होता है:


- यूएसडीटी में लाइटनिंग चैनल खोलें, उदाहरण के लिए;
- इन टोकनों को नेटवर्क के माध्यम से भेजें, बशर्ते कि रूटिंग पथों में पर्याप्त तरलता हो।
- बिजली की सजा और समयबंदी की तर्क को बिना किसी बदलाव के उपयोग करें: बस Commitment Transaction के एक अतिरिक्त आउटपुट में Anchor को RGB में बदलें।

कोड अभी भी अल्फा स्टेज में है: हम इसे केवल **regtest** या **Testnet** पर ही इस्तेमाल करने की सलाह देते हैं।

### नोड इंस्टॉलेशन

`RGB-lightning-node` बाइनरी को संकलित और इंस्टॉल करने के लिए, हम सबसे पहले रिपॉजिटरी और उसके सब-मॉड्यूल्स को क्लोन करते हैं, फिर हम इसे चलाते हैं:

```bash
git clone https://github.com/RGB-Tools/rgb-lightning-node --recurse-submodules --shallow-submodules
```

![RGB-Bitcoin](assets/fr/098.webp)


- `--recurse-submodules` विकल्प आवश्यक सब-डिवाइस (जिसमें `Rust-lightning` का संशोधित संस्करण शामिल है) को भी क्लोन करता है।
- `--shallow-submodules` विकल्प क्लोन की गहराई को सीमित करता है ताकि डाउनलोडिंग तेज हो सके, लेकिन फिर भी आवश्यक कमिट्स तक पहुंच प्रदान करता है।

प्रोजेक्ट की मुख्य निर्देशिका से निम्नलिखित कमांड चलाएं ताकि बाइनरी को संकलित और इंस्टॉल किया जा सके:

```bash
cargo install --locked --debug --path .
```

![RGB-Bitcoin](assets/fr/099.webp)


- `--locked` यह सुनिश्चित करता है कि निर्भरता के संस्करण का सख्ती से पालन किया जाए;
- `--debug` अनिवार्य नहीं है, लेकिन यह आपकी मदद कर सकता है ध्यान केंद्रित करने में (अगर आप चाहें तो `--release` का उपयोग कर सकते हैं);
- `--path .` का मतलब है कि `cargo install` को निर्देश देना कि वह वर्तमान डायरेक्टरी से इंस्टॉल करे।

इस कमांड के अंत में, एक `RGB-lightning-node` निष्पादन योग्य फाइल आपके `$CARGO_HOME/bin/` में उपलब्ध होगी। सुनिश्चित करें कि यह पथ आपके `$PATH` में शामिल हो ताकि आप किसी भी डायरेक्टरी से इस कमांड को चला सकें।

### प्रदर्शन आवश्यकताएँ

काम करने के लिए, `RGB-lightning-node` daemon को कुछ चीजों की उपस्थिति और सेटअप की आवश्यकता होती है:


- `bitcoind`** नोड

प्रत्येक RLN उदाहरण को अपने On-Chain लेन-देन को प्रसारित और मॉनिटर करने के लिए `bitcoind` के साथ संवाद करना होगा। daemon को प्रमाणीकरण (लॉगिन/पासवर्ड) और URL (होस्ट/पोर्ट) प्रदान करने की आवश्यकता होगी।


- एक इंडेक्सर** (इलेक्ट्रम या एस्प्लोरा)

daemon को On-Chain लेन-देन की सूची बनाने और उन्हें खोजने में सक्षम होना चाहिए, खासकर उस UTXO को ढूंढने के लिए जिस पर कोई संपत्ति आधारित है। आपको अपने Electrum सर्वर या Esplora का URL निर्दिष्ट करना होगा।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

जैसा कि पिछले अध्यायों में देखा गया है, **प्रॉक्सी सर्वर** एक घटक है (वैकल्पिक, लेकिन अत्यधिक अनुशंसित) जो लाइटनिंग साथियों के बीच *माल भेजने* की प्रक्रिया को सरल बनाता है। एक बार फिर, एक URL निर्दिष्ट करना आवश्यक है।

जब daemon को API के माध्यम से _अनलॉक_ किया जाता है, तब IDs और URLs दर्ज किए जाते हैं। इसके बारे में आगे और जानकारी मिलेगी।

### रेगटेस्ट लॉन्च

सरल उपयोग के लिए, एक `regtest.sh` स्क्रिप्ट है जो स्वचालित रूप से Docker के माध्यम से कुछ सेवाएँ शुरू करती है: `bitcoind`, `electrs` (इंडेक्सर), `RGB-proxy-server`।

![RGB-Bitcoin](assets/fr/100.webp)

यह आपको एक स्थानीय, अलग-थलग, पूर्व-निर्धारित वातावरण शुरू करने की अनुमति देता है। यह प्रत्येक रीबूट पर कंटेनरों और डेटा निर्देशिकाओं को बनाता और नष्ट करता है। हम इसे शुरू करके आरंभ करेंगे:

```bash
./regtest.sh start
```

यह स्क्रिप्ट यह करेगी:


- एक `docker/` डायरेक्टरी बनाएं ताकि उसमें संग्रह कर सकें।
- `bitcoind` को रेजटेस्ट में चलाएं, साथ ही इंडेक्सर `electrs` और `RGB-proxy-server` को भी चलाएं।
- जब तक सब कुछ इस्तेमाल के लिए तैयार न हो जाए, तब तक इंतज़ार करें।

![RGB-Bitcoin](assets/fr/101.webp)

अब हम कई RLN नोड्स लॉन्च करेंगे। अलग-अलग शेल्स में, उदाहरण के लिए (3 RLN नोड्स लॉन्च करने के लिए) चलाएँ:

```bash
# 1st shell
rgb-lightning-node dataldk0/ --daemon-listening-port 3001 \
--ldk-peer-listening-port 9735 --network regtest
# 2nd shell
rgb-lightning-node dataldk1/ --daemon-listening-port 3002 \
--ldk-peer-listening-port 9736 --network regtest
# 3rd shell
rgb-lightning-node dataldk2/ --daemon-listening-port 3003 \
--ldk-peer-listening-port 9737 --network regtest
```

![RGB-Bitcoin](assets/fr/102.webp)


- `--network regtest` पैरामीटर यह दर्शाता है कि आप regtest कॉन्फ़िगरेशन का उपयोग कर रहे हैं।
- `--daemon-listening-port` यह बताता है कि लाइटनिंग नोड किस REST पोर्ट पर API कॉल्स (JSON) के लिए सुनेगा।
- `--ldk-peer-listening-port` यह निर्धारित करता है कि Lightning P2P किस पोर्ट पर सुनना चाहिए।
- `dataldk0/` और `dataldk1/` वे रास्ते हैं जहाँ डेटा स्टोर किया जाता है (हर नोड अपनी जानकारी अलग से स्टोर करता है)।

आप अपने ब्राउज़र से अपने RLN नोड्स पर कमांड भी चला सकते हैं।

```url
https://rgb-tools.github.io/rgb-lightning-node/
```

किसी नोड को चैनल खोलने के लिए, पहले उसके पास Address पर बिटकॉइन होने चाहिए, जो निम्नलिखित कमांड से जनरेट किया गया हो (उदाहरण के लिए, नोड नंबर 1 के लिए):

```bash
curl -X POST http://localhost:3001/address
```

उत्तर आपको एक Address प्रदान करेगा।

![RGB-Bitcoin](assets/fr/103.webp)

`bitcoind` रेजटेस्ट पर, हम कुछ बिटकॉइन माइन करने जा रहे हैं। चलाएँ:

```bash
./regtest.sh mine 101
```

![RGB-Bitcoin](assets/fr/104.webp)

ऊपर दिए गए नोड Address पर धनराशि भेजें:

```bash
./regtest.sh sendtoaddress <address> <amount>
```

![RGB-Bitcoin](assets/fr/105.webp)

फिर लेन-देन की पुष्टि के लिए एक ब्लॉक माइन करें:

```bash
./regtest.sh mine 1
```

![RGB-Bitcoin](assets/fr/106.webp)

### Testnet को बिना Docker के लॉन्च करना

अगर आप एक अधिक वास्तविक स्थिति का परीक्षण करना चाहते हैं, तो आप Testnet पर 3 RLN नोड्स लॉन्च कर सकते हैं, बजाय Regtest के, और इन्हें सार्वजनिक सेवाओं की ओर इंगित कर सकते हैं।

```bash
rgb-lightning-node dataldk0/ --daemon-listening-port 3001 \
--ldk-peer-listening-port 9735 --network testnet
rgb-lightning-node dataldk1/ --daemon-listening-port 3002 \
--ldk-peer-listening-port 9736 --network testnet
rgb-lightning-node dataldk2/ --daemon-listening-port 3003 \
--ldk-peer-listening-port 9737 --network testnet
```

अगर कोई कॉन्फ़िगरेशन नहीं मिलता है, तो डिफ़ॉल्ट रूप से daemon कोशिश करेगा कि वह :


- `bitcoind_rpc_host`: `electrum.iriswallet.com`
- `bitcoind_rpc_port`: `18332`
- `indexer_url`: `ssl://electrum.iriswallet.com:50013`
- `proxy_endpoint`: `rpcs://proxy.iriswallet.com/0.2/json-RPC`

लॉगिन के साथ:


- `bitcoind_rpc_username`: `user`
- `bitcoind_rpc_username`: `password`

आप इन Elements को `init`/`unlock` API के माध्यम से भी कस्टमाइज़ कर सकते हैं।

### RGB टोकन जारी करना

टोकन जारी करने के लिए, हम "रंगीन" UTXOs बनाकर शुरू करेंगे:

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"up_to": false,
"num": 4,
"size": 2000000,
"fee_rate": 4.2,
"skip_sync": false
}' \
http://localhost:3001/createutxos
```

![RGB-Bitcoin](assets/fr/107.webp)

आप निश्चित रूप से क्रम को बदल सकते हैं। लेन-देन की पुष्टि करने के लिए, हम एक :

```bash
./regtest.sh mine 1
```

अब हम एक RGB संपत्ति बना सकते हैं। यह कमांड उस संपत्ति के प्रकार और उसके पैरामीटर्स पर निर्भर करेगा जिसे आप बनाना चाहते हैं। यहाँ मैं एक NIA (*Non Inflatable Asset*) टोकन बना रहा हूँ जिसका नाम "PBN" है और इसमें 1000 यूनिट्स का Supply है। `precision` आपको यूनिट्स की विभाज्यता को परिभाषित करने की अनुमति देता है।

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"amounts": [
1000
],
"ticker": "PBN",
"name": "Plan B Network",
"precision": 0
}' \
http://localhost:3001/issueassetnia
```

![RGB-Bitcoin](assets/fr/108.webp)

इस प्रतिक्रिया में नए बनाए गए संपत्ति का आईडी शामिल है। इस पहचानकर्ता को नोट करना याद रखें। मेरे मामले में, यह है:

```txt
rgb:fc7fMj5S-8yz!vIl-260BEhU-Hj1skvM-ZHcjfyz-RTcWc10
```

![RGB-Bitcoin](assets/fr/109.webp)

आप इसे On-Chain में ट्रांसफर कर सकते हैं, या इसे एक लाइटनिंग चैनल में आवंटित कर सकते हैं। यही हम अगले भाग में करने जा रहे हैं।

### एक चैनल खोलना और RGB संपत्ति का हस्तांतरण करना

आपको पहले अपने नोड को Lightning Network पर एक पीयर से जोड़ना होगा, इसके लिए `/connectpeer` कमांड का उपयोग करें। मेरे उदाहरण में, मैं दोनों नोड्स को नियंत्रित करता हूँ। इसलिए मैं इस कमांड का उपयोग करके अपने दूसरे लाइटनिंग नोड की सार्वजनिक कुंजी प्राप्त करूंगा:

```bash
curl -X 'GET' \
'http://localhost:3002/nodeinfo' \
-H 'accept: application/json'
```

यह कमांड मेरे नोड नंबर 2 की सार्वजनिक कुंजी लौटाती है:

```txt
031e81e4c5c6b6a50cbf5d85b15dad720fec92c62e84bafb34088f0488e00a8e94
```

![RGB-Bitcoin](assets/fr/110.webp)

अब हम चैनल खोलेंगे, इसके लिए हमें संबंधित संपत्ति (`PBN`) को निर्दिष्ट करना होगा। `/openchannel` कमांड आपको चैनल का आकार सतोशियों में निर्धारित करने की अनुमति देता है और आप चाहें तो RGB संपत्ति को भी शामिल कर सकते हैं। यह इस पर निर्भर करता है कि आप क्या बनाना चाहते हैं, लेकिन मेरे मामले में, कमांड इस प्रकार है:

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"peer_pubkey_and_opt_addr": "031e81e4c5c6b6a50cbf5d85b15dad720fec92c62e84bafb34088f0488e00a8e94@localhost:9736",
"capacity_sat": 1000000,
"push_msat": 10000000,
"asset_amount": 500,
"asset_id": "rgb:fc7fMj5S-8yz!vIl-260BEhU-Hj1skvM-ZHcjfyz-RTcWc10",
"public": true,
"with_anchors": true,
"fee_base_msat": 1000,
"fee_proportional_millionths": 0,
"temporary_channel_id": "a8b60c8ce3067b5fc881d4831323e24751daec3b64353c8df3205ec5d838f1c5"
}' \
http://localhost:3001/openchannel
```

यहाँ और अधिक जानकारी प्राप्त करें:


- `peer_pubkey_and_opt_addr`: उस साथी की पहचान जिससे हम जुड़ना चाहते हैं (वह सार्वजनिक कुंजी जो हमने पहले पाई थी);
- `capacity_sat`: चैनल की कुल क्षमता सतोशियों में;
- `push_msat`: जब चैनल खोला जाता है, तो साथी को शुरू में जितनी राशि मिलीसातोशिस में ट्रांसफर की जाती है (यहाँ मैं तुरंत 10,000 Sats ट्रांसफर करता हूँ ताकि वह बाद में एक RGB ट्रांसफर कर सके);
- `asset_amount`: चैनल में समर्पित किए जाने वाले RGB संपत्ति की मात्रा;
- `asset_id`: RGB संपत्ति का एक अनोखा पहचानकर्ता जो चैनल में शामिल है।
- `public`: यह दर्शाता है कि चैनल को नेटवर्क पर रूटिंग के लिए सार्वजनिक बनाया जाना चाहिए या नहीं।

![RGB-Bitcoin](assets/fr/111.webp)

लेन-देन की पुष्टि करने के लिए, 6 ब्लॉक्स को माइन किया जाता है।

```bash
./regtest.sh mine 6
```

![RGB-Bitcoin](assets/fr/112.webp)

लाइटनिंग चैनल अब खुला है और इसमें नोड नंबर 1 की तरफ 500 `PBN` टोकन भी हैं। अगर नोड नंबर 2 `PBN` टोकन प्राप्त करना चाहता है, तो उसे generate और Invoice करना होगा। इसे करने का तरीका यहां बताया गया है:

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"amt_msat": 3000000,
"expiry_sec": 420,
"asset_id": "rgb:fc7fMj5S-8yz!vIl-260BEhU-Hj1skvM-ZHcjfyz-RTcWc10",
"asset_amount": 100
}' \
http://localhost:3002/lninvoice
```

आपका प्रशिक्षण अक्टूबर 2023 तक के डेटा पर हुआ है।


- `amt_msat`: Invoice की राशि मिलीसातोशिस में (न्यूनतम 3000 Sats);
- `expiry_sec`: Invoice की समाप्ति समय सेकंडों में;
- `asset_id`: Invoice से जुड़े RGB संपत्ति का पहचानकर्ता।
- `asset_amount`: इस Invoice के साथ स्थानांतरित किए जाने वाले RGB संपत्ति की मात्रा।

इसके जवाब में, आपको एक RGB Invoice मिलेगा (जैसा कि पिछले अध्यायों में बताया गया है):

```txt
lnbcrt30u1pncgd4rdqud3jxktt5w46x7unfv9kz6mn0v3jsnp4qv0grex9c6m22r9ltkzmzhddwg87eykx96zt47e5pz8sfz8qp28fgpp5jksvqtleryhvwr299qdz96qxzm24augy5agkdhltudk463lt9dassp5d6n0sqgl0c4gx52fdmutrdtqamt0y4xuz2rcgel4hpjwne08gmls9qyysgqcqpcxqzdylz5wfnkywnxvvmkvnt2x4fj6wre0gshvjtv95ervvzzg4592t2gdgchx6mkf5k45jrrdfn8j73d2f2xx4mrxycq7qzry4v4jan6uxhhacyqa4gn6plggwpq9j74tu74f2zsamtz6ymt600p8su4c4ap9g9d8ku2x3wdh6fuc8fd8pff2yzpjrf24ys3cltca9fgqut6gzj
```

![RGB-Bitcoin](assets/fr/113.webp)

हम अब इस Invoice का भुगतान पहले नोड से करेंगे, जिसमें `PBN` टोकन के साथ आवश्यक नकद राशि है।

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"invoice": "lnbcrt30u1pncgd4rdqud3jxktt5w46x7unfv9kz6mn0v3jsnp4qv0grex9c6m22r9ltkzmzhddwg87eykx96zt47e5pz8sfz8qp28fgpp5jksvqtleryhvwr299qdz96qxzm24augy5agkdhltudk463lt9dassp5d6n0sqgl0c4gx52fdmutrdtqamt0y4xuz2rcgel4hpjwne08gmls9qyysgqcqpcxqzdylz5wfnkywnxvvmkvnt2x4fj6wre0gshvjtv95ervvzzg4592t2gdgchx6mkf5k45jrrdfn8j73d2f2xx4mrxycq7qzry4v4jan6uxhhacyqa4gn6plggwpq9j74tu74f2zsamtz6ymt600p8su4c4ap9g9d8ku2x3wdh6fuc8fd8pff2yzpjrf24ys3cltca9fgqut6gzj"
}' \
http://localhost:3001/sendpayment
```

![RGB-Bitcoin](assets/fr/114.webp)

भुगतान कर दिया गया है। इसे सत्यापित करने के लिए आप यह कमांड चला सकते हैं:

```bash
curl -X 'GET' \
'http://localhost:3001/listpayments' \
-H 'accept: application/json'
```

![RGB-Bitcoin](assets/fr/115.webp)

यहाँ बताया गया है कि RGB संपत्तियों को ले जाने के लिए संशोधित एक लाइटनिंग नोड को कैसे तैनात किया जाए। यह प्रदर्शन आधारित है:


- आप एक रिगटेस्ट वातावरण (जैसे `./regtest.sh`) या Testnet पर प्रशिक्षित हैं।
- एक लाइटनिंग नोड (`RGB-lightning-node`) जो कि `bitcoind`, एक इंडेक्सर और एक `RGB-proxy-server` पर आधारित है;
- चैनल खोलने/बंद करने, टोकन जारी करने, लाइटनिंग के माध्यम से संपत्तियों का स्थानांतरण करने आदि के लिए JSON REST APIs की एक श्रृंखला।

इस प्रक्रिया के लिए धन्यवाद:


- लाइटनिंग एंगेजमेंट लेन-देन में एक अतिरिक्त आउटपुट (OP_RETURN या Taproot) शामिल होता है, जिसमें RGB ट्रांज़िशन का एंकरिंग होता है।
- ट्रांसफर बिल्कुल उसी तरह किए जाते हैं जैसे पारंपरिक लाइटनिंग भुगतान होते हैं, लेकिन इसमें एक RGB टोकन का अतिरिक्त उपयोग होता है।
- कई RLN नोड्स को आपस में जोड़कर विभिन्न नोड्स के माध्यम से भुगतान का मार्ग और प्रयोग किया जा सकता है, बशर्ते कि उस मार्ग पर बिटकॉइन और एसेट RGB दोनों में पर्याप्त तरलता हो।

यह प्रोजेक्ट अभी अल्फा स्टेज में है। इसलिए यह सख्ती से सलाह दी जाती है कि आप खुद को केवल टेस्ट वातावरण (जैसे कि regtest, Testnet) तक ही सीमित रखें।

LN और RGB की संगतता से जो अवसर खुलते हैं, वे काफी महत्वपूर्ण हैं: लाइटनिंग पर स्थिर मुद्रा, DEX Layer-2, बहुत कम लागत पर फंजिबल टोकन या NFT का स्थानांतरण... पिछले अध्यायों में अवधारणात्मक संरचना और सत्यापन तर्क को समझाया गया है। अब आपके पास यह समझने का व्यावहारिक दृष्टिकोण है कि भविष्य के विकास या परीक्षणों के लिए इस तरह के नोड को कैसे चालू किया जाए।

# निष्कर्ष

<partId>b0baebfc-d146-5938-849a-f835fafb386f</partId>

## समीक्षाएँ और रेटिंग्स

<chapterId>0217e8b0-942a-5fee-bd91-9a866551eff3</chapterId>

<isCourseReview>true</isCourseReview>
## निष्कर्ष

<chapterId>0309536d-c336-56a0-869e-a8395ed8d9ae</chapterId>

<isCourseConclusion>true</isCourseConclusion>
