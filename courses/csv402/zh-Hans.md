---
name: 从理论到实践的 RGB 协议
goal: 掌握理解和使用 RGB 所需的技能
objectives: 

  - 了解 RGB 协议的基本概念
  - 掌握客户端验证和比特币承诺的原则
  - 了解如何创建、管理和转移 RGB 合同
  - 如何操作兼容 RGB 的 Lightning 节点

---
# 发现 RGB 协议

深入了解 RGB 的世界，这是一个基于比特币区块链的共识规则和操作，旨在以合约和资产的形式实施和执行数字权利的协议。从 "客户端验证 "和 "一次性封印 "的概念到高级智能合约的实施，本综合培训课程将指导您了解 RGB 的技术和实践基础。

通过结构化、循序渐进的程序，您将发现客户端验证机制、比特币上的确定性承诺以及用户之间的交互模式。学习如何在比特币或闪电网络上创建、管理和转移 RGB 代币。

无论您是开发人员、比特币爱好者，还是只是想更多地了解这项技术，本培训课程都将为您提供掌握 RGB 和在比特币上构建创新解决方案所需的工具和知识。

课程以 Fulgur'Ventures 组织的现场研讨会为基础，由三位知名教师和 RGB 专家授课。

+++
# 导言

<partId>c6f7a70f-d894-595f-8c0a-b54759778839</partId>

## 课程介绍

<chapterId>cf2f087b-6c6b-5037-8f98-94fc9f1d7f46</chapterId>

大家好，欢迎来到 RGB 培训课程，RGB 是运行在比特币和闪电网络上的客户端验证智能合约系统。本课程的结构设计旨在深入探讨这一复杂的主题。以下是课程的组织结构：

**第 1 部分：理论

第一部分是理解客户端验证和 RGB 基本原理所需的理论概念。在本课程中，您会发现 RGB 引入了许多在比特币中并不常见的技术概念。在本节中，您还会看到一个词汇表，为 RGB 协议的所有特定术语提供定义。

**第 2 部分：实践

第二部分将重点介绍第一部分中理论概念的应用。我们将学习如何创建和处理 RGB 合约。我们还将了解如何使用这些工具进行编程。前两部分由 Maxim Orlovsky 介绍。

**第 3 部分：应用

最后一部分由其他发言人介绍基于 RGB 的具体应用，以突出现实生活中的使用案例。

---
本培训课程最初源于 [Fulgur'Ventures](https://fulgur.ventures/) 在托斯卡纳 Viareggio 举办的为期两周的高级开发训练营。第一周的重点是 Rust 和 SDK，可在另一个课程中找到：

https://planb.network/courses/9fbd8b57-f278-4304-8d88-a2d384eaff58

在本课程中，我们将重点讲解新兵训练营的第二周内容，即 RGB。

**第 1 周 - LNP402:**

![RGB-Bitcoin](assets/fr/001.webp)

**第 2 周 - 当前培训 CSV402:**

![RGB-Bitcoin](assets/fr/002.webp)

非常感谢这些现场课程的组织者和参加课程的 3 位教师：


- 马克西姆-奥尔洛夫斯基 *Ex Tenebrae sententia sapiens dominabitur astris.赛弗、人工智能、机器人、超人类主义。RGB、Prime、Radiant 和 lnp_bp、mycitadel_io 和 cyphernet_io* 的创建者；
- 亨特-特鲁吉洛 *开发者、Rust、比特币、闪电、RGB* ；
- 费德里科-腾格 *我正在为把世界变成一个赛弗朋克的乌托邦尽自己的一份力量。目前正在 Bitfinex* 开发 RGB。

本培训课程的书面版本是利用两个主要资源起草的：


- Maxim Orlovsky、Hunter Trujilo 和 Frederico Tenga 在 Lightning Bootcamp 研讨会上的视频；
- RGB 文件由 [Bitfinex](https://www.bitfinex.com/) 赞助制作。

# 理论上的 RGB

<partId>80e797ee-3f33-599f-ab82-e82eeee08219</partId>

## 分布式计算概念简介

<chapterId>f52f8af5-5d7c-588b-b56d-99b97176204b</chapterId>

![video](https://youtu.be/AF2XbifPGXM)

RGB 协议是基于比特币区块链的共识规则和操作，以可扩展和保密的方式应用和执行数字权利（以合约和资产的形式）的协议。本章旨在介绍 RGB 协议的基本概念和术语，特别强调其与客户端验证和一次性封印等基本分布式计算概念的密切联系。

在本章中，我们将探讨**分布式共识系统**的基本原理，并了解 RGB 如何融入这一技术家族。我们还将介绍一些主要原则，这些原则有助于我们理解为什么 RGB 的目标是可扩展且独立于比特币自身的共识机制，同时在必要时依赖于它。

### 导言

分布式计算是计算机科学的一个特定分支，研究用于在节点网络上流通和处理信息的协议。这些节点和协议规则共同构成了所谓的分布式系统。分布式系统的基本特性包括 ：


- 每个节点对某些数据进行独立验证和确认的**能力；
- 节点可以（根据协议）构建完整或部分的信息视图。这些视图就是分布式系统的**状态；
- 操作的**时间顺序**，以便对数据进行可靠的时间标记，并就事件顺序（状态顺序）达成共识。

特别是，分布式系统中的**共识**概念包括两个方面：


- 识别状态变化的有效性**（根据协议规则）；
- 这些状态变化的顺序**一致，这使得无法事后重写或逆向验证操作（这在比特币中也被称为 "双重支出保护"）。

中本聪（Satoshi Nakamoto）通过比特币（Bitcoin）引入了第一个功能性、无权限的分布式共识机制，这要归功于区块链数据结构和工作证明（PoW）算法的结合使用。在这个系统中，区块历史的可信度取决于节点（矿工）的计算能力。因此，比特币是一个向所有人开放（*无权限*）的分布式共识系统的重要历史性范例。

在区块链和分布式计算领域，我们可以区分两种基本范式： *传统意义上的***区块链***和***状态通道***，其中最典型的例子是闪电网络。区块链被定义为按时间顺序排列的事件登记簿，在一个开放、无权限的网络中通过共识进行复制。另一方面，状态通道是点对点通道，使两个（或更多）参与者能够在链外保持更新状态，仅在打开和关闭这些通道时使用区块链。

就比特币而言，毫无疑问，您已经熟悉了区块链上的挖矿、去中心化和交易终结原则，以及支付渠道的工作原理。与区块链或闪电不同，RGB 包含本地（客户端）存储和验证智能合约的状态转换。这也有别于其他 "DeFi "技术（_rollups_、_plasma_、_ARK_等），因为客户端验证依赖于区块链来防止重复消费，并拥有一个时间戳系统，同时只对相关参与者保留链外状态和转换的注册信息。

![RGB-Bitcoin](assets/fr/003.webp)

稍后，我们还将介绍一个重要术语："**匿**"的概念，它指的是保存合约状态所需的客户端数据集，因为这些数据不会在全网范围内复制。最后，我们将介绍利用客户端验证的协议 RGB 背后的原理，以及它与现有方法（区块链和状态通道）相辅相成的原因。

### 分布式计算中的三难问题

要了解客户端验证和 RGB 如何解决区块链和闪电无法解决的问题，我们先来了解一下分布式计算中的三大 "难题"：


- 可扩展性、去中心化、隐私** ；
- CAP** 定理（一致性、可用性、分区容差） ；
- CIA** 三难（保密性、完整性和可用性）。

#### 1.可扩展性、分散性和保密性


- 区块链（比特币）**

区块链高度分散，但可扩展性不强。更重要的是，由于一切都在一个全球性的公共登记册中，保密性是有限的。我们可以尝试使用零知识技术（保密交易、mimblewimble 方案等）来提高保密性，但公有链无法隐藏交易图。


- 闪电/国家频道**

状态通道（如闪电网络）比区块链更具可扩展性和私密性，因为交易是在链外进行的。不过，公开宣布某些要素（资金交易、网络拓扑结构）的义务以及对网络流量的监控可能会部分损害保密性。去中心化也会受到影响：路由是现金密集型的，主要节点可能成为中心化点。这正是我们在闪电上开始看到的现象。


- 客户端验证（RGB）**

这种新模式的可扩展性更强，保密性更高，因为我们不仅可以整合零披露的知识证明技术，而且没有全局交易图谱，因为没有人掌握整个注册表。另一方面，这也意味着对去中心化的某种妥协：智能合约的发布者可以扮演中心角色（就像以太坊中的 "合约部署者"）。不过，与区块链不同的是，使用客户端验证（Client-side Validation），你只需存储和验证你感兴趣的合约，这就避免了下载和验证所有现有状态的需要，从而提高了可扩展性。

![RGB-Bitcoin](assets/fr/004.webp)

#### 2.CAP 定理（一致性、可用性、分区容差）

CAP 定理强调，分布式系统不可能同时满足一致性（*一致性*）、可用性（*可用性*）和分区容差（*分区容差*）。


- 区块链**

区块链倾向于一致性和可用性，但在网络分区方面做得不好：如果你看不到某个区块，你就无法采取行动，也无法获得与整个网络相同的视图。


- 闪电** （法语）

状态通道系统具有可用性和分区容错性（因为即使网络支离破碎，两个节点仍能保持相互连接），但整体一致性取决于区块链上通道的打开和关闭。


- 客户端验证（RGB）**

像 RGB 这样的系统可以提供一致性（每个参与者都在本地验证其数据，不会产生歧义）和分区容差（你可以自主保存数据），但不能保证全球可用性（每个人都必须确保自己拥有相关的历史片段，有些参与者可能不会发布任何信息或停止共享某些信息）。

![RGB-Bitcoin](assets/fr/005.webp)

#### 3.CIA 三难（保密性、完整性和可用性）

这个三难问题提醒我们，不能同时优化保密性、完整性和可用性。区块链、"闪电 "和客户端验证以不同方式实现了这一平衡。我们的想法是，没有一个系统能提供所有功能；有必要将几种方法（区块链的时间戳、闪电的同步方法以及使用 RGB 的本地验证）结合起来，以获得一个在每个维度上都能提供良好保证的连贯一揽子方案。

![RGB-Bitcoin](assets/fr/006.webp)

### 区块链的作用和分片概念

区块链（这里指比特币）主要是作为一种时间戳机制和防止重复消费的保护机制。我们不需要插入智能合约或去中心化系统的完整数据，而只需包含对交易的**加密承诺**（_commitments_）（在客户端验证的意义上，我们称之为 "状态转换"）。因此 ：


- 我们将区块链从大量数据和逻辑中解放出来；
- 每个用户只存储自己那部分合约（他的 "*碎片*"）所需的历史记录，而不是复制全局状态。

分片（Sharding）的概念起源于分布式数据库（如用于 Facebook 或 Twitter 等社交网络的 MySQL）。为了解决数据量和同步延迟的问题，数据库被分割成_碎片_（美国、欧洲、亚洲等）。每个分区都是本地一致的，只与其他分区部分同步。

对于 RGB 类型的智能合约，我们根据合约本身进行分片。每个合约都是一个独立的分区。例如，如果你只持有 USDT 代币，你就不必存储或验证另一种代币（如 USDC）的全部历史。在比特币上，区块链不做分片：你有一组全局的UTXO。通过客户端验证，每个参与者只保留其持有或使用的合约数据。

因此，我们可以把生态系统想象成这样：


- 区块链（比特币）** 作为基础，可确保最小登记册的完整复制，并作为时间戳层；
- 闪电网络**，用于快速、保密交易，仍以比特币区块链的安全性和最终结算为基础；
- RGB 和客户端验证**可添加更复杂的智能合约逻辑，而不会造成区块链混乱或失去保密性。

![RGB-Bitcoin](assets/fr/007.webp)

这三个元素构成了一个三角形的整体，而不是 "第 2 层"、"第 3 层 "等的线性堆叠。闪电 "可以直接连接比特币，也可以与包含 RGB 数据的比特币交易相关联。同样，"BiFi "用途（比特币上的金融）可以根据保密性、可扩展性或合约逻辑的需要与区块链、闪电和 RGB 组成。

![RGB-Bitcoin](assets/fr/008.webp)

### 状态转换的概念

在任何分布式系统中，验证机制的目的都是能够**确定状态变化的有效性和时间顺序。其目的是验证协议规则是否得到遵守，并证明这些状态变化是按照确定的、不可篡改的顺序相继发生的。

为了理解这种验证在**比特币**中是如何工作的，以及更广泛地说，为了掌握客户端验证背后的理念，让我们先回顾一下比特币区块链的机制，然后再看看客户端验证与它们有什么不同，以及它能带来哪些优化。

![RGB-Bitcoin](assets/fr/009.webp)

在比特币区块链中，交易验证基于一个简单的规则：


- 所有网络节点都会下载每个区块和交易；
- 它们验证这些交易，以核实 UTXO 集（所有未用输出）的正确演变；
- 它们（以数据块的形式）存储这些数据，以便在必要时重放历史数据。

![RGB-Bitcoin](assets/fr/010.webp)

然而，这种模式有两大缺点：


- 可扩展性**：由于每个节点都必须处理、验证和存档每个人的交易，因此交易容量有一个明显的限制，特别是与最大区块大小有关（比特币平均 10 分钟 1 MB，不包括 cookies）；
- 隐私**：所有内容（金额、目的地地址等）都是公开广播和存储的，这限制了交流的保密性。

![RGB-Bitcoin](assets/fr/012.webp)

在实践中，这种模式适用于作为基础层（第 1 层）的比特币，但对于同时需要高交易吞吐量和一定保密性的更复杂用途来说，这种模式可能就不够用了。

客户端验证基于相反的理念：每个参与者（客户端）只验证与自己相关的历史部分，而不是要求整个网络验证和存储所有交易：


- 当一个人收到资产（或任何其他数字财产）时，他只需要知道并验证导致该资产的操作链（状态转换），并证明其合法性；
- 这一连串的操作，从***创世***（初始发行）到最近的交易，构成了一个无循环有向图（DAG）或分片，即整个历史的一部分。

![RGB-Bitcoin](assets/fr/013.webp)

与此同时，为了使网络的其他部分（更准确地说，是底层，如比特币）能够锁定最终状态，而不看到这些数据的细节，客户端验证依赖于****承诺****的概念。

承诺*是一种加密承诺，通常是插入到比特币交易中的哈希值（例如 SHA-256），它可以证明私人数据已被包含在内，但不会泄露这些数据。

由于这些承诺，我们可以证明


- 信息的存在（因为信息被保存在哈希值中） ；
- 信息的前置性（因为它在区块链中被锚定并带有时间戳，有日期和区块顺序）。

不过，具体内容不会透露，因此可以保密。

以下是 RGB 状态转换的具体工作原理：


- 准备新的状态转换（例如 RGB 标记的转移）；
- 您可以生成对这一转变的加密承诺，并将其插入比特币交易中（这些承诺在 RGB 协议中被称为 "*锚"）；
- 交易方（接收方）检索与该资产相关的客户方历史记录，并验证端到端的一致性，从智能合约的创建到您向其传输的过渡。

![RGB-Bitcoin](assets/fr/014.webp)

客户端验证有两大优势：


- 可扩展性：**

区块链中包含的承诺（*承诺*）很小（大约几十个字节）。这确保了区块空间不会饱和，因为只需包含哈希值。由于每个用户只需存储自己的历史片段（他或她的_stash_），这也使得链外协议得以发展。


- 隐私：**

交易本身（即其详细内容）不会在链上公布。只有它们的指纹（*哈希*）才会被公布。因此，金额、地址和合约逻辑都是保密的，接收方可以通过检查之前的所有交易，在本地验证其分片的有效性。除非发生争议或需要证明，否则接收方没有理由公开这些数据。

在像 RGB 这样的系统中，来自不同合约（或不同资产）的多个状态转换可以通过单个_commitment_聚合到单个比特币交易中。这种机制在链上交易和链下数据（客户端验证的转换）之间建立了一个确定的、有时间戳的链接，并使多个分片能够同时记录在一个锚点中，从而进一步降低链上成本和占用空间。

实际上，当这种比特币交易被验证后，它就永久 "锁定 "了底层合约的状态，因为不可能修改已经刻在区块链上的哈希值。

![RGB-Bitcoin](assets/fr/015.webp)

### 储藏概念

储藏库**是参与者为维护 RGB 智能合约的完整性和历史记录而必须绝对保留的一组客户端数据。与闪电通道不同，在闪电通道中，某些状态可以在本地从共享信息中重建，而 RGB 合约的储藏库不会复制到其他地方：如果您丢失了它，没有人能够将其恢复给您，因为您要对自己的历史份额负责。因此，您需要在 RGB 中采用具有可靠备份程序的系统。

![RGB-Bitcoin](assets/fr/016.webp)

### 一次性使用密封件：起源与运作

在接受货币等资产时，有两项保证必不可少：


- 收到物品的真实性；
- 所收物品的唯一性，以避免重复支出。

对于钞票等实物资产来说，实物的存在足以证明它没有被复制。然而，在数字世界中，资产纯粹是信息资产，这种验证更为复杂，因为信息很容易被复制和倍增。

正如我们前面所看到的，发送方对状态转换历史的揭示使我们能够确保 RGB 令牌的真实性。通过访问自创始交易以来的所有交易，我们可以确认代币的真实性。这一原理与比特币类似，比特币的历史可以追溯到最初的 coinbase 交易，以验证其有效性。但与比特币不同的是，RGB 中的状态转换历史是私有的，保存在客户端。

为防止重复使用 RGB 令牌，我们使用了一种名为 "**一次性封印**"的机制。该系统可确保每个令牌一旦使用过，就无法再次欺诈性地重复使用。

一次性封印是彼得-托德（Peter Todd）于 2016 年提出的密码基元，类似于物理封印的概念：一旦在容器上贴上封印，如果不不可逆地破坏封印，就无法打开或修改容器。

![RGB-Bitcoin](assets/fr/018.webp)

将这种方法移植到数字世界中，就可以证明一系列事件确实已经发生，而且事后再也无法更改。因此，一次性封印超越了 "哈希+时间戳 "的简单逻辑，增加了只能封印***一次的封印概念。

![RGB-Bitcoin](assets/fr/017.webp)

要让一次性印章发挥作用，你需要一个能够证明出版物存在或不存在的出版物证明媒介，而且一旦信息传播出去，就很难伪造（如果不是不可能的话）。区块链**（如比特币）就能起到这样的作用，比如一份公开发行的纸质报纸。这个想法如下：


- 我们希望证明，在不泄露信息内容的情况下，信息 `h(m)` 的某项承诺已向受众公布；
- 我们要证明的是，没有其他竞争性的 "h(m') "信息承诺被发布，以取代 "h(m)"；
- 我们还希望能够检查信息 `m` 是否在某个日期之前存在。

区块链非常适合扮演这一角色：只要交易被包含在一个区块中，整个网络就会对其存在和内容拥有相同的不可篡改的证明（至少部分证明，因为_承诺_可以隐藏细节，同时证明信息的真实性）。

因此，"一次性使用印章 "可被视为一种正式承诺，即以一种可由所有相关方验证的方式，一次性且仅一次性地发布一条信息（现阶段仍是未知信息）。

与证明存在日期的简单_commitments_（哈希值）或时间戳不同，一次性封印提供了额外的保证，即**没有替代承诺**可以共存：你不能关闭同一个封印两次，或试图替换被封印的信息。

下面的比较有助于理解这一原则：


- 加密承诺（散列）**：使用散列函数，您可以通过公布散列值来承诺某个数据（一个数字）。在公布预映像之前，数据仍然是保密的，但你可以证明你事先知道它；
- 时间戳（区块链）**：通过在区块链中插入该散列值，我们也证明了我们在某一精确时刻（即包含在区块中的时刻）知道该散列值；
- 一次性密封件**：有了一次性封印，我们就能更进一步，使承诺变得独一无二。使用单个哈希值，你可以同时创建多个相互矛盾的承诺（医生向家人宣布 "*是个男孩*"，却在个人日记中写道 "*是个女孩*"的问题）。一次性封印消除了这种可能性，它将承诺与比特币区块链等公示证明媒介相连接，这样，UTXO 的支出就明确地封印了承诺。相同的UTXO一旦花费，就不能再次花费以取代承诺。

一次性密封件 | 时间戳 | 简单承诺（摘要/哈希值） | 一次性密封件 | 简单承诺（摘要/哈希值） | 一次性密封件 | 一次性密封件

| -------------------------------------------------------------------------------- | ------------------------------- | ---------- | ---------------- |

| 公布承诺不会泄露信息 | 是 | 是 | 是 | 是

| 不可能 | 可能 | 可能 | 可能

| 不可能 | 可能 | 证明不可能存在其他替代承诺

一次性使用密封件的工作主要分为三个阶段：

**密封定义：**


- 爱丽丝事先定义了印章的发布规则（何时、何地以及如何发布信息）；
- 鲍勃接受或承认这些条件。

![RGB-Bitcoin](assets/fr/021.webp)

**Seal Closing :**


- 在运行时，Alice 通过发布实际信息（通常是_commitment_形式，例如哈希值）来关闭封印；
- 它还提供了**证人**（密码证明），证明印章是封闭的、不可撤销的。

![RGB-Bitcoin](assets/fr/019.webp)

**密封验证：**


- 一旦封条关闭，鲍勃就无法再打开它：他只能检查封条是否已经关闭；
- 鲍勃收集印章、**见证人**和信息（或他的承诺），以确保一切相符，没有相互竞争的印章或不同的版本。

这一过程可概括如下

```txt
# Défini par Alice, validé ou accepté par Bob
seal <- Define()
# Fermeture du sceau par Alice avec le message
witness <- Close(seal, message)
# Vérification par Bob
bool <- Verify(seal, witness, message)
```

客户端验证则更进一步：如果印章本身的定义仍在区块链之外，那么（理论上）有人就有可能质疑相关印章的存在性或合法性。为了解决这个问题，我们使用了连锁的一次性印章链：


- 每个封闭的印章都包含以下印章的定义；
- 我们在区块链（比特币交易）中注册这些闭包（及其_承诺）；
- 因此，任何修改先前封印的尝试都会与比特币中蕴含的历史相矛盾。

这正是 RGB 系统的作用：


- 发布的信息是对客户端验证数据的_承诺_；
- 封印定义与比特币 UTXO 相关联；
- 当该UTXO 用完或新的输出记入同一承付款时，封印关闭；
- 花费这些 UTXO 的交易链与发布证明相对应：因此，RGB 上的每一次过渡或状态变化都锚定在比特币上。

总而言之


- 密封定义_是您打算密封未来承诺的UTXO；
- 当您花费这笔UTXO，创建一个包含承诺的交易时，_seal closing_就发生了；
- 见证人_是交易本身，它证明您已用此内容盖上印章；
- 你无法证明封印没有被关闭（你无法绝对确定UTXO 没有被花掉或不会被花掉在你还没有看到的区块中），但你可以证明它确实被关闭了。

这种唯一性对于客户端验证非常重要：当你验证一个状态转换时，你需要检查它是否对应于一个唯一的UTXO，而这个UTXO在之前的竞争承诺中没有使用过。这就保证了链外智能合约中没有重复消费。

### 多重承诺和根基

一个 RGB 智能合约可能需要同时使用多个一次性封印（多个 UTXO）。更重要的是，一个比特币交易可能会引用多个不同的合约，每个合约都会封印自己的状态转换。这就需要一个**多承诺**机制，以确定性和唯一性地证明没有一个承诺是重复的。这就是 RGB 中**锚**概念的由来：一种连接比特币交易和一个或多个客户端承诺（状态转换）的特殊结构，每个承诺都可能属于不同的合约。我们将在下一章仔细研究这个概念。

![RGB-Bitcoin](assets/fr/023.webp)

该项目的两个主要 GitHub 资源库（隶属于 LNPBP 组织）汇集了第一章中研究的这些概念的基本实现：


- 客户端验证** ：包含用于本地验证的 Rust 基元；
- single_use_seals**：实现安全定义和关闭这些封印的逻辑。

![RGB-Bitcoin](assets/fr/020.webp)

请注意，这些软件砖块与比特币无关；理论上，它们可以应用于任何其他出版证明媒介（其他注册机构、期刊等）。在实践中，RGB 依赖于比特币的稳健性和广泛共识。

![RGB-Bitcoin](assets/fr/021.webp)

### 公众提问

#### 争取更广泛地使用一次性密封件

彼得-托德（Peter Todd）还创建了_Open Timestamps_协议，而一次性印章（Single-use Seal）概念正是这些理念的自然延伸。除了 RGB 之外，我们还可以设想其他用例，例如在不使用合并挖矿的情况下构建侧链（_sidechains_），或与驱动链相关的建议（如 BIP300）。原则上，任何需要单一承诺的系统都可以利用这种加密原语。如今，RGB 已成为第一个大规模全面实施的系统。

#### 数据可用性问题

由于在客户端验证中，每个用户都会存储自己的部分历史记录，因此无法在全球范围内保证数据的可用性。如果合约发行者隐瞒或撤销某些信息，您可能不知道报价的实际变化情况。在某些情况下（如稳定币），发行者需要维护公共数据以证明流通量，但技术上并没有这样做的义务。因此，有可能设计出故意不透明、无限供应的合约，这就产生了信任问题。

#### 分片和合同隔离

每个合约代表一个独立的_shard_：例如，USDT 和 USDC 不必共享它们的历史记录。原子交换仍然是可能的，但这并不涉及合并它们的寄存器。一切都通过加密承诺完成，无需向每个参与者披露整个历史图谱。

### 结论

我们已经看到了客户端验证的概念与区块链和状态通道的契合点，它如何应对分布式计算的三难问题，以及它如何利用比特币区块链的独特性来避免重复消费和*时间戳*。这个想法基于 "一次性封印"（**Single-use Seal**）的概念，可以创建无法随意重复消费的唯一承诺。通过这种方式，每个参与者只上传绝对必要的历史记录，提高了智能合约的可扩展性和保密性，同时保留了比特币作为背景的安全性。

下一步，我们将更详细地解释如何在比特币中应用这种一次性封印机制（通过 UTXOs），如何创建和验证锚，以及如何在 RGB 中构建完整的智能合约。我们将特别探讨多重承诺的问题，即如何证明比特币交易同时封印不同合约中的多个状态转换，而不会引入漏洞或双重承诺的技术难题。

在深入探讨第二章的技术细节之前，请先重读一下关键定义（客户端验证、一次性印章、锚等），并牢记整体逻辑：我们希望将比特币区块链的优势（安全性、去中心化、时间戳）与链外解决方案的优势（速度、保密性、可扩展性）相协调，而这正是 RGB 和客户端验证所要实现的目标。

## 承诺层

<chapterId>cc2fe85a-9cc7-5b8c-a00a-c0a867241061</chapterId>

![video](https://youtu.be/FS6PDprWl5Q)

在本章中，我们将探讨客户端验证和一次性封印在比特币区块链中的实现。我们将介绍 RGB 的**承诺层**（第 1 层）的主要原理，并特别关注**TxO2**方案，RGB 使用该方案来定义和关闭比特币交易中的封印。接下来，我们将讨论两个尚未详细介绍的要点：


- 确定性比特币承诺_；
- 多协议承诺。

正是这些概念的结合，使我们能够在单个 UTXO 上叠加多个系统或合约，从而形成单个区块链。

需要提醒的是，所述加密操作绝对适用于其他区块链或出版媒体，但比特币的特点（去中心化、抵制审查和对所有人开放）使其成为开发高级可编程性（如**RGB**所需的可编程性）的理想基础。

### 比特币中的承诺方案及其在 RGB 中的应用

正如我们在课程第一章中所看到的，一次性封印是一个一般概念：我们承诺在交易的特定位置包含一个承诺（_commitment_），这个位置就像我们在信息上盖上的一个封印。然而，在比特币区块链上，有几种选择可以用来选择在哪里放置这个_commitment_。

为了理解其中的逻辑，让我们回顾一下基本原理：要关闭一个_单次使用的封印_，我们需要通过在给定的消息上插入_承诺_来花费封印区域。在比特币中，这可以通过多种方式实现：


- 使用公钥或地址**

我们可以确定某个特定的公钥或地址是_一次性封印_。只要这个密钥或地址出现在交易链上，就意味着封印已通过特定信息关闭。


- 使用比特币**交易输出

这意味着，一个_单次使用的封条_被定义为一个精确的_输出点_（一个 TXID + 输出编号对）。一旦这个_输出点_用完，封印就会关闭。

在开发 RGB 的过程中，我们发现至少有 4 种不同的方法可以在比特币上实现这些封印：


- 通过公钥定义封印，并在 _output_ 中关闭封印；
- 用_outpoint_定义封印，用_output_关闭封印；
- 
- 通过_outpoint_定义封印，并在_input_中关闭封印。

| 印章定义 | 印章封口 | 其他要求 | 主要应用 | 可能的参与计划

| ------------- | ------------------------- | --------------------- | ----------------------------------------------------------------- | ---------------------------- | ------------------------------ |

| P2(W)PKH | 目前无 | Keytweak, taptweak, opret | P2(W)PKH | 目前无

| TxO2 | 交易输出 | 交易输出 | 需要比特币上的确定性承诺 | RGBv1（通用） | Keytweak, tapret, opret | RGBv1（通用

| PkI | 公钥值 | 交易条目 | 仅适用于 Taproot，与传统钱包不兼容 | 基于比特币的身份 | Sigtweak, witweak | 基于比特币的身份

| TxO1 | 交易输出 | 交易输入 | 仅适用于 Taproot，与传统钱包不兼容 | 目前无 | Sigtweak, witweak | Sigtweak, witweak | TxO1

我们不会详细介绍每种配置，因为在 RGB 中，我们选择使用**个_输出点_作为封**的定义，并将_提交_置于花费该_输出点_的事务输出中。因此，我们可以在续集中引入以下概念：


- "密封定义 "** ：给定的_输出点（通过 TXID + 输出编号标识） ；
- "密封关闭 "**：花费此_出点_的事务，其中_提交_被添加到报文中。

选择这种方案是为了与 RGB 架构兼容，但其他配置也可用于不同用途。

TxO2 "中的 "O2 "提醒我们，定义和关闭都是基于交易输出的支出（或创建）。

### TxO2 图表示例

需要提醒的是，定义_单次使用封印_并不一定需要发布链上交易。例如，爱丽丝已经有了一个未使用的UTXO，这就足够了。她可以决定"这个_输出点_（已经存在）现在是我的印章"。她会在本地（_客户端_）记录这一点，直到这个 UTXO 被用完，封印才会被认为是开放的。

![RGB-Bitcoin](assets/fr/024.webp)

在它要关闭封印（发出事件信号或锚定特定报文）的那一天，它会在一个新事务中花费这个 UTXO（这个事务通常被称为"_见证事务_"（与_segwit_无关，只是我们给它的术语））。这个新事务将包含对消息的_commitment_。

![RGB-Bitcoin](assets/fr/025.webp)

请注意，在本例中 ：


- 除了鲍勃（或爱丽丝选择向其透露完整证明的人），没有人会知道这笔交易中隐藏了某个信息；
- 每个人都能看到_outpoint_已被花费，但只有鲍勃掌握着信息实际锚定在交易中的证明。

为了说明这种 TxO2 方案，我们可以使用_单次使用印章_作为撤销 PGP 密钥的机制。爱丽丝可以说："这个比特币输出，如果花掉了，就意味着我的 PGP 密钥被废止了"如果使用了这个比特币输出，就意味着我的 PGP 密钥被废止了"。

因此，Alice 拥有一个特定的 UTXO，在本地（客户端）与之关联的是特定的状态或数据（只有她自己知道）。

爱丽丝告诉鲍勃，如果花掉这笔UTXO，就会认为发生了一个特定事件。从外表上看，我们看到的只是一笔比特币交易；但鲍勃知道，这笔支出有其隐含的意义。

![RGB-Bitcoin](assets/fr/026.webp)

当 Alice 使用完这个 UTXO 时，她就会在一条信息上盖章，表明她的新密钥，或者只是撤销了旧密钥。这样，链上的任何监控人员都能看到 UTXO 已用完，但只有拥有完整证明的人才能知道这正是 PGP 密钥的撤销。

![RGB-Bitcoin](assets/fr/027.webp)

为了让鲍勃或其他相关人员检查隐藏信息，爱丽丝必须向他提供链外信息。

![RGB-Bitcoin](assets/fr/028.webp)

因此，爱丽丝必须向鲍勃提供 ：


- 信息本身（例如新的 PGP 密钥） ；
- 该信息参与交易的加密证明（称为 "额外交易证明 "或 "锚"）。

![RGB-Bitcoin](assets/fr/029.webp)

第三方没有这些信息。他们只能看到 UTXO 已被使用。因此，保密性得到了保证。

为了明确结构，让我们用两个事务来概括整个过程：


- 事务 1**：其中包含_封印定义_，即用作封印的_输出点_。

![RGB-Bitcoin](assets/fr/031.webp)


- 交易 2**：使用该_输出点。这将关闭封印，并在同一事务中为报文插入_commitment_。

![RGB-Bitcoin](assets/fr/033.webp)

因此，我们称第二笔交易为"_见证交易"。

为了从另一个角度说明这一点，我们可以用两层来表示：


- 顶层（区块链，公开）**：每个人都能看到交易，并知道_输出点_已被花费；
- 下层（客户端，私有）**：只有爱丽丝（或相关人员）通过加密证明和她保存在本地的信息，知道这笔费用与这样那样的信息相对应。

![RGB-Bitcoin](assets/fr/034.webp)



在上一节中，我们简要提到了客户端验证模型如何应用于 RGB 和其他系统。在这里，我们将讨论关于**确定性比特币承诺**的部分，以及如何将它们整合到交易中。我们的想法是理解为什么我们要在见证交易中插入一个单一的承诺，最重要的是如何确保不会有其他未披露的竞争承诺。

### 交易中的承诺位置

当你向别人证明某条信息被嵌入到事务中时，你需要能够保证在同一事务中没有另一种形式的承诺（第二条隐藏信息）没有被泄露给你。为了使客户端验证保持稳健，你需要一种**确定的**机制，在事务中放置一个单一的_承诺_，以关闭_单次使用的封印_。

见证交易花费了著名的UTXO（或_封印定义_），这一花费与封印的关闭相对应。从技术上讲，我们知道每个外点只能花费一次。这正是比特币抵制重复消费的基础。但是，消费交易可能有几个输入、几个输出，或者以复杂的方式组成（币币连接、闪电通道等）。因此，我们需要明确、统一地定义在这个结构中插入_commitment_的位置。

无论采用哪种方法（PkO、TxO2 等），都可以插入_commitment_____________________________________：


- 
    - Sigtweak** （修改 ECDSA 签名的 `r` 部分，类似于 "从签名到合同 "原则） ；
    - 弱**（交易的_隔离见证数据被修改）。
- 
    - 密钥调整**（收件人的公开密钥与信息一起 "调整"） ；
    - Opret**（信息被置于非消耗性输出`OP_RETURN`中）；
    - Tapret**（或 _Taptweak_），它依靠 taproot 将承诺插入到 taproot 密钥的脚本部分，从而对公钥进行确定性修改。

![RGB-Bitcoin](assets/fr/035.webp)

以下是每种方法的详细信息：

![RGB-Bitcoin](assets/fr/038.webp)

*** 签名调整（签约到合同）：***

早期的方案是利用签名（ECDSA 或 Schnorr）的随机部分来嵌入_承诺_：这就是所谓的 "**签约**"技术。用包含数据的哈希值替换随机生成的非ce。这样，签名就隐含地显示了你的承诺，而不需要在事务中增加任何额外的空间。这种方法有很多优点：


- 无链上重载（使用与基本 nonce 相同的位置）；
- 从理论上讲，这可以是非常离散的，因为 nonce 最初是一个随机数据。

不过，也出现了两大弊端：


- Taproot 前的 Multisig：当您有多个签名者时，您需要决定由哪个签名来携带_commitment_。签名的顺序可以不同，如果某个签名者拒绝签名，你就失去了对_commitment_结果的控制；
- MuSig 和共享 nonce：使用 Schnorr multisig (*MuSig*)，nonce 生成是一种多方算法，几乎不可能单独调整 nonce。

实际上，**sig tweak**与现有的硬件（硬件钱包）和格式（闪电等）也不太兼容。因此，这个伟大的想法很难付诸实践。

***主要调整（按合同付费）：***

密钥调整**采用了 "按合同支付 "的历史概念。我们使用公开密钥 `X`，并通过添加值 `H(信息)`对其进行调整。具体来说，如果 `X = x * G` 和 `h = H(信息)`，那么新的密钥就是 `X' = X + h * G`。这个经过调整的密钥隐藏了对 "信息 "的承诺。原始私钥的持有者可以通过在其私钥 "x "上添加 "h "来证明他拥有花费输出的密钥。从理论上讲，这是非常优雅的，因为：


- 输入_commitment_（承诺）时无需添加任何其他字段；
- 您无需存储任何额外的链上数据。

但在实践中，我们会遇到以下困难：


- 钱包不再识别标准公钥，因为它已被 "调整 "过，所以钱包无法轻易将UTXO 与你的普通密钥联系起来；
- 硬件钱包在设计上不能使用非标准派生密钥进行签名；
- 您需要调整脚本、描述符等。

就 RGB 而言，这条道路曾设想到 2021 年，但事实证明过于复杂，无法在现有标准和基础设施的条件下实现。

***见证调整：***

另一种想法是将数据直接放在事务的 "见证 "部分（因此有 "见证调整 "的说法），某些协议（如_inscriptions Ordinals_）已将这种想法付诸实践。然而，这种方法 ：


- 让参与立即可见（你只需将原始数据粘贴到见证器中）；
- 可能会受到审查（矿工或节点可能会拒绝转发过大或其他任意特征的信息）；
- 占用色块空间，违背了 RGB 自由、轻巧的目标。

此外，见证的设计在某些情况下是可剪枝的，这可能会使稳健证明变得更加复杂。

***开放式返回（opret）：***

操作非常简单，"OP_RETURN "允许在事务的一个特殊字段中存储哈希值或消息。但它会立即被发现：每个人都能看到事务中有一个_commitment_，它可以被审查或丢弃，也可以增加额外的输出。由于这增加了透明度和体积，因此从客户端验证解决方案的角度来看，它并不令人满意。

```txt
34-byte_Opret_Commitment =
OP_RETURN   OP_PUSHBYTE_32   <mpc::Commitment>
|_________| |______________| |_________________|
1-byte       1-byte         32 bytes
```

### 塔布莱特

最后一种方案是使用**Taproot**（在 BIP341 中引入）和*Tapret*方案。 *Tapret* 是一种更复杂的确定性承诺形式，在区块链上的足迹和合约操作的保密性方面都有改进。其主要思想是将承诺隐藏在[taproot 交易](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)的 "脚本路径花费 "部分。

![RGB-Bitcoin](assets/fr/036.webp)

在介绍如何将承诺插入分根事务之前，我们先来看看承诺的**精确形式**，它必须**相对**对应于一个 64 字节的字符串[构造](https://github.com/BP-WG/bp-core/blob/master/dbc/src/tapret/mod.rs#L179-L196)，如下所示：

```txt
64-byte_Tapret_Commitment =
OP_RESERVED ...  ... .. OP_RESERVED   OP_RETURN   OP_PUSHBYTE_33  <mpc::Commitment>  <Nonce>
|___________________________________| |_________| |______________| |_______________|  |______|
OP_RESERVED x 29 times = 29 bytes      1 byte         1 byte          32 bytes        1 byte
|________________________________________________________________| |_________________________|
TAPRET_SCRIPT_COMMITMENT_PREFIX = 31 bytes                    MPC commitment + NONCE = 33 bytes
```


- 29 个字节的 `OP_RESERVED`, 接着是 `OP_RETURN`, 然后是 `OP_PUSHBYTE_33`, 构成了 31 个字节的 _prefix_ 部分；
- 接下来是一个 32 字节的_commitment_（通常是来自 **MPC** 的 Merkle 根），我们在其中添加 1 字节的 **Nonce**（第二部分共 33 字节）。

因此，64 字节的 "Tapret "方法看起来就像一个 "Opret"，我们在其中添加了 29 个字节的 "OP_RESERVED "前缀，并额外添加了一个字节作为 Nonce。

为了在实施、保密和扩展方面保持灵活性，Tapret 方案根据不同的要求考虑了各种使用情况：


- 独特地将 Tapret 承诺纳入分根交易，而无需预先存在脚本路径结构；
- 将 Tapret 承诺整合到已配备脚本路径的 Taproot 交易中。

让我们来仔细看看这两种情况。

#### 没有现有脚本路径的 Tapret 合并

在第一种情况下，我们从自根输出密钥 (*Taproot Output Key*) `Q` 开始，它只包含内部公钥 `P` *(Internal Key*)，没有相关的脚本路径 (*Script Path*) ：

![RGB-Bitcoin](assets/fr/047.webp)


- P"：_Key Path Spend_ 的内部公开密钥。
- G：椭圆曲线 [secp256k1](https://en.bitcoin.it/wiki/Secp256k1) 的生成点。
- t = tH_TWEAK(P)`是调整因子，根据[BIP86](https://github.com/bitcoin/bips/blob/master/bip-0086.mediawiki#address-derivation)通过_标记哈希_（例如`SHA-256(SHA-256(TapTweak) || P)`）计算得出。这证明不存在隐藏脚本。

若要包含**Tapret**承诺，请添加**脚本路径花费**和**唯一脚本**，如下所示：

![RGB-Bitcoin](assets/fr/048.webp)


- t = tH_TWEAK(P || Script_root)`就会成为新的调整因子，包括 **Script_root** 。
- `Script_root = tH_BRANCH(64-byte_Tapret_Commitment)`表示该**脚本的根，它只是一个类型为 `SHA-256(SHA-256(TapBranch) || 64-byte_Tapret_Commitment)` 的哈希值。

直根树中包含性和唯一性的证明可归结为单一内部公开密钥 `P`。

#### 将 Tapret 集成到已有的脚本路径中

第二种情况涉及更复杂的 `Q` taproot** 输出，其中已包含多个脚本。例如，我们有一棵包含 3 个脚本的树：

![RGB-Bitcoin](assets/fr/049.webp)


- tH_LEAF(x)` 表示叶子脚本的归一化标记哈希函数。
- a、B、C` 表示已包含在分根结构中的脚本。

要添加 Tapret 承诺，我们需要在树的第一层插入一个*不可消耗脚本*，将现有脚本向下移动一层。从视觉上看，这棵树变成了.NET 树：

![RGB-Bitcoin](assets/fr/050.webp)


- tHABC` 表示顶层分组 "A、B、C "的标记哈希值。
- tHT` 表示与 64 字节的`Tapret`相对应的脚本哈希值。

根据直根规则，每个分支/叶必须按照词典散列顺序进行组合。有两种可能的情况：


- tHT`>`tHABC`：Tapret 承诺移动到树的右边。唯一性证明只需要 `tHABC` 和 `P` ；
- tHT` < `tHABC`**：Tapret 承诺放在左边。为了证明右边没有其他的 Tapret 承诺，必须揭示 `tHAB` 和 `tHC` 以证明没有其他这样的脚本。

第一种情况（`tHABC < tHT`）的可视化示例：

![RGB-Bitcoin](assets/fr/051.webp)

第二种情况的示例（`tHABC > tHT`）：

![RGB-Bitcoin](assets/fr/052.webp)

#### 使用非证书进行优化

为了提高保密性，我们可以 "挖掘"（更准确的说法是 "暴力破解"）"<Nonce>"（64 字节 "Tapret "的最后一个字节）的值，试图获得哈希值 "tHT"，即 "tHABC < tHT"。在这种情况下，承诺被置于右侧，用户无需泄露现有脚本的全部内容来证明 Tapret 的唯一性。

总之，"Tapret "提供了一种将承诺纳入自根交易的离散且确定的方式，同时尊重对 RGB 客户端验证和一次性印章逻辑至关重要的唯一性和明确性要求。

#### 有效出口

对于 RGB 承诺交易，有效的比特币承诺方案的主要要求如下：交易（*见证交易*）必须能证明包含一个单一的承诺。这一要求使得在同一笔交易中无法为客户端验证数据构建替代历史。这就意味着_单次使用封印_关闭的信息是唯一的。

为满足这一原则，无论事务中有多少个输出，我们都要求**个且仅有一个输出**能包含一个承诺（*commitment*）。对于所使用的每种方案（*Opret* 或 *Tapret*），能包含 RGB 承诺的唯一有效输出是 ：


- *Opret* 方案的第一个输出 `OP_RETURN`（如果存在）；
- *Tapret* 方案的第一个分根输出（如果存在）。

请注意，一个事务完全有可能在两个不同的输出中包含一个 "Opret "承诺和一个 "Tapret "承诺。由于 Seal Definition 的确定性，这两个承诺对应于客户端验证的两个不同的数据块。

### RGB 的分析和实用选择

启动 RGB 时，我们审查了所有这些方法，以确定在何处以及如何以确定的方式在事务中放置_commitment_。我们定义了一些标准：


- 兼容不同的应用场景（如多重签名、闪电、硬件钱包等）；
- 对链上空间的影响 ；
- 实施和维护的难度 ；
- 保密和抵制审查。

| 跟踪和链上选型 | 客户端选型 | 投资组合集成 | 硬件兼容性 | Lightning 兼容性 | Taproot 兼容性 | 硬件集成

| --------------------------------------------------- | ------------------------ | ------------------ | ----------------------------- | ------------------------ | ----------------------- | --------------------- |

| Keytweak (deterministic P2C) | 🟢 | 🟡 | 🔴 | 🟠 | 🔴 BOLT, 🔴 Bifrost | 🟠 Taproot, 🟢 MuSig

| Sigtweak（确定性 S2C） | 🟢 | 🟠 | 🔴 | 🔴 BOLT、 🔴 Bifrost | 🟠 Taproot、 🔴 MuSig | 🟠 Taproot

| Opret (OP_RETURN) | | 🔴 | 🟢 | 🟢 | 🟠 | 🔴 BOLT, 🟠 Bifrost | - |

| Tapret 算法：左上角节点 | | 🟠 | 🔴 | 🟠 | 🟢 | 🔴 BOLT、 🟢 Bifrost | 🟢 Taproot、 🟢 MuSig | 🟢 Taproot

| Tapret 算法 #4：任意节点 + 证明 | 🟢 | 🟠 | 🟢 | 🔴 BOLT、 🟢 Bifrost | 🟢 Taproot、 🟢 MuSig | 🟢 Taproot、 🟢 MuSig

| 确定性承诺方案 | 标准 | 链上成本 | 客户端证据的大小

| ------------------------------------------------------------- | -------------- | ----------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------ |

| 密钥调整（确定性 P2C） | LNPBP-1，2 | 0 字节 | 33 字节（未调整密钥） | LNPBP-1, 2 | 0 字节

| Sigtweak（确定性 S2C） | WIP（LNPBP-39） | 0 字节 | 0 字节 | 0 字节

| Opret (OP_RETURN) | - | 36 (v)bytes (TxOut additional) | 0 bytes |

| Tapret 算法：左上角节点 | LNPBP-6 | 在任何 n-of-m 多位元组上的见证字节数为 32 字节（8 vbytes），每个脚本路径花费 | 在无分根脚本的脚本上为 0 字节 ~ 在单个脚本的情况下为 270 字节，在多个脚本的情况下为 ~128 字节 | | Tapret 算法：左上角节点

Tapret 算法 #4：任意节点 + 唯一性证明 | LNPBP-6 | 单脚本情况下，见证符为 32 字节（8 vbytes），其他大多数情况下，见证符为 0 字节 | 无分根脚本时为 0 字节，Taptree 有十几个脚本时才为 65 字节 | Tapret 算法 #5：任意节点 + 唯一性证明 | LNPBP-6 | 单脚本情况下，见证符为 32 字节（8 vbytes），其他大多数情况下，见证符为 0 字节

层 | 链上成本（字节/字节） | 链上成本（字节/字节） | 链上成本（字节/字节） | 链上成本（字节/字节） | 链上成本（字节/字节） | 客户端成本（字节） | 客户端成本（字节） | 客户端成本（字节） | 客户端成本（字节） | 客户端成本（字节） | 客户端成本（字节） | 客户端成本（字节） | 客户端成本（字节） | 客户端成本（字节） | 客户端成本（字节

| ------------------------------ | ---------------------------- | ---------------------------- | ---------------------------- | ---------------------------- | ---------------------------- | ------------------------ | ------------------------ | ------------------------ | ------------------------ | ------------------------ |

| **Type** | **Tapret** | **Tapret #4** | **Keytweak** | **Sigtweak** | **Opret** | **Tapret #4** | **Keytweak** | **Sigtweak** | **Opret**

| Single-sig | 0 | 0 | 0 | 0 | 32 | 0 | 0 | 32 | 0?| 0 | 0 |

| MuSig (n-of-n) | 0 | 0 | 0 | 32 | 0 | 0 | 32 | ?> 0 | 0 |

| 多字符 2-of-3 | 32/8 | 32/8 或 0 | 0 n/a | 32 | ~270 | 65 | 32 | n/a | 0 |

| 32/8 | 32/8 或 0 | 0 n/a | 32 | ~340 | 65 | 32 | n/a | 0 |

| 有超时的三对二多用户密码 | 32/8 | 0 | 0 n/a | 32 | 64 | 65 | 32 | n/a | 0 | 0

| 层 | 链上成本（字节） | 链上成本（字节） | 链上成本（字节） | 客户端成本（字节） | 客户端成本（字节） | 客户端成本（字节

| -------------------------------- | ---------------------- | ---------------------- | ---------------------- | ------------------------ | ------------------------ |

| **类型** | **基础** | **塔普雷特 #2** | **塔普雷特 #4** | **塔普雷特 #2** | **塔普雷特 #4** | **塔普雷特 #2** | **塔普雷特 #4**

| MuSig (n-of-n) | 16.5 | 0 | 0 | 0 | 0 | 0

| FROST (n-of-m) | ?| 0 | 0 | 0 | 0 |

| Multi_a (n-of-m) | 1+16n+8m | 8 | 8 | 33 * m | 65 |

| MuSig 分支 / Multi_a (n-of-m) | 1+16n+8n+8xlog(n) | 8 | 0 | 64 | 65 |

| 有超时 (n-of-m) | 1+16n+8n+8xlog(n) | 8 | 0 | 64 | 65 |

| 方法 | 保密性和可扩展性 | 互操作性 | 兼容性 | 可移植性 | 复杂性

| ----------------------------------------- | ------------------------------ | ---------------- | ------------- | ----------- | ---------- |

Keytweak (deterministic P2C) | 🟢 | 🔴 | 🔴 | 🟡 | 🟡 | 🟡 | 🟡 | 🟡

| Sigtweak（确定性 S2C） | | 🟢 | 🔴 | 🔴 | 🟢 | 🔴 | 🔴

| Opret (OP_RETURN) | | 🔴 | 🟠 | 🔴 | 🟢 | 🟢 | 🟢

| Algo Tapret：左上角节点 | | 🟠 | 🟢 | 🔴 | 🟠 | 🟠 | 🟠

| Algo Tapret #4：任何节点 + 证明 | | 🟢 | 🟢 | 🟠 | 🔴 | 🔴

在研究过程中，我们发现没有一种承诺方案能完全兼容当前的 Lightning 标准（该标准未采用 Taproot、_muSig2_ 或额外的_承诺_支持）。我们正在努力修改 Lightning 的通道构造（*BiFrost*），以允许插入 RGB 承诺。这也是我们需要重新审视事务结构、密钥和通道更新签名方式的另一个领域。

分析表明，事实上，其他方法（按键调整、SIG 调整、证人调整等）也会带来其他形式的复杂性：


- 要么我们的链上交易量很大；
- 要么就是与现有的钱包代码完全不兼容；
- 要么，在非合作多 ID 中，解决方案不可行。

对于 RGB，有两种方法特别突出： *Opret****和***Tapret***都被归类为 "事务输出"，与协议使用的 TxO2 模式兼容。

### 多协议承诺 - MPC

在本节中，我们将探讨**RGB**如何通过确定性方案（根据 "Opret "或 "Tapret"）在比特币交易中记录的单个承诺（*承诺*）中处理多个合约（或更准确地说，它们的_过渡束_）的聚合。为了实现这一目标，各种合约的默克尔化顺序在一个名为 **MPC Tree** （多协议承诺树）的结构中进行。在本节中，我们将介绍这种多协议承诺树的构造、如何获得其根，以及多个合约如何能够保密且明确地共享同一个事务。

多协议承诺（MPC）旨在满足两种需求：


- mPC::Commitment "哈希值的构建：它将根据 "Opret "或 "Tapret "方案被包含在比特币区块链中，并且必须反映所有需要验证的状态变化；
- 在单个_commitment_中同时存储多个合约，从而在单个比特币交易中管理多个资产或 RGB 合约的单独更新。

具体来说，每个_过渡束_都属于一个特定的合约。所有这些信息都会被插入一个 **MPC 树**，然后对其根（"mPC::Root"）进行散列，得到 "mPC::Commitment"。根据所选择的确定性方法，最后的哈希值被放入比特币交易（_见证交易_）中。

![RGB-Bitcoin](assets/fr/042.webp)

#### MPC 根散列

链上实际写入的值（在 "Opret "或 "Tapret "中）称为 "mPC::Commitment"。其计算公式为 [BIP-341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)：

```txt
mpc::Commitment = SHA-256(SHA-256(mpc_tag) || SHA-256(mpc_tag) || depth || cofactor || mpc::Root )
```

其中


- `mpc_tag` 是一个标签：urn:ubideco:mpc:commitment#2024-01-31"，根据 [RGB 标记约定](https://github.com/RGB-WG/rgb-core/blob/master/doc/Commitments.md) 选择；
- depth"（1 个字节）表示 *MPC 树* 的深度；
- cofactor`（16 位，小端值）是一个参数，用于提高分配给树中每个合约的位置的唯一性；
- `mpc::Root` 是 *MPC Tree* 的根，根据下一节描述的过程计算得出。

![RGB-Bitcoin](assets/fr/044.webp)

#### MPC 树建造

要建立这棵 MPC 树，我们需要确保每份合同都与唯一的叶子位置相对应。假设我们有 ：


- c` 份合同，以`i={0,1,...,C-1}`中的`i`为索引；
- 对于每个合同 `c_i`，我们都有一个标识符 `ContractId(i) = c_i`。

然后，我们构建一棵宽度为 `w` 、深度为 `d` 的树，使得 `2^d = w`，其中 `w > C`，这样每份合约都可以放在单独的_叶_中。每份合约在树中的位置 `pos(c_i)` 由 ：

```txt
pos(c_i) = c_i mod (w - cofactor)
```

其中，"系数 "是一个整数，用来增加每个合约获得不同位置的概率。在实践中，构建过程是一个迭代过程：


- 我们从最小深度开始（"d=3 "是惯例，以隐藏合约的确切数量）；
- 我们尝试不同的 "系数"（最多为 "w/2"，或出于性能原因最多为 500）；
- 如果我们无法在不发生碰撞的情况下定位所有合约，我们就会递增 `d` 并重新开始。

目的是避开过高的树木，同时将碰撞风险降到最低。请注意，碰撞现象遵循的是随机分布逻辑，与[周年悖论](https://en.wikipedia.org/wiki/Birthday_problem) 有关。

#### 有人居住的树叶

一旦为合约 `i = {0,1,...,C-1}`获取了 `C` 个不同的位置 `pos(c_i)` ，每张纸都会被填充一个哈希函数（*标记哈希*）：

```txt
tH_MPC_LEAF(c_i) = SHA-256(SHA-256(merkle_tag) || SHA-256(merkle_tag) || 0x10 || c_i || BundleId(c_i))
```

其中


- `merkle_tag = urn:ubideco:merkle:node#2024-01-31`，总是根据 RGB 的默克尔约定来选择；
- 0x10 "表示一个_合同叶_；
- c_i` 是 32 字节的合同标识符（源自 Genesis 哈希值）；
- bundleId(c_i)` 是一个 32 字节的哈希值，用于描述与 `c_i` 相对的 `State Transition` 集合（集合为一个 *Transition Bundle*）。

#### 无人居住的树叶

其余未分配给合约的叶子（即 `w - C` 叶子）由一个 "虚拟 "值（_熵叶子_）填充：

```txt
tH_MPC_LEAF(j) = SHA-256(SHA-256(merkle_tag) || SHA-256(merkle_tag) || 0x11 || entropy || j )
```

其中


- `merkle_tag = urn:ubideco:merkle:node#2024-01-31`，总是根据 RGB 的默克尔约定来选择；
- 0x11 "表示熵叶；
- 熵 "是一个 64 字节的随机值，由构建树的人选择；
- j "是该树叶在树中的位置（32 位 Little Endian）。

#### MPC 节点

生成 "w "叶（无论是否有人居住）后，我们继续进行 "梅克尔化"。任何内部节点都会按如下方式散列：

```txt
tH_MPC_BRANCH(tH1 || tH2) = SHA-256(SHA-256(merkle_tag) || SHA-256(merkle_tag) || b || d || w || tH1 || tH2)
```

其中


- `merkle_tag = urn:ubideco:merkle:node#2024-01-31`，总是根据 RGB 的默克尔约定来选择；
- b` 是分支因子（8 位）。大多数情况下，`b=0x02`，因为树是二进制和完整的；
- d` 是节点在树中的深度；
- w` 是树的宽度（256 位 Little Endian 二进制）；
- tH1` 和 `tH2` 是子节点（或叶子）的哈希值，计算过程如上所示。

这样，我们就得到了根 `mPC::Root`。然后，我们可以计算 `mPC::Commitment`（如上所述），并将其插入链上。

为了说明这一点，让我们设想一个 `C=3`（三个合约）的例子。它们的位置假定为 `pos(c_0)=7`, `pos(c_1)=4`, `pos(c_2)=2`。其他叶子（位置 0、1、3、5、6）是_熵叶子_。下图显示了以 ：


- 代表 `BUNDLEId(c_i)` 的 `BUNDLE_i` ；
- tH_MPC_LEAF(A)` 等等，它们代表叶子（有些代表契约，有些代表熵）；
- 每个分支`tH_MPC_BRANCH(...)`都结合了其两个子分支的哈希值。

最终结果是**mPC::Root**，然后是`mPC::Commitment`。

![RGB-Bitcoin](assets/fr/053.webp)

#### MPC 轴检查

当验证者希望确保 `c_i` 合约（及其 `BundleId` ）包含在最终的 `mpc::Commitment` 中时，他只需接收一个 Merkle 证明。该证明指出了从叶（这里是 `c_i` 的 _contract leaf_）追溯到根所需的节点。没有必要公开整个 *MPC 树*：这样可以保护其他合约的机密性。

在这个例子中，`c_2`验证器只需要一个中间哈希值（`tH_MPC_LEAF(D)`）、两个`tH_MPC_BRANCH(...)`、`pos(c_2)`位置证明和`cofactor`值。然后，它可以本地重构根，然后重新计算 `mpc::Commitment` 并与比特币交易（在 `Opret` 或 `Tapret` 中）中写入的进行比较。

![RGB-Bitcoin](assets/fr/054.webp)

这一机制确保：


- 相对于 `c_2` 的状态确实包含在汇总信息块中（客户端）；
- 由于链上_commitment_指向的是单个 MPC 根，因此没有人能用相同的事务建立另一个历史。

#### 方案协调会结构概述

多协议承诺* (MPC) 是使 RGB 能够将多个合约聚合到单个比特币交易中的原理，同时保持承诺的唯一性和对其他参与者的保密性。得益于树状结构的确定性，每个合约都被分配到一个唯一的位置，而 "假 "叶子（*熵叶子*）的存在则部分掩盖了参与交易的合约总数。

整个梅克尔树从不存储在客户端。我们只需为每个相关合约生成一个 _Merkle 路径，然后传送给接收方（接收方可对承诺进行验证）。在某些情况下，您可能会有多个资产通过同一个 UTXO。这时，您可以将多个_Merkle 路径_合并为一个所谓的_多协议承诺块_，以避免重复过多的数据。

因此，每个 _Merkle 证明都是轻量级的，尤其是在 RGB 树深度不超过 32 的情况下。还有一个 "梅克尔块 "的概念，它保留了更多的信息（横截面、熵等），对于组合或分离几个分支非常有用。

这就是为什么花了这么长时间才最终确定 RGB 的原因。从 2019 年开始，我们就有了整体构想：将所有东西都放在客户端，在链外流通代币。但是，像多合约分片、梅克尔树的结构、如何处理碰撞和合并证明......所有这些细节都需要反复推敲。

### 锚：全球大会

在构建我们的承诺（"Opret "或 "Tapret"）和我们的MPC（*多协议承诺*）之后，我们需要解决RGB协议中的**锚**概念。锚（Anchor）是一种客户端验证结构，它汇集了验证比特币承诺是否确实包含特定合同信息所需的元素。换句话说，锚点总结了验证上述承诺所需的所有数据。

锚点由三个有序字段组成：


- Txid
- MPC 证明
- 额外交易证明 - ETP

这些字段中的每一个都在验证过程中发挥着作用，无论是重建底层比特币交易还是证明隐藏承诺的存在（尤其是在 "Tapret "的情况下）。

#### TxId

Txid "字段对应于包含 "Opret "或 "Tapret "承诺的比特币交易的 32 字节标识符。

从理论上讲，按照单次使用封印的逻辑，可以通过追踪指向每个见证交易的状态转换链来找到这个 "Txid"。但是，为了方便和加快验证，这个 `Txid` 只需包含在锚中，这样验证者就不必回溯整个链外历史。

#### MPC 证明

第二个字段 "多协议承诺证明 "是指该特定合约（如 "c_i"）包含在 "多协议承诺 "中的证明。它是 ：


- pos_i"，该合同在 MPC 树中的位置；
- cofactor"，即为解决位置碰撞而定义的值；
- 默克尔证明"，即用于重建 MPC 根节点和哈希值的节点集，并验证合同标识符及其 "过渡包 "是否已提交给根节点。

这一机制在上一节 "构建 *MPC 树*"中有所描述，在这一节中，由于 .NET Framework 3.0 的存在，每份合同都能获得一个唯一的树叶：

```txt
pos(c_i) = c_i mod (w - cofactor)
```

然后，使用一个确定性的梅克尔化方案来聚合所有叶子（契约 + 熵）。最后，"MPC 证明 "允许在本地重建根，并与链上包含的 "mPC::Commitment "进行比较。

#### 额外交易证明 - ETP

第三个字段，即**ETP**，取决于所使用的承诺类型。如果承诺类型是 `Opret`，则不需要额外的证明。验证器会检查事务的第一个 `OP_RETURN` 输出，并直接在那里找到 `mPC::Commitment`。

**If the commitment is of type `Tapret`**, an additional proof called *Extra Transaction Proof - ETP* must be provided.它包含 ：


- 分录根输出的内部公钥 (`P`)，*提交*被嵌入其中；
- 脚本路径花费 "的伙伴节点（在脚本中插入 Tapret *commitment* 时），以证明该脚本在 taproot 树中的确切位置：
 - 如果 `Tapret` *commitment* 位于右侧分支，我们就会显示左侧节点（例如 `tHABC`）、
 - 如果 `tapret` *commitment* 在左侧，则需要披露 2 个节点（例如 `tHAB` 和 `tHC`），以证明右侧没有其他 *commitment* 存在。
- nonce "可用于 "挖掘 "最佳配置，允许将*承诺*放在树的右侧（证明优化）。

这个额外的证明是必不可少的，因为与 `Opret` 不同，`Tapret` 承诺被集成到了分根脚本的结构中，这就需要揭示分根树的一部分，以便正确验证 * 承诺 * 的位置。

![RGB-Bitcoin](assets/fr/045.webp)

因此，**Anchors**封装了在RGB背景下验证比特币承诺所需的所有信息。它们同时显示相关交易（`Txid`）和合约定位证明（`MPC Proof`），并在`Tapret`的情况下管理附加证明（`ETP`）。通过这种方式，锚可以保护链外状态的完整性和唯一性，确保同一交易不能被重新解释为其他合约数据。

### 结论

本章将介绍 ：


- 如何在比特币中应用一次性封印概念（特别是通过_outpoint_）；
- 在事务中确定性插入提交的各种方法（Sig tweak、Key tweak、witness tweak、op_return、Taproot/Tapret）；
- RGB 专注于 Tapret 承诺的原因 ；
- 通过 _multi-protocol commitments_ 进行多合约管理，如果你不想在证明某个特定观点时暴露整个状态或其他合约，这一点至关重要；
- 我们还看到了 _Anchors_ 的作用，它将所有功能（交易 TXID、梅克尔树证明和 Taproot 证明）整合在一个包中。

在实践中，技术实现分为几个专用的 Rust _crates（在 _client_side_validation_、_commit-verify_、_bp_core_ 等中）。基本概念是存在的：

![RGB-Bitcoin](assets/fr/046.webp)

在下一章中，我们将研究 RGB 的纯粹链外组件，即合约逻辑。我们将看到，作为部分复制的无限状态机，RGB 合约是如何实现比比特币脚本更高的表现力，同时又能保持其数据的机密性。

## 智能合约及其状态介绍

<chapterId>04a9569f-3563-5382-bf53-0c7069343ba0</chapterId>

![video](https://youtu.be/tmAVdyXGmj4)

在本章和下一章中，我们将探讨 RGB 环境中***智能合约***的概念，并探索这些合约定义和演进其*状态*的不同方式。我们将了解为什么 RGB 架构使用一次性封印的有序序列，能够以可扩展的方式执行各种类型的****合同操作****，而无需通过集中式注册中心。我们还将了解****业务逻辑****在构建合同状态演变过程中的基本作用。

### 智能合约和数字无记名权利

RGB 的目标是为在比特币上执行智能合约提供基础设施。我们所说的 "智能合约 "是指几方之间的协议，该协议通过计算自动执行，无需人工干预条款的执行。换句话说，合同的法律由软件执行，而不是由受信任的第三方执行。

这种自动化提出了权力下放的问题：我们如何才能摆脱中央登记处（如中央平台或数据库）来管理所有权和合同履行？RGB 最初的想法是回到一种被称为 "无记名工具 "的所有权模式。历史上，某些证券（债券、股票等）以不记名形式发行，使任何实际拥有该文件的人都能行使其权利。

![RGB-Bitcoin](assets/fr/055.webp)

RGB 将这一概念应用于数字世界：权利（和义务）被封装在链外操作的数据中，这些数据的状态由参与者自己验证。与其他基于公共登记簿的方法相比，这种方法具有更高的保密性和独立性。

### 智能合约 RGB 状态介绍

RGB 中的智能合约可以看成是一个状态机，由 .NET Framework 定义：


- 状态**，即反映合同当前配置的一组信息；
- 业务逻辑**（一套规则），说明在什么条件下以及由谁修改状态。

![RGB-Bitcoin](assets/fr/056.webp)

重要的是要明白，这些合约并不局限于代币的简单转让。它们可以体现各种各样的应用：从传统资产（代币、股票、债券）到更复杂的机制（使用权、商业条款等）。与其他区块链不同的是，在其他区块链中，所有人都可以访问和执行合约代码，而 RGB 的方法则将合约的访问和知识分隔给参与者（"***合约参与者***"）。参与者有几种角色：


- 合约的发行人**或创建者，由他定义合约的创始及其初始变量；
- 拥有权利**（*所有权*）或其他执行能力的缔约方 ；
- 观察者**，可能仅限于看到某些信息，但不能触发修改。

这种角色分离确保只有获得授权的人才能与合约状态进行交互，从而有助于抵制审查。它还赋予了 RGB 横向扩展的能力：大多数验证都是在区块链之外进行的，只有加密锚（*承诺*）被刻在比特币上。

### RGB 中的状态和业务逻辑

从实际角度来看，合同的**业务逻辑**采用规则和脚本的形式，在 RGB 所称的**模式**中定义。模式对 .NET Framework 3.0 进行编码：


- 国家结构（哪些领域是公共的？哪些领域归哪些方面所有？
- 有效性条件（授权状态更新前必须检查什么？
- 授权（谁可以启动*状态转换*？ 谁只能观察？）

同时，**合同国**往往分为两个部分：


- 全局状态**：公共部分，有可能被所有人观察到（取决于配置）；
- 自有状态**：私有部分，通过合同逻辑中引用的UTXO专门分配给所有者。

正如我们在接下来的章节中所看到的，任何状态更新（*合约操作*）都必须与比特币_承诺_（通过`Opret`或`Tapret`）对接，并符合*业务逻辑*脚本，才能被视为有效。

### 合同业务：国家的建立与演变

在 RGB 宇宙中，***合约操作***是将合约从**旧状态**变为**新状态**的任何事件。这些操作遵循以下逻辑：


- 我们注意到合同的现状；
- 我们应用规则或操作（****状态转换****、****创世****（如果是第一个状态）或****状态扩展****（如果有公共*值*要重新触发））；
- 我们通过在区块链上提交新的_commitment_来锚定修改，关闭一个_single-use seal_，并创建另一个.NET_single-use seal_；
- 相关权利人在本地（*客户端*）验证过渡符合*模式*，并在链上注册相关比特币交易。

![RGB-Bitcoin](assets/fr/057.webp)

最终结果是一个更新的合约，现在的状态已经不同了。这种转换不需要整个比特币网络关注细节，因为区块链中只记录了一个小的加密指纹（_commitment_）。一次性封印序列可以防止任何重复消费或重复使用状态。

### 业务链：从创始到终端状态

从这个角度来看，RGB 智能合约以**创世**（第一个状态）开始。此后，各种合约操作接踵而至，形成一个 DAG（*定向循环图*）操作：


- 每个过渡都基于之前的一个状态（或多个状态，如果是趋同过渡）；
- 时间顺序由比特币锚中的每一次过渡来保证，时间戳和工作证明的共识保证了时间顺序的不可更改性；
- 当没有任何操作正在进行时，就会进入**终端状态**：合约的最新完整状态。

![RGB-Bitcoin](assets/fr/012.webp)

这种 DAG 拓扑（而不是简单的线性链）反映了合同的不同部分可能并行发展，只要它们不相互矛盾。然后，RGB 通过对每个参与方进行*客户端*验证来避免任何不一致。

### 摘要

RGB 中的智能合约引入了一种数字无记名票据模式，这种模式是去中心化的，但以比特币为基础，用于时间标记和保证交易顺序。这些合约的自动执行基于.NET技术：


- 合同状态*，表示合同的当前配置（权利、余额、变量等）；
- 业务逻辑**（*模式*），定义允许哪些转换以及必须如何验证转换；
- 合约操作**，通过比特币交易中的承诺来逐步更新状态。

在下一章中，我们将更详细地介绍这些***状态***和***状态转换***在链外层面的具体表现，以及它们与比特币中嵌入的UTXO和一次性封印的关系。我们将借此机会了解 RGB 基于客户端验证的内部机制如何在维护数据机密性的同时保持智能合约的一致性。

## RGB 合同操作

<chapterId>78c44e88-50c4-5ec4-befe-456c1a9f080b</chapterId>

![video](https://youtu.be/lUTjeuM0oTA)

在本章中，我们将了解智能合约中的操作和状态转换是如何进行的，同样也是在 RGB 协议中进行的。此外，我们还将了解多个参与者如何合作转移资产的所有权。

### 状态转换及其机制

一般原则仍然是客户端验证，即状态数据由所有者持有，由接收者验证。不过，RGB 的特殊性在于，鲍勃作为接收方，要求爱丽丝将某些信息纳入合同数据，以便通过对其某个UTXO 的隐藏引用，真正控制所接收的资产。

为了说明*状态转换*的过程（这是 RGB 中的基本***合约操作***之一），让我们以爱丽丝和鲍勃之间的资产转移为例逐步说明：

**最初情况：**

爱丽丝有一个本地验证数据（*客户端*）的***储藏库 RGB***。这个储藏库指的是她在比特币上的一个UTXO。这意味着，该数据中的一个_密封定义_指向属于爱丽丝的一个UTXO。其目的是使爱丽丝能够将与资产（如 RGB 代币）相关的某些数字权利转移给鲍勃。

![RGB-Bitcoin](assets/fr/058.webp)

**鲍勃也有UTXO：**

而鲍勃至少有一个自己的UTXO，与爱丽丝的UTXO没有直接联系。在鲍勃没有UTXO的情况下，仍然可以使用*见证交易*本身向他进行转移：该交易的输出将包括承诺（_commitment_），并隐含地将新合约的所有权与鲍勃联系起来。

![RGB-Bitcoin](assets/fr/059.webp)

**建造新房产（*新州*）：**

鲍勃向爱丽丝发送以***发票***形式编码的信息（我们将在后面的章节中详细介绍发票的构造），要求她创建一个符合合同规则的新状态。这个状态将包括一个新的*密封定义*，指向鲍勃的一个UTXO。这样，鲍勃就获得了新状态中定义的资产的所有权，例如一定数量的 RGB 代币。

![RGB-Bitcoin](assets/fr/060.webp)

**准备交易样本：**

然后，爱丽丝创建一个比特币交易，花费前一个封印中引用的UTXO（使她作为持有者合法化的那个）。在这笔交易的输出中，会插入一个*承诺*（通过`Opret`或`Tapret`）来锚定新的 RGB 状态。Opret "或 "Tapret "承诺源于一棵*MPC 树*（如前面章节所述），它可以汇集来自不同合约的多个过渡。

**向鲍勃转交*委托书*：**

在广播交易之前，爱丽丝会向鲍勃发送一份***委托***，其中包含所有必要的*客户端*数据（他的*储藏*）以及对鲍勃有利的新状态信息。此时，鲍勃会应用 RGB 共识规则：


- 它会验证*委托*中包含的所有 RGB 数据，包括授予资产所有权的新状态；
- 根据*委托*中包含的*锚点*，它可以验证见证交易的时间顺序（从创世纪到最近的过渡），并验证区块链中的相应承诺。

**完成过渡：**

如果鲍勃感到满意，他可以表示同意（例如，签署*委托书*）。然后，爱丽丝就可以广播准备好的交易样本。一旦得到确认，这就关闭了之前由爱丽丝持有的封印，并正式确定了鲍勃的所有权。防重复消费的安全机制与比特币相同：UTXO 已用完，证明爱丽丝不能再重复使用。

![RGB-Bitcoin](assets/fr/061.webp)

新状态现在引用了鲍勃的UTXO，使鲍勃获得了之前由爱丽丝持有的所有权。锚定 RGB 数据的比特币输出将成为所有权转移的不可撤销证明。

一个由两个合约操作（**创世**和***状态转换***）组成的最小 DAG（*有向无环图*）的例子可以说明 RGB 状态（*客户端*层，红色）是如何连接到比特币区块链（*承诺*层，橙色）的。

![RGB-Bitcoin](assets/fr/062.webp)

它表明，创世纪定义了一个封印（*封印定义*），然后*状态转换*关闭了这个封印，在另一个UTXO 中创建了一个新的封印。

在这方面，这里有一些术语提醒：


- 一项****任务****结合了：
    - 密封定义****（指向UTXO）；
    - 所有权状态**，即与所有权相关的数据（例如，转让的代币数量）。
- 一个**全球状态**汇集了合约的一般属性，对所有人可见，并确保演变的全球一致性。

上一章介绍的状态转换**是合约操作的主要形式。它们引用一个或多个先前的状态（来自创世纪或另一个状态转换），并将其更新为一个新状态。

![RGB-Bitcoin](assets/fr/063.webp)

该图显示了在一个*状态转换捆绑包*中，如何在单个样本事务中关闭多个封印，同时打开新的封印。事实上，RGB 协议的一个有趣特点就是它的扩展能力：多个过渡可以聚合成一个过渡捆绑包，每个聚合包都与*MPC 树*的一个不同叶子（一个唯一的捆绑包标识符）相关联。得益于*Deterministic Bitcoin Commitment* (DBC)机制，整个信息会被插入到一个 "Tapret "或 "Opret "输出中，同时关闭之前的封印并可能定义新的封印。Anchor* 是存储在区块链中的承诺与客户端验证结构（*客户端*）之间的直接链接。

在接下来的章节中，我们将了解构建和验证状态转换所涉及的所有组件和流程。其中大部分元素都是 RGB 共识的一部分，在 **RGB 核心库**中实现。

### 过渡包

在 RGB 上，可以捆绑属于同一合约的不同状态转换（即共享相同的**ContractId**，源自 Genesis **OpId**）。在最简单的情况下，就像上例中 Alice 和 Bob 之间的情况一样，一个**转换捆绑**只包含一个转换。但支持多用户操作（如硬币连接、闪电通道开启等）意味着多个用户可以将他们的状态转换合并到一个捆绑包中。

一旦收集完毕，这些转换将（通过 MPC + DBC 机制）锚定在单个比特币交易中：


- 每个状态转换都会被散列并分组为一个转换包；
- 过渡包本身会被散列并插入与此合约（一个 BundleId）相对应的 MPC 树叶中；
- 在见证事务中，MPC 树最终通过 "Opret "或 "Tapret "参与，从而关闭已消耗的封印并定义新的封印。

从技术上讲，在 MPC 工作表中插入的 **BundleId** 是通过应用于 bundle 的 *InputMap* 字段严格序列化的标记哈希值获得的：

```txt
BundleId = SHA256( SHA256(bundle_tag) || SHA256(bundle_tag) || InputMap )
```

其中 `bundle_tag = urn:lnp-bp:rgb:bundle#2024-02-03` 举例来说。

InputMap* 是一个数据结构，其中列出了示例事务的每个输入 `i`，以及相应状态转换的 *OpId* 的引用。例如

```txt
InputMap =
N               input_0    OpId(input_0)    input_1    OpId(input_1)   ...    input_N-1  OpId(input_N-1)
|____________________| |_________||______________| |_________||______________|       |__________||_______________|
16-bit Little Endian   32-bit LE   32-byte hash
|_________________________| |_________________________|  ...  |___________________________|
MapElement1                MapElement2                       MapElementN
```


- N "是事务中引用 "OpId "的条目的总数；
- opId(input_j)` 是包中存在的状态转换之一的操作标识符。

通过有序地对每个条目只引用一次，我们可以防止同一印章在两个同时进行的状态转换中被使用两次。

### 状态生成和活动状态

因此，状态转换可用于将资产的所有权从一个人转移到另一个人。然而，这并不是 RGB 协议中唯一可能的操作。该协议定义了三种**合约操作**：


- 状态转换** ；
- 创世纪** ；
- 州推广**。

其中，**创世**和**状态扩展**有时被称为 "*状态生成操作*"，因为它们在创建新状态时不会立即关闭任何状态。这是非常重要的一点： **Genesis** 和 **State Extension** 并不涉及关闭封印。相反，它们定义了一个新的封印，该封印必须在随后的**状态转换**中使用，才能在区块链历史中得到真正的验证。

![RGB-Bitcoin](assets/fr/064.webp)

合约的**活跃状态**通常被定义为交易历史（DAG）中产生的最新状态集合，从创世开始，依次是比特币区块链中的所有锚点。任何已经过时的旧状态（即附属于已耗尽的 UTXOs）都不再被视为活跃状态，但对于检查历史的一致性仍然至关重要。

### 创世纪

创世纪是每个 RGB 合约的起点。它由合约发行方创建，并根据**模式**定义初始参数。就 RGB 令牌而言，创世可指定例如 ：


- 最初创建的代币数量及其所有者；
- 可能的发行上限总额 ；
- 任何重发规则，以及哪些参与者有资格重发。

作为合约中的第一笔交易，"创世 "不会引用任何先前的状态，也不会关闭任何封印。然而，要在历史记录中出现并得到验证，创世必须被第一个状态转换（通常是对发行方本身的扫描/自动支出交易，或对用户的初始分配）**消耗**（关闭）。

### 州推广

状态扩展**为智能合约提供了一种独创的功能。它们使赎回合约定义中规定的某些数字权利（*Valencies*）成为可能，而无需立即关闭封印。这通常与.NET Framework有关：


- 分布式令牌问题；
- 资产互换机制 ；
- 有条件重发（可能包括销毁其他资产等）。

从技术上讲，状态扩展引用了一个 *Redeem*（RGB 输入的一种特殊类型），与之前定义的 *Valency* 相对应（例如，在创世纪或其他状态转换中）。它定义了一个新的印记，受益人或受益条件可使用该印记。要使封印生效，必须在随后的状态转换中使用该封印。

![RGB-Bitcoin](assets/fr/065.webp)

例如：《创世纪》创建了一项发行权（*Valency*）。经授权的行为者可以行使这一权利，然后建立一个国家扩展......：


- 它指的是 Valency（赎回）；
- 它创建了一个新的*分配*（新的*拥有状态*数据），指向一个UTXO；
- 由新 UTXO 所有者发布的未来状态转换将实际转移或分发新发行的代币。

### 合同业务的组成部分

现在，我想详细介绍一下 RGB 中**合同操作**的每个组成要素。合同操作是修改合同状态的操作，由合法接收方以确定的方式在客户端进行验证。具体而言，我们将了解合同操作如何一方面考虑合同的**旧状态**（*Old State*），另一方面考虑**新状态**（*New State*）的定义。

```txt
+---------------------------------------------------------------------------------------------------------------------+
|  Contract Operation                                                                                                 |
|                                                                                                                     |
|  +-----+     +-----------------------+      +--------------------------------+      +---------+     +------------+  |
|  | Ffv |     | ContractId | SchemaId |      | TransitionType | ExtensionType |      | Testnet |     | AltLayers1 |  |
|  +-----+     +-----------------------+      +--------------------------------+      +---------+     +------------+  |
|                                                                                                                     |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |
|  | Metadata                                      |  | Global State                                               |  |
|  |                                               |  | +----------------------------------+                       |  |
|  | +-------------------------------------+       |  | | +-------------------+ +--------+ |                       |  |
|  | |          Structured Data            |       |  | | |  GlobalStateType  | |  Data  | |     ...     ...       |  |
|  | +-------------------------------------+       |  | | +-------------------+ +--------+ |                       |  |
|  |                                               |  | +----------------------------------+                       |  |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |         +------+
|                                                                                                                     +---------> OpId |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |         +------+
|  | Inputs                                        |  | Assignments                                                |  |
|  |                                               |  |                                                            |  |
|  | +-------------------------------------------+ |  | +--------------------------------------------------------+ |  |
|  | | Input #1                                  | |  | | Assignment #1                                          | |  |
+------+       |  | | +----------+ +----------------+ +-------+ | |  | | +----------------+ +-------------+ +-----------------+ | |  |       +--------------+
| OpId +--------------> PrevOpId | | AssignmentType | | Index | | |  | | | AssignmentType | | Owned State | | Seal Definition +--------------> Bitcoin UTXO |
+------+       |  | | +----------+ + ---------------+ +-------+ | |  | | +----------------+ +-------------+ +-----------------+ | |  |       +--------------+
|  | +-------------------------------------------+ |  | +--------------------------------------------------------+ |  |
|  |                                               |  |                                                            |  |
|  | +-------------------------------------------+ |  | +--------------------------------------------------------+ |  |
|  | | Input #2                                  | |  | | Assignment #2                                          | |  |
+------+       |  | | +----------+ +----------------+ +-------+ | |  | | +----------------+ +-------------+ +-----------------+ | |  |       +--------------+
| OpId +--------------> PrevOpId | | AssignmentType | | Index | | |  | | | AssignmentType | | Owned State | | Seal Definition +--------------> Bitcoin UTXO |
+------+       |  | | +----------+ +----------------+ +-------+ | |  | | +----------------+ +-------------+ +-----------------+ | |  |       +--------------+
|  | +-------------------------------------------+ |  | +--------------------------------------------------------+ |  |
|  |                                               |  |                                                            |  |
|  |       ...           ...          ...          |  |     ...          ...             ...                       |  |
|  |                                               |  |                                                            |  |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |
|                                                                                                                     |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |
|  | Redeems                                       |  | Valencies                                                  |  |
|  |                                               |  |                                                            |  |
|  | +------------------------------+              |  |                                                            |  |
+------+       |  | | +----------+ +-------------+ |              |  |  +-------------+  +-------------+                          |  |
| OpId +--------------> PrevOpId | | ValencyType | |  ...   ...   |  |  | ValencyType |  | ValencyType |         ...              |  |
+------+       |  | | +----------+ +-------------+ |              |  |  +-------------+  +-------------+                          |  |
|  | +------------------------------+              |  |                                                            |  |
|  |                                               |  |                                                            |  |
|  +-----------------------------------------------+  +------------------------------------------------------------+  |
|                                                                                                                     |
+---------------------------------------------------------------------------------------------------------------------+
```

如果我们看一下上图，就会发现一个合约操作包括指向**新状态**的元素和指向更新后**旧状态**的其他元素。

新国家***的要素是 ：


- 任务**，其中定义了：
 - 密封定义**；
 - **拥有的国家**。
- 可以修改或充实的**全球国家**；
- 值**，可能在状态转换或创世纪中定义。

旧州**通过.NET Framework引用：


- 输入**，指向之前状态转换的*分配*（《创世纪》中没有）；
- Redeems**，指的是以前定义的 Valencies（仅在状态扩展中）。

此外，"合同操作 "还包括与操作相关的更多通用字段：


- ffv`（*快进版本*）：表示合同版本的 2 字节整数；
- transitionType` 或 ExtensionType`：根据业务逻辑指定过渡或扩展类型的 16 位整数；
- `ContractId`：32 字节的数字，指合同的 *OpId* Genesis。包含在 Transitions 和 Extensions 中，但不包含在 Genesis .NET 中；
- schemaId：仅出现在 Genesis 中，是 32 字节的哈希值，代表合同的结构（*Schema*）；
- testnet`：布尔值，表示您是在 Testnet 还是 Mainnet 网络上。仅适用于 Genesis；
- altlayers1`：变量，用于标识除 Bitcoin 之外的另一数据锚定层（侧链或其他）。仅在创世中出现；
- 元数据"：可存储临时信息的字段，对验证复杂合同有用，但不得记录在最终状态历史记录中。

最后，所有这些字段都会通过定制的散列处理进行压缩，生成一个独一无二的指纹--"OpId"。然后，这个 "OpId "会被整合到过渡捆绑包中，使其能够在协议中得到验证和确认。

因此，每个 "合约操作 "都由一个名为 "OpId "的 32 字节哈希值来标识。该散列值由组成操作的所有元素的 SHA256 散列值计算得出。换句话说，每个*合约操作*都有自己的加密承诺，其中包括验证操作真实性和一致性所需的所有数据。

然后，RGB 合同由 "ContractId "标识，该 "ContractId "源自创世的 "OpId"（因为没有创世前的操作）。具体来说，我们将创世的 `OpId`，颠倒字节顺序并应用 Base58 编码。这种编码使 `ContractId` 更容易处理和识别。

### 状态更新方法和规则

合同状态**表示 RGB 协议必须跟踪的特定合同信息集。它由 ：


- 单一全局状态**：这是合约的公共、全局部分，对所有人可见；
- 一个或多个拥有国**：每个拥有国都有一个独一无二的印章（因此也是比特币上的UTXO）。.NET "和".NET "之间是有区别的：
    - 公**有制国家、
    - 私人**拥有的国家。

![RGB-Bitcoin](assets/fr/066.webp)

全局状态 "作为一个单独的区块直接包含在 "合约操作 "中。拥有的状态*在每个*分配*中与*密封定义*一起定义。

RGB 的一大特点是全局状态和所有者状态的修改方式。通常有两种行为：


- 可变**：当一个状态元素被描述为可变时，每次新的操作都会用新的状态替换之前的 状态。旧数据将被视为过时数据；
- 累加**：当一个状态元素被定义为累加时，每次新的操作都会给之前的状态添加新的信 息，而不会覆盖之前的状态。结果就是一种累积历史。

如果在合同中，某个状态元素没有被定义为可变或可累加，那么这个元素在后续操作中将保持为空（换句话说，这个字段没有新版本）。合同模式（即编码的业务逻辑）决定了状态（全局或自有）是可变的、可累积的还是固定的。一旦定义了 "创世"，这些属性只有在合同本身允许的情况下才能修改，例如通过特定的 "状态扩展"。

下表说明了每种类型的 "合约操作 "如何操纵（或不操纵）"全局状态 "和 "自有状态"：

| 生成 | 状态扩展 | 状态转换 | 生成

| ---------------------------- | :-----:| :-------------:| :--------------:|

| **添加全局状态** | + | - | + | |

| n/a | - | + | **全局状态突变** | - | + |

| **添加所有权状态** | + | - | + | |

| **拥有国突变** | n/a | No | + | |

| **添加阀值** | + | + | + | | + | |

**`+`** ：如果合同的模式允许，可以执行。

**`-`**：操作必须由随后的状态转换确认（仅状态扩展不会关闭一次性封印）。

此外，每类数据的时间范围和更新权限可按下表进行区分：

| 元数据 | 全局状态 | 所有者状态 | 所有者状态

| ------------------------------- | ---------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |

| 为单个合同操作定义 | 为合同全局定义 | 为每个印章定义（*分配*） | 为单个合同操作定义 | 为合同全局定义 | 为每个印章定义（*分配*） | 为每个印章定义（*分配*） | 为每个合同定义

| 不可变现（短暂数据） | 由行为者（发行者等）发行的交易 | 取决于印章的合法持有者（可在后续交易中使用印章的人） | | 印章的使用权

| 状态在操作前已定义（通过上一个操作的*密封定义*） | 状态在操作结束时建立 | 状态在操作结束时建立 | 状态在操作前已定义（通过上一个操作的*密封定义*） | 状态在操作结束时建立

### 全球国家

全球状态通常被描述为 "无人拥有，人人皆知"。它包含有关合约的一般信息，这些信息是公开可见的。例如，在代币发行合约中，全局状态可能包含 ：


- 代码（令牌的符号缩写）：ticker` ；
- 令牌的全名： `name` ；
- 精度（小数位数）：`precision` ；
- 首次发行（和/或最大代币限额）：发行供应
- 发布日期：`创建` ；
- 法律数据或其他公共信息：`data`.

这种 "全局状态 "可以放在公共资源（网站、IPFS、Nostr、Torrent 等）上，并向社区分发。此外，经济激励（持有和转移这些代币的需要等）自然会促使合约用户自己维护和传播这些数据。

### 作业

分配*是定义.NET Framework 的基本结构：


- 封印（*封印定义*），指向特定的UTXO；
- 拥有状态*，即与该印章相关的属性或数据。

*Assignment* 可以看作是比特币交易输出的类似物，但具有更大的灵活性。财产转移的逻辑就在于此：*Assignment* 将特定类型的资产或权利（"AssignmentType"）与印章联系起来。谁拥有与该印章相关联的UTXO私钥（或谁能使用该UTXO），谁就被视为该*所有权状态*的所有者。

RGB 的一大优势在于能够随意显示（*显示*）或隐藏（*隐藏*）*密封定义*和*拥有状态*字段。这提供了保密性和选择性的强大组合。例如，您可以在不公开所有数据的情况下证明转换是有效的，方法是向需要验证转换的人提供公开版本，而第三方只能看到隐藏版本（哈希值）。在实践中，转换的 `OpId` 总是从*隐藏*数据中计算出来的。

![RGB-Bitcoin](assets/fr/067.webp)

#### 密封件定义

密封定义*的显式形式有四个基本字段：txptr"、"vout"、"blinding "和 "method"：


- txptr**：这是对比特币上UTXO的引用：
    - 如果是**创世封印**，则直接指向现有的UTXO（与创世相关的UTXO）；
    - 在**图形密封**的情况下，我们可以有 ：
        - 如果指向特定的UTXO，则是一个简单的 "txid"、
        - 或 "WitnessTx"，表示自引用：印章指向交易本身。这在没有外部UTXO的情况下特别有用，例如在闪电通道开启交易中，或者收件人没有UTXO的情况下。
- vout** : `txptr`指示的事务输出编号。仅出现在标准图形封印中（不适用于 `WitnessTx`）；
- 盲**：8 个字节的随机数，用于加强保密性，防止对UTXO 身份的暴力破解；
- method**：表示使用的锚定方法（"Tapret "或 "Opret"）。

封印定义的*隐蔽*形式是这 4 个字段连接的 SHA256 哈希值（标记），并带有 RGB 的特定标记。

![RGB-Bitcoin](assets/fr/068.webp)

#### 拥有国

分配*的第二个组成部分是自有状态。与全局国不同，它可以以公共或私人形式存在：


- 公有国家**：每个人都知道与印章相关的数据。例如，公共图像；
- 私有状态**：数据是隐藏的，只有所有者（必要时可能还有验证者）知道。例如，持有的代币数量。

RGB 为 "自有状态 "定义了四种可能的状态类型（*StateTypes*）：


- 声明式**：不包含数字数据，只包含声明式权利（如投票权）。隐藏形式和揭示形式完全相同；
- 可互换**：表示可互换的数量（如代币）。在显式中，我们有 "数量 "和 "盲法"。在隐藏形式下，我们有一个 *Pedersen 承诺*，它隐藏了数量和盲码；
- 结构化**：存储结构化数据（最多 64 kB）。在公开形式下，它是数据 Blob。在隐藏形式下，它是该 blob 的标记哈希值：

```txt
SHA-256(SHA-256(tag_data) || SHA-256(tag_data) || blob)
```

例如：

```txt
tag_data = urn:lnp-bp:rgb:state-data#2024-02-12
```


- 附件**：将文件（音频、图像、二进制文件等）链接到 "所属状态"，存储文件哈希值 "file_hash"、MIME 类型 "media type "和加密盐 "salt"。文件本身托管在其他地方。文件的隐藏形式是一个哈希值，上面有三个数据项：

```txt
SHA-256(SHA-256(tag_attachment) || SHA-256(tag_attachment) || file_hash || media_type || salt)
```

例如：

```txt
tag_attachment = urn:rgb:state-attach#2024-02-12
```

总之，以下是公开和隐藏形式的 4 种可能状态：

```txt
State                      Concealed form                              Revealed form
+---------------------------------------------------------------------------------------------------------
+--------------------------------------------------------------------------------+
|                                                                                |
Declarative        |                              < void >                                          |
|                                                                                |
+--------------------------------------------------------------------------------+
+---------------------------------------------------------------------------------------------------------
+--------------------------+             +---------------------------------------+
| +----------------------+ |             |         +--------+ +----------+       |
Fungible           | | Pedersen Commitement | | <========== |         | Amount | | Blinding |       |
| +----------------------+ |             |         +--------+ +----------+       |
+--------------------------+             +---------------------------------------+
+---------------------------------------------------------------------------------------------------------
+--------------------------+             +---------------------------------------+
| +----------------------+ |             |         +--------------------+        |
Structured         | |     Tagged Hash      | | <========== |         |     Data Blob      |        |
| +----------------------+ |             |         +--------------------+        |
+--------------------------+             +---------------------------------------+
+---------------------------------------------------------------------------------------------------------
+--------------------------+             +---------------------------------------+
| +----------------------+ |             | +-----------+ +------------+ +------+ |
Attachments        | |     Tagged Hash      | | <========== | | File Hash | | Media Type | | Salt | |
| +----------------------+ |             | +-----------+ +------------+ +------+ |
+--------------------------+             +---------------------------------------+
```

| **表述性** | **可互换性** | **结构性** | **附件** | **附件**

| --------------------- | -------------- | ------------------------------------ | ----------------------------- | ---------------------------- |

| 无 | 64 位有符号或无符号整数 | 任何严格的数据类型 | 任何文件 | 任何数据类型。

| 信息类型** | 无 | 有符号或无符号 | 严格类型 | MIME 类型 | 无

| Pedersen 承诺 | 带盲法的散列 | 散列文件 ID

大小限制** | 不适用 | 256 字节 | 最大 64 KB | 最大 ~500 Gb | 不适用 | 256 字节 | 最大 64 KB | 最大 ~500 Gb | 不适用

### 输入

合约操作*的输入指的是这项新操作中使用的*分配。输入表示 ：


- prevOpId`：*Assignment*所在的上一个操作的标识符（`OpId`）；
- assignmentType`：*Assignment*的类型（例如，令牌的`assetOwner`）；
- Index"：与前一个 "OpId "相关联的列表中*Assignment*的索引，在对隐藏封印进行词性排序后确定。

输入从未出现在 "创世纪 "中，因为之前没有 "分配"。它们也不会出现在 "状态扩展 "中（因为 "状态扩展 "不会关闭封印，而是根据 Valencies 重新定义新的封印）。

当我们拥有 "Fungible "类型的 "已拥有状态 "时，验证逻辑（通过模式中提供的 AluVM 脚本）会检查总和的一致性：输入标记（*Inputs*）的总和必须等于输出标记（在新的*Assignments*中）的总和。

### 元数据

**Metadata** 字段的最大容量为 64 KiB，用于包含对验证有用的临时数据，但不会整合到合约的永久状态中。例如，这里可以存储复杂脚本的中间计算变量。该空间不打算存储在全局历史记录中，因此不属于 "自有状态 "或 "全局状态 "的范围。

### 阀值

Valencies** 是一种独创的 RGB 协议机制。它们可以在 "创世纪"、"状态转换 "或 "状态扩展 "中找到。它们代表数字权利，可由状态扩展（通过 *Redeems*）激活，然后由随后的转换最终确定。每个 Valency 由一个 "ValencyType"（16 位）标识。其语义（重发权、令牌交换、烧毁权等）在模式中定义。

具体来说，我们可以想象一个定义了 "重发权 "价的创世纪。如果满足某些条件，国家扩展就会消耗它（*重新发行*），以引入新数量的代币。然后，从印章持有者处产生的状态转换就可以转移这些新的代币。

### 赎回

重置相当于分配的输入。它们只出现在状态扩展中，因为这是激活先前定义的有效性的地方。重置由两个字段组成：


- PrevOpId：指定有效性的操作的 `OpId`；
- ValencyType"：您希望激活的 Valency 类型（每个 "ValencyType "在国家扩展项目中只能使用一次）。

例如：赎回可以对应于币币交换执行，这取决于 Valency 中的编码。

### RGB 状态特性

现在我们来看看 RGB 的几个基本状态特征。特别是，我们将了解 ：


- 严格类型系统**，对数据进行精确的类型化组织；
- 将**验证**与**所有权**分开的重要性 ；
- RGB 中的**共识进化**系统，包括*快进*和*后推*的概念。

请记住，所有与合约状态有关的内容都是根据协议中规定的共识规则在客户端进行验证的，其最终的加密参考是以比特币交易为基础的。

#### 严格的类型系统

RGB 采用*严格类型系统*和确定性序列化模式（*严格编码*）。该组织旨在确保合同数据的定义、处理和验证具有完美的可重复性和精确性。

在许多编程环境（JSON、YAML......）中，数据结构可以是灵活的，甚至是过于宽松的。而在 RGB 中，每个字段的结构和类型都有明确的约束条件。例如 ：


- 每个变量都有特定的类型（例如，8 位无符号整数 `u8` 或 16 位有符号整数等）；
- 类型可以组成（嵌套类型）。这意味着您可以根据其他类型定义一个类型（例如，一个包含 `u8` 字段、`bool` 字段等的聚合类型）；
- 还可以指定集合：列表 (*list*)、集合 (*set*) 或字典 (*map*)，并确定递进顺序；
- 每个字段都有边界（*下限*/*上限*）。我们还对集合中元素的数量进行了限制（包含）；
- 数据是字节对齐的，序列化是严格定义和明确的。

多亏了这种严格的编码协议 ：


- 无论使用哪种实现方式或编程语言，字段的顺序始终保持不变；
- 因此，在同一数据集上计算出的哈希值是可重复和相同的（严格的确定性*承诺*）；
- 边界可防止数据大小不受控制地增长（例如字段过多）；
- 这种编码方式有利于加密验证，因为每个参与者都清楚地知道如何对数据进行序列化和散列。

在实践中，结构（*模式*）和由此产生的代码（*接口*和相关逻辑）都是经过编译的。描述性语言用于定义契约（类型、字段、规则）并生成严格的二进制格式。编译后的结果是.NET 文件：


- 每个字段的*内存布局*；
- 语义标识符（表明更改变量名是否会对逻辑产生影响，即使内存结构保持不变）。

严格的类型系统还能精确监控变化：对结构的任何修改（甚至字段名称的变化）都能被检测到，并导致整体足迹的变化。

最后，每次编译都会产生一个 "指纹"，这是一个加密标识符，可证明代码（数据、规则、验证）的确切版本。例如，形式为 ：

```txt
BEiLYE-am9WhTW1-oK8cpvw4-FEMtzMrf-mKocuGZn-qWK6YF#ginger-parking-nirvana
```

这样就可以管理共识或实施更新，同时确保网络中使用的版本具有详细的可追溯性。

为防止 RGB 合约的状态在客户端验证时变得过于繁琐，一条共识规则规定，验证计算中涉及的任何数据的最大大小为 `2^16` 字节（64 Kio）。这适用于每个变量或结构：不超过 65536 字节或等效数字（32768 个 16 位整数等）。这也适用于集合（列表、集合、映射），其元素不得超过 `2^16`。

这一限额保证 ：


- 控制状态转换期间可操作数据的最大大小；
- 与用于运行验证脚本的虚拟机 (*AluVM*) 兼容。

#### 验证 != 自主权范式

RGB 的主要创新之一是严格区分两个概念：


- 验证**：检查状态转换是否符合合约规则（业务逻辑、历史记录等）；
- **所有权**（所有权或控制权）：拥有比特币UTXO的事实，使一次性印章得以使用（或关闭），从而实现状态转换。

验证**在 RGB 软件堆栈（库、*承诺*协议等）层面进行。其作用是确保合约的内部规则（金额、权限等）得到遵守。观察员或其他参与者也可以验证数据历史。

而所有权**则完全依赖于比特币的安全性。拥有一个UTXO的私钥，就意味着控制了启动新转换（关闭一次性封印）的能力。因此，即使有人可以看到或验证数据，但如果他们不拥有相关的UTXO，就无法改变状态。

![RGB-Bitcoin](assets/fr/069.webp)

这种方法限制了在更复杂的区块链中遇到的典型漏洞（智能合约的所有代码都是公开的，任何人都可以修改，这有时会导致黑客攻击）。在 RGB 上，攻击者无法简单地与链上状态交互，因为对状态采取行动的权利（*所有权*）受到比特币层的保护。

此外，这种解耦使 RGB 能够与闪电网络自然集成。闪电通道可用于参与和移动 RGB 资产，而无需每次都参与链上*承诺*。我们将在本课程的后续章节中详细介绍 RGB 与 Lightning 的集成。

#### RGB 的共识发展

除了语义代码版本控制外，RGB 还包括一个用于随时间演变或更新合约共识规则的系统。进化有两种主要形式：


- 快进**
- 推回**（法语）

当以前无效的规则变为有效时，就会发生快进。例如，如果合同演变为允许一种新的 `AssignmentType` 类型或一个新的字段.AssignmentType "或.AssignmentType"：


- 这不能与经典的区块链硬分叉相比，因为 RGB 在客户端验证中工作，不会影响区块链的整体兼容性；
- 在实际操作中，这类变更由合约操作中的 `Ffv`（*快进版本*）字段表示；
- 目前的持有者不会受到损害：他们的身份仍然有效；
- 而新受益人（或新用户）则需要更新软件（钱包）以识别新规则。

回推意味着以前有效的规则变为无效。因此，这是规则的 "硬化"，但严格来说并不是软叉：


- 现有持有者可能会受到影响（他们可能会发现自己的资产在新版本中变得过时或无效）；
- 我们可以认为，我们实际上是在创建一个新的协议：谁采用了新规则，谁就脱离了旧规则；
- 发行商可能会决定用新协议重新发行资产，如果用户想同时管理两个版本，就必须维护两个独立的钱包（一个用于旧协议，另一个用于新协议）。

在有关 RGB 合约操作的这一章中，我们探讨了该协议的基本原理。正如您所注意到的，RGB 协议本身的复杂性要求使用许多专业术语。因此，在下一章中，我将为您提供一份词汇表，总结第一部分理论中涉及的所有概念，以及与 RGB 相关的所有技术术语的定义。然后，在下一部分中，我们将实际考察 RGB 合约的定义和实施。

## RGB 术语表

<chapterId>545e16a4-3cca-44a3-9fd5-dbc5868abf97</chapterId>

如果您需要再次查阅 RGB 世界中使用的重要技术术语的简短词汇表（按字母顺序排列），您会发现它非常有用。如果你已经理解了我们在第一节中介绍的所有内容，那么本章并不是必不可少的。

#### AluVM

缩写 AluVM 代表"_算法逻辑单元虚拟机_"，是一种基于寄存器的虚拟机，设计用于智能合约验证和分布式计算。它用于（但不限于）验证 RGB 合约。因此，RGB 合约中包含的脚本或操作可在 AluVM 环境中执行。

欲了解更多信息，请访问[AluVM官方网站](https://www.aluvm.org/)

#### 锚

锚点代表一组客户端数据，用于证明交易中包含唯一的_提交_。在 RGB 协议中，锚点由以下元素组成：


- 见证交易**的比特币交易标识符（TXID）；
- 多议定书承诺（MPC）** ；
- 确定性比特币承诺（DBC）**；
- 如果使用**Tapret**承诺机制，则需要**额外交易证明 (ETP)**（请参阅有关该模式的章节）。

因此，锚点的作用是在特定的比特币交易和经 RGB 协议验证的私人数据之间建立一个可验证的链接。它保证这些数据确实包含在区块链中，而其确切内容不会被公开。

#### 任务

在 RGB 的逻辑中，"赋值 "相当于事务输出，用于修改、更新或创建合约状态中的某些属性。赋值由两个元素组成：


- A **密封圈定义**（指特定的UTXO） ；
- 一个**所有国**（描述与该新所有者相关的国家的数据）。

因此，"分配 "表示状态的一部分（例如资产）现在被分配给一个特定的持有者，该持有者通过与UTXO相连的一次性印章来识别。

#### 业务逻辑

业务逻辑将合同的所有规则和内部操作组合在一起，由其**模式**（即合同本身的结构）描述。它规定了合同的状态如何演变，以及在什么条件下演变。

#### 客户端验证

客户端验证是指各方（客户端）根据协议规则对私下交换的一组数据进行验证的过程。在 RGB 的情况下，这些交换的数据被组合在一起，即所谓的**合约**。比特币协议要求在链上公布所有交易，而 RGB 与之不同，它只允许公开存储承诺（锚定在比特币中），而基本的合约信息（过渡、证明、证明）则保留在链外，只在相关用户之间共享。

#### 承诺

承诺（密码学意义上的）是一个数学对象，记作 "C"，由对结构化数据 "m"（信息）和随机值 "r "的操作确定地推导出来。我们写成 ：

$$
C = \text{commit}(m, r)
$$

该机制包括两项主要操作：


- 承诺**：对信息`m`和随机数`r`应用加密函数，生成`C`；
- 验证**：我们使用 `C`、`m` 信息和 `r` 值来检查该承诺是否正确。函数返回 `True` 或 `False`。

承诺必须尊重两个属性：


- 绑定**：一定不可能找到两个不同的信息产生相同的 `C` ：

$$
m' : \, | \, : m' \neq m \quad \text{and} \quad r' : \, | \, : r' \neq r \quad
$$

例如 ：

$$
\text{verify}(m, r, C) = \text{verify}(m', r', C) \rightarrow \text{True}
$$


- 隐藏**：对 `C` 的了解不得泄露 `m` 的内容。

在 RGB 协议中，比特币交易中包含一个承诺，以证明在特定时间存在某条信息，而不透露信息本身。

#### 寄售

委托***将各方之间交换的数据集中在一起，并在 RGB 中进行客户端验证。托运有两大类：


- 合同委托**：由*签发人*（合同签发人）提供，包括模式、创世纪、接口和接口实现等初始化信息。
- 转账委托**：由付款方（*付款人*）提供。它包含导致终端寄售（即付款方收到的最终状态）的整个状态转换历史。

这些货物不会在区块链上公开记录，而是由相关各方通过自己选择的通信渠道直接交换。

#### 合同

合同是通过 RGB 协议在多个参与者之间以数字方式执行的一组权利。它有一个活动状态和一个业务逻辑，由一个模式定义，其中规定了哪些操作是授权的（转让、扩展等）。合同的状态及其有效性规则在模式中表达。在任何时候，合同都只能根据模式和验证脚本（例如在 AluVM 中运行）所允许的内容进行演变。

#### 合同操作

合同操作是根据模式规则执行的合同状态更新。RGB 中存在以下操作：


- 状态转换** ；
- 创世纪** ；
- 州推广**。

每个操作都通过添加或替换某些数据（全局状态、自有状态......）来修改状态。

#### 合同参与者

合同参与者是指参与合同相关操作的行为者。在 RGB 中，.A、.B、.C 和.D 之间有区别：


- 合同的签发者，它创建了创世纪（合同的起源）；
- 合同双方，即合同状态权利的持有者；
- 公共方，如果合同提供公众可访问的 Valencies，则公共方可建设国家扩展项目。

#### 合同权利

合同权利是指参与 RGB 合同的各方可以行使的各种权利。它们可分为几类：


- 所有权**，与特定 UTXO 的所有权相关（通过_密封定义_）；
- 执行权**，即根据模式建立一个或多个转换（状态转换）的能力；
- 公共权利**，即模式授权某些公共用途，例如通过赎回有效期创建国家扩展。

#### 合同状态

合同状态（Contract State）是指合同在某一特定时刻的当前状态。它可以由公共数据和私人数据组成，反映合同的状态。RGB 将.NET 和.RGB 区分开来：


- 全局状态**，包括合同的公共属性（在创世中设置或通过授权更新添加）；
- 国有**，属于特定的所有者，由其UTXO标识。

#### 确定性比特币承诺 - DBC

确定性比特币承诺（DBC）是一套规则，用于在比特币交易中可证明地、唯一地注册_承诺_。在 RGB 协议中，DBC 有两种主要形式：


- Opret**
- 塔布雷特**

这些机制精确定义了如何在比特币交易的输出或结构中对承诺进行编码，以确保这种承诺是确定可追溯和可验证的。

#### 有向无环图 - DAG

DAG（或*无循环引导图*）是一种无循环图，可实现拓扑调度。区块链（如 RGB 合约的_shards_）可以用 DAG 表示。

欲了解更多信息，请访问[有向无环图](https://en.wikipedia.org/wiki/Directed_acyclic_graph)

#### 雕刻

雕刻是一种可选的数据字符串，合同的历任所有者都可以将其输入合同历史记录。例如，**RGB21** 界面中就有此功能，可在合同历史记录中添加纪念性或描述性信息。

#### 额外交易证明 - ETP

ETP（*额外交易证明*）是锚文件的一部分，包含验证**Tapret*****承诺*（在_taproot_的情况下）所需的额外数据。其中包括 taproot 脚本的内部公钥（_internal PubKey_）和_Script Path Spend_ 的特定信息。

#### 创世纪

创世（Genesis）是指由模式（Schema）管理的数据集，它构成了 RGB 中任何合约的初始状态。它可以与比特币的_创世区块_概念或 Coinbase 交易概念相比较，但这里是在_客户端_和 RGB 令牌层面。

#### 全球国家

全局状态是包含在合约状态中的一组公共属性。它在创世时定义，根据合同规则，可通过授权转换更新。与 "自有状态 "不同，"全局状态 "不属于某个特定实体；它更接近于合同中的公共注册表。

#### 界面

接口是一套指令，用于解码模式或合约操作中编译的二进制数据及其状态，以便用户或其钱包可以读取。它是一个解释层。

#### 接口实施

接口实现是将**接口**与**模式**连接起来的一组声明。它使接口本身能够进行语义转换，从而使用户或相关软件（钱包）能够理解合约的原始数据。

#### 发票

发票的形式是以[base58](https://en.wikipedia.org/wiki/Binary-to-text_encoding#Base58)编码的 URL，其中包含（付款方）构建**状态转换**所需的数据。换句话说，它是一张发票，使交易方（*支付方*）能够创建相应的转换，以转移资产或更新合同状态。

#### 闪电网络

闪电网络是比特币上一个去中心化的支付通道（或称状态通道）网络，由 2/2 个多签名钱包组成。它实现了快速、低成本的链外交易，同时在必要时依靠比特币第一层进行仲裁（或关闭）。

如需了解有关 "闪电 "工作原理的更多信息，我建议您学习另一门课程：

https://planb.network/courses/34bd43ef-6683-4a5c-b239-7cb1e40a4aeb

#### 多协议承诺 - MPC

多协议承诺（MPC）指的是 RGB 中使用的梅克尔树结构，用于在单个比特币交易中包含来自不同合约的多个**过渡包**。其目的是将多个承诺（可能对应不同的合约或不同的资产）集中到一个锚点，以优化区块空间的占用。

#### 国有

自有状态是指合同状态的一部分，该部分包含在转让中，并与特定持有人相关联（通过指向 UTXO 的一次性印章）。例如，这代表了分配给该人的数字资产或特定合同权利。

#### 所有权

所有权是指控制和使用印章定义所引用的UTXO的能力。当一个拥有国与一个UTXO相关联时，该UTXO的拥有者有权根据合约规则转让或演变相关联的国家。

#### 部分签名比特币交易 - PSBT

PSBT（_部分签名比特币交易_）是一种尚未完全签名的比特币交易。它可以在多个实体之间共享，每个实体都可以添加或验证某些元素（签名、脚本......），直到交易被认为可以在链上分发。

欲了解更多信息，请访问[BIP-0174](https://github.com/bitcoin/bips/blob/master/bip-0174.mediawiki)

#### Pedersen 承诺

Pedersen 承诺是一种加密承诺，具有与加法运算**同构的特性。这意味着可以验证两个承诺的总和，而无需透露各自的值。

形式上，如果 ：

$$
C1=\text{commit}(m1,r1) \quad C2=\text{commit}(m2,r2)
$$

然后

$$
C3=C1⋅C2=\text{commit}(m1+m2, r1+r2)
$$

例如，这一属性对于隐藏交换的代币数量非常有用，同时还能验证总数。

更多信息：[Pedersen commitment](https://link.springer.com/chapter/10.1007/3-540-46766-1_9)

#### 兑换

在状态扩展中，Redeem 指的是收回（或利用）先前宣布的**有效性**的行为。由于有效期是一项公共权利，Redeem 允许获得授权的参与者要求特定的合约状态扩展。

#### 模式

RGB 中的模式是一段声明性代码，用于描述管理合同运行的变量、规则和业务逻辑（*业务逻辑*）集。模式定义了状态结构、允许的转换类型和验证条件。

#### 密封件定义

印章定义是转让中将承诺与新持有人拥有的UTXO相关联的部分。换句话说，它指明了条件的位置（在哪个UTXO中），并确定了资产或权利的所有权。

#### 碎片

分片代表 RGB 合约状态转换历史 DAG 中的一个分支。换句话说，它是合约整体历史的一个连贯子集，例如，与自_创世_以来证明特定资产有效性所需的转换序列相对应。

#### 一次性密封件

一次性印章是对一个未知信息的加密承诺，该信息在未来只会公开一次，而且必须为特定受众的所有成员所知。其目的是防止为同一印章创建多个相互竞争的承诺。

#### 储藏室

储藏库是用户为一个或多个 RGB 合约存储的客户端数据集，用于验证（*客户端验证*）。其中包括过渡历史、寄售、有效性证明等。每个持有者只保留其所需的历史记录部分（*碎片*）。

#### 州推广

状态扩展（State Extension）是一种合约操作，用于通过赎回先前声明的**变量**来重新触发状态更新。状态扩展必须由状态转换（更新合约的最终状态）关闭才能生效。

#### 状态转换

状态转换是将 RGB 合约的状态更改为新状态的操作。它可以修改全局状态和/或自有状态数据。在实践中，每个转换都要经过模式规则的验证，并通过_commitment_锚定在比特币区块链中。

#### 直根

指比特币的 Segwit v1 交易格式，由 [BIP341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki) 和 [BIP342](https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki) 引入。Taproot 提高了脚本的保密性和灵活性，尤其是使交易更加紧凑，难以相互区分。

#### 终端托运--托运终点

终端寄售（或_寄售端点_）是*转让寄售*，包含合同的最终状态，包括从收件人发票（*收款人*）创建的状态转换。因此，它是转让的终点，具有证明所有权或状态已转让的必要数据。

#### 过渡包

转换捆绑是一组 RGB 状态转换（属于同一合约），它们都参与了同一****见证交易****比特币。这使得将多个更新或转移捆绑到一个链上锚中成为可能。

#### UTXO（UTXO

比特币UTXO（*未花费交易输出*）由交易哈希值和输出索引（*vout*）定义。它有时也被称为_输出点_。在 RGB 协议中，对UTXO 的引用（通过**密封定义**）可以确定**拥有状态**的位置，即在区块链上持有的属性。

#### 效价

有效期是一种公共权利，本身不需要国家储存，但可以通过**国家延期**赎回。因此，它是一种对所有人（或某些参与者）开放的可能性形式，在合约逻辑中声明，以便在稍后日期进行特定的扩展。

#### 见证交易

见证交易是一种比特币交易，用于关闭包含多协议承诺（MPC）信息的一次性封印。该交易花费或创建一个UTXO，以封印与RGB协议相关的承诺。它可以作为链上证明，证明状态已在特定时间点设定。

# 在 RGB 上编程

<partId>148a7436-d079-56d9-be08-aaa4c14c6b3a</partId>

## 执行 RGB 合同

<chapterId>8333ea5f-51c7-5dd5-b1d7-47d491e58e51</chapterId>

![video](https://youtu.be/Uo1UoxiImsI)

在本章中，我们将仔细研究 RGB 合同是如何定义和实现的。我们将了解 RGB 合约的组成部分、作用以及构建方式。

### RGB 合同的组成部分

到目前为止，我们已经讨论了代表合约起点的**创世纪**，并了解了它如何与*合约操作*的逻辑和协议状态相匹配。然而，RGB 合约的完整定义并不局限于创世纪：它包含三个互补组件，共同构成了实现的核心。

第一个组件称为**模式**。这是一个描述合约基本结构和业务逻辑（*业务逻辑*）的文件。它规定了使用的数据类型、验证规则、允许的操作（如初始令牌发放、转让、特殊条件等）--简而言之，就是规定合同如何运作的总体框架。

第二个组成部分是**界面**。它的重点是用户（推而广之，组合软件）如何与本合同进行交互。它描述了语义，即各种字段和操作的可读性。因此，模式定义了合约在技术上的运作方式，而界面则定义了如何展示和公开这些功能：方法名称、数据显示等。

第三个组成部分是**接口实现**，它是对前两个组成部分的补充，是连接模式和接口的桥梁。换句话说，它将接口所表达的语义与模式中定义的基本规则联系起来。例如，钱包中输入的参数与协议规定的二进制结构之间的转换，或机器语言中验证规则的编译，都将由该实现来管理。

这种模块化是 RGB 的一个有趣特征，因为它允许不同的开发人员小组分别在这些方面（*模式*、*接口*、*实施*）开展工作，只要他们遵循协议的共识规则即可。

总之，每份合同包括 ：


- Genesis**，即合约的初始状态（可类比为定义资产、权利或任何其他可参数化数据的首个所有权的特殊交易）；
- 模式**，描述合同的业务逻辑（数据类型、验证规则等）；
- 接口**，为钱包和人类用户提供了一个语义层，明确了交易的读取和执行；
- 实施**界面，它是业务逻辑和表现形式之间的桥梁，以确保合同定义与用户体验相一致。

![RGB-Bitcoin](assets/fr/070.webp)

值得注意的是，钱包要管理 RGB 资产（无论是可替代代币还是任何类型的权利），必须具备所有这些编译元素： *模式*、*接口*、*接口实现*和*创世纪*。这将通过***合约委托***进行传输，即包含验证客户端合约所需的所有内容的数据包。

为了帮助澄清这些概念，这里有一个汇总表，将 RGB 合约的组成部分与面向对象编程 (OOP) 或以太坊生态系统中已知的概念进行比较：

| RGB 合约组件 | 含义 | OOP 等价物 | 以太坊等价物 | RGB 合约组件

| ---------------------------- | --------------------------------------- | -------------------------------------------------- | ---------------------------------- |

| 类构造函数 | 合同构造函数 | 合同的初始状态

| 类 | 合同业务逻辑

| 合约语义 | 接口（Java）/特质（Rust）/协议（Swift） | ERC 标准 | ERC 标准

| 应用程序二进制接口 (ABI) | Impl (Rust) / Implements (Java) | 语义和逻辑的映射

左侧一栏显示 RGB 协议特有的元素。中间一栏显示了每个组件的具体功能。然后，在 "OOP 等价物 "一栏中，我们可以找到面向对象编程中的等价术语：


- **Genesis** 的作用类似于 *Class 构造函数*：这里是初始化合约状态的地方；
- **模式**是对一个类的描述，即对其属性、方法和基本逻辑的定义；
- ** 接口**对应于 *interfaces* (Java)、*traits* (Rust) 或 *protocols* (Swift)：它们是函数、事件、字段......的公共定义；
- 接口实现***对应于 Rust 中的 *Impl* 或 Java 中的 *Implements*，我们在这里指定代码如何实际执行接口中公布的方法。

在以太坊的语境中，创世更接近于*合约构造器*，模式更接近于合约定义，接口更接近于ERC-20或ERC-721等标准，而接口实现更接近于ABI（*应用二进制接口*），后者规定了与合约交互的格式。

RGB 模块化的优势还在于，不同的利益相关者可以编写自己的接口实现等，只要他们尊重 *模式*的逻辑和 *接口*的语义即可。因此，发行人可以开发新的、更方便用户的前端（接口），而无需修改合同的逻辑；反之，发行人也可以扩展模式以增加功能，并提供新版本的适应接口实现，而旧的实现仍可用于基本功能。

编译新合约时，我们会生成创世（发行或分发资产的第一步）及其组件（模式、接口、接口实现）。之后，合约就可以完全运行，并传播给钱包和用户。这种方法将 Genesis 与这三个组件结合在一起，保证了高度的定制化（每个合约都可以有自己的逻辑）、去中心化（每个人都可以为给定的组件做出贡献）和安全性（验证仍然由协议严格定义，而不像其他区块链那样依赖于任意的链上代码）。

现在，我想仔细研究一下这些组件：**模式**、**接口**和**接口实现**。

### 模式

在上一节中，我们看到在 RGB 生态系统中，合同由多个元素组成：建立初始状态的 "创世纪 "和其他几个补充组件。模式的目的是声明性地描述合同的所有业务逻辑，即数据结构、使用的类型、允许的操作及其条件。因此，它是使合约在客户端运行的一个非常重要的元素，因为每个参与者（例如钱包）都必须检查其接收到的状态转换是否符合模式中定义的逻辑。

模式可以比作面向对象编程（OOP）中的 "类"。一般来说，它是一个定义合约组件的模型，如 .NET Framework 3.0、.NET Framework 4.0、.NET Framework 5.0 和.NET Framework 6.0：


- 不同类型的 "拥有状态 "和 "分配" ；
- 价权，即在某些操作中可以触发（*赎回*）的特殊权利；
- 全局状态字段，用于描述合约的全局、公共和共享属性；
- 创世结构（激活合同的第一个操作） ；
- 允许的状态转换和状态扩展形式，以及这些操作如何修改.NET 文件；
- 与每个操作相关的元数据，用于存储临时或附加信息；
- 决定内部合同数据如何演变的规则（例如，字段是可变的还是可累积的）；
- 被认为有效的操作顺序：例如，需要遵守的转换顺序或需要满足的逻辑条件集。

![RGB-Bitcoin](assets/fr/071.webp)

当 RGB 上资产的*发行方*发布合约时，会提供与之相关的创世和模式。希望与资产进行交互的用户或钱包会检索该模式，以了解合约背后的逻辑，并在日后验证他们将参与的转换是否合法。

对于接收 RGB 资产信息（如令牌转让）的任何人来说，第一步都是根据模式验证该信息。这包括使用模式汇编来.NET Framework 3.0：


- 检查 "自有状态"、"赋值 "和其他元素的定义是否正确，以及它们是否遵守强加的类型（所谓的 "严格类型系统 "*）；
- 检查过渡规则（验证脚本）是否符合要求。这些脚本可通过 AluVM 运行，AluVM 存在于客户端，负责验证业务逻辑（转账金额、特殊条件等）的一致性。

实际上，模式并不是可执行代码，这在存储链上代码的区块链（以太坊上的 EVM）中可以看到。相反，RGB 将业务逻辑（声明性）与区块链上的可执行代码（仅限于加密锚点）分离开来。因此，模式决定了规则，但根据客户端验证原则，这些规则的应用发生在区块链之外，在每个参与者的网站上。

RGB 应用程序在使用模式之前必须对其进行编译。编译后会生成一个二进制文件（如 `.rgb`）或一个加密的二进制文件（`.rgba`）。当钱包导入该文件时，它会知道 .RGB 文件的内容：


- 由于采用了严格的类型系统，每种数据类型（整数、结构、数组......）看起来都是什么样的；
- 创世纪应如何构建（以了解资产初始化）；
- 不同类型的操作（状态转换、状态扩展）及其如何修改状态；
- AluVM 引擎用于检查操作有效性的脚本规则（在模式中引入）。

如前几章所述，*严格类型系统*为我们提供了一种稳定、确定的编码格式：所有变量，无论是自有状态（Owned State）、全局状态（Global State）还是值域（Valencies），都有精确的描述（大小、必要时的下限和上限、有符号或无符号类型等）。还可以定义嵌套结构，例如支持复杂的用例。

模式可选择引用根 "SchemaId"，这有助于重用现有的基本结构（模板）。通过这种方式，您可以从一个已经验证过的模板演化出一个合约或创建变体（例如一种新的标记类型）。这种模块性避免了重新创建整个合约的需要，并促进了最佳实践的标准化。

另一个要点是，状态演化（转移、更新等）的逻辑在模式中以脚本、规则和条件的形式进行描述。因此，如果合同设计者希望授权重发或强制执行烧毁机制（销毁代币），他可以在模式的验证部分为 AluVM 指定相应的脚本。

#### 与可编程链上区块链的区别

以太坊等系统将智能合约代码（可执行文件）写入区块链本身，而 RGB 与之不同，它以编译声明文件的形式将合约（其逻辑）存储在链外。这意味着，.NET 和 RGB 都可以在区块链上运行：


- 比特币网络的每个节点都不运行图灵完备的虚拟机。RGB 合约的规则不是在区块链上执行的，而是在每个希望验证状态的用户中执行的；
- 合约数据不会污染区块链：只有加密证据（*承诺*）才会嵌入比特币交易（通过 "Tapret "或 "Opret"）；
- 模式可以更新或拒绝（*快进*、*后推*等），而不需要在比特币区块链上分叉。钱包只需导入新的模式并适应共识变化即可。

#### 发行人和用户的使用

当*发行人*创造一种资产（例如，一种非通货膨胀的可替代代币）时，它准备............：


- 描述排放、转移等规则的模式；
- 与本模式相适应的创世纪（包括已发行代币的总数、初始所有者的身份、重新发行的任何特殊 Valencies 等）。

然后，它将编译后的模式（一个 `.rgb` 文件）提供给用户，这样，任何收到此标记传输的人都可以在本地检查操作的一致性。如果没有该模式，用户就无法解释状态数据或检查其是否符合合约规则。

因此，当新钱包希望支持一种资产时，只需集成相关的模式即可。这种机制可以在不改变钱包软件基础的情况下，为新的 RGB 资产类型添加兼容性：只需导入二进制模式并理解其结构即可。

模式定义了 RGB 中的业务逻辑。它列出了合同的演变规则、数据结构（自有状态、全局状态、有效性）以及相关的验证脚本（可由 AluVM 执行）。有了这份声明性文件，合约的定义（编译文件）与规则的实际执行（客户端）就明确分开了。这种解耦赋予了 RGB 极大的灵活性，使其能够在避免可编程链上区块链的复杂性和典型缺陷的同时，实现广泛的用例（可替换代币、NFT、更复杂的合约）。

#### 模式示例

让我们来看一个 RGB 合约模式的具体例子。这是 Rust 文件 `nia.rs`（"*Non-Inflatable Assets*"的首字母缩写）中的一个摘要，它定义了一种可替代代币的模型，这种代币在初始供应量之外不能再发行（一种非通胀资产）。这种类型的代币在 RGB 宇宙中相当于以太坊上的 ERC20，即遵守某些基本规则（如转让、供应初始化等）的可替代代币。

在深入研究代码之前，有必要回顾一下 RGB 模式的一般结构。在 RGB 模式中，有一系列以 .NET Framework 3.0 为框架的声明：


- 可能的 `SchemaId`，表示使用了另一个基本模式作为模板；
- 全球国家**和自有国家**（及其严格类型） ；
- 阀值**（如有）；
- 可以引用这些状态和价态的**操作**（创世、状态转换、状态扩展）；
- 用于描述和验证数据的**严格类型系统**；
- 验证脚本**（通过 AluVM 运行）。

![RGB-Bitcoin](assets/fr/072.webp)

下面的代码显示了 Rust 模式的完整定义。我们将按照下面的注释 (1) 至 (9) 逐部分进行注释：

```rust
// ===== PART 1: Function Header and SubSchema =====
fn nia_schema() -> SubSchema {
// definitions of libraries and variables
// ===== PART 2: General Properties (ffv, subset_of, type_system) =====
Schema {
ffv: zero!(),
subset_of: None,
type_system: types.type_system(),
// ===== PART 3: Global States =====
global_types: tiny_bmap! {
GS_NOMINAL => GlobalStateSchema::once(types.get("RGBContract.DivisibleAssetSpec")),
GS_DATA => GlobalStateSchema::once(types.get("RGBContract.ContractData")),
GS_TIMESTAMP => GlobalStateSchema::once(types.get("RGBContract.Timestamp")),
GS_ISSUED_SUPPLY => GlobalStateSchema::once(types.get("RGBContract.Amount")),
},
// ===== PART 4: Owned Types =====
owned_types: tiny_bmap! {
OS_ASSET => StateSchema::Fungible(FungibleType::Unsigned64Bit),
},
// ===== PART 5: Valencies =====
valency_types: none!(),
// ===== PART 6: Genesis: Initial Operations =====
genesis: GenesisSchema {
metadata: Ty::<SemId>::UNIT.id(None),
globals: tiny_bmap! {
GS_NOMINAL => Occurrences::Once,
GS_DATA => Occurrences::Once,
GS_TIMESTAMP => Occurrences::Once,
GS_ISSUED_SUPPLY => Occurrences::Once,
},
assignments: tiny_bmap! {
OS_ASSET => Occurrences::OnceOrMore,
},
valencies: none!(),
},
// ===== PART 7: Extensions =====
extensions: none!(),
// ===== PART 8: Transitions: TS_TRANSFER =====
transitions: tiny_bmap! {
TS_TRANSFER => TransitionSchema {
metadata: Ty::<SemId>::UNIT.id(None),
globals: none!(),
inputs: tiny_bmap! {
OS_ASSET => Occurrences::OnceOrMore,
},
assignments: tiny_bmap! {
OS_ASSET => Occurrences::OnceOrMore,
},
valencies: none!(),
}
},
// ===== PART 9: Script AluVM and Entry Points =====
script: Script::AluVM(AluScript {
libs: confined_bmap! { alu_id => alu_lib },
entry_points: confined_bmap! {
EntryPoint::ValidateGenesis => LibSite::with(FN_GENESIS_OFFSET, alu_id),
EntryPoint::ValidateTransition(TS_TRANSFER) => LibSite::with(FN_TRANSFER_OFFSET, alu_id),
},
}),
}
}
```


- (1) - 函数头和子模式**

nia_schema() "函数返回一个 "SubSchema"，表示该模式可部分继承自一个更通用的模式。在 RGB 生态系统中，这种灵活性使得重用主模式的某些标准元素成为可能，然后再定义特定于相关合约的规则。在此，我们选择不启用继承，因为 `subset_of` 将是 `None`。


- (2) - 一般属性：ffv、subset_of、type_system**

ffv "属性对应合约的*快进*版本。这里的`0!()`值表示我们处于版本 0 或该模式的初始版本。如果以后希望添加新的功能（新的操作类型等），可以递增该版本，以表示协商一致的变更。

subset_of：None` 属性确认不存在继承。`type_system` 字段指的是已在 `types` 库中定义的严格类型系统。这一行表示合约使用的所有数据都使用了相关库提供的严格序列化实现。


- (3) - 全球国家

在 `global_types` 块中，我们声明了四个元素。我们使用关键字，如 `GS_NOMINAL` 或 `GS_ISSUED_SUPPLY`，以便以后引用它们：


- GS_NOMINAL "指的是 "DivisibleAssetSpec "类型，该类型描述了所创建标记的各个字段（全名、代码、精度......）；
- `GS_DATA` 表示一般数据，如免责声明、元数据或其他文本；
- GS_TIMESTAMP "指的是发布日期；
- `GS_ISSUED_SUPPLY` 设置总供应量，即可创建代币的最大数量。

关键字 "once(...) "表示每个字段只能出现一次。


- (4) - 自有类型

在 `owned_types` 中，我们声明了 `OS_ASSET`，它描述了可互换状态。我们使用`StateSchema::Fungible(FungibleType::Unsigned64Bit)`，表示资产（代币）的数量存储为 64 位无符号整数。因此，任何交易都将发送一定数量单位的代币，并根据这种严格类型化的数字结构进行验证。


- (5) - Valencies**

我们指出 "Valency_types: none!()"，这意味着本模式中没有 Valencies，换句话说，没有特殊或额外的权限（如重新发布、有条件烧毁等）。如果模式中包含任何类型，则应在本节中声明。


- (6) - 创世纪：第一次行动

在这里，我们进入了宣布合同操作的部分。创世纪》是由 ：


- 没有`metadata`（字段`metadata：Ty::<SemId>::UNIT.id(None)`) ；
- 必须各出现一次（"Once"）的全局状态；
- 任务列表，其中 `OS_ASSET` 必须出现 `一次或多次`。这意味着 Genesis 需要至少一个 `OS_ASSET` 分配（初始持有人）；
- 无 Valency : `valencies: none!()`。

这就是我们如何限制初始代币发行的定义：我们必须声明发行的供应品（`GS_SISSUED_SUPPLY`），加上至少一个持有者（类型为`OS_ASSET`的自有状态）。


- (7) - 扩展

扩展：无!() "字段表示本合约中未预见任何状态扩展。这意味着在转换之前没有赎回数字权利（有效期）或执行状态扩展的操作。所有操作都通过创世纪或状态转换完成。


- (8) - 过渡：TS_TRANSFER

在 `transitions` 中，我们定义了 `TS_TRANSFER` 类型的操作。我们解释说：


- 它没有元数据；
- 它不会修改全局状态（全局状态已在《创世纪》中定义）；
- 它将一个或多个 `OS_ASSET` 作为输入。这意味着它必须使用现有的 "拥有状态"；
- 它创建（"分配"）至少一个新的 "OS_ASSET"（换句话说，接收者或接收者收到令牌）；
- 它不会产生新的 Valency。

这是对基本转账行为的模拟，基本转账会消耗UTXO 上的代币，然后为接收方创建新的自有国，从而保持输入和输出之间的总量相等。


- (9) - AluVM 脚本和入口点**（法语）

最后，我们声明一个 AluVM 脚本 (`Script::AluVM(AluScript { ... })`)。该脚本包含 ：


- 验证过程中要使用的一个或多个外部库 (`libs`)；
- 指向 AluVM 代码中函数偏移的入口点，对应于 Genesis (`ValidateGenesis`) 和每个已声明的转换 (`ValidateTransition(TS_TRANSFER)`)的验证。

该验证码负责应用业务逻辑。例如，它将检查.NET Framework 2.0 和.NET Framework 3.0：


- 在创世过程中未超过 `GS_ISSUED_SUPPLY` 值；
- 输入"（花费的代币）总和等于 "TS_TRANSFER "的 "分配"（收到的代币）总和。

如果不遵守这些规则，过渡将被视为无效。

这个 "*非充气可互换资产*"模式的示例让我们更好地理解了简单的 RGB 可互换令牌合约的结构。我们可以清楚地看到数据描述（全局和自有状态）、操作声明（创世、转换、扩展）和验证实现（AluVM 脚本）之间的分离。得益于这种模式，代币的行为就像经典的可替代代币，但仍在客户端进行验证，不依赖链上基础设施来执行代码。在比特币区块链中只锚定加密承诺。

### 界面

接口层的目的是使用户（人工阅读）和组合（软件阅读）都能阅读和操作合同。因此，界面的作用类似于面向对象编程语言（Java、Rust trait 等）中的接口，它揭示并阐明了合同的功能结构，但不一定揭示业务逻辑的内部细节。

Schema 纯粹是声明性的，编译成二进制文件后很难直接使用，而 Interface 则不同，它提供了 .NET 所需的读取键：


- 列出并说明合同中包括的全球国家和拥有国；
- 访问每个字段的名称和值，以便显示（例如，查找令牌的股票代码、最大金额等）；
- 通过将数据与可理解的名称关联起来（例如，通过明确指定 "金额 "而不是二进制标识符来执行转账），解释和构建合约操作（创始、状态转换或状态扩展）。

![RGB-Bitcoin](assets/fr/073.webp)

有了该接口，您就可以在钱包中编写代码，直接操作 "代币数量"、"资产名称 "等标签，而不是操作字段。这样，合约管理就变得更加直观。这样，合约管理就变得更加直观了。

#### 一般操作

这种方法有很多优点：


- 标准化：**

同一类型的合约可以由一个标准接口来支持，并在多个钱包实现之间共享。这有利于兼容性和代码重用。


- 明确区分模式和接口：**

在 RGB 设计中，模式（业务逻辑）和界面（展示和操作）是两个独立的实体。编写合同逻辑的开发人员可以专注于模式，而不必担心人体工程学或数据表示问题，而另一个团队（或同一团队，但在不同的时间轴上）则可以开发界面。


- 灵活演变：**

资产发行后，可以修改或添加接口，而无需更改合约本身。这是与一些链上智能合约系统的主要区别，在这些系统中，接口（通常与执行代码混合在一起）被冻结在区块链中。


- 多接口能力

同一个合约可以通过不同的接口公开，以满足不同的需求：一个简单的接口供最终用户使用，另一个更高级的接口供需要管理复杂配置操作的发行商使用。然后，钱包可以根据用途选择导入哪个接口。

![RGB-Bitcoin](assets/fr/074.webp)

实际上，当钱包检索 RGB 合约（通过`.rgb`或`.rgba`文件）时，它也会导入相关的接口，并对其进行编译。例如，在运行时，钱包可以.....：


- 浏览状态列表并读取其名称，以便在用户界面上显示 Ticker、初始金额、发行日期等信息，而不是无法读取的数字标识符；
- 使用显式参数名构建操作（如转账）：它可以在表单中为用户提供一个 "金额 "字段，并将此信息转换为合约所期望的严格类型字段，而不是编写 "分配 { OS_ASSET => 1 }"。

#### 与以太坊和其他系统的区别

在以太坊上，接口（通过 ABI（*应用程序二进制接口*）描述）通常来自链上存储的代码（智能合约）。在不触及合约本身的情况下，修改接口的特定部分可能成本很高或很复杂。然而，RGB 完全基于链外逻辑，数据锚定在比特币上的*承诺*中。这种设计使修改接口（或其实现）成为可能，而不会影响合约的基本安全性，因为业务规则的验证仍在模式和引用的 AluVM 代码中进行。

#### 界面汇编

与模式（Schema）一样，"接口"（Interface）也是在源代码中定义的（通常使用 Rust 语言），并编译成`.rgb`或`.rgba`文件。这个二进制文件包含了钱包 .NET 所需的所有信息：


- 通过名称识别字段 ；
- 将每个字段（及其值）链接到合同中定义的严格系统类型；
- 了解允许的不同操作以及如何构建这些操作。

界面导入后，钱包就能正确显示合约，并向用户提出互动建议。

### LNP/BP 协会标准化接口

在 RGB 生态系统中，接口用于为合同的数据和操作赋予可读和可操作的含义。因此，接口是对模式的补充，而模式描述的是内部业务逻辑（严格类型、验证脚本等）。在本节中，我们将介绍 LNP/BP 协会为常见合约类型（可互换代币、NFT 等）开发的标准接口。

需要提醒的是，每个接口都描述了如何在钱包端显示和操作合约，清楚地命名了字段（如`spec`、`ticker`、`issuedSupply`......）并定义了可能的操作（如`Transfer`、`Burn`、`Rename`......）。目前已有多个接口投入使用，但未来还会有越来越多的接口投入使用。

#### 一些随时可用的界面

**RGB20** 是可替代资产的接口，可与以太坊的 ERC20 标准相媲美。不过，它更进一步，提供了更广泛的功能：


- 例如，资产发行后可以重新命名（更改*标签*或全名），或调整其精度（*股票分割*）；
- 它还可以描述二次再发行（有限或无限）以及先烧毁后置换的机制，以便授权发行人在某些条件下销毁资产，然后再重新创造资产；

例如，RGB20 接口可连接到**非膨胀资产（NIA）计划**（该计划规定初始供应量不可膨胀），或根据需要连接到其他更先进的计划。

**RGB21** 涉及 NFT 类型的合同，或更广泛地涉及任何独特的数字内容，如数字媒体（图像、音乐等）的表示。除了描述单一资产的发行和转让外，它还包括以下功能：.........：


- 集成支持在合同中直接包含文件（最多 16 MB）（用于客户端检索）；
- 所有者可在历史记录中输入 "*雕刻*"，以证明过去对 NFT 的所有权。

**RGB25** 是一种混合标准，结合了可互换性和不可互换性两个方面。它专为部分可互换资产（如房地产标记化）而设计，在这种情况下，您希望拆分财产，同时保留与单一根资产的链接（换句话说，您有房子的可互换部分，但链接到不可互换的房子）。从技术上讲，该接口可与**可收集可互换资产*（CFA）**模式相连接，后者考虑到了在追踪原始资产的同时进行拆分的概念。

#### 正在开发的接口

其他接口计划用于更专业的用途，但尚未推出：


- RGB22**，专门用于数字身份，以管理 RGB 生态系统中的标识符和链上配置文件；
- RGB23**，用于高级时间戳记，使用了 *Opentimestamps* 的一些理念，但具有可追溯功能；
- RGB24**，其目标是建立一个类似于*以太坊名称服务*的去中心化域名系统（DNS）；
- RGB26**，旨在以更复杂的形式（治理、投票等）管理 DAO（*去中心化自治组织*）；
- RGB30**, 与 RGB20 非常相似，但考虑到分散初始发行和使用国家扩展的特殊性。这将用于重新发行由多个实体管理或受更严格条件限制的资产。

当然，根据您咨询本课程的日期，这些界面可能已经可以运行和访问。

#### 界面示例

这段 Rust 代码片段展示了一个 [RGB20](https://github.com/RGB-WG/rgb-std/blob/master/src/interface/rgb20.rs) 接口（可替换资产）。这段代码来自标准 RGB 库中的 `rgb20.rs` 文件。让我们来看看它，以了解 Interface 的结构，以及它是如何在业务逻辑（在模式中定义）与暴露给钱包和用户的功能之间架起一座桥梁的。

```rust
// ...
fn rgb20() -> Iface {
let types = StandardTypes::with(rgb20_stl());
Iface {
version: VerNo::V1,
name: tn!("RGB20"),
global_state: tiny_bmap! {
fname!("spec") => GlobalIface::required(types.get("RGBContract.DivisibleAssetSpec")),
fname!("data") => GlobalIface::required(types.get("RGBContract.ContractData")),
fname!("created") => GlobalIface::required(types.get("RGBContract.Timestamp")),
fname!("issuedSupply") => GlobalIface::one_or_many(types.get("RGBContract.Amount")),
fname!("burnedSupply") => GlobalIface::none_or_many(types.get("RGBContract.Amount")),
fname!("replacedSupply") => GlobalIface::none_or_many(types.get("RGBContract.Amount")),
},
assignments: tiny_bmap! {
fname!("inflationAllowance") => AssignIface::public(OwnedIface::Amount, Req::NoneOrMore),
fname!("updateRight") => AssignIface::public(OwnedIface::Rights, Req::Optional),
fname!("burnEpoch") => AssignIface::public(OwnedIface::Rights, Req::Optional),
fname!("burnRight") => AssignIface::public(OwnedIface::Rights, Req::NoneOrMore),
fname!("assetOwner") => AssignIface::private(OwnedIface::Amount, Req::NoneOrMore),
},
valencies: none!(),
genesis: GenesisIface {
metadata: Some(types.get("RGBContract.IssueMeta")),
global: tiny_bmap! {
fname!("spec") => ArgSpec::required(),
fname!("data") => ArgSpec::required(),
fname!("created") => ArgSpec::required(),
fname!("issuedSupply") => ArgSpec::required(),
},
assignments: tiny_bmap! {
fname!("assetOwner") => ArgSpec::many(),
fname!("inflationAllowance") => ArgSpec::many(),
fname!("updateRight") => ArgSpec::optional(),
fname!("burnEpoch") => ArgSpec::optional(),
},
valencies: none!(),
errors: tiny_bset! {
SUPPLY_MISMATCH,
INVALID_PROOF,
INSUFFICIENT_RESERVES
},
},
transitions: tiny_bmap! {
tn!("Transfer") => TransitionIface {
optional: false,
metadata: None,
globals: none!(),
inputs: tiny_bmap! {
fname!("previous") => ArgSpec::from_non_empty("assetOwner"),
},
assignments: tiny_bmap! {
fname!("beneficiary") => ArgSpec::from_non_empty("assetOwner"),
},
valencies: none!(),
errors: tiny_bset! {
NON_EQUAL_AMOUNTS
},
default_assignment: Some(fname!("beneficiary")),
},
tn!("Issue") => TransitionIface {
optional: true,
metadata: Some(types.get("RGBContract.IssueMeta")),
globals: tiny_bmap! {
fname!("issuedSupply") => ArgSpec::required(),
},
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_non_empty("inflationAllowance"),
},
assignments: tiny_bmap! {
fname!("beneficiary") => ArgSpec::from_many("assetOwner"),
fname!("future") => ArgSpec::from_many("inflationAllowance"),
},
valencies: none!(),
errors: tiny_bset! {
SUPPLY_MISMATCH,
INVALID_PROOF,
ISSUE_EXCEEDS_ALLOWANCE,
INSUFFICIENT_RESERVES
},
default_assignment: Some(fname!("beneficiary")),
},
tn!("OpenEpoch") => TransitionIface {
optional: true,
metadata: None,
globals: none!(),
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_required("burnEpoch"),
},
assignments: tiny_bmap! {
fname!("next") => ArgSpec::from_optional("burnEpoch"),
fname!("burnRight") => ArgSpec::required()
},
valencies: none!(),
errors: none!(),
default_assignment: Some(fname!("burnRight")),
},
tn!("Burn") => TransitionIface {
optional: true,
metadata: Some(types.get("RGBContract.BurnMeta")),
globals: tiny_bmap! {
fname!("burnedSupply") => ArgSpec::required(),
},
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_required("burnRight"),
},
assignments: tiny_bmap! {
fname!("future") => ArgSpec::from_optional("burnRight"),
},
valencies: none!(),
errors: tiny_bset! {
SUPPLY_MISMATCH,
INVALID_PROOF,
INSUFFICIENT_COVERAGE
},
default_assignment: None,
},
tn!("Replace") => TransitionIface {
optional: true,
metadata: Some(types.get("RGBContract.BurnMeta")),
globals: tiny_bmap! {
fname!("replacedSupply") => ArgSpec::required(),
},
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_required("burnRight"),
},
assignments: tiny_bmap! {
fname!("beneficiary") => ArgSpec::from_many("assetOwner"),
fname!("future") => ArgSpec::from_optional("burnRight"),
},
valencies: none!(),
errors: tiny_bset! {
NON_EQUAL_AMOUNTS,
SUPPLY_MISMATCH,
INVALID_PROOF,
INSUFFICIENT_COVERAGE
},
default_assignment: Some(fname!("beneficiary")),
},
tn!("Rename") => TransitionIface {
optional: true,
metadata: None,
globals: tiny_bmap! {
fname!("new") => ArgSpec::from_required("spec"),
},
inputs: tiny_bmap! {
fname!("used") => ArgSpec::from_required("updateRight"),
},
assignments: tiny_bmap! {
fname!("future") => ArgSpec::from_optional("updateRight"),
},
valencies: none!(),
errors: none!(),
default_assignment: Some(fname!("future")),
},
},
extensions: none!(),
error_type: types.get("RGB20.Error"),
default_operation: Some(tn!("Transfer")),
type_system: types.type_system(),
}
}
```

在这个界面中，我们可以看到与模式结构的相似之处：我们可以找到全局状态、自有状态、合约操作（生成和转换）以及错误处理的声明。但界面的重点是如何为钱包或其他应用程序展示和操作这些元素。

与 Schema 的区别在于类型的性质。Schema 使用严格的类型（如 `FungibleType::Unsigned64Bit`）和技术性更强的标识符。接口使用字段名、宏（`fname!()`、`tn!()`）和参数类引用（`ArgSpec`、`OwnedIface::Rights`......）。这样做的目的是为了便于理解功能和组织钱包中的元素。

此外，只要与最终验证的客户端逻辑保持一致，"接口 "还可为基本模式引入额外功能（例如管理 "burnEpoch "权）。模式中的 AluVM "脚本 "部分将确保加密有效性，而 "接口 "则描述用户（或钱包）如何与这些状态和转换进行交互。

#### 全局状态和任务

在 "global_state "部分，我们可以找到 "spec"（资产描述）、"data"、"created"、"issuedSupply"、"burnedSupply"、"replacedSupply "等字段。这些都是钱包可以读取和显示的字段。例如


- `spec` 将显示令牌配置；
- issuedSupply "或 "burnedSupply "提供了已发行或已烧毁的代币总数，等等。

在 "分配 "部分，我们定义了各种角色或权限。例如


- `assetOwner` 与代币的持有相对应（它是可互换的 *Owned State* ）；
- `burnRight`对应于燃烧代币的能力；
- updateRight` 与重命名资产的权利相对应。

public "或 "private "关键字（例如 `AssignIface::public(...)`）表示这些状态是可见的（"public"）还是保密的（"private"）。至于 `Req::NoneOrMore`、`Req::Optional`，它们表示预期出现的情况。

#### 起源与过渡

创世 "部分描述了如何初始化资产：


- spec"、"data"、"created "和 "issuedSupply "字段为必填字段（"ArgSpec::required()"）；
- 资产所有者 "等赋值可以有多个副本（"ArgSpec::many()"），从而可以将代币分配给多个初始持有者；
- Genesis 中可能包含（也可能不包含）"通胀允许值 "或 "燃烧纪元 "等字段。

然后，对于每个转换（"传输"、"发布"、"刻录"......），"接口 "定义了操作希望将哪些字段作为输入，操作将产生哪些字段作为输出，以及可能出现的任何错误。例如

**Transition :**


- 输入： `previous` → 必须是一个 `assetOwner` ；
- 分配： `beneficiary` → 将成为新的 `assetOwner` ；
- 错误："NON_EQUAL_AMOUNTS"（因此，钱包可以处理输入总和与输出总和不一致的情况）。

**Transition `Issue` :**


- 可选项（"optional: true"），因为附加排放不一定激活；
- 输入：`used` → `inflationAllowance`，即添加更多代币的权限；
- 分配：受益人"（收到的新代币）和 "未来"（剩余的 "通胀补贴"）；
- 可能出现的错误：SUPPLY_MISMATCH`、`ISSUE_EXCEEDS_ALLOWANCE` 等。

**燃烧过渡：**


- 输入： `used` → a `burnRight` ；
- Globals : `burnedSupply` required ；
- 任务：如果我们还没有烧掉所有东西，`future` → `burnRight` 的可能延续；
- 错误：供应不匹配"、"无效证明"、"覆盖不足"。

因此，每项操作都以钱包可读的方式进行描述。这样就可以显示一个图形界面，让用户一目了然："您有权焚烧。您想烧掉多少钱？代码知道如何填写 "burnedSupply "字段并检查 "burnRight "是否有效。

总之，重要的是要记住，无论接口多么完整，它本身并不能定义合约的内部逻辑。核心工作由**模式**完成，其中包括严格类型、创世纪结构、转换等。接口只是以更直观和命名的方式公开这些元素，供应用程序使用。

得益于 RGB 的模块性，用户无需重写整个合同即可对界面进行升级（例如，通过添加 "Rename "转换、纠正字段显示等）。只要更新了 `.rgb` 或 `.rgba` 文件，该界面的用户就能立即从这些改进中受益。

但一旦声明了接口，就需要将其链接到相应的模式。这是通过 *** 接口实现****完成的，它规定了如何将每个命名字段（如 `fname!("assetOwner")`）映射到模式中定义的严格 ID（如 `OS_ASSET`）。例如，这可确保当钱包操作 "burnRight "字段时，该状态在模式中描述了焚烧代币的能力。

### 接口实施

在 RGB 架构中，我们看到每个组件（模式、接口等）都可以独立开发和编译。但是，仍有一个不可或缺的元素将这些不同的构件联系在一起：***接口实现***。这就是将模式（业务逻辑方面）中定义的标识符或字段明确映射到接口（展示和用户交互方面）中声明的名称。这样，当钱包加载合约时，就能准确了解哪个字段对应什么，以及接口中的操作名称与模式的逻辑关系。

重要的一点是，"接口实现 "并不一定要公开模式的所有功能，也不一定要公开接口的所有字段：它可以仅限于一个子集。实际上，这样就可以限制或过滤模式的某些方面。例如，模式可以有四种操作类型，但实现接口在给定上下文中只能映射其中两种。相反，如果某个接口提出了额外的端点，我们可以选择不在这里实现它们。

下面是接口实现的一个经典示例，我们将一个 *Non-Inflatable Asset* (NIA) 模式与 RGB20 接口关联起来：

```rust
fn nia_rgb20() -> IfaceImpl {
let schema = nia_schema();
let iface = Rgb20::iface();
IfaceImpl {
version: VerNo::V1,
schema_id: schema.schema_id(),
iface_id: iface.iface_id(),
script: none!(),
global_state: tiny_bset! {
NamedField::with(GS_NOMINAL, fname!("spec")),
NamedField::with(GS_DATA, fname!("data")),
NamedField::with(GS_TIMESTAMP, fname!("created")),
NamedField::with(GS_ISSUED_SUPPLY, fname!("issuedSupply")),
},
assignments: tiny_bset! {
NamedField::with(OS_ASSET, fname!("assetOwner")),
},
valencies: none!(),
transitions: tiny_bset! {
NamedType::with(TS_TRANSFER, tn!("Transfer")),
},
extensions: none!(),
}
}
```

在此实施界面中，.NET Framework 3.0.1.1.1.将对.NET Framework 3.0.1.1.1.进行详细说明：


- 我们通过 `nia_schema()` 明确引用模式，通过 `Rgb20::iface()` 明确引用接口。调用`schema.schema_id()`和`iface.iface_id()`是为了在编译时锚定接口实现（关联这两个组件的加密标识符）；
- 在模式元素和接口元素之间建立映射。例如，模式中的 `GS_NOMINAL` 字段与接口中的字符串 `"spec"` 相链接（`NamedField::with(GS_NOMINAL, fname!("spec") `）。操作也是如此，例如 `TS_TRANSFER`，我们将其链接到 Interface 中的 `"Transfer"`...；
- 我们可以看到，这里没有 Valencies (`valencies:none!()`)或 extensions (`extensions:none!()`)，这说明 NIA 合约没有使用这些功能。

编译后的结果是一个单独的`.rgb`或`.rgba`文件，除了模式和接口外，还将导入钱包。这样，软件就知道如何将该 NIA 合约（其逻辑由其模式描述）与 "RGB20 "接口（为可替换代币提供人称和交互模式）具体连接起来，并将该接口实现作为两者之间的网关。

#### 为什么要单独实现接口？

分离增强了灵活性。一个模式可以有多个不同的接口实现，每个接口实现映射一组不同的功能。此外，接口实现本身也可以发展或重写，而无需更改模式或接口。这保留了 RGB 的模块化原则：只要遵守协议规定的兼容性规则（相同的标识符、类型的一致性等），每个组件（模式、接口、接口实现）都可以独立地进行版本控制和更新。

在具体使用中，当钱包加载合同时，必须 ：


- 加载已编译的**模式**（了解业务逻辑结构）；
- 加载已编译的**接口**（了解名称和用户端操作） ；
- 加载已编译的**接口实现**（将模式逻辑与接口名称联系起来，逐个操作，逐个字段）。




- 限制某些用户的某些操作：例如，提供部分实施界面，只提供基本传输功能，而不提供刻录或更新功能；
- 变更展示：设计一个接口实现，重新命名接口中的字段或以不同方式映射它，而不改变合同的基础；
- 支持多种方案：钱包可以为同一界面类型加载多个界面实现，以处理不同的方案（不同的令牌逻辑），前提是它们的结构是兼容的。

在下一章中，我们将了解合同转让的运作方式以及 RGB 发票的生成方式。

## 合同转让

<chapterId>f043a307-d420-5752-b0d7-ebfd845802c0</chapterId>

![video](https://youtu.be/sVoKIi-1XbY)

在本章中，我们将分析 RGB 生态系统中的合约转让过程。为了说明这一点，我们将以爱丽丝和鲍勃为例来说明，他们是我们通常所说的希望交换 RGB 资产的主角。我们还将展示 `rgb` 命令行工具的一些命令摘录，以了解其实际运行情况。

### 了解 RGB 合同转移

让我们以 Alice 和 Bob 之间的转账为例。在这个例子中，我们假设 Bob 刚刚开始使用 RGB，而 Alice 已经在她的钱包中持有 RGB 资产。我们将看到鲍勃如何设置他的环境，导入相关合约，然后向爱丽丝请求转账，最后爱丽丝如何在比特币区块链上进行实际交易。

#### 1) 安装 RGB 钱包

首先，鲍勃需要安装一个 RGB 钱包，即与协议兼容的软件。一开始不包含任何合约。鲍勃还需要.NET Framework：


- 用于管理 UTXOs 的比特币钱包；
- 与比特币节点（或 Electrum 服务器）的连接，以便识别UTXOs 并在网络上传播交易。

需要提醒的是，RGB 中的 **Owned States** 指的是比特币 UTXOs。因此，我们必须始终能够在包含指向 RGB 数据的加密承诺（"Tapret "或 "Opret"）的比特币交易中管理和使用 UTXO。

#### 2) 获取合同信息

然后，鲍勃需要检索他感兴趣的合同数据。这些数据可以通过任何渠道传播：网站、电子邮件、信息应用程序......在实践中，这些数据会以***委托***的形式组合在一起，即一个包含 .NET Framework 2.0 和 .NET Framework 3.0 的小数据包：


- 创始**，定义合同的初始状态；
- **模式**，描述业务逻辑（严格类型、验证脚本等）；
- **接口**，用于定义表现层（字段名称、可访问操作）；
- 接口实现**，将模式与接口具体联系起来。

![RGB-Bitcoin](assets/fr/075.webp)

由于每个组件的重量一般不超过 200 字节，因此总大小通常为几千字节。也可以在 Base58 中通过抗审查渠道（如 Nostr 或闪电网络等）或 QR 码的形式广播这种托运货物。

#### 3) 合同导入和验证

鲍勃收到货物后，将其导入 RGB 钱包。这将 ：


- 检查创世和模式是否有效；
- 加载接口和接口实现 ；
- 更新客户端数据存储。

鲍勃现在可以看到钱包中的资产（即使他还不拥有它），并了解有哪些字段可用、可以进行哪些操作......然后，他需要联系一个实际拥有要转移资产的人。在我们的例子中，这个人就是 Alice。

发现谁持有某种 RGB 资产的过程与发现比特币付款人的过程类似。这种连接的细节取决于用途（市场、私人聊天频道、发票、商品和服务销售、工资......）。

#### 4) 开具发票

要启动 RGB 资产转让，Bob 必须先开具发票。该发票用于 ：


- 告诉 Alice 要执行的操作类型（例如，从 RGB20 接口进行 "传输"）；
- 向 Alice 提供鲍勃的*密封定义*（即他希望接收资产的UTXO）；
- 指定所需的活性成分数量（如 100 单位）。

鲍勃使用命令行上的 `rgb` 工具。假设他想要 100 个单位的令牌，其 `ContractId` 已知，想要依靠 `Tapret`，并指定了其 UTXO（`456e3..dfe1:0`）：

```bash
bob$ rgb invoice RGB20 100 <ContractId> tapret1st:456e3..dfe1:0
```

我们将在本章末尾仔细研究 RGB 发票的结构。

#### 5) 发票传送

生成的发票（例如 URL：`rgb:2WBcas9.../RGB20/100+utxob:...`）包含 Alice 准备转账所需的所有信息。与托运单一样，它可以紧凑编码（Base58 或其他格式），并通过信息应用程序、电子邮件、Nostr... 发送。

![RGB-Bitcoin](assets/fr/076.webp)

#### 6) Alice 方面的交易准备工作

爱丽丝收到鲍勃的发票。在她的 RGB 钱包中，有一个包含要转移的资产的储藏库。要使用包含该资产的UTXO，她必须先用自己的UTXO生成一个PSBT（*部分签名比特币交易*），即一个不完整的比特币交易：

```bash
alice$ wallet construct tx.psbt
```

这个基本交易（暂时未签名）将用于锚定与向鲍勃转账相关的加密承诺。这样，爱丽丝的UTXO 将被耗尽，我们将在输出中为鲍勃放置 "Tapret "或 "Opret "承诺。

#### 7) 生成转让委托书

接下来，Alice 通过 .NET 命令建立***终端委托***（有时称为 "转移委托"）：

```bash
alice$ rgb transfer tx.psbt <invoice> consignment.rgb
```

这个新的 `consignment.rgb` 文件包含 ：


- 截至目前（自创世纪以来）验证资产所需的完整国家过渡历史；
- 根据 Bob 开具的发票，将资产从 Alice 转移到 Bob 的新状态转换；
- 不完整的比特币交易（*见证交易*）(`tx.psbt`)，花费了爱丽丝的一次性印章，修改后包括对鲍勃的加密承诺。

在这个阶段，交易还没有在比特币网络上广播。寄售比基本寄售更大，因为它包括整个历史记录（*证明链*），以证明资产的合法性。

#### 8) 鲍勃检查并接受托运货物

爱丽丝将此**终端委托**传输给鲍勃。然后，鲍勃将 ：


- 检查状态转换的有效性（确保历史记录一致、遵守合同规则等）；
- 将其添加到您的本地藏品中；
- 可能在托运货物上生成一个签名（"sig:..."），以证明货物已被检查和批准（有时称为 "*付款单*"）。

```bash
bob$ rgb accept consignment.rgb
sig:DbwzvSu4BZU81jEpE9FVZ3xjcyuTKWWy2gmdnaxtACrS
```

![RGB-Bitcoin](assets/fr/077.webp)

#### 9)选项：鲍勃向爱丽丝发回确认函（*付款单*）。

如果鲍勃愿意，他可以将此签名发回给爱丽丝。这表明


- 它承认过渡是有效的；
- 他同意比特币交易被广播。

这并不是强制性的，但它可以为爱丽丝提供保证，确保日后不会因转让而产生纠纷。

#### 10) Alice 签署并发布交易

这样，爱丽丝就可以 ：


- 检查 Bob 的签名 (`rgb check <sig>`)；
- 签署*见证交易*，这仍然是 PSBT（"钱包签名"）；
- 在比特币网络上发布见证交易 (`-发布`)。

```bash
alice$ rgb check <sig>
alice$ wallet sign —publish tx.psbt
```

![RGB-Bitcoin](assets/fr/078.webp)

一经确认，该交易即标志着转让的完成。鲍勃成为资产的新所有者：他现在有一个 "拥有状态"，指向他控制的UTXO，交易中的承诺证明了这一点。

以下是完整的转移过程：

![RGB-Bitcoin](assets/fr/079.webp)

### RGB 传输的优势


- 保密** ：

只有 Alice 和 Bob 可以访问所有状态转换数据。他们通过委托在区块链外交换这些信息。比特币交易中的加密承诺不会泄露资产类型或金额，这就保证了比其他链上代币系统更高的保密性。


- 客户方验证** ：

鲍勃可以通过比较*寄售*和比特币区块链中的*锚点*来检查转账的一致性。他不需要第三方验证。爱丽丝不必在区块链上公布全部历史记录，这就减轻了基础协议的负担，提高了保密性。


- 简化原子** ：

复杂的交换（例如 BTC 和 RGB 资产之间的原子交换）可以在单笔交易中进行，无需 HTLC 或 PTLC 脚本。如果协议没有广播，每个人都可以以其他方式重复使用自己的 UTXO。

### 转账汇总图

在详细了解发票之前，先来看看 RGB 转账的整体流程图：


- Bob 安装了 RGB 钱包，并获得了初始合同委托；
- Bob 开具发票，并注明UTXO 接收资产的地点；
- Alice 收到发票后，建立 PSBT 并生成终端托运单；
- 鲍勃接受它，进行检查，将数据添加到他的储藏室，并在必要时签字（*付款单*）；
- Alice 在比特币网络上发布交易；
- 交易确认后，转账才算正式完成。

![RGB-Bitcoin](assets/fr/080.webp)

这次转账充分体现了 RGB 协议的强大功能和灵活性：在客户端验证的私人交易所，以最小的成本悄无声息地锚定在比特币区块链上，并保留了该协议的最佳安全性（无重复消费风险）。这使得 RGB 成为一个前景广阔的价值转移生态系统，它比链上可编程区块链更具保密性和可扩展性。

### 发票 RGB

在本节中，我们将详细解释 ** 发票** 在 RGB 生态系统中的工作原理，以及它们如何使操作（尤其是转账）与合约一起执行。首先，我们将介绍所使用的标识符，然后介绍标识符的编码方式，最后介绍以 URL 表示的发票结构（这种格式在钱包中使用非常方便）。

#### 标识符和编码

为以下每个要素定义了一个唯一标识符：


- RGB 合同
- 其模式（业务逻辑） ；
- 其界面和界面实现 ；
- 其资产（代币、NFT 等）、

这种唯一性非常重要，因为系统的每个组件都必须是可区分的。例如，合同 X 不能与另一个合同 Y 混淆，两个不同的接口（如 RGB20 与 RGB21）必须有不同的标识符。

为了使这些标识符既高效（体积小）又可读，我们使用了 .NET 技术：


- Base58 编码，可避免使用容易混淆的字符（如 "0 "和字母 "O"），并提供相对较短的字符串；
- 表示标识符性质的前缀，通常采用 `rgb:` 或类似 URN 的形式。

例如，"ContractId "可以用类似于 ：

```txt
rgb:2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX
```

前缀 `rgb:` 确认这是一个 RGB 标识符，而不是 HTTP 链接或其他协议。有了这个前缀，钱包才能正确理解这个字符串。

#### 标识符分割

RGB 标识符通常很长，因为底层（加密）安全可能需要 256 位或更多的字段。为了方便人工读取和验证，我们将这些字符串分成若干块，中间用连字符（`-`）隔开。因此，我们不再使用一长串不间断的字符，而是将其分成较短的区块。这种做法在信用卡或电话号码中很常见，在这里也同样适用，以方便验证。例如，可以告诉用户或合作伙伴"*请核对第三个区块是否为`9GEgnyMj7`*"，而不必一次性比对全部内容。最后一个区块通常用作**校验和**，以便建立一个错误或错别字检测系统。

例如，经过编码和分段的基 58 `ContractId` 可以是 ：

```txt
2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX
```

每个破折号将字符串分成若干部分。这不会影响代码的语义，只会影响代码的表达。

#### 发票使用 URL

RGB 发票以 URL 的形式呈现。这意味着它可以被点击或扫描（如 QR 码），钱包可以直接解读它以进行交易。这种简单的交互方式不同于其他一些系统，在其他系统中，您必须将各种数据复制并粘贴到软件的不同字段中。

可替代令牌（如 RGB20 令牌）的发票可能如下所示：

```txt
rgb:2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX/RGB20/100+utxob:egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb
```

让我们来分析一下这个 URL：


- rgb:`**（前缀）：表示调用 RGB 协议的链接（类似于其他上下文中的 `http:` 或 `bitcoin:`）；
- 2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX`**：表示要操作的令牌的 `ContractId`；
- `/RGB20/100`**：表示使用 `RGB20` 接口，并请求 100 个单位的资产。语法为`/Interface/amount` ；
- `+utxob:`**: 指定添加有关接收方 UTXO 的信息（或更准确地说，一次性封印的定义）；
- egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb`**：这是*屏蔽*的UTXO（或封印定义）。换句话说，鲍勃屏蔽了他的确切UTXO，因此发送方（爱丽丝）不知道确切地址是什么。她只知道有一个有效的封印指向一个由鲍勃控制的UTXO。

只需在钱包中点击或扫描一下，即可执行操作。

我们可以设想用一个简单的代号（如 "USDT"）代替 "ContractId "的系统。然而，这将引发重大的信任和安全问题：一个代号并不是唯一的参考（多个合约都可以声称自己被称为 `USDT`）。对于 RGB，我们需要一个唯一、明确的加密标识符。因此，我们采用了 256 位字符串，以基数 58 编码并分段。用户知道他所操作的正是 ID 为 `2WBcas9-yjz...` 的合约，而不是其他合约。

#### 附加 URL 参数

您还可以在 URL 中添加其他参数，方法与 HTTP 相同，如 .URL、.URL、.URL、.URL、.URL、.URL：

```txt
rgb:2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX/RGB20/100+utxob:egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb?sig=6kzbKKffP6xftkxn9UP8gWqiC41W16wYKE5CYaVhmEve
```


- sig=......"：例如，表示与发票相关的签名，某些钱包可以验证该签名；
- 如果钱包不管理此签名，则会忽略此参数。

让我们以通过 RGB21 接口的 NFT 为例。例如，我们可以使用 ：

```txt
rgb:7BKsac8-beMNMWA8r-3GEprtFh7-bjzEvGufY-aNLuU4nSN-MRsLOIK/RGB21/DbwzvSu-4BZU81jEp-E9FVZ3xj-cyuTKWWy-2gmdnaxt-ACrS+utxob:egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb
```

在这里，我们看到 ：


- `rgb:`**：URL 前缀 ；
- `7BKsac8-beMNMWA8r-3GEprtFh7-bjzEvGufY-aNLuU4nSN-MRsLOIK`**：合同编号 (NFT) ；
- rGB21**：不可移动资产（NFT）接口 ；
- DbwzvSu-4BZU81jEp-...... "***：对 NFT 唯一部分的明确引用，例如数据 Blob（媒体、元数据......）的哈希值；
- `+utxob:egXsFnw-...`**: 封印定义。

想法是一样的：发送一个钱包可以解读的唯一链接，明确标识要转移的唯一资产。

#### 通过 URL 进行其他操作

RGB URL 不仅用于请求传输。它们还可以编码更高级的操作，例如发行新令牌（*issuance*）。例如

```txt
rgb:2WBcas9-yjzEvGufY-9GEgnyMj7-beMNMWA8r-sPHtV1nPU-TMsGMQX/RGB20/issue/100000+utxob:egXsFnw-5Eud7WKYn-7DVQvcPbc-rR69YmgmG-veacwmUFo-uMFKFb
```

在这里，我们发现 ：


- `rgb:` : 协议 ；
- 2WBcas9-...`：合同编号；
- `/RGB20/issue/100000`：表示要调用 "*Issue*"转换来创建额外的 100 000 个代币；
- `+utxob:`: 印章定义。

例如，钱包的内容可能是"我被要求在`RGB20'界面上执行一项`发行'操作，在这样或那样的合同上发行 100,000 个单位，受益人是这样或那样的一次性印章*"。

现在，我们已经了解了 RGB 编程的主要元素，接下来我将带您了解如何起草 RGB 合同。

## 起草智能合约

<chapterId>0e0a645c-0049-588d-8965-b8c536590cc9</chapterId>

![video](https://youtu.be/GRwS-NvWF3I)

在本章中，我们将使用命令行工具 `rgb` 来逐步编写合同。目的是展示如何安装和操作 CLI、编译**模式**、导入**接口**和**接口实现**，然后发布（*issue*）资产。我们还将了解底层逻辑，包括编译和状态验证。本章结束时，您应该能够重现这一过程并创建自己的 RGB 合约。

需要提醒的是，RGB 的内部逻辑基于 Rust 库，作为开发人员，您可以将 Rust 库导入到您的项目中，以管理客户端验证部分。此外，LNP/BP 协会团队正在开发其他语言的绑定，但尚未最终确定。此外，其他实体（如 Bitfinex）也在开发自己的集成栈（我们将在课程的最后两章讨论）。因此，"rgb "CLI 暂时是官方参考，尽管它仍相对不够完善。

### 安装和演示 rgb 工具

主命令名为 `rgb`。它的设计让人联想到 `git`，有一系列子命令用于操作合约、调用合约、发行资产等。比特币钱包目前尚未集成，但将在即将推出的版本（0.11）中集成。下一个版本将使用户能够直接从`rgb`创建和管理他们的钱包（通过描述符），包括生成 PSBT、兼容外部硬件（如硬件钱包）进行签名，以及与 Sparrow 等软件的互操作性。这将简化整个资产发行和转移过程。

#### 通过货运安装

我们在 Rust 中用 .NET Framework 安装该工具：

```bash
cargo install rgb-contracts --all-features
```

(注意：该板块名为 "rgb-contracts"，安装的命令名为 "rgb"。如果已存在名为 `rgb` 的板块，则可能会发生碰撞，因此命名为 `rgb`)

安装过程中会编译大量依赖项（如命令解析、Electrum 集成、零知识证明管理等）。

安装完成后，.NET Framework 将自动运行：

```bash
rgb
```

运行 `rgb`（不带参数）会显示可用的子命令列表，如 `interfaces`, `schema`, `import`, `export`, `issue`, `invoice`, `transfer` 等。你可以更改本地存储目录（存放所有日志、示意图和实现的储藏室）、选择网络（testnet、mainnet）或配置你的 Electrum 服务器。

![RGB-Bitcoin](assets/fr/081.webp)

#### 控制措施概览

运行以下命令时，你会看到默认情况下已经集成了一个 `RGB20` 界面：

```bash
rgb interfaces
```

如果未集成该接口，请克隆.NET Framework 4.0：

```bash
git clone https://github.com/RGB-WG/rgb-interfaces
```

编译：

```bash
cargo run
```

然后导入您选择的界面：

```bash
rgb import interfaces/RGB20.rgb
```

![RGB-Bitcoin](assets/fr/082.webp)

另一方面，我们被告知还没有将模式导入软件。储藏库中也没有合同。要查看它，请运行命令 ：

```bash
rgb schemata
```

然后，您可以克隆该资源库，以检索某些原理图：

```bash
git clone https://github.com/RGB-WG/rgb-schemata
```

![RGB-Bitcoin](assets/fr/083.webp)

该资源库的 `src/` 目录中包含多个 Rust 文件（例如 `nia.rs`），这些文件定义了模式（NIA 表示 "*Non Inflatable Asset*"，UDA 表示 "*Unique Digital Asset*"等）。编译时，您可以运行 ：

```bash
cd rgb-schemata
cargo run
```

这会生成多个与编译示意图相对应的 `.rgb` 和 `.rgba` 文件。例如，您可以找到 `NonInflatableAsset.rgb`。

#### 导入模式和接口实现

现在您可以将原理图导入 `rgb` ：

```bash
rgb import schemata/NonInflatableAssets.rgb
```

![RGB-Bitcoin](assets/fr/084.webp)

这将把它添加到本地存储库中。如果我们运行以下命令，就会看到模式已经出现：

```bash
rgb schemata
```

### 合同创建（签发）

创建新资产有两种方法：


- 我们可以使用 Rust 中的脚本或代码，通过填充模式字段（全局状态、自有状态等）来构建合约，并生成`.rgb`或`.rgba`文件；
- 或者直接使用 `issue` 子命令，用 YAML（或 TOML）文件描述令牌的属性。

您可以在 Rust 的`examples`文件夹中找到示例，其中说明了如何构建`ContractBuilder`、填写`global state`（资产名称、股票代码、供应量、日期等）、定义 Owned State（分配给哪个 UTXO），然后将所有这些编译成您可以导出、验证并导入储藏库的*合同委托。

另一种方法是手动编辑 YAML 文件，以自定义 "ticker"、"name "和 "supply "等。假设文件名为 `RGB20-demo.yaml`。您可以指定 ：


- spec`：代码、名称、精度 ；
- "条款"：用于法律通告的字段；
- `issuedSupply` ：已发行的代币数量；
- `assignments`: 表示一次性使用密封件（*密封件定义*）和已解锁的数量。

下面是一个要创建的 YAML 文件示例：

```yaml
interface: RGB20Fixed
globals:
spec:
ticker: PBN
name: Plan B Network
details: "Pay attention: the asset has no value"
precision: 2
terms:
text: >
SUBJECT TO, AND WITHOUT IN ANY WAY LIMITING, THE REPRESENTATIONS AND WARRANTIES OF ANY SELLER. PROPERTY IS BEING SOLD “AS IS”...
media: ~
issuedSupply: 100000000
assignments:
assetOwner:
seal: tapret1st:b449f7eaa3f98c145b27ad0eeb7b5679ceb567faef7a52479bc995792b65f804:1
amount: 100000000 # this is 1 million (we have two digits for cents)
```

![RGB-Bitcoin](assets/fr/085.webp)

然后只需运行命令 ：

```bash
rgb issue '<SchemaID>' ssi:<Issuer> rgb20-demo.yaml
```

![RGB-Bitcoin](assets/fr/086.webp)

在我的情况中，唯一模式标识符（用单引号括起来）是 `RDYhMTR!9gv8Y2GLv9UNBEK1hcrCmdLDFk9Qd5fnO8k`，我没有输入任何发行人。因此，我的订单是 ：

```txt
rgb issue 'RDYhMTR!9gv8Y2GLv9UNBEK1hcrCmdLDFk9Qd5fnO8k' ssi:anonymous rgb20-demo.yaml
```

如果不知道模式 ID，请运行命令 ：

```bash
rgb schemata
```

CLI 会回复说，已签发了一份新合同，并将其添加到了储量中。如果我们键入下面的命令，就会看到现在又多了一份合同，与刚刚签发的合同相对应：

```bash
rgb contracts
```

![RGB-Bitcoin](assets/fr/087.webp)

然后，下一条命令会显示全局状态（名称、代号、供应量......）和自有状态列表，即分配情况（例如，UTXO `b449f7eaa3f98c145b27ad0eeb7b5679ceb567faef7a52479bc995792b65f804:1` 中定义的 100 万个 `PBN` 代币）。

```bash
rgb state '<ContractId>'
```

![RGB-Bitcoin](assets/fr/088.webp)

### 导出、导入和验证

要与其他用户共享这份合同，可以将其从储藏库导出到 .NET 文件：

```bash
rgb export '<ContractId>' myContractPBN.rgb
```

![RGB-Bitcoin](assets/fr/089.webp)

可将 `myContractPBN.rgb` 文件传给其他用户，后者可使用命令 ：

```bash
rgb import myContractPBN.rgb
```

导入时，如果是简单的*合同委托*，我们会收到"`导入委托 rgb`"信息。如果是较大的*状态转换委托*，命令会有所不同（`rgb accept`）。

为确保有效性，您还可以使用本地验证功能。例如，您可以运行 ：

```bash
rgb validate myContract.rgb
```

#### 储藏库的使用、验证和显示

需要提醒的是，储藏库是模式、接口、实现和合约（创世纪 + 过渡）的本地库存。每运行一次 "导入"，就会向储藏库添加一个元素。可以使用命令 ：

```bash
rgb dump
```

![RGB-Bitcoin](assets/fr/090.webp)

这将生成一个文件夹，其中包含整个藏品的详细信息。

### 转账和 PSBT

要进行转账，您需要操作一个本地比特币钱包来管理 "Tapret "或 "Opret "承诺。

#### 生成发票

在大多数情况下，合约参与者（如 Alice 和 Bob）之间的互动是通过生成发票来实现的。如果爱丽丝希望鲍勃执行某些操作（代币转移、重新发行、DAO 中的操作等），爱丽丝就会创建一张发票，详细说明她对鲍勃的指示。因此，我们有 ：


- Alice** （发票开具人） ；
- 鲍勃**（接收和执行发票者）。

与其他生态系统不同，RGB 发票并不局限于付款的概念。它可以嵌入与合约相关的任何请求：撤销密钥、投票、在 NFT 上创建雕刻（*engraving*）等。相应的操作可在合约接口中描述。相应的操作可在合约界面中描述。

以下命令生成一张 RGB 发票：

```bash
$ rgb invoice $CONTRACT -i $INTERFACE $ACTION $STATE $SEAL
```

与 ：


- $CONTRACT`：合同标识符 (*ContractId*) ；
- `$INTERFACE`：要使用的接口（如 `RGB20`） ；
- `$ACTION`：接口中指定的操作名称（对于简单的可替换令牌传输，可以是 "Transfer"（传输））。如果接口已经提供了默认操作，则无需在此再次输入；
- $STATE`：要传输的状态数据（例如，如果传输的是可替换令牌，则是令牌的数量）；
- $SEAL`：受益人（Alice）的一次性印章，即对UTXO的明确引用。鲍勃将使用此信息建立见证交易，相应的输出将属于爱丽丝（以*屏蔽的UTXO*或未加密的形式）。

例如，使用以下命令

```bash
alice$ CONTRACT='iZgIN9EL-2H21UgQ-x!A3uJc-WwXhCSm-$9Lwcc1-v!mUkKY'
alice$ MY_UTXO=4960acc21c175c551af84114541eace09c14d3a1bb184809f7b80916f57f9ef8:1
alice$ rgb invoice $CONTRACT -i RGB20 --amount 100 $MY_UTXO
```

CLI 将生成类似于 .NET 的发票：

```bash
rgb:iZgIN9EL-2H21UgQ-x!A3uJc-WwXhCSm-$9Lwcc1-v!mUkKY/RGB20/100+utxob:zlVS28Rb-...
```

它可以通过任何渠道（文本、QR 码等）传送给 Bob。

#### 进行转账

要从本发票转账 ：


- 鲍勃（在他的储藏中持有代币）有一个比特币钱包。他需要准备一个比特币交易（以 PSBT 的形式，例如 `tx.psbt`），花费所需 RGB 代币所在的 UTXO，外加一个用于货币（兑换）的 UTXO；
- 鲍勃执行以下命令

```bash
bob$ rgb transfer tx.psbt $INVOICE consignment.rgb
```


- 这将生成一个 `consignment.rgb` 文件，其中包含 ：
 - 过渡历史向 Alice 证明了代币的真实性；
 - 将代币转移到 Alice 的一次性印章的新过渡；
 - 见证交易（无符号）。
- Bob 将此 `consignment.rgb` 文件发送给 Alice（通过电子邮件、共享服务器或 RGB-RPC 协议、Storm 等）；
- Alice 接收到 `consignment.rgb` 并将其存入自己的存储库：

```bash
alice$ rgb accept consignment.rgb
```


- CLI 会检查过渡的有效性，并将其添加到 Alice 的存储库中。如果无效，命令会失败，并带有详细的错误信息。否则，命令成功，并报告样本交易尚未在比特币网络上广播（Bob 正在等待 Alice 的绿灯）；
- 作为确认，"接受 "命令会返回一个签名（*付款单*），爱丽丝可以将该签名发送给鲍勃，向他表明她已经验证了*委托*；
- 然后，鲍勃就可以签署并发布（"--发布"）他的比特币交易：

```bash
bob$ rgb check <sig> && wallet sign --publish tx.psbt
```


- 一旦这笔交易在链上得到确认，该资产的所有权就被视为转移给了 Alice。爱丽丝的钱包在监控交易的挖矿过程中，会看到新的 "拥有状态 "出现在它的钱包中。

在下一章中，我们将详细介绍如何将 RGB 集成到闪电网络中。

## 闪电网络上的 RGB

<chapterId>0962980a-8f94-5d0f-9cd0-43d7f884a01d</chapterId>

![video](https://youtu.be/mqCupTlDbA0)

在本章中，我将探讨如何在闪电网络中使用 RGB，通过链外支付渠道整合和转移 RGB 资产（代币、NFT 等）。

其基本思想是，RGB 状态转换（*状态转换*）可以提交给比特币交易，而比特币交易又可以保持在链外，直到闪电通道关闭。因此，每次更新通道时，新的 RGB 状态转换就会被纳入新的提交交易，从而使旧的转换失效。这样，闪电通道就可以用来转移 RGB 资产，并以与传统闪电支付相同的方式进行路由。

### 渠道创建和资金筹措

要创建一个传输 RGB 资产的闪电通道，我们需要两个要素：


- 比特币资金用于创建通道的 2/2 multisig（通道的基本 UTXO）；
- RGB 资金，它将资产发送到相同的 multisig。

用比特币术语来说，资金交易必须存在，以定义参考 UTXO，即使它只包含少量的 sats（这只是在未来的承诺交易中每个输出保持高于尘埃限制的问题）。例如，爱丽丝可能决定提供 10k sats 和 500 USDT（作为 RGB 资产发行）。在融资交易中，我们会添加一个锚定 RGB 状态转换的承诺（"Opret "或 "Tapret"）。

![RGB-Bitcoin](assets/fr/091.webp)

一旦资金交易准备就绪（但尚未广播），就会创建承诺交易，这样任何一方都可以随时单方面关闭通道。这些交易类似于 Lightning 的经典承诺交易，只是我们增加了一个额外的输出，其中包含与新状态转换相关联的 RGB 锚点（OP_RETURN 或 Taproot）。

然后，RGB 状态转换将资产从资金的 2/2 多位数转移到承诺交易的输出。这一过程的优势在于，RGB 状态的安全性与闪电的惩罚机制完全吻合：如果鲍勃广播了一个旧的信道状态，爱丽丝可以惩罚他并花费输出，从而收回 sats 和 RGB 代币。因此，与没有 RGB 资产的 "闪电 "信道相比，"闪电 "信道的激励机制更加强大，因为攻击者不仅会失去信道状态，还会失去信道的 RGB 资产。

因此，由 Alice 签名并发送给 Bob 的承诺交易会是这样的：

![RGB-Bitcoin](assets/fr/092.webp)

由 Bob 签名并发送给 Alice 的附带承诺交易将如下所示：

![RGB-Bitcoin](assets/fr/093.webp)

### 频道更新

当两个通道参与者之间发生支付（或希望改变资产分配）时，他们会创建一对新的承诺交易。每个输出上以 sats 为单位的金额可能保持不变，也可能不保持不变，这取决于实现方式，因为其主要作用是构建有效的 UTXO。另一方面，OP_RETURN（或 Taproot）输出必须修改，以包含新的 RGB 锚点，代表通道中新的资产分布。

例如，如果 Alice 在通道中向 Bob 转账 30 USDT，新的状态转换将反映 Alice 和 Bob 的余额分别为 400 USDT 和 100 USDT。提交事务会添加到 OP_RETURN/Taproot 锚点（或被 OP_RETURN/Taproot 锚点修改），以包含这一转换。请注意，从 RGB 的角度来看，过渡的输入仍然是初始多位元（链上资产在通道关闭前实际分配）。只有 RGB 的输出（分配）会根据决定的重新分配而改变。

爱丽丝签署的承诺交易，准备由鲍勃分发：

![RGB-Bitcoin](assets/fr/094.webp)

鲍勃签署的承诺交易，准备由爱丽丝分发：

![RGB-Bitcoin](assets/fr/095.webp)

### HTLC 管理

实际上，"闪电网络 "可以通过 HTLC（"*散列时间锁定合约*"）实现多通道支付。RGB 也是如此：对于通过通道进行的每笔支付，都会在提交的交易中添加 HTLC 输出，并将 RGB 分配与 HTLC 链接。因此，无论谁使用了 HTLC 输出（由于秘密或在时间锁定到期后），都会收回 sats 和相关的 RGB 资产。另一方面，你显然需要在路上有足够的现金，包括 sats 和 RGB 资产。

![RGB-Bitcoin](assets/fr/096.webp)

因此，RGB 在 Lightning 上的运行必须与 Lightning 网络本身的运行同步考虑。如果您想更深入地了解这一主题，我强烈建议您参加其他综合培训课程：

https://planb.network/courses/34bd43ef-6683-4a5c-b239-7cb1e40a4aeb

### RGB 代码图

最后，在进入下一部分之前，我想向大家介绍一下 RGB 所使用的代码。该协议基于一系列 Rust 库和开源规范。下面是主要资源库和板条箱的概览：

![RGB-Bitcoin](assets/fr/097.webp)

#### 客户端验证


- 存储库**：[客户端验证](https://github.com/LNP-BP/client_side_validation)
- 板条箱** ：[client_side_validation](https://crates.io/crates/client_side_validation), [single_use_seals](https://crates.io/crates/single_use_seals)

管理链外验证和一次性使用密封逻辑。

#### 确定性比特币承诺（DBC）


- 存储库**：[bp-core](https://github.com/BP-WG/bp-core)
- 箱**：[BP-DBC](https://crates.io/crates/bp-dbc)

比特币交易中的确定性锚定管理（Tapret、OP_RETURN 等）。

#### 多协议承诺（MPC）


- 存储库**：[客户端验证](https://github.com/LNP-BP/client_side_validation)
- 板条箱** ：[commit_verify](https://crates.io/crates/commit_verify)

多种接合组合并与不同协议集成。

#### 严格类型和严格编码


- 规格**：[网站 strict-types.org](https://www.strict-types.org/)
- 资源库**：[严格类型](https://github.com/strict-types/strict-types), [严格编码](https://github.com/strict-types/strict-encoding)
- 板条箱** ：[strict_types](https://crates.io/crates/strict_types), [strict_encoding](https://crates.io/crates/strict_encoding)

用于客户端验证的严格类型系统和确定性序列化。

#### RGB 核心


- 存储库**：[rgb-core](https://github.com/RGB-WG/rgb-core)
- 板条箱**：[rgb-core](https://crates.io/crates/rgb-core)

协议的核心，包含 RGB 验证的主要逻辑。

#### RGB 标准库和钱包


- 存储库**：[rgb-std](https://github.com/RGB-WG/rgb-std)
- 木箱** ：[rgb-std](https://crates.io/crates/rgb-std)

标准实施、储藏和钱包管理。

#### RGB CLI


- 存储库**：[rgb](https://github.com/RGB-WG/rgb)
- 板条箱**：[rgb-cli](https://crates.io/crates/rgb-cli), [rgb-wallet](https://crates.io/crates/rgb-wallet)

`rgb` CLI 和 crate wallet，用于对合约进行命令行操作。

#### RGB 模式


- 存储库**：[rgb-schemata](https://github.com/RGB-WG/rgb-schemata/)

包含模式（NIA、UDA 等）及其实现的示例。

#### ALuVM


- 信息** ：[aluvm.org](https://www.aluvm.org/)
- 资源库**：[aluvm-spec](https://github.com/AluVM/aluvm-spec), [alure](https://github.com/AluVM/alure)
- 板条箱**：[aluvm](https://crates.io/crates/aluvm), [aluasm](https://crates.io/crates/aluasm)

基于注册表的虚拟机，用于运行验证脚本。

#### 比特币协议 - BP


- 资源库** ：[bp-core](https://github.com/BP-WG/bp-core), [bp-std](https://github.com/BP-WG/bp-std), [bp-wallet](https://github.com/BP-WG/bp-wallet)

支持比特币协议的插件（交易、旁路等）。

#### 无所不在的确定性计算 - UBIDECO


- 存储库**：[UBIDECO](https://github.com/UBIDECO)

与开源确定性开发相关联的生态系统。

# 以 RGB 为基础

<partId>3b4b0d66-0c1b-505a-b5ca-4b2e57dd73c2</partId>

## DIBA 和 Bitmask 项目

<chapterId>dc92a5e8-ed93-5a3f-bcd0-d433932842f4</chapterId>

![video](https://youtu.be/nbUtV8GOR_U)

本课程的最后一部分以 RGB 培训营中各位发言人的发言为基础。其中包括对 RGB 及其生态系统的评价和反思，以及对基于协议的工具和项目的介绍。第一章由 Hunter Beast 主持，后两章由 Frederico Tenga 主持。

### 从 JavaScript 到 Rust，再到比特币生态系统

起初，Hunter Beast 主要使用 JavaScript。后来，他发现了**Rust**，起初这种语言的语法似乎并不吸引人，而且令人沮丧。然而，他逐渐体会到了这种语言的强大功能、对内存（*堆*和*栈*）的控制以及随之而来的安全性和性能。他强调，Rust 是深入了解计算机工作原理的绝佳训练场。

Hunter Beast讲述了他在*altcoin*生态系统中参与各种项目的背景，例如以太坊（使用Solidity、TypeScript等），以及后来的Filecoin。他解释说，他最初对其中的一些协议印象深刻，但最终对大多数协议感到失望，尤其是因为它们的代币经济学。他谴责了这些项目中可疑的财务激励机制、稀释投资者的代币膨胀创造以及潜在的剥削方面。因此，他最终采取了**比特币最大化**的立场，尤其是因为一些人让他看到了比特币更健全的经济机制，以及这个系统的稳健性。

### RGB 和图层的魅力

用他的话说，让他对比特币的相关性深信不疑的是 RGB 的发现和层的概念。他认为，其他区块链上的现有功能可以在比特币之上的更高层次上复制，而不会改变基本协议。

2022 年 2 月，他加入**DIBA**，专门负责 RGB，尤其是**Bitmask**钱包。当时，Bitmask 仍处于 0.01 版本，而 RGB 运行于 0.4 版本，仅用于管理单个代币。他指出，与现在相比，这种方式不那么以自我保管为导向，因为其逻辑部分是基于服务器的。从那时起，该架构就朝着这个模式发展，深受比特币用户的喜爱。

### RGB 协议的基础

**RGB** 协议是 "彩色币 "概念的最新和最先进的体现，在 2012-2013 年左右就已开始探索。当时，一些团队希望将不同的比特币价值与UTXO联系起来，这导致了多种分散的实施方案。由于缺乏标准化，加上当时的需求量较低，这些解决方案无法获得持久的立足点。

如今，RGB 因其概念上的稳健性和通过 LNP/BP 关联实现的统一规范而脱颖而出。其原理基于客户端验证。比特币区块链只存储加密承诺（_commitments_，通过 Taproot 或 OP_RETURN），而大部分数据（合约定义、转账历史等）由相关用户存储。通过这种方式，可以分散存储负荷，加强交换的保密性，同时不会给区块链带来负担。这种方法可以在模块化和可扩展的框架内创建可互换资产（**RGB20** 标准）或唯一资产（**RGB21** 标准）。

### 令牌功能（RGB20）和独特资产（RGB21）

通过 **RGB20**，我们在比特币上定义了一种可互换的代币。发行者选择一个_供应量_、一个_精度_，并创建一个_合约_，然后就可以进行转账。每次转账都会参考比特币UTXO，UTXO就像一个*一次性使用的印章*。这一逻辑确保用户无法两次使用相同的资产，因为只有能够使用UTXO的人才能真正掌握更新客户端合约状态的密钥。

**RGB21** 以唯一资产（或 "NFT"）为目标。资产的供应量为 1，可与通过特定字段描述的元数据（图像文件、音频等）相关联。与公共区块链上的 NFT 不同，数据及其 MIME 标识符可以保持私有，由所有者自行决定进行点对点分发。

### Bitmask 解决方案：RGB 钱包

为了在实践中利用 RGB 的功能，**DIBA** 项目设计了一款名为 [Bitmask](https://bitmask.app/) 的钱包。其设计理念是提供一种基于 Taproot 的非托管工具，可作为网络应用程序或浏览器扩展进行访问。Bitmask 可管理 RGB20 和 RGB21 资产，并集成了各种安全机制：


- 核心代码用 Rust 编写，然后用 WebAssembly 进行编译，以便在 JavaScript 环境（React）中运行；
- 密钥在本地生成，然后在本地加密存储；
- 状态数据（储藏库）保存在内存中，通过**Carbonado**库进行序列化和加密，该库使用 Blake3 执行压缩、纠错、加密和流验证。

得益于这种架构，所有资产交易都在客户端进行。从外观上看，比特币交易不过是一个典型的 Taproot 支出交易，没有人会怀疑它还携带着可替代代币或 NFT 的转移。没有链上过载（没有公开存储的元数据）保证了一定程度的自由裁量权，也更容易抵制可能的审查企图。

### 安全和分布式架构

由于 RGB 协议要求每个参与者保留其交易历史（以证明其收到的转账的有效性），因此出现了存储问题。Bitmask 建议在本地对这些藏匿数据进行序列化，然后将其发送到多个服务器或云（可选）。用户通过**Carbonado**对数据进行加密，因此服务器无法读取。如果出现部分损坏，纠错层可以重建内容。

使用 CRDT（无冲突复制数据类型）可以在不同版本的藏匿数据出现分歧时进行合并。每个人都可以随心所欲地托管这些数据，因为没有一个完整的节点可以承载与资产相关的所有信息。这恰恰反映了*客户端验证*的理念，即每个所有者都有责任存储其 RGB 资产有效性的证据。

### 建立更广泛的生态系统：市场、互操作性和新功能

Bitmask 背后的公司并不局限于简单的钱包开发。DIBA 打算开发.NET技术：


- 交换代币的**市场**，尤其是**RGB21**形式的代币；
- 与其他钱包（如 *Iris Wallet*）兼容；
- 传输批处理**技术，即在一次交易中可连续进行若干次 RGB 传输。

与此同时，我们还在开发**WebBTC**或**WebLN**（使网站能够要求钱包签署比特币或闪电交易的标准），以及 "远程烧录 "Ordinals 条目的功能（如果我们想将Ordinals 转换为更隐蔽、更灵活的 RGB 格式）。

### 结论

整个过程展示了如何通过强大的技术解决方案来部署 RGB 生态系统并使最终用户可以使用。从替代币的视角过渡到更加以比特币为中心的愿景，再加上*客户端验证*的发现，说明了一条相当合乎逻辑的道路：我们了解到，只需利用 Taproot 交易或 OP_RETURN 上的加密承诺，就有可能在不分叉区块链的情况下实现各种功能（可替代代币、NFT、智能合约......）。

**比特面具**钱包就是这种方法的一部分：在区块链方面，你看到的只是普通的比特币交易；在用户方面，你操作的是一个网络界面，在这里你可以创建、交换和存储各种链外资产。这种模式明确地将货币基础设施（比特币）与发行和转账逻辑（RGB）分离开来，同时确保了高度的保密性和更好的可扩展性。

## Bitfinex 在 RGB 方面的工作

<chapterId>d4d80e07-5eac-5b29-a93a-123180e97047</chapterId>

![vidéo](https://youtu.be/5iAhsgCSL3U)

在本章中，我们将根据 Frederico Tenga 的演讲，介绍 Bitfinex 团队专门为 RGB 开发的一系列工具和项目，目的是促进围绕该协议形成一个丰富多样的生态系统。该团队的最初目标不是发布特定的商业产品，而是提供软件构建模块，为 RGB 协议本身做出贡献，并提出具体的实施参考方案，如移动钱包（*Iris Wallet* ）或兼容 RGB 的闪电节点。

### 背景和目标

自 2022 年左右以来，Bitfinex RGB 团队一直专注于开发技术栈，使 RGB 能够得到有效利用和测试。团队已经做出了多项贡献：


- 参与源代码和协议规范，包括撰写改进建议、修复错误等；
- 供开发人员使用的工具，可简化 RGB 在其应用程序中的集成；
- 设计名为 [Iris](https://iriswallet.com/)的移动钱包，以实验和说明使用 RGB 的最佳做法；
- 创建一个定制的 Lightning 节点，能够管理带有 RGB 资产的通道；
- 支持其他团队在 RGB 上构建解决方案，以鼓励多样性和强大的生态系统。

这种方法旨在涵盖整个需求链：从实现钱包的底层库（*[RGBlib](https://github.com/RGB-Tools/rgb-lib)*）到生产方面（闪电节点、安卓钱包等）。

### RGBlib 库：简化 RGB 应用程序的开发

要实现 RGB 钱包和应用程序创建的民主化，重要的一点是提供一个足够简单的抽象，这样开发人员就不必学习协议内部逻辑的所有知识。这正是用 Rust 编写的 **RGBlib** 的目标所在。

RGBlib 是我们在前几章中研究的高度灵活（但有时也很复杂）的 RGB 要求与应用程序开发人员的具体需求之间的桥梁。换句话说，希望管理代币转移、资产发行、验证等的钱包（或服务）可以依赖 RGBlib，而无需了解每个加密细节或每个可定制的 RGB 参数。

书店提供 ：


- 发行（_issuance_）资产（可互换或不可互换）的统包功能；
- 通过操作简单对象（地址、金额、UTXOs 等）来转移（发送/接收）资产的能力；
- 用于存储和加载客户端验证所需的状态信息（*分配*）的机制。

因此，RGBlib 依赖于 RGB 特有的复杂概念（客户端验证、Tapret/Opret 锚点），但对这些概念进行了封装，因此最终应用程序无需对所有内容进行重新编程或做出风险决策。更重要的是，RGBlib 已经与多种语言（Kotlin 和 Python）绑定，为 Rust 之外的其他应用打开了大门。

### 虹膜钱包：安卓上的 RGB 钱包示例

为了证明 RGBlib 的有效性，Bitfinex 团队开发了**Iris Wallet**，现阶段仅在安卓系统上使用。这是一个移动钱包，其用户体验与普通比特币钱包类似：您可以发行资产、发送资产、接收资产并查看其历史记录，同时保持自我保管模式。

虹膜有许多有趣的功能：

**使用 Electrum 服务器：**

与其他钱包一样，Iris 需要了解区块链上的交易确认情况。Iris 没有嵌入完整的节点，而是默认使用由 Bitfinex 团队维护的 Electrum 服务器。不过，用户也可以配置自己的服务器或其他第三方服务。这样，比特币交易就能以模块化方式得到验证和信息检索（索引）。

**RGB 代理服务器：**

与比特币不同，RGB 需要在发送方和接收方之间交换链外元数据（*分配*）。为了简化这一过程，Iris 提供了一种通过代理服务器进行通信的解决方案。接收钱包会生成一份*发票*，其中会提及发送方应将*客户端*数据发送到哪里。默认情况下，URL 指向 Bitfinex 团队托管的代理，但您可以更改代理（或托管自己的代理）。这样做的目的是让用户回到熟悉的用户体验，即收件人显示二维码，发件人扫描二维码进行交易，而无需任何复杂的额外操作。

**连续备份：**

在严格的比特币环境中，备份种子通常就足够了（尽管现在我们建议备份种子和描述符）。对于 RGB 来说，这还不够：您还需要保存本地历史记录（*收据*），以证明您确实拥有 RGB 资产。每次收到收据时，设备都会存储新数据，这对后续消费至关重要。Iris 会自动在用户的 Google Drive 中管理加密备份。由于备份是加密的，因此无需特别信任谷歌，而且未来还计划提供更强大的选项（如个人服务器），以避免任何第三方运营商审查或删除的风险。

**其他功能：**


- 创建一个龙头，用于快速测试或分发代币，以进行实验或推广；
- 一个认证系统（目前是集中式的），用于区分合法令牌和复制著名股票的假令牌。未来，这种认证可能会变得更加分散（通过 DNS 或其他机制）。

总而言之，Iris 提供的用户体验与经典比特币钱包接近，但由于使用了 RGBlib 和代理服务器，掩盖了额外的复杂性（储藏管理、*寄售*历史记录等）。

### 代理服务器和用户体验

上文介绍的代理服务器值得详细说明，因为它是实现流畅用户体验的关键。发送方无需手动向接收方传送*配售*，而是通过.NET Framework 3.0 在后台进行 RGB 交易：


- 收件人生成一张*发票*（其中包括代理地址）；
- 发送方（通过 HTTP 请求）向代理发送一个过渡项目（*委托*）；
- 接收方检索该项目，并在本地执行*客户端*验证；
- 然后，接收方通过代理发布对状态转换的接受（或可能拒绝）；
- 发送方可以查看验证状态，如果接受，则广播比特币交易，最终完成转账。

这样，钱包的行为几乎与普通钱包无异。用户并不知道所有的中间步骤。诚然，当前的代理既没有加密，也没有验证（这让人担心保密性和完整性），但这些改进在以后的版本中都有可能实现。代理概念对于重现 "我发送二维码，你扫描付款 "的体验仍然非常有用。

### 闪电网络上的 RGB 集成

Bitfinex 团队工作的另一个重点是使闪电网络与 RGB 资产兼容。其目的是在 USDT（或任何其他代币）中启用闪电通道，并受益于闪电上与比特币相同的优势（近乎瞬时的交易、路由等）。具体而言，这涉及创建一个修改为.NET 的闪电节点：


- 打开通道时，不仅要将 satoshis，还要将一个或多个 RGB 资产放入资金 UTXO multisig 中；
- 生成闪电承诺交易（比特币端），并伴随相应的 RGB 状态转换。每次更新通道时，RGB 转换都会重新定义闪电输出中的资产分布；
- 根据闪电网络规则（HTLC、时间锁定、惩罚等），启用单边关闭功能，在专属 UTXO 中检索资产。

该解决方案被称为 "**RGB Lightning Node**"，它以 LDK（*Lightning Dev Kit*）为基础，并添加了将 RGB 标记注入通道所需的机制。Lightning 承诺保留了经典结构（可标点输出、时间锁......），此外还锚定了 RGB 状态转换（通过 `Opret` 或 `Tapret`）。对于用户来说，这为稳定币或任何其他通过 RGB 发行的资产中的闪电通道开辟了道路。

### DEX 的潜力和对比特币的影响

一旦通过闪电管理了多个资产，就有可能在单一的闪电路由路径上想象出一个**原子交易所，并使用相同的秘密和时钟逻辑。例如，用户 A 在一个闪电通道上持有比特币，用户 B 在另一个闪电通道上持有 USDT RGB。他们可以建立一条连接两个通道的路径，同时将 BTC 兑换成 USDT，而无需信任。这只不过是在几个跳转过程中进行的**原子交换**，外部参与者几乎不会注意到他们正在进行交易，而不仅仅是路由。这种方法提供了 ：


- 延迟极低，因为 Lightning 上的一切都保持在链外。
- 卓越的**隐私**：没有人知道这是一笔交易，而不是普通的路由；
- 避免链上 DEX 经常出现的问题--前置运行；
- 降低成本（无需支付区块空间费用，只需支付闪电路由费用）。

我们可以想象这样一个生态系统：闪电节点提供掉期价格（通过提供流动性）。如果愿意，每个节点都可以扮演 "做市商 "的角色，在 "闪电 "上买卖各种资产。这种_layer-2_ DEX的前景强化了这样一种想法，即无需分叉或使用第三方区块链就能获得去中心化的资产交易所。

对比特币的影响可能是积极的：由于这些*稳定币*、衍生品和其他代币产生的交易量，闪电的基础设施（节点、通道和服务）将得到更充分的利用。对 Lightning 上的 USDT 支付感兴趣的商家会发现 Lightning 上的 BTC 支付（由相同的堆栈管理）。闪电网络基础设施的维护和融资也可以从这些非 BTC 流量的倍增中受益，这将间接惠及比特币用户。

### 结论和资源

致力于 RGB 的 Bitfinex 团队通过其工作展示了在该协议基础上可以开展的工作的多样性。一方面，RGBlib 是一个便于设计钱包和应用程序的库。另一方面，我们还有 Iris Wallet，它在安卓系统上实际演示了简洁的终端用户界面。最后，RGB 与 Lightning 的整合表明稳定币通道是可能的，并为 Lightning 上潜在的去中心化 DEX 开辟了道路。

这种方法在很大程度上仍处于试验阶段，并将继续发展：RGBlib 库在不断完善，Iris 钱包也在定期改进，而专用 Lightning 节点还不是主流 Lightning 客户端。

对于那些希望了解更多信息或做出贡献的人，我们提供了一些资源，包括：


- [GitHub RGB 工具软件源](https://github.com/RGB-Tools)；
- [虹膜钱包专用信息网站](https://iriswallet.com/) 测试安卓系统上的钱包。

下一章，我们将详细介绍如何启动 RGB "闪电 "节点。

## RLN - RGB 闪电节点

<chapterId>ecaabe32-20ba-5f8c-8ca1-a3f095792958</chapterId>

![vidéo](https://youtu.be/piQQH4Q2nr0)

在最后一章中，Frederico Tenga 将带您逐步在 Regtest 环境中设置一个 Lightning RGB 节点，并向您展示如何在该节点上创建 RGB 代币。通过启动两个独立的节点，您还会发现如何在它们之间打开闪电通道并交换 RGB 资产。

本视频作为教程，与我们在上一章中介绍的内容类似，但这次特别关注 "闪电"！

本视频的主要资源是 Github 存储库 [RGB Lightning Node](https://github.com/RGB-Tools/rgb-lightning-node)，它可以让您在 Regtest 中轻松启动此配置。

### 部署兼容 RGB 的 Lightning 节点

这一过程是对前几章所涉及的所有概念的总结和实践：


- 在闪电通道的 2/2 multisig 上封锁的**UTXO**不仅可以接收比特币，还可以作为 RGB 资产的一次性封印（无论是否可互换）；
- 在每个 "闪电 "参与事务中增加一个输出（"Tapret "或 "Opret"），专门用于锚定 RGB 状态转换；
- 验证比特币交易和交换 * 客户端 * 数据的相关基础设施（bitcoind/indexer/proxy）。

### 介绍 rgb-lightning 节点

rgb-lightning-node "***项目是一个基于 "rust-lightning"（LDK）分叉的Rust守护进程，该分叉经过修改，考虑到了通道中RGB资产的存在。打开通道时，可以指定资产的存在，每次更新通道状态时，都会创建一个 RGB 转换，反映资产在 Lightning 输出中的分布。这样就能实现.NET Framework 2.0：


- 例如，在 USDT 中打开闪电通道；
- 只要路由路径有足够的流动性，就可以通过网络路由这些代币；
- 无需修改即可利用 Lightning 的惩罚和时间锁定逻辑：只需在承诺事务的额外输出中固定 RGB 转换即可。

该代码仍处于alpha阶段：我们建议仅在**regtest**或**testnet**上使用。

### 节点安装

要编译和安装 `rgb-lightning-node` 二进制文件，我们首先要克隆软件源及其子模块，然后运行 .NET Framework：

```bash
git clone https://github.com/RGB-Tools/rgb-lightning-node --recurse-submodules --shallow-submodules
```

![RGB-Bitcoin](assets/fr/098.webp)


- 子模块 "选项也会克隆必要的子设备（包括修改版的 "rust-lightning"）；
- shallow-submodules "选项限制了克隆的深度，以加快下载速度，同时仍可访问重要提交。

在项目根目录下运行以下命令，编译并安装二进制 .NET 文件：

```bash
cargo install --locked --debug --path .
```

![RGB-Bitcoin](assets/fr/099.webp)


- 锁定 "确保严格遵守依赖项的版本；
- debug "不是必须的，但可以帮助你集中注意力（如果你愿意，也可以使用"--release"）；
- `--path .` 告诉 `cargo install` 从当前目录安装。

命令结束后，您的 `$CARGO_HOME/bin/` 目录中将出现一个 `rgb-lightning-node` 可执行文件。请确保该路径位于您的 `$PATH` 中，这样您就可以从任何目录调用该命令。

### 性能要求

rgb-lightning-node "守护进程需要.NET Framework 2.0 的存在和配置才能运行：


- 一个 `bitcoind`** 节点

每个 RLN 实例都需要与 `bitcoind` 通信，以广播和监控其链上交易。需要向守护进程提供身份验证（登录名/密码）和 URL（主机/端口）。


- 索引器**（Electrum 或 Esplora）

守护进程必须能够列出并探索链上交易，尤其是找到资产锚定的UTXO。您需要指定 Electrum 服务器或 Esplora 的 URL。


- RGB** 代理

如前几章所述，**代理服务器**是一个组件（可选，但强烈建议使用），用于简化闪电同行之间的*分配*交换。同样，必须指定一个 URL。

当守护进程通过 API 解锁时，就会输入 ID 和 URL。稍后再详述。

### 启动 Regtest

对于简单的使用，有一个 `regtest.sh` 脚本可以通过 Docker 自动启动一组服务：bitcoind"、"electrs"（索引器）、"rgb-proxy-server"。

![RGB-Bitcoin](assets/fr/100.webp)

它允许你启动一个本地、隔离、预配置的环境。每次重启时，它都会创建并销毁容器和数据目录。首先，我们将启动 .NET Framework：

```bash
./regtest.sh start
```

该脚本将 ：


- 创建一个 `docker/` 目录来存储 ；
- 在 regtest 中运行 `bitcoind` 以及索引器 `electrs` 和 `rgb-proxy-server` ；
- 等待一切准备就绪后再使用。

![RGB-Bitcoin](assets/fr/101.webp)

接下来，我们将启动几个 RLN 节点。在不同的 shell 中运行，例如（启动 3 个 RLN 节点） ：

```bash
# 1st shell
rgb-lightning-node dataldk0/ --daemon-listening-port 3001 \
--ldk-peer-listening-port 9735 --network regtest
# 2nd shell
rgb-lightning-node dataldk1/ --daemon-listening-port 3002 \
--ldk-peer-listening-port 9736 --network regtest
# 3rd shell
rgb-lightning-node dataldk2/ --daemon-listening-port 3003 \
--ldk-peer-listening-port 9737 --network regtest
```

![RGB-Bitcoin](assets/fr/102.webp)


- 网络 regtest "参数表示使用 regtest 配置；
- daemon-listening-port "表示 Lightning 节点将在哪个 REST 端口监听 API 调用（JSON）；
- ldk--peer-listening-port "指定要监听的 Lightning p2p 端口；
- dataldk0/"、"dataldk1/"是存储目录的路径（每个节点单独存储信息）。

您还可以通过浏览器在 RLN 节点上运行命令：

```url
https://rgb-tools.github.io/rgb-lightning-node/
```

节点要打开通道，首先必须在用以下命令生成的地址上有比特币（以节点 n°1 为例）：

```bash
curl -X POST http://localhost:3001/address
```

答案将为您提供一个地址。

![RGB-Bitcoin](assets/fr/103.webp)

在 `bitcoind` Regtest 中，我们将挖掘一些比特币。运行 ：

```bash
./regtest.sh mine 101
```

![RGB-Bitcoin](assets/fr/104.webp)

将资金发送到上述生成的节点地址：

```bash
./regtest.sh sendtoaddress <address> <amount>
```

![RGB-Bitcoin](assets/fr/105.webp)

然后开采一个区块来确认交易：

```bash
./regtest.sh mine 1
```

![RGB-Bitcoin](assets/fr/106.webp)

### 测试网启动（无 Docker）

如果您想测试更真实的场景，可以在 Testnet 而不是 Regtest 中启动 3 个 RLN 节点，指向公共服务：

```bash
rgb-lightning-node dataldk0/ --daemon-listening-port 3001 \
--ldk-peer-listening-port 9735 --network testnet
rgb-lightning-node dataldk1/ --daemon-listening-port 3002 \
--ldk-peer-listening-port 9736 --network testnet
rgb-lightning-node dataldk2/ --daemon-listening-port 3003 \
--ldk-peer-listening-port 9737 --network testnet
```

默认情况下，如果找不到配置，守护进程将尝试使用 .NET Framework：


- bitcoind_rpc_host`: `electrum.iriswallet.com`.
- `bitcoind_rpc_port`: `18332`
- indexer_url`: `ssl://electrum.iriswallet.com:50013`.
- `proxy_endpoint`: `rpcs://proxy.iriswallet.com/0.2/json-rpc`

登录 ：


- `bitcoind_rpc_username`: `user`.
- `bitcoind_rpc_username`: `password`.

您还可以通过 `init`/`unlock` API 自定义这些元素。

### 发行 RGB 令牌

要发行令牌，我们首先要创建 "可着色 "的 UTXO：

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"up_to": false,
"num": 4,
"size": 2000000,
"fee_rate": 4.2,
"skip_sync": false
}' \
http://localhost:3001/createutxos
```

![RGB-Bitcoin](assets/fr/107.webp)

当然，您也可以调整订单。为了确认交易，我们会在您的.NET 账号上显示一个".NET "字样：

```bash
./regtest.sh mine 1
```

现在我们可以创建一个 RGB 资产。命令取决于您要创建的资产类型及其参数。在这里，我要创建一个名为 "PBN "的 NIA（*非充气资产*）令牌，供应量为 1000 个单位。精度 "允许您定义单位的可分割性。

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"amounts": [
1000
],
"ticker": "PBN",
"name": "Plan B Network",
"precision": 0
}' \
http://localhost:3001/issueassetnia
```

![RGB-Bitcoin](assets/fr/108.webp)

响应包括新创建资产的 ID。请记住这个标识符。在我的例子中，它是 ：

```txt
rgb:fc7fMj5S-8yz!vIl-260BEhU-Hj1skvM-ZHcjfyz-RTcWc10
```

![RGB-Bitcoin](assets/fr/109.webp)

然后，您可以在链上传输，或在闪电通道中分配。这正是我们下一节要做的。

### 打开通道并传输 RGB 资产

首先，你必须使用`/connectpeer`命令将你的节点连接到闪电网络上的一个对等节点。在我的例子中，我控制着两个节点。因此，我要用这条命令获取第二个闪电节点的公钥：

```bash
curl -X 'GET' \
'http://localhost:3002/nodeinfo' \
-H 'accept: application/json'
```

命令返回我的节点 n°2 的公钥：

```txt
031e81e4c5c6b6a50cbf5d85b15dad720fec92c62e84bafb34088f0488e00a8e94
```

![RGB-Bitcoin](assets/fr/110.webp)

接下来，我们将通过指定相关资产（`PBN`）来打开通道。通过 `/openchannel` 命令，您可以用 satoshis 为单位定义通道的大小，并选择是否包含 RGB 资产。这取决于你想创建什么，但在我的情况下，命令是 ：

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"peer_pubkey_and_opt_addr": "031e81e4c5c6b6a50cbf5d85b15dad720fec92c62e84bafb34088f0488e00a8e94@localhost:9736",
"capacity_sat": 1000000,
"push_msat": 10000000,
"asset_amount": 500,
"asset_id": "rgb:fc7fMj5S-8yz!vIl-260BEhU-Hj1skvM-ZHcjfyz-RTcWc10",
"public": true,
"with_anchors": true,
"fee_base_msat": 1000,
"fee_proportional_millionths": 0,
"temporary_channel_id": "a8b60c8ce3067b5fc881d4831323e24751daec3b64353c8df3205ec5d838f1c5"
}' \
http://localhost:3001/openchannel
```

点击此处了解更多信息：


- peer_pubkey_and_opt_addr`：我们希望连接的对等节点的标识符（我们之前找到的公钥）；
- capacity_sat`：频道总容量（以卫星为单位）；
- push_msat`：通道打开时最初传输给对等设备的数量（单位：毫萨特）（这里我立即传输 10,000 萨特，以便他稍后进行 RGB 传输）；
- `asset_amount`：要投入通道的 RGB 资产数量；
- asset_id`：通道中 RGB 资产的唯一标识符；
- public`：表示通道是否应在网络上公开路由。

![RGB-Bitcoin](assets/fr/111.webp)

为了确认交易，需要开采 6 个区块：

```bash
./regtest.sh mine 6
```

![RGB-Bitcoin](assets/fr/112.webp)

现在，"闪电 "通道已打开，节点 n°1 一侧也包含 500 个 "PBN "代币。如果节点 n°2 希望接收 `PBN` 代币，则必须生成一张发票。具体方法如下

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"amt_msat": 3000000,
"expiry_sec": 420,
"asset_id": "rgb:fc7fMj5S-8yz!vIl-260BEhU-Hj1skvM-ZHcjfyz-RTcWc10",
"asset_amount": 100
}' \
http://localhost:3002/lninvoice
```

与 ：


- amt_msat`：发票金额（单位：毫萨托希）（最少 3000 萨特）；
- expiry_sec`：发票到期时间，以秒为单位；
- asset_id`：与发票相关联的 RGB 资产的标识符；
- 资产金额：与此发票一起转移的 RGB 资产金额。

作为回应，您将收到一张 RGB 发票（如前几章所述）：

```txt
lnbcrt30u1pncgd4rdqud3jxktt5w46x7unfv9kz6mn0v3jsnp4qv0grex9c6m22r9ltkzmzhddwg87eykx96zt47e5pz8sfz8qp28fgpp5jksvqtleryhvwr299qdz96qxzm24augy5agkdhltudk463lt9dassp5d6n0sqgl0c4gx52fdmutrdtqamt0y4xuz2rcgel4hpjwne08gmls9qyysgqcqpcxqzdylz5wfnkywnxvvmkvnt2x4fj6wre0gshvjtv95ervvzzg4592t2gdgchx6mkf5k45jrrdfn8j73d2f2xx4mrxycq7qzry4v4jan6uxhhacyqa4gn6plggwpq9j74tu74f2zsamtz6ymt600p8su4c4ap9g9d8ku2x3wdh6fuc8fd8pff2yzpjrf24ys3cltca9fgqut6gzj
```

![RGB-Bitcoin](assets/fr/113.webp)

现在，我们将从第一个节点支付这张发票，该节点持有必要的`PBN`令牌现金：

```bash
curl -X POST -H "Content-Type: application/json" \
-d '{
"invoice": "lnbcrt30u1pncgd4rdqud3jxktt5w46x7unfv9kz6mn0v3jsnp4qv0grex9c6m22r9ltkzmzhddwg87eykx96zt47e5pz8sfz8qp28fgpp5jksvqtleryhvwr299qdz96qxzm24augy5agkdhltudk463lt9dassp5d6n0sqgl0c4gx52fdmutrdtqamt0y4xuz2rcgel4hpjwne08gmls9qyysgqcqpcxqzdylz5wfnkywnxvvmkvnt2x4fj6wre0gshvjtv95ervvzzg4592t2gdgchx6mkf5k45jrrdfn8j73d2f2xx4mrxycq7qzry4v4jan6uxhhacyqa4gn6plggwpq9j74tu74f2zsamtz6ymt600p8su4c4ap9g9d8ku2x3wdh6fuc8fd8pff2yzpjrf24ys3cltca9fgqut6gzj"
}' \
http://localhost:3001/sendpayment
```

![RGB-Bitcoin](assets/fr/114.webp)

已付款。执行命令 ：

```bash
curl -X 'GET' \
'http://localhost:3001/listpayments' \
-H 'accept: application/json'
```

![RGB-Bitcoin](assets/fr/115.webp)

下面介绍如何部署一个经过修改的 Lightning 节点，以携带 RGB 资产。本演示基于 .NET Framework 3.0：


- regtest 环境（通过 `./regtest.sh`）或 testnet ；
- 一个 Lightning 节点（`rgb-lightning-node`），基于一个`bitcoind`、一个索引器和一个`rgb-proxy-server`；
- 一系列 JSON REST API，用于打开/关闭通道、发行令牌、通过 Lightning 传输资产等。

多亏了这一过程 ：


- 闪电啮合事务包括一个附加输出（OP_RETURN 或 Taproot），锚定 RGB 转换；
- 转账方式与传统的闪电支付完全相同，但增加了一个 RGB 令牌；
- 只要路径上的比特币和资产 RGB 有足够的流动性，就可以连接多个 RLN 节点，在多个节点之间进行路由和支付试验。

该项目仍处于 alpha 阶段。因此强烈建议您只使用测试环境（regtest、testnet）。

这种 LN-RGB 兼容性带来的机遇相当可观：闪电上的稳定币、DEX layer-2、可替代代币或 NFT 的低成本转移......前面几章概述了概念架构和验证逻辑。现在，您可以从实际角度了解如何启动并运行这样一个节点，以用于未来的开发或测试。

# 结论

<partId>b0baebfc-d146-5938-849a-f835fafb386f</partId>


## 评论与评级

<chapterId>0217e8b0-942a-5fee-bd91-9a866551eff3</chapterId>

<isCourseReview>真</isCourseReview>。

## 结论

<chapterId>0309536d-c336-56a0-869e-a8395ed8d9ae</chapterId>

<isCourseConclusion>true</isCourseConclusion>
