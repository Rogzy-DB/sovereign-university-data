---
name: Bitcoin वॉलेट्स का आंतरिक कार्यप्रणाली
goal: Bitcoin वॉलेट्स को शक्ति देने वाले क्रिप्टोग्राफिक सिद्धांतों में गहराई से जानें।
objectives: 
  - बिटकॉइन में उपयोग किए जाने वाले क्रिप्टोग्राफ़िक एल्गोरिदम को समझने के लिए आवश्यक सैद्धांतिक अवधारणाओं को परिभाषित करें।
  - एक नियतात्मक और पदानुक्रमित वॉलेट के निर्माण को पूरी तरह से समझें।
  - वॉलेट के प्रबंधन से जुड़े जोखिमों की पहचान करना और उन्हें कम करना सीखें।
  - हैश फ़ंक्शन, क्रिप्टोग्राफ़िक कुंजियों और डिजिटल हस्ताक्षरों के सिद्धांतों को समझें।

---
# Bitcoin वॉलेट्स के दिल की यात्रा

हमारे CYP201 कोर्स के साथ निर्धारक और श्रेणीबद्ध Bitcoin वॉलेट्स के रहस्यों की खोज करें! चाहे आप एक नियमित उपयोगकर्ता हों या अपनी जानकारी को और गहरा करने के इच्छुक उत्साही, यह कोर्स उन उपकरणों के कामकाज में पूरी तरह से डूबने का अवसर प्रदान करता है जिन्हें हम सभी रोज़ाना इस्तेमाल करते हैं।

आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं। Hash के कार्यों के तरीकों, डिजिटल हस्ताक्षरों (ECDSA और Schnorr), Mnemonic वाक्यांशों, क्रिप्टोग्राफिक कुंजियों और प्राप्त करने वाले पते बनाने की प्रक्रिया के बारे में जानें, और साथ ही उन्नत सुरक्षा रणनीतियों का अन्वेषण करें।

यह प्रशिक्षण न केवल आपको Bitcoin और Wallet की संरचना को समझने के लिए ज्ञान से लैस करेगा, बल्कि आपको क्रिप्टोग्राफी की रोमांचक दुनिया में गहराई से उतरने के लिए भी तैयार करेगा।

स्पष्ट शिक्षण विधियों, 60 से अधिक व्याख्यात्मक चित्रों और ठोस उदाहरणों के साथ, CYP201 आपको A से Z तक यह समझने में सक्षम बनाएगा कि आपका Wallet कैसे काम करता है, ताकि आप Bitcoin ब्रह्मांड में आत्मविश्वास के साथ नेविगेट कर सकें। आज ही अपने UTXOs पर नियंत्रण प्राप्त करें यह समझकर कि HD वॉलेट कैसे काम करते हैं!

+++
# परिचय

<partId>32960669-d13a-592f-a053-37f70b997cbf</partId>

## कोर्स परिचय

<chapterId>fb4e8857-ea35-5a8a-ae8a-5300234e0104</chapterId>

आपका स्वागत है CYP201 कोर्स में, जहाँ हम HD Bitcoin वॉलेट्स के कामकाज को गहराई से समझेंगे। यह कोर्स उन सभी के लिए बनाया गया है जो Bitcoin का तकनीकी आधार समझना चाहते हैं, चाहे वे सामान्य उपयोगकर्ता हों, जागरूक उत्साही हों, या भविष्य के विशेषज्ञ बनने की राह पर हों।

इस प्रशिक्षण का उद्देश्य आपको उन उपकरणों में महारत हासिल करने की कुंजी देना है, जिन्हें आप रोज़ाना इस्तेमाल करते हैं। HD Bitcoin वॉलेट्स, जो आपके उपयोगकर्ता अनुभव के केंद्र में हैं, कभी-कभी जटिल अवधारणाओं पर आधारित होते हैं, जिन्हें हम सरल बनाने की कोशिश करेंगे। हम मिलकर इन्हें समझने में आसानी करेंगे!

Bitcoin वॉलेट्स के निर्माण और संचालन के विवरण में जाने से पहले, हम कुछ अध्यायों के साथ शुरू करेंगे जो क्रिप्टोग्राफिक प्राइमिटिव्स के बारे में जानकारी देंगे, ताकि आगे की जानकारी को समझने में आसानी हो।

हम क्रिप्टोग्राफिक Hash फंक्शन्स से शुरू करेंगे, जो कि वॉलेट्स और खुद Bitcoin प्रोटोकॉल के लिए बुनियादी हैं। आप इनके मुख्य विशेषताओं को जानेंगे, Bitcoin में उपयोग की जाने वाली विशेष फंक्शन्स के बारे में समझेंगे, और एक अधिक तकनीकी अध्याय में, आप Hash फंक्शन्स की रानी SHA256 के काम करने के तरीके के बारे में विस्तार से जानेंगे।

![CYP201](assets/fr/010.webp)

अब हम उन डिजिटल सिग्नेचर एल्गोरिदम के कामकाज पर चर्चा करेंगे, जिन्हें आप हर दिन अपने UTXOs को सुरक्षित करने के लिए उपयोग करते हैं। Bitcoin दो का उपयोग करता है: ECDSA और Schnorr प्रोटोकॉल। आप जानेंगे कि इन एल्गोरिदम के पीछे कौन-कौन से गणितीय आधार होते हैं और ये कैसे लेन-देन की सुरक्षा सुनिश्चित करते हैं।

![CYP201](assets/fr/021.webp)

जब हमें क्रिप्टोग्राफी के इन Elements का अच्छी तरह से समझ आ जाएगा, तब हम आखिरकार प्रशिक्षण के मुख्य भाग की ओर बढ़ेंगे: निर्धारक और पदानुक्रमित वॉलेट्स! सबसे पहले, एक खंड Mnemonic वाक्यांशों के लिए समर्पित है, ये 12 या 24 शब्दों की श्रृंखलाएँ जो आपको अपने वॉलेट्स बनाने और पुनर्स्थापित करने की अनुमति देती हैं। आप जानेंगे कि ये शब्द कैसे एक एंट्रॉपी स्रोत से उत्पन्न होते हैं और कैसे वे Bitcoin के उपयोग को आसान बनाते हैं।

![CYP201](assets/fr/040.webp)

प्रशिक्षण में BIP39 passphrase, seed (जिसे Mnemonic वाक्यांश के साथ भ्रमित नहीं किया जाना चाहिए), मास्टर चेन कोड और मास्टर की का अध्ययन जारी रहेगा। हम विस्तार से देखेंगे कि ये Elements क्या हैं, उनकी भूमिकाएँ क्या हैं, और इन्हें कैसे गणना किया जाता है।

![CYP201](assets/fr/045.webp)

अंत में, मास्टर कुंजी से हम यह जानेंगे कि क्रिप्टोग्राफिक कुंजी जोड़े कैसे एक निश्चित और अनुक्रमिक तरीके से प्राप्त होते हैं, जो प्राप्त करने वाले पते तक जाते हैं।

![CYP201](assets/fr/056.webp)

यह प्रशिक्षण आपको अपने Wallet सॉफ़्टवेयर का आत्मविश्वास के साथ उपयोग करने में सक्षम बनाएगा, साथ ही आपके कौशल को जोखिमों की पहचान और उन्हें कम करने में सुधार करेगा। Bitcoin वॉलेट्स में एक सच्चे विशेषज्ञ बनने के लिए तैयार हो जाइए!

# Hash कार्यक्षमताएँ

<partId>3713fee1-2ec2-512e-9e97-b6da9e4d2f17</partId>

## Hash फ़ंक्शन्स का परिचय

<chapterId>dba011f5-1805-5a48-ac2b-4bd637c93703</chapterId>

Bitcoin पर उपयोग किए जाने वाले पहले प्रकार के क्रिप्टोग्राफिक एल्गोरिदम में Hash फंक्शन शामिल होते हैं। ये प्रोटोकॉल के विभिन्न स्तरों पर और Bitcoin वॉलेट्स के भीतर भी एक महत्वपूर्ण भूमिका निभाते हैं। आइए मिलकर जानें कि Hash फंक्शन क्या है और Bitcoin में इसका उपयोग किस लिए होता है।

### हैशिंग की परिभाषा और सिद्धांत

हैशिंग एक प्रक्रिया है जिसमें किसी भी डेटा को एक निश्चित लंबाई के अद्वितीय कोड या मान में परिवर्तित किया जाता है। यह कोड या मान, जिसे हैश कहा जाता है, डेटा की पहचान करने में मदद करता है और इसे जल्दी से खोजने या संगठित करने में उपयोगी होता है।

हैशिंग का मुख्य सिद्धांत यह है कि यह डेटा को एक छोटे, निश्चित आकार के आउटपुट में बदल देता है, जिससे डेटा को स्टोर करना और एक्सेस करना आसान हो जाता है। हैशिंग का उपयोग अक्सर डेटा संरचनाओं में, जैसे हैश टेबल्स, और सुरक्षा उद्देश्यों के लिए, जैसे पासवर्ड स्टोरेज में किया जाता है। इसका उद्देश्य डेटा को सुरक्षित और कुशल तरीके से प्रबंधित करना है।

हैशिंग एक प्रक्रिया है जो किसी भी लंबाई की जानकारी को एक निश्चित लंबाई की जानकारी में बदल देती है, और यह काम एक क्रिप्टोग्राफिक Hash फंक्शन के माध्यम से होता है। सरल शब्दों में, एक Hash फंक्शन किसी भी आकार की इनपुट लेता है और उसे एक निश्चित आकार के फिंगरप्रिंट में बदल देता है, जिसे "Hash" कहा जाता है।

Hash को कभी-कभी "डाइजेस्ट", "कंडेन्सेट", "कंडेन्स्ड", या "हैश्ड" भी कहा जा सकता है।

उदाहरण के लिए, SHA256 Hash फ़ंक्शन 256 बिट्स की निश्चित लंबाई का Hash उत्पन्न करता है। इसलिए, अगर हम "_PlanB_" इनपुट का उपयोग करते हैं, जो कि किसी भी लंबाई का संदेश हो सकता है, तो उत्पन्न Hash निम्नलिखित 256-बिट फिंगरप्रिंट होगा:

```text
24f1b93b68026bfc24f5c8265f287b4c940fb1664b0d75053589d7a4f821b688
```

![CYP201](assets/fr/001.webp)

### Hash फंक्शन्स की विशेषताएँ

ये क्रिप्टोग्राफिक Hash फंक्शन कुछ महत्वपूर्ण विशेषताएँ रखते हैं जो उन्हें Bitcoin और अन्य कंप्यूटर सिस्टम के संदर्भ में विशेष रूप से उपयोगी बनाती हैं:


- अप्रतिवर्तनीयता (या पूर्वछवि प्रतिरोध)
- छेड़छाड़ प्रतिरोध (एवलांच प्रभाव)
- टकराव प्रतिरोध
- दूसरी प्रीइमेज प्रतिरोध

#### 1. अपरिवर्तनीयता (पूर्वछवि प्रतिरोध):

अपरिवर्तनीयता का मतलब है कि इनपुट जानकारी से Hash की गणना करना आसान है, लेकिन इसका उल्टा, यानी Hash से इनपुट जानकारी को खोजना, व्यावहारिक रूप से असंभव है। इस गुण के कारण Hash फंक्शन्स को अनोखे डिजिटल फिंगरप्रिंट बनाने के लिए आदर्श माना जाता है, बिना मूल जानकारी को नुकसान पहुंचाए।

दिए गए उदाहरण में, अगर आपके पास इनपुट "_PlanB_" है, तो Hash `24f1b9…` प्राप्त करना आसान और तेज़ है। लेकिन अगर आपके पास सिर्फ `24f1b9…` है, तो उससे संदेश "_PlanB_" का पता लगाना असंभव है।

![CYP201](assets/fr/002.webp)

इसलिए, यह असंभव है कि हम किसी Hash $h$ के लिए एक पूर्व-छवि $m$ खोज सकें, जिससे $h = \text{Hash}(m)$ हो, जहाँ $\text{Hash}$ एक क्रिप्टोग्राफिक Hash फंक्शन है।

#### 2. छेड़छाड़ प्रतिरोध (हिमस्खलन प्रभाव)

दूसरी विशेषता है छेड़छाड़ प्रतिरोध, जिसे **एवलांच इफेक्ट** के नाम से भी जाना जाता है। यह विशेषता Hash फंक्शन में तब देखी जाती है जब इनपुट संदेश में थोड़े से बदलाव से आउटपुट Hash में बड़ा बदलाव आ जाता है।

अगर हम अपने उदाहरण पर वापस जाएँ जिसमें इनपुट "_PlanB_" और SHA256 फंक्शन है, तो हमने देखा कि उत्पन्न हुआ Hash इस प्रकार है:

```text
24f1b93b68026bfc24f5c8265f287b4c940fb1664b0d75053589d7a4f821b688
```

अगर हम इनपुट में थोड़ा सा बदलाव करें और इस बार "_Planb_" का उपयोग करें, तो सिर्फ "B" को बड़े अक्षर से छोटे अक्षर "b" में बदलने से SHA256 आउटपुट पूरी तरह से बदल जाता है Hash:

```text
bb038b4503ac5d90e1205788b00f8f314583c5e22f72bec84b8735ba5a36df3f
```

![CYP201](assets/fr/003.webp)

यह गुण सुनिश्चित करता है कि मूल संदेश में थोड़े से भी बदलाव को तुरंत पहचाना जा सकता है, क्योंकि यह सिर्फ Hash के एक छोटे हिस्से को नहीं बदलता, बल्कि पूरे Hash को बदल देता है। यह विभिन्न क्षेत्रों में संदेशों, सॉफ़्टवेयर, या यहां तक कि Bitcoin लेनदेन की सत्यता की जांच करने के लिए उपयोगी हो सकता है।

#### 3. टकराव प्रतिरोध

तीसरी विशेषता है टकराव प्रतिरोध। एक Hash फ़ंक्शन टकराव-प्रतिरोधी होता है यदि यह गणनात्मक रूप से असंभव हो कि 2 अलग-अलग संदेशों को ढूंढा जा सके जो फ़ंक्शन से वही Hash आउटपुट उत्पन्न करते हैं। औपचारिक रूप से, यह दो भिन्न संदेश $m_1$ और $m_2$ को ढूंढना कठिन होता है ताकि:

$$
\text{HASH}(m_1) = \text{HASH}(m_2)
$$

![CYP201](assets/fr/004.webp)

वास्तव में, यह गणितीय रूप से अनिवार्य है कि Hash फंक्शनों के लिए टकराव मौजूद होते हैं, क्योंकि इनपुट का आकार आउटपुट के आकार से बड़ा हो सकता है। इसे डिरिख्ले ड्रॉअर सिद्धांत के रूप में जाना जाता है: यदि $n$ वस्तुओं को $m$ ड्रॉअर में वितरित किया जाता है, जहां $m < n$ है, तो कम से कम एक ड्रॉअर में अनिवार्य रूप से दो या अधिक वस्तुएं होंगी। Hash फंक्शन के लिए, यह सिद्धांत लागू होता है क्योंकि संभावित संदेशों की संख्या (लगभग) अनंत है, जबकि संभावित हैश की संख्या सीमित है ($2^{256}$ SHA256 के मामले में)।

इसका मतलब यह नहीं है कि Hash फंक्शन्स के लिए कोई टकराव नहीं होते, बल्कि यह है कि एक अच्छा Hash फंक्शन टकराव मिलने की संभावना को नगण्य बना देता है। उदाहरण के लिए, यह विशेषता SHA-0 और SHA-1 एल्गोरिदम पर लागू नहीं होती, जो SHA-2 के पूर्ववर्ती हैं, और जिनमें टकराव पाए गए हैं। इसलिए, इन फंक्शन्स का अब उपयोग करने की सलाह नहीं दी जाती और इन्हें अक्सर पुराना माना जाता है।

यदि आपके पास $n$ बिट्स का एक Hash फंक्शन है, तो उसकी टकराव प्रतिरोधक क्षमता लगभग $2^{\frac{n}{2}}$ के क्रम की होती है, जो कि बर्थडे अटैक के अनुसार है। उदाहरण के लिए, SHA256 ($n = 256$) के लिए, टकराव खोजने की जटिलता लगभग $2^{128}$ प्रयासों के क्रम की होती है। व्यावहारिक रूप से, इसका मतलब यह है कि यदि आप इस फंक्शन के माध्यम से $2^{128}$ अलग-अलग संदेश भेजते हैं, तो आपको संभवतः एक टकराव मिल सकता है।

#### 4. दूसरे प्रीइमेज के प्रति प्रतिरोध

दूसरे प्रीइमेज के प्रति प्रतिरोध Hash फंक्शनों की एक और महत्वपूर्ण विशेषता है। इसका मतलब है कि यदि आपके पास एक संदेश $m_1$ और उसका Hash $h$ है, तो यह गणनात्मक रूप से असंभव है कि आप कोई दूसरा संदेश $m_2 \neq m_1$ ढूंढ सकें, जिससे:

$$
\text{HASH}(m_1) = \text{HASH}(m_2)
$$

इसलिए, दूसरे प्रीइमेज के प्रति प्रतिरोध कुछ हद तक टकराव प्रतिरोध के समान होता है, लेकिन यहाँ पर हमला करना थोड़ा मुश्किल होता है क्योंकि हमलावर $m_1$ को स्वतंत्र रूप से चुन नहीं सकता।

![CYP201](assets/fr/005.webp)

### Hash फ़ंक्शन्स का Bitcoin में उपयोग

Bitcoin में सबसे ज्यादा इस्तेमाल किया जाने वाला Hash फंक्शन **SHA256** है, जिसे "_सिक्योर Hash एल्गोरिदम 256 बिट्स_" भी कहा जाता है। इसे 2000 के दशक की शुरुआत में NSA द्वारा डिज़ाइन किया गया था और NIST द्वारा मानकीकृत किया गया था। यह 256-बिट का Hash आउटपुट उत्पन्न करता है।

यह फंक्शन Bitcoin के कई पहलुओं में उपयोग किया जाता है। प्रोटोकॉल स्तर पर, यह Proof-of-Work मैकेनिज्म में शामिल होता है, जहां इसे डबल हैशिंग में लागू किया जाता है ताकि एक संभावित ब्लॉक के हेडर, जिसे Miner द्वारा बनाया गया है, और कठिनाई लक्ष्य के बीच आंशिक टकराव खोजा जा सके। अगर यह आंशिक टकराव मिल जाता है, तो संभावित ब्लॉक वैध हो जाता है और उसे Blockchain में जोड़ा जा सकता है।

SHA256 का उपयोग Merkle Tree के निर्माण में भी किया जाता है, जो विशेष रूप से ब्लॉकों में लेनदेन रिकॉर्ड करने के लिए एकत्रक के रूप में उपयोग होता है। यह संरचना Utreexo प्रोटोकॉल में भी पाई जाती है, जो UTXO सेट के आकार को कम करने की अनुमति देती है। इसके अलावा, 2021 में Taproot के परिचय के साथ, SHA256 का उपयोग MAST (_Merkelised Alternative Script Tree_) में किया जाता है, जो स्क्रिप्ट में केवल उन्हीं खर्च की शर्तों को प्रकट करने की अनुमति देता है जो वास्तव में उपयोग की गई हैं, बिना अन्य संभावित विकल्पों को प्रकट किए। यह लेनदेन पहचानकर्ताओं की गणना में, P2P नेटवर्क पर पैकेटों के प्रसारण में, इलेक्ट्रॉनिक हस्ताक्षरों में भी उपयोग होता है... अंत में, और यह इस प्रशिक्षण में विशेष रूप से रुचिकर है, SHA256 का उपयोग एप्लिकेशन स्तर पर Bitcoin वॉलेट्स के निर्माण और पतों की व्युत्पत्ति के लिए किया जाता है।

अधिकतर समय, जब आप Bitcoin पर SHA256 का उपयोग देखते हैं, तो वास्तव में यह एक डबल Hash SHA256 होता है, जिसे "**HASH256**" कहा जाता है। इसका मतलब है कि SHA256 को दो बार लगातार लागू किया जाता है।

$$
\text{HASH256}(m) = \text{SHA256}(\text{SHA256}(m))
$$

यह डबल हैशिंग की प्रक्रिया कुछ संभावित हमलों के खिलाफ अतिरिक्त Layer सुरक्षा जोड़ती है, भले ही आज एकल SHA256 को क्रिप्टोग्राफिक रूप से सुरक्षित माना जाता है।

स्क्रिप्ट भाषा में एक और हैशिंग फंक्शन उपलब्ध है, जिसका उपयोग प्राप्त करने वाले पते निकालने के लिए किया जाता है, वह है RIPEMD160 फंक्शन। यह फंक्शन 160-बिट Hash उत्पन्न करता है (जो SHA256 से छोटा होता है)। इसे आमतौर पर SHA256 के साथ मिलाकर HASH160 फंक्शन बनाया जाता है।

$$
\text{HASH160}(m) = \text{RIPEMD160}(\text{SHA256}(m))
$$

यह संयोजन generate छोटे हैश बनाने के लिए उपयोग किया जाता है, खासकर कुछ Bitcoin पतों के निर्माण में जो कुंजियों या स्क्रिप्ट हैश के हैश का प्रतिनिधित्व करते हैं, और साथ ही कुंजी फिंगरप्रिंट्स बनाने के लिए भी।

आखिरकार, केवल एप्लिकेशन स्तर पर, कभी-कभी SHA512 फ़ंक्शन का भी उपयोग किया जाता है, जो वॉलेट्स के लिए कुंजी व्युत्पत्ति में अप्रत्यक्ष रूप से भूमिका निभाता है। यह फ़ंक्शन अपने संचालन में SHA256 के बहुत समान है; दोनों एक ही SHA2 परिवार से संबंधित हैं, लेकिन SHA512, जैसा कि इसके नाम से पता चलता है, 512-बिट Hash उत्पन्न करता है, जबकि SHA256 256 बिट्स उत्पन्न करता है। हम इसके उपयोग का विवरण अगले अध्यायों में देंगे।

अब आप हैशिंग फंक्शन्स के बारे में आवश्यक मूल बातें जान चुके हैं। अगले अध्याय में, मैं आपको Bitcoin के केंद्र में स्थित फंक्शन SHA256 के कामकाज को और विस्तार से समझाने का प्रस्ताव करता हूँ। हम इसे इस तरह से समझेंगे कि यह उन विशेषताओं को कैसे प्राप्त करता है जिनका हमने यहाँ वर्णन किया है। यह अगला अध्याय काफी लंबा और तकनीकी है, लेकिन बाकी प्रशिक्षण को समझने के लिए यह आवश्यक नहीं है। इसलिए, यदि इसे समझने में कठिनाई हो रही है, तो चिंता न करें और सीधे अगले अध्याय पर जाएं, जो अधिक सुलभ होगा।

## SHA256 के आंतरिक कार्यप्रणाली

<chapterId>905eb320-f15b-5fb6-8d2d-5bb447337deb</chapterId>

हमने पहले देखा है कि हैशिंग फंक्शन्स में कुछ महत्वपूर्ण विशेषताएँ होती हैं जो Bitcoin पर उनके उपयोग को सही ठहराती हैं। अब आइए इन हैशिंग फंक्शन्स के आंतरिक तंत्र की जांच करें जो उन्हें ये गुण प्रदान करते हैं, और इसके लिए, मैं SHA256 के संचालन को विस्तार से समझने का प्रस्ताव करता हूँ।

SHA256 और SHA512 फंक्शन एक ही SHA2 परिवार के अंतर्गत आते हैं। इनका काम करने का तरीका एक विशेष निर्माण पर आधारित है जिसे **Merkle-Damgård निर्माण** कहा जाता है। RIPEMD160 भी इसी प्रकार के निर्माण का उपयोग करता है।

याद दिला दें कि हमारे पास एक संदेश है जिसकी आकार सीमा तय नहीं है, जिसे हम SHA256 में इनपुट के रूप में देंगे। इसे फंक्शन के माध्यम से पास करके हमें 256-बिट का Hash आउटपुट प्राप्त होगा।

### इनपुट की पूर्व-प्रसंस्करण

शुरू करने के लिए, हमें अपने इनपुट संदेश $m$ को इस तरह तैयार करना होगा कि उसकी लंबाई 512 बिट्स के गुणज में हो। यह कदम बाद में एल्गोरिदम के सही तरीके से काम करने के लिए बहुत महत्वपूर्ण है।

इस काम को करने के लिए, हम सबसे पहले पैडिंग बिट्स के चरण से शुरू करते हैं। हम पहले संदेश के अंत में एक विभाजक बिट `1` जोड़ते हैं, उसके बाद कुछ `0` बिट्स जोड़ते हैं। जोड़े गए `0` बिट्स की संख्या इस तरह से तय की जाती है कि इस जोड़ के बाद संदेश की कुल लंबाई 512 से विभाजित करने पर 448 के बराबर हो। इस प्रकार, पैडिंग बिट्स के साथ संदेश की लंबाई $L$ इस प्रकार होती है:

$$
L \equiv 448 \mod 512
$$

$\text{mod}$, जिसे मॉड्यूलो कहा जाता है, एक गणितीय ऑपरेशन है जो दो पूर्णांकों के बीच किया जाता है। यह ऑपरेशन पहले संख्या को दूसरी संख्या से भाग देकर शेषफल को लौटाता है। उदाहरण के लिए: $16 \mod 5 = 1$। यह ऑपरेशन क्रिप्टोग्राफी में बहुत अधिक उपयोग किया जाता है।

यहाँ, पैडिंग चरण यह सुनिश्चित करता है कि अगले चरण में 64 बिट्स जोड़ने के बाद, समतलित संदेश की कुल लंबाई 512 बिट्स के गुणज में होगी। यदि प्रारंभिक संदेश की लंबाई $M$ बिट्स है, तो जोड़े जाने वाले `0` बिट्स की संख्या ($N$) इस प्रकार होगी:

$$
N = (448 - (M + 1) \mod 512) \mod 512
$$

उदाहरण के लिए, अगर शुरुआती संदेश 950 बिट्स का है, तो गणना इस प्रकार होगी:

$$
\begin{align*}
M & = 950 \\
M + 1 & = 951 \\
(M + 1) \mod 512 & = 951 \mod 512 \\
& = 951 - 512 \cdot \left\lfloor \frac{951}{512} \right\rfloor \\
& = 951 - 512 \cdot 1 \\
& = 951 - 512 \\
& = 439 \\
\\
448 - (M + 1) \mod 512 & = 448 - 439 \\
& = 9 \\
\\
N & = (448 - (M + 1) \mod 512) \mod 512 \\
N & = 9 \mod 512 \\
& = 9
\end{align*}
$$

इस प्रकार, हमारे पास 9 `0` होंगे इसके अलावा एक विभाजक `1` होगा। हमारे संदेश $M$ के ठीक बाद जो पैडिंग बिट्स जोड़ने हैं, वे इस प्रकार होंगे:

```text
1000 0000 00
```

हमारे संदेश $M$ में पैडिंग बिट्स जोड़ने के बाद, हम संदेश $M$ की मूल लंबाई का 64-बिट प्रतिनिधित्व भी जोड़ते हैं, जिसे बाइनरी में व्यक्त किया जाता है। यह Hash फंक्शन को बिट्स के क्रम और संदेश की लंबाई के प्रति संवेदनशील बनाता है।

अगर हम अपने उदाहरण में 950 बिट्स के शुरुआती संदेश पर वापस जाएं, तो हम दशमलव संख्या `950` को बाइनरी में बदलते हैं, जो हमें `1110 1101 10` देता है। हम इस संख्या को आधार पर शून्य जोड़कर पूरा करते हैं ताकि कुल 64 बिट्स हो जाएं। हमारे उदाहरण में, यह इस प्रकार होता है:

```text
0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0011 1011 0110
```

यह पैडिंग आकार बिट पैडिंग के बाद जोड़ा जाता है। इसलिए, हमारे पूर्वप्रसंस्करण के बाद संदेश तीन भागों में होता है:


- मूल संदेश $M$;
- एक बिट `1` के बाद कई बिट `0` आते हैं ताकि बिट पैडिंग बनाई जा सके।
- $M$ की लंबाई को 64-बिट में दर्शाना ताकि इसे आकार के साथ पैडिंग बनाने में इस्तेमाल किया जा सके।

![CYP201](assets/fr/006.webp)

### वेरिएबल्स की प्रारंभिक स्थापना

SHA256 में आठ प्रारंभिक स्थिति चर होते हैं, जिन्हें $A$ से $H$ तक दर्शाया जाता है, और ये प्रत्येक 32 बिट के होते हैं। इन चर को विशेष स्थिरांक के साथ प्रारंभ किया जाता है, जो पहले आठ अभाज्य संख्याओं के वर्गमूल के भिन्नात्मक भाग होते हैं। हम इन मानों का उपयोग हैशिंग प्रक्रिया के दौरान करेंगे:


- $A = 0x6a09e667$ 

यह एक हेक्साडेसिमल संख्या है।
- $B = 0xbb67ae85$
- $C = 0x3c6ef372$
- $D = 0xa54ff53a$ एक हेक्साडेसिमल संख्या है। हेक्साडेसिमल प्रणाली में 0-9 के अलावा A-F अक्षरों का उपयोग होता है, जहाँ A का मतलब 10, B का मतलब 11, और इसी तरह F का मतलब 15 होता है। इस संख्या को दशमलव (decimal) में बदलने के लिए, आप इसे 16 के आधार पर विस्तारित कर सकते हैं।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
- $G = 0x1f83d9ab$ एक हेक्साडेसिमल संख्या है। हेक्साडेसिमल प्रणाली में 0-9 के अलावा A-F अक्षरों का उपयोग होता है, जो 10-15 के मान को दर्शाते हैं। इस संख्या को समझने के लिए, इसे दशमलव प्रणाली में बदल सकते हैं।
- $H = 0x5be0cd19$

SHA256 एल्गोरिदम में 64 अन्य स्थिरांक भी उपयोग होते हैं, जिन्हें $K_0$ से $K_{63}$ तक दर्शाया जाता है। ये स्थिरांक पहले 64 अभाज्य संख्याओं के घनमूल के भिन्नांश होते हैं।

$$
K[0 \ldots 63] = \begin{pmatrix}
0x428a2f98, & 0x71374491, & 0xb5c0fbcf, & 0xe9b5dba5, \\
0x3956c25b, & 0x59f111f1, & 0x923f82a4, & 0xab1c5ed5, \\
0xd807aa98, & 0x12835b01, & 0x243185be, & 0x550c7dc3, \\
0x72be5d74, & 0x80deb1fe, & 0x9bdc06a7, & 0xc19bf174, \\
0xe49b69c1, & 0xefbe4786, & 0x0fc19dc6, & 0x240ca1cc, \\
0x2de92c6f, & 0x4a7484aa, & 0x5cb0a9dc, & 0x76f988da, \\
0x983e5152, & 0xa831c66d, & 0xb00327c8, & 0xbf597fc7, \\
0xc6e00bf3, & 0xd5a79147, & 0x06ca6351, & 0x14292967, \\
0x27b70a85, & 0x2e1b2138, & 0x4d2c6dfc, & 0x53380d13, \\
0x650a7354, & 0x766a0abb, & 0x81c2c92e, & 0x92722c85, \\
0xa2bfe8a1, & 0xa81a664b, & 0xc24b8b70, & 0xc76c51a3, \\
0xd192e819, & 0xd6990624, & 0xf40e3585, & 0x106aa070, \\
0x19a4c116, & 0x1e376c08, & 0x2748774c, & 0x34b0bcb5, \\
0x391c0cb3, & 0x4ed8aa4a, & 0x5b9cca4f, & 0x682e6ff3, \\
0x748f82ee, & 0x78a5636f, & 0x84c87814, & 0x8cc70208, \\
0x90befffa, & 0xa4506ceb, & 0xbef9a3f7, & 0xc67178f2
\end{pmatrix}
$$

### इनपुट का विभाजन

अब जब हमारे पास समान इनपुट है, तो हम SHA256 एल्गोरिदम के मुख्य प्रसंस्करण चरण की ओर बढ़ेंगे: संपीड़न फ़ंक्शन। यह चरण बहुत महत्वपूर्ण है, क्योंकि यही मुख्य रूप से Hash फ़ंक्शन को उसके क्रिप्टोग्राफिक गुण प्रदान करता है, जिनका हमने पिछले अध्याय में अध्ययन किया था।

सबसे पहले, हम अपने समतलित संदेश (प्रारंभिक प्रसंस्करण चरणों का परिणाम) को 512 बिट्स के कई ब्लॉकों $P$ में विभाजित करते हैं। यदि हमारे समतलित संदेश का कुल आकार $n \times 512$ बिट्स है, तो हमारे पास $n$ ब्लॉक होंगे, जिनमें से प्रत्येक 512 बिट्स का होगा। प्रत्येक 512-बिट ब्लॉक को संपीड़न फ़ंक्शन द्वारा व्यक्तिगत रूप से संसाधित किया जाएगा, जिसमें 64 राउंड की लगातार क्रियाएं शामिल होती हैं। चलिए इन ब्लॉकों को $P_1$, $P_2$, $P_3$... नाम देते हैं।

### तार्किक संचालन

कंप्रेशन फंक्शन को विस्तार से समझने से पहले, इसमें उपयोग होने वाले बुनियादी लॉजिकल ऑपरेशन्स को समझना ज़रूरी है। ये ऑपरेशन्स, जो बूलियन बीजगणित पर आधारित होते हैं, बिट स्तर पर काम करते हैं। उपयोग किए जाने वाले बुनियादी लॉजिकल ऑपरेशन्स हैं:


- संयोजन (AND)**: इसे $\land$ से दर्शाया जाता है, और यह एक तार्किक "और" के समान होता है।
- विच्छेदन (या): जिसे $\lor$ से दर्शाया जाता है, यह एक तार्किक "या" के समान होता है।
- निषेध (NOT)**: जिसे $\lnot$ से दर्शाया जाता है, यह एक तार्किक "NOT" के समान होता है।

इन बुनियादी क्रियाओं से, हम और जटिल क्रियाओं को परिभाषित कर सकते हैं, जैसे "एक्सक्लूसिव OR" (XOR) जिसे $\oplus$ से दर्शाया जाता है, और यह क्रिप्टोग्राफी में व्यापक रूप से उपयोग होता है।

हर तार्किक ऑपरेशन को एक सत्य सारणी (ट्रुथ टेबल) द्वारा दर्शाया जा सकता है, जो सभी संभावित द्विआधारी इनपुट मानों (दो ऑपरेण्ड $p$ और $q$) के लिए परिणाम दिखाती है।

XOR ($\oplus$) के लिए:

| $p$ | $q$ | $p \oplus q$ |

| --- | --- | ------------ |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

और (AND) के लिए:

| $p$ | $q$ | $p \land q$ |

इस तालिका में $p$ और $q$ दो कथन हैं, और $p \land q$ का मतलब है कि दोनों कथन सही हैं। अगर दोनों $p$ और $q$ सही हैं, तो $p \land q$ भी सही होगा। अगर इनमें से कोई भी एक गलत है, तो $p \land q$ गलत होगा।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

NOT ($\lnot p$) का मतलब है "नहीं p"। इसका मतलब है कि अगर p सच है, तो NOT p झूठ होगा, और अगर p झूठ है, तो NOT p सच होगा। यह एक तार्किक ऑपरेशन है जो किसी कथन की सच्चाई को उलट देता है। उदाहरण के लिए, अगर p का मतलब है "आज बारिश हो रही है," तो NOT p का मतलब होगा "आज बारिश नहीं हो रही है।"

| $p$ | $\lnot p$ |
|---|---|
| सत्य | असत्य |
| असत्य | सत्य |

| --- | --------- |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आइए एक उदाहरण लेते हैं ताकि हम बिट स्तर पर XOR ऑपरेशन को समझ सकें। मान लीजिए हमारे पास दो 6 बिट के बाइनरी नंबर हैं:


- $a = 101100$
- $b = 001000$

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

$$
a \oplus b = 101100 \oplus 001000 = 100100
$$

बिट दर बिट XOR लागू करके:

| बिट स्थिति | $a$ | $b$ | $a \oplus b$ |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

इसलिए परिणाम $100100$ है।

तार्किक संचालन के अलावा, संपीड़न फ़ंक्शन बिट-शिफ्टिंग संचालन का उपयोग करता है, जो एल्गोरिदम में बिट्स के प्रसार में एक महत्वपूर्ण भूमिका निभाएगा।

पहले, एक लॉजिकल राइट शिफ्ट ऑपरेशन होता है, जिसे $ShR_n(x)$ के रूप में दर्शाया जाता है। इसमें $x$ के सभी बिट्स को $n$ स्थानों तक दाईं ओर खिसकाया जाता है, और बाईं ओर खाली हुए स्थानों को शून्य से भरा जाता है।

उदाहरण के लिए, यदि $x = 101100001$ (9 बिट्स में) और $n = 4$ हो:

$$
ShR_4(101100001) = 000010110
$$

योजना के अनुसार, दाएँ शिफ्ट ऑपरेशन को इस तरह देखा जा सकता है:

![CYP201](assets/fr/007.webp)

SHA256 में बिट्स को मैनेज करने के लिए एक और ऑपरेशन का उपयोग होता है जिसे राइट सर्कुलर रोटेशन कहते हैं। इसे $RotR_n(x)$ के रूप में दर्शाया जाता है। इसमें $x$ के बिट्स को $n$ स्थानों तक दाईं ओर घुमाया जाता है और जो बिट्स शिफ्ट होते हैं उन्हें स्ट्रिंग की शुरुआत में फिर से डाल दिया जाता है।

उदाहरण के लिए, यदि $x = 101100001$ (9 बिट्स में) और $n = 4$ हो:

$$
RotR_4(101100001) = 000110110
$$

योजना के अनुसार, दाएँ सर्कुलर शिफ्ट ऑपरेशन को इस तरह देखा जा सकता है:

![CYP201](assets/fr/008.webp)

### संपीड़न फ़ंक्शन

अब जब हमने बुनियादी प्रक्रियाओं को समझ लिया है, तो चलिए SHA256 संपीड़न फ़ंक्शन को विस्तार से देखते हैं।

पिछले चरण में, हमने अपनी इनपुट को कई 512-बिट के टुकड़ों $P$ में विभाजित किया। प्रत्येक 512-बिट ब्लॉक $P$ के लिए, हमारे पास है:


- संदेश शब्द $W_i$**: जहाँ $i$ की मान 0 से 63 तक होती है।
- $K_i$ स्थिरांक: जहाँ $i$ की मान 0 से 63 तक होती है, जैसा कि पिछले चरण में परिभाषित किया गया है।
- राज्य चर $A, B, C, D, E, F, G, H$**: पिछले चरण से प्राप्त मानों के साथ प्रारंभ किए गए हैं।

पहले 16 शब्द, $W_0$ से $W_{15}$, सीधे 512-बिट के प्रोसेस किए गए ब्लॉक $P$ से निकाले जाते हैं। प्रत्येक शब्द $W_i$ ब्लॉक के 32 लगातार बिट्स से बना होता है। उदाहरण के लिए, हम अपनी पहली इनपुट $P_1$ लेते हैं और इसे और छोटे 32-बिट के टुकड़ों में विभाजित करते हैं, जिन्हें हम शब्द कहते हैं।

अगले 48 शब्द ($W_{16}$ से $W_{63}$ तक) निम्नलिखित सूत्र का उपयोग करके उत्पन्न किए जाते हैं:

$$
W_i = W_{i-16} + \sigma_0(W_{i-15}) + W_{i-7} + \sigma_1(W_{i-2}) \mod 2^{32}
$$

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।


- $\sigma_0(x) = RotR_7(x) \oplus RotR_{18}(x) \oplus ShR_3(x)$ का मतलब है कि हम $x$ पर तीन अलग-अलग ऑपरेशन्स कर रहे हैं और फिर उनके परिणामों को XOR (जिसे $\oplus$ से दर्शाया गया है) के साथ जोड़ रहे हैं।

1. $RotR_7(x)$ का मतलब है कि $x$ को 7 बिट्स से राइट रोटेट करना।
2. $RotR_{18}(x)$ का मतलब है कि $x$ को 18 बिट्स से राइट रोटेट करना।
3. $ShR_3(x)$ का मतलब है कि $x$ को 3 बिट्स से राइट शिफ्ट करना।

इन तीनों ऑपरेशन्स के परिणामों को XOR ऑपरेशन के जरिए जोड़कर हमें $\sigma_0(x)$ मिलता है। यह एक सामान्य प्रक्रिया है जो क्रिप्टोग्राफी और हैशिंग एल्गोरिदम में उपयोग की जाती है।
- $\sigma_1(x) = RotR_{17}(x) \oplus RotR_{19}(x) \oplus ShR_{10}(x)$ का मतलब है कि हम $x$ पर तीन अलग-अलग बिट ऑपरेशन्स कर रहे हैं और फिर उनके परिणामों को XOR ऑपरेशन के जरिए जोड़ रहे हैं।

1. $RotR_{17}(x)$ का मतलब है कि $x$ को 17 बिट्स राइट रोटेट करना।
2. $RotR_{19}(x)$ का मतलब है कि $x$ को 19 बिट्स राइट रोटेट करना।
3. $ShR_{10}(x)$ का मतलब है कि $x$ को 10 बिट्स राइट शिफ्ट करना।

इन तीनों ऑपरेशन्स के परिणामों को XOR ऑपरेशन के जरिए जोड़कर हमें $\sigma_1(x)$ मिलता है।

इस मामले में, $\sigma_0(x)$ के लिए $x$ का मान $W_{i-15}$ है और $\sigma_1(x)$ के लिए $x$ का मान $W_{i-2}$ है।

जब हमने अपने 512-बिट टुकड़े के लिए सभी शब्द $W_i$ निर्धारित कर लिए हैं, तो हम संपीड़न फ़ंक्शन की ओर बढ़ सकते हैं, जिसमें 64 राउंड शामिल होते हैं।

![CYP201](assets/fr/009.webp)

प्रत्येक राउंड $i$ के लिए, जो 0 से 63 तक होते हैं, हमारे पास तीन प्रकार के इनपुट होते हैं। सबसे पहले, $W_i$ होता है जिसे हमने अभी निर्धारित किया है, जो आंशिक रूप से हमारे संदेश के टुकड़े $P_n$ से बना होता है। इसके बाद, 64 स्थिरांक $K_i$ होते हैं। अंत में, हम स्टेट वेरिएबल्स $A$, $B$, $C$, $D$, $E$, $F$, $G$, और $H$ का उपयोग करते हैं, जो हैशिंग प्रक्रिया के दौरान विकसित होते हैं और प्रत्येक संपीड़न फ़ंक्शन के साथ संशोधित होते हैं। हालांकि, पहले टुकड़े $P_1$ के लिए, हम पहले से दिए गए प्रारंभिक स्थिरांक का उपयोग करते हैं।

इसके बाद हम अपने इनपुट पर निम्नलिखित कार्य करते हैं:


- कार्य $\Sigma_0$:**

$$
\Sigma_0(A) = RotR_2(A) \oplus RotR_{13}(A) \oplus RotR_{22}(A)
$$


- फंक्शन $\Sigma_1$:**

$$
\Sigma_1(E) = RotR_6(E) \oplus RotR_{11}(E) \oplus RotR_{25}(E)
$$


- फ़ंक्शन $Ch$ ("_चुनें_"):**

$$
Ch(E, F, G) = (E \land F) \oplus (\lnot E \land G)
$$


- फ़ंक्शन $Maj$ ("_बहुमत_"):**

$$
Maj(A, B, C) = (A \land B) \oplus (A \land C) \oplus (B \land C)
$$

फिर हम 2 अस्थायी चर की गणना करते हैं:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

$$
temp1 = H + \Sigma_1(E) + Ch(E, F, G) + K_i + W_i \mod 2^{32}
$$


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

$$
temp2 = \Sigma_0(A) + Maj(A, B, C) \mod 2^{32}
$$

अब, हम राज्य चर को इस प्रकार अपडेट करते हैं:

$$
\begin{cases}
H = G \\
G = F \\
F = E \\
E = D + temp1 \mod 2^{32} \\
D = C \\
C = B \\
B = A \\
A = temp1 + temp2 \mod 2^{32}
\end{cases}
$$

निम्नलिखित चित्रण उस दौर को दर्शाता है जो हमने अभी-अभी वर्णित किया है: SHA256 संपीड़न फ़ंक्शन का एक दौर।

![CYP201](assets/fr/010.webp)


- तीर डेटा के प्रवाह को दर्शाते हैं।
- डिब्बे उन कार्यों का प्रतिनिधित्व करते हैं जो किए गए हैं;
- यहाँ पर $+$ के चारों ओर जो निशान है, वह $2^{32}$ के मापांक में जोड़ को दर्शाता है।

हम पहले से ही देख सकते हैं कि इस चरण में नए स्थिति चर $A$, $B$, $C$, $D$, $E$, $F$, $G$, और $H$ उत्पन्न होते हैं। ये नए चर अगले चरण के लिए इनपुट के रूप में काम करेंगे, जो बदले में नए चर $A$, $B$, $C$, $D$, $E$, $F$, $G$, और $H$ उत्पन्न करेगा, जिन्हें अगले चरण के लिए उपयोग किया जाएगा। यह प्रक्रिया 64वें चरण तक चलती रहती है।

64 राउंड के बाद, हम प्रारंभिक मानों को राउंड 64 के अंत में प्राप्त अंतिम मानों में जोड़कर राज्य चर के प्रारंभिक मानों को अपडेट करते हैं।

$$
\begin{cases}
A = A_{\text{initial}} + A \mod 2^{32} \\
B = B_{\text{initial}} + B \mod 2^{32} \\
C = C_{\text{initial}} + C \mod 2^{32} \\
D = D_{\text{initial}} + D \mod 2^{32} \\
E = E_{\text{initial}} + E \mod 2^{32} \\
F = F_{\text{initial}} + F \mod 2^{32} \\
G = G_{\text{initial}} + G \mod 2^{32} \\
H = H_{\text{initial}} + H \mod 2^{32}
\end{cases}
$$

ये नए मान $A$, $B$, $C$, $D$, $E$, $F$, $G$, और $H$ अगले ब्लॉक $P_2$ के लिए प्रारंभिक मान के रूप में काम करेंगे। इस ब्लॉक $P_2$ के लिए, हम 64 राउंड के साथ वही संपीड़न प्रक्रिया दोहराते हैं, फिर हम ब्लॉक $P_3$ के लिए वेरिएबल्स को अपडेट करते हैं, और इसी तरह तब तक करते रहते हैं जब तक कि हमारे समतलित इनपुट का अंतिम ब्लॉक पूरा नहीं हो जाता।

सभी संदेश ब्लॉकों को प्रोसेस करने के बाद, हम वेरिएबल्स $A$, $B$, $C$, $D$, $E$, $F$, $G$, और $H$ के अंतिम मानों को जोड़ते हैं ताकि हमारी हैशिंग फंक्शन का अंतिम 256-बिट Hash तैयार हो सके।

$$
\text{Hash} = A \Vert B \Vert C \Vert D \Vert E \Vert F \Vert G \Vert H
$$

प्रत्येक वेरिएबल 32-बिट का पूर्णांक है, इसलिए जब हम इन्हें जोड़ते हैं, तो यह हमेशा 256-बिट का परिणाम देता है, चाहे हमारे हैशिंग फंक्शन में संदेश इनपुट का आकार कुछ भी हो।

### क्रिप्टोग्राफिक गुणों का औचित्यकरण

लेकिन फिर, यह फ़ंक्शन अपरिवर्तनीय, टकराव-प्रतिरोधी और छेड़छाड़-प्रतिरोधी कैसे है?

छेड़छाड़ प्रतिरोध को समझना काफी आसान है। इसमें कई गणनाएँ एक के बाद एक की जाती हैं, जो इनपुट और स्थिरांक दोनों पर निर्भर करती हैं। अगर प्रारंभिक संदेश में थोड़ी सी भी बदलाव होती है, तो यह पूरी तरह से रास्ता बदल देती है, और इस तरह से आउटपुट Hash भी पूरी तरह से बदल जाता है। इसे ही हिमस्खलन प्रभाव कहा जाता है। इस गुण को आंशिक रूप से प्रत्येक टुकड़े के लिए मध्यवर्ती अवस्थाओं को प्रारंभिक अवस्थाओं के साथ मिलाकर सुनिश्चित किया जाता है।

जब हम क्रिप्टोग्राफिक Hash फंक्शन की बात करते हैं, तो "अप्रतिवर्तनीयता" शब्द का उपयोग आमतौर पर नहीं किया जाता है। इसके बजाय, हम "प्राइमेज रेजिस्टेंस" की बात करते हैं, जो यह बताता है कि किसी दिए गए $y$ के लिए, ऐसा $x$ ढूंढना मुश्किल होता है कि $h(x) = y$ हो। यह प्राइमेज रेजिस्टेंस उस अलजेब्रिक जटिलता और उन मजबूत गैर-रेखीय ऑपरेशनों द्वारा सुनिश्चित की जाती है जो संपीड़न फंक्शन में किए जाते हैं, साथ ही प्रक्रिया में कुछ जानकारी के नुकसान के कारण भी। उदाहरण के लिए, किसी दिए गए मॉड्यूलो जोड़ के परिणाम के लिए, कई संभावित ऑपरेन्ड हो सकते हैं।

$$
3+2 \mod 10 = 5 \\
7+8 \mod 10 = 5 \\
5+10 \mod 10 = 5
$$

इस उदाहरण में, यदि आपको केवल उपयोग किया गया मॉड्यूलो (10) और परिणाम (5) पता है, तो आप निश्चित रूप से यह नहीं बता सकते कि जोड़ में कौन से सही संख्याएँ उपयोग की गई थीं। इसे कहा जाता है कि मॉड्यूलो 10 के तहत कई संगतताएँ होती हैं।

XOR ऑपरेशन के लिए भी हमें वही समस्या का सामना करना पड़ता है। इस ऑपरेशन के लिए सच तालिका (truth table) को याद करें: किसी भी 1-बिट आउटपुट को दो अलग-अलग इनपुट संयोजनों द्वारा निर्धारित किया जा सकता है, जिनके सही मान होने की संभावना बिल्कुल समान होती है। इसलिए, केवल परिणाम जानकर XOR के ऑपरेन्ड्स को निश्चित रूप से निर्धारित नहीं किया जा सकता। यदि हम XOR ऑपरेन्ड्स का आकार बढ़ाते हैं, तो केवल परिणाम जानने पर संभावित इनपुट्स की संख्या घातीय रूप से बढ़ जाती है। इसके अलावा, XOR का अक्सर अन्य बिट-स्तरीय ऑपरेशन्स के साथ उपयोग किया जाता है, जैसे कि $\text{RotR}$ ऑपरेशन, जो परिणाम के और भी अधिक संभावित व्याख्याएं जोड़ते हैं।

कंप्रेशन फंक्शन में $\text{ShR}$ ऑपरेशन का भी उपयोग होता है। यह ऑपरेशन मूल जानकारी के एक हिस्से को हटा देता है, जिसे बाद में वापस पाना असंभव होता है। एक बार फिर, इस ऑपरेशन को उल्टा करने का कोई बीजगणितीय तरीका नहीं है। ये सभी एकतरफा और जानकारी-हानि वाले ऑपरेशन कंप्रेशन फंक्शनों में बहुत बार उपयोग किए जाते हैं। किसी दिए गए आउटपुट के लिए संभावित इनपुट की संख्या लगभग अनंत होती है, और उल्टी गणना का हर प्रयास बहुत अधिक अज्ञातों वाली समीकरणों की ओर ले जाएगा, जो हर कदम पर तेजी से बढ़ते जाएंगे।

अंत में, टकराव प्रतिरोध की विशेषता के लिए कई पैरामीटर महत्वपूर्ण होते हैं। मूल संदेश की पूर्व-प्रसंस्करण एक महत्वपूर्ण भूमिका निभाता है। बिना इस पूर्व-प्रसंस्करण के, फ़ंक्शन पर टकराव ढूंढना आसान हो सकता है। हालांकि, सैद्धांतिक रूप से टकराव मौजूद होते हैं (कबूतर छिद्र सिद्धांत के कारण), लेकिन Hash फ़ंक्शन की संरचना, और पहले बताए गए गुणों के साथ मिलकर, टकराव खोजने की संभावना को बेहद कम कर देती है।

Hash फंक्शन को टकराव-प्रतिरोधी (collision-resistant) बनाने के लिए यह आवश्यक है कि:


- आउटपुट अप्रत्याशित होता है: कोई भी पूर्वानुमानितता का उपयोग करके टकराव को ब्रूट फोर्स हमले से तेज़ी से खोजा जा सकता है। यह फ़ंक्शन सुनिश्चित करता है कि आउटपुट का प्रत्येक बिट इनपुट पर एक जटिल तरीके से निर्भर करता है। दूसरे शब्दों में, फ़ंक्शन इस तरह से डिज़ाइन किया गया है कि अंतिम परिणाम का प्रत्येक बिट 0 या 1 होने की स्वतंत्र संभावना रखता है, भले ही यह स्वतंत्रता व्यवहार में पूर्ण न हो।
- हैश का वितरण छद्म-यादृच्छिक होता है: इसका मतलब है कि हैश समान रूप से वितरित होते हैं।
- Hash का आकार काफी बड़ा है: जितना बड़ा संभावित परिणामों के लिए स्थान होता है, टकराव ढूंढना उतना ही कठिन होता है।

क्रिप्टोग्राफर इन फंक्शनों को इस तरह से डिज़ाइन करते हैं कि वे सबसे अच्छे संभावित हमलों का मूल्यांकन करके टकराव खोज सकें, फिर इन हमलों को बेअसर करने के लिए पैरामीटर को समायोजित करते हैं।

### मर्कल-डैमगार्ड निर्माण

SHA256 की संरचना Merkle-Damgård निर्माण पर आधारित है, जो एक संपीड़न फ़ंक्शन को Hash फ़ंक्शन में बदलने की अनुमति देता है, जो किसी भी लंबाई के संदेशों को प्रोसेस कर सकता है। यही बात हमने इस अध्याय में देखी है।

हालांकि, कुछ पुराने Hash फंक्शन्स जैसे SHA1 या MD5, जो इस विशेष निर्माण का उपयोग करते हैं, लंबाई विस्तार हमलों के लिए असुरक्षित हैं। यह एक तकनीक है जो एक हमलावर को, जो संदेश $M$ का Hash और $M$ की लंबाई जानता है (बिना स्वयं संदेश को जाने), $M$ के साथ अतिरिक्त सामग्री जोड़कर बने संदेश $M'$ का Hash निकालने की अनुमति देती है।

SHA256, भले ही यह उसी प्रकार की संरचना का उपयोग करता है, लेकिन यह सैद्धांतिक रूप से इस प्रकार के हमले के प्रति प्रतिरोधी है, जबकि SHA1 और MD5 नहीं हैं। यह शायद Bitcoin में Satoshi नाकामोटो द्वारा लागू किए गए डबल हैशिंग के रहस्य को समझा सकता है। इस प्रकार के हमले से बचने के लिए, Satoshi ने शायद डबल SHA256 का उपयोग करना पसंद किया होगा।

$$
\text{HASH256}(m) = \text{SHA256}(\text{SHA256}(m))
$$

यह संभावित हमलों के खिलाफ सुरक्षा को बढ़ाता है जो Merkle-Damgård निर्माण से संबंधित होते हैं, लेकिन यह हैशिंग प्रक्रिया की सुरक्षा को टकराव प्रतिरोध के मामले में नहीं बढ़ाता। इसके अलावा, भले ही SHA256 इस प्रकार के हमले के लिए संवेदनशील होता, इसका गंभीर प्रभाव नहीं पड़ता, क्योंकि Hash कार्यों के सभी उपयोग मामले Bitcoin में सार्वजनिक डेटा से संबंधित होते हैं। हालांकि, लंबाई विस्तार हमला केवल तभी उपयोगी हो सकता है जब हैश किया गया डेटा निजी हो और उपयोगकर्ता ने इन डेटा के लिए Hash कार्य को प्रमाणीकरण तंत्र के रूप में उपयोग किया हो, जैसे कि एक MAC। इसलिए, Bitcoin के डिज़ाइन में डबल हैशिंग का कार्यान्वयन एक रहस्य बना हुआ है।

अब जब हमने Hash फंक्शन्स के कामकाज को विस्तार से देख लिया है, खासकर SHA256 को, जो Bitcoin में व्यापक रूप से उपयोग होता है, तो हम अब एप्लिकेशन स्तर पर उपयोग होने वाले क्रिप्टोग्राफिक डेरिवेशन एल्गोरिदम पर विशेष रूप से ध्यान केंद्रित करेंगे, खासकर आपके Wallet के लिए चाबियाँ निकालने के लिए।

## व्युत्पत्ति के लिए उपयोग किए गए एल्गोरिदम

<chapterId>cc668121-7789-5e99-bf5e-1ba085f4f5f2</chapterId>

Bitcoin में एप्लिकेशन स्तर पर, Hash फंक्शन्स के अलावा, क्रिप्टोग्राफिक डेरिवेशन एल्गोरिदम का उपयोग किया जाता है ताकि generate डेटा को शुरुआती इनपुट से सुरक्षित किया जा सके। हालांकि ये एल्गोरिदम Hash फंक्शन्स पर निर्भर करते हैं, लेकिन इनका उद्देश्य अलग होता है, खासकर प्रमाणीकरण और कुंजी निर्माण के मामले में। ये एल्गोरिदम Hash फंक्शन्स की कुछ विशेषताओं को बनाए रखते हैं, जैसे कि अपरिवर्तनीयता, छेड़छाड़ प्रतिरोध, और टकराव प्रतिरोध।

Bitcoin वॉलेट्स पर मुख्य रूप से 2 व्युत्पत्ति एल्गोरिदम का उपयोग किया जाता है:


- HMAC (हैश-आधारित संदेश प्रमाणीकरण कोड)
- PBKDF2 (पासवर्ड-आधारित कुंजी व्युत्पत्ति फ़ंक्शन 2)

हम एक साथ मिलकर इनमें से प्रत्येक के कार्य और भूमिका का पता लगाएंगे।

### HMAC-SHA512 एक प्रकार की क्रिप्टोग्राफिक तकनीक है जिसका उपयोग डेटा की सुरक्षा के लिए किया जाता है। यह एक हैश फंक्शन है जो मैसेज और एक सीक्रेट की का उपयोग करके एक सुरक्षित कोड जनरेट करता है। इसका उपयोग यह सुनिश्चित करने के लिए किया जाता है कि डेटा को भेजते समय या स्टोर करते समय उसमें कोई छेड़छाड़ नहीं हुई है। HMAC का मतलब हैश-बेस्ड मैसेज ऑथेंटिकेशन कोड होता है और SHA512 एक विशेष हैश एल्गोरिदम है जो 512 बिट्स की सुरक्षा प्रदान करता है। यह तकनीक आमतौर पर इंटरनेट पर डेटा की सुरक्षा के लिए उपयोग की जाती है।

HMAC एक क्रिप्टोग्राफिक एल्गोरिदम है जो एक प्रमाणीकरण कोड की गणना करता है, जो Hash फंक्शन और एक गुप्त कुंजी के संयोजन पर आधारित होता है। Bitcoin HMAC-SHA512 का उपयोग करता है, जो HMAC का एक प्रकार है जो SHA512 Hash फंक्शन का उपयोग करता है। हमने पिछले अध्याय में पहले ही देखा है कि SHA512, SHA256 की तरह ही Hash फंक्शनों के परिवार का हिस्सा है, लेकिन यह 512-बिट का आउटपुट उत्पन्न करता है।

यहाँ इसका सामान्य संचालन योजना है जहाँ $m$ इनपुट संदेश है और $K$ एक गुप्त कुंजी है:

![CYP201](assets/fr/011.webp)

आइए हम इस HMAC-SHA512 ब्लैक बॉक्स में क्या होता है, इसे और विस्तार से समझते हैं। HMAC-SHA512 फ़ंक्शन के साथ:


- $m$: उपयोगकर्ता द्वारा चुना गया मनमाने आकार का संदेश (पहला इनपुट);
- $K$: उपयोगकर्ता द्वारा चुनी गई मनमानी गुप्त कुंजी (दूसरा इनपुट);
- $K'$: कुंजी $K$ को Hash फंक्शन ब्लॉक्स के आकार $B$ के अनुसार समायोजित किया गया है (SHA512 के लिए 1024 बिट्स, या 128 बाइट्स);
- $\text{SHA512}$: यह SHA512 Hash फंक्शन है।
- $\oplus$: XOR (एक्सक्लूसिव ऑर) ऑपरेशन;
- $\Vert$: संयोजन ऑपरेटर, जो बिट स्ट्रिंग्स को एक के बाद एक जोड़ता है;
- $\text{opad}$: एक स्थिरांक है जो बाइट $0x5c$ को 128 बार दोहराकर बनाया गया है।
- $\text{ipad}$: एक स्थिर मान है जो बाइट $0x36$ को 128 बार दोहराकर बनाया गया है।

HMAC की गणना करने से पहले, कुंजी और स्थिरांक को ब्लॉक आकार $B$ के अनुसार बराबर करना ज़रूरी होता है। उदाहरण के लिए, अगर कुंजी $K$ 128 बाइट्स से छोटी है, तो इसे शून्य (zeros) जोड़कर $B$ आकार तक पहुँचाया जाता है। अगर $K$ 128 बाइट्स से लंबी है, तो इसे SHA512 का उपयोग करके संकुचित किया जाता है, और फिर इसे 128 बाइट्स तक पहुँचाने के लिए शून्य जोड़े जाते हैं। इस तरह, एक बराबर की गई कुंजी $K'$ प्राप्त होती है।

$\text{opad}$ और $\text{ipad}$ के मान उनके आधार बाइट को दोहराकर प्राप्त किए जाते हैं ($\text{opad}$ के लिए $0x5c$, $\text{ipad}$ के लिए $0x36$) जब तक कि आकार $B$ तक नहीं पहुँच जाता। इस प्रकार, यदि $B = 128$ बाइट्स है, तो हमारे पास होगा:

$$
\text{opad} = \underbrace{0x5c5c\ldots5c}\_{128 \, \text{bytes}}
$$

प्रारंभिक प्रसंस्करण पूरा हो जाने के बाद, HMAC-SHA512 एल्गोरिदम निम्नलिखित समीकरण द्वारा परिभाषित किया जाता है:

$$
\text {HMAC-SHA512}\_K(m) = \text{SHA512} \left( (K' \oplus \text{opad}) \parallel \text{SHA512} \left( (K' \oplus \text{ipad}) \parallel m \right) \right)
$$

इस समीकरण को निम्नलिखित चरणों में विभाजित किया गया है:


- समायोजित कुंजी $K'$ को $\text{ipad}$ के साथ XOR करें ताकि $\text{iKpad}$ प्राप्त हो सके।
- समायोजित कुंजी $K'$ को $\text{opad}$ के साथ XOR करें ताकि $\text{oKpad}$ प्राप्त हो सके।
- संदेश $m$ के साथ $\text{iKpad}$ को जोड़ें।
- Hash को SHA512 के साथ प्रोसेस करके एक मध्यवर्ती Hash $H_1$ प्राप्त करें।
- $\text{oKpad}$ को $H_1$ के साथ जोड़ें।
- Hash इस परिणाम को SHA512 के साथ उपयोग करें ताकि अंतिम परिणाम $H_2$ प्राप्त हो सके।

इन चरणों को योजनाबद्ध तरीके से इस प्रकार संक्षेप में प्रस्तुत किया जा सकता है:

![CYP201](assets/fr/012.webp)

HMAC का उपयोग Bitcoin में खासतौर पर HD (हाइरार्किकल डिटरमिनिस्टिक) वॉलेट्स में कुंजी व्युत्पत्ति के लिए किया जाता है (हम इसके बारे में आने वाले अध्यायों में और विस्तार से बात करेंगे) और यह PBKDF2 का एक घटक भी है।

### PBKDF2 एक पासवर्ड-आधारित कुंजी व्युत्पत्ति फ़ंक्शन है। इसका उपयोग पासवर्ड को सुरक्षित रूप से स्टोर करने के लिए किया जाता है। यह एक पासवर्ड, एक सॉल्ट (एक यादृच्छिक मान), और कई पुनरावृत्तियों का उपयोग करके एक मजबूत क्रिप्टोग्राफिक कुंजी उत्पन्न करता है। यह प्रक्रिया पासवर्ड को हैश करने के लिए होती है ताकि अगर कोई पासवर्ड डेटाबेस तक पहुंच भी जाए, तो भी पासवर्ड को आसानी से क्रैक न किया जा सके। PBKDF2 का उपयोग कई सुरक्षा अनुप्रयोगों और प्रणालियों में किया जाता है।

PBKDF2 (पासवर्ड-बेस्ड की डेरिवेशन फंक्शन 2) एक की डेरिवेशन एल्गोरिदम है जो पासवर्ड की सुरक्षा को बढ़ाने के लिए बनाया गया है। यह एल्गोरिदम एक पासवर्ड और एक क्रिप्टोग्राफिक सॉल्ट पर एक छद्म-रैंडम फंक्शन (यहाँ HMAC-SHA512) लागू करता है, और फिर इस प्रक्रिया को कई बार दोहराता है ताकि एक आउटपुट की उत्पन्न हो सके।

Bitcoin में, PBKDF2 का उपयोग generate के लिए किया जाता है, जो कि एक HD Wallet का seed होता है, जिसे एक Mnemonic वाक्यांश और एक passphrase से प्राप्त किया जाता है (लेकिन हम इसके बारे में अधिक विस्तार से आने वाले अध्यायों में बात करेंगे)।

PBKDF2 प्रक्रिया इस प्रकार है, जिसमें:


- $m$: उपयोगकर्ता का Mnemonic वाक्यांश;
- $s$: सुरक्षा बढ़ाने के लिए वैकल्पिक passphrase (यदि कोई passphrase नहीं है तो यह स्थान खाली रहेगा);
- $n$: यह उस फंक्शन के कितनी बार चलने की संख्या है, हमारे मामले में यह 2048 है।

PBKDF2 फंक्शन को क्रमिक रूप से परिभाषित किया गया है। हर चरण में पिछले परिणाम को लिया जाता है, उसे HMAC-SHA512 के माध्यम से पास किया जाता है, और लगातार प्राप्त परिणामों को मिलाकर अंतिम कुंजी तैयार की जाती है।

$$
\text{PBKDF2}(m, s) = \text{HMAC-SHA512}^{2048}(m, s)
$$

आरेख के रूप में, PBKDF2 को इस प्रकार दर्शाया जा सकता है:

![CYP201](assets/fr/013.webp)

इस अध्याय में, हमने HMAC-SHA512 और PBKDF2 फंक्शन्स का अध्ययन किया है, जो हैशिंग फंक्शन्स का उपयोग करके Bitcoin प्रोटोकॉल में कुंजी व्युत्पत्ति की अखंडता और सुरक्षा सुनिश्चित करते हैं। अगले भाग में, हम डिजिटल हस्ताक्षरों पर नजर डालेंगे, जो Bitcoin में व्यापक रूप से उपयोग की जाने वाली एक और क्रिप्टोग्राफिक विधि है।

# डिजिटल हस्ताक्षर

<partId>76b58a00-0c18-54b9-870d-6b7e34029db8</partId>

## डिजिटल हस्ताक्षर और एलिप्टिक कर्व्स

<chapterId>c9dd9672-6da1-57f8-9871-8b28994d4c1a</chapterId>

Bitcoin में इस्तेमाल की जाने वाली दूसरी क्रिप्टोग्राफिक विधि डिजिटल सिग्नेचर एल्गोरिदम है। आइए जानें कि यह क्या है और कैसे काम करता है।

### बिटकॉइन, UTXOs, और खर्च की शर्तें

Bitcoin में "_वॉलेट_" शब्द शुरुआती लोगों के लिए काफी भ्रमित करने वाला हो सकता है। वास्तव में, जिसे Bitcoin Wallet कहा जाता है, वह एक सॉफ्टवेयर है जो सीधे आपके बिटकॉइन को नहीं रखता, जैसे कि एक भौतिक Wallet सिक्के या नोट्स को रख सकता है। बिटकॉइन केवल लेखांकन की इकाइयाँ हैं। इस लेखांकन इकाई को **UTXO** (_अनस्पेंट ट्रांजैक्शन आउटपुट्स_) द्वारा दर्शाया जाता है, जो कि अनस्पेंट ट्रांजैक्शन आउटपुट्स होते हैं। अगर ये आउटपुट अनस्पेंट हैं, तो इसका मतलब है कि वे किसी उपयोगकर्ता के हैं। UTXOs, एक तरह से, बिटकॉइन के टुकड़े होते हैं, जिनका आकार बदलता रहता है और वे किसी उपयोगकर्ता के होते हैं।

Bitcoin प्रोटोकॉल वितरित है और बिना किसी केंद्रीय प्राधिकरण के संचालित होता है। इसलिए, यह पारंपरिक बैंकिंग रिकॉर्ड की तरह नहीं है, जहाँ आपके यूरो बस आपकी व्यक्तिगत पहचान से जुड़े होते हैं। Bitcoin पर, आपके UTXOs आपके होते हैं क्योंकि वे स्क्रिप्ट भाषा में निर्दिष्ट खर्च की शर्तों द्वारा सुरक्षित होते हैं। सरल शब्दों में, दो प्रकार की स्क्रिप्ट होती हैं: लॉकिंग स्क्रिप्ट (_scriptPubKey_), जो एक UTXO की सुरक्षा करती है, और अनलॉकिंग स्क्रिप्ट (_scriptSig_), जो एक UTXO को अनलॉक करने और इस प्रकार Bitcoin इकाइयों को खर्च करने की अनुमति देती है।

Bitcoin का प्रारंभिक संचालन P2PK स्क्रिप्ट्स के साथ इस प्रकार होता है कि इसमें एक सार्वजनिक कुंजी का उपयोग करके धन को लॉक किया जाता है। _scriptPubKey_ में यह निर्दिष्ट किया जाता है कि जो व्यक्ति इस UTXO को खर्च करना चाहता है, उसे इस सार्वजनिक कुंजी के अनुरूप निजी कुंजी के साथ एक वैध हस्ताक्षर प्रदान करना होगा। इस प्रकार, इस UTXO को अनलॉक करने के लिए _scriptSig_ में एक वैध हस्ताक्षर प्रदान करना आवश्यक है। जैसा कि उनके नाम से पता चलता है, सार्वजनिक कुंजी सभी को ज्ञात होती है क्योंकि यह Blockchain पर प्रसारित होती है, जबकि निजी कुंजी केवल धन के वैध मालिक को ही ज्ञात होती है।

यह Bitcoin का मूल संचालन है, लेकिन समय के साथ यह संचालन अधिक जटिल हो गया है। पहले, Satoshi ने P2PKH स्क्रिप्ट्स को भी पेश किया, जो _scriptPubKey_ में एक प्राप्त करने वाले Address का उपयोग करती हैं, जो सार्वजनिक कुंजी के Hash का प्रतिनिधित्व करती है। फिर, प्रणाली SegWit और फिर Taproot के आगमन के साथ और भी जटिल हो गई। हालांकि, सामान्य सिद्धांत मूल रूप से वही रहता है: UTXOs को लॉक करने के लिए एक सार्वजनिक कुंजी या इस कुंजी का प्रतिनिधित्व उपयोग किया जाता है, और उन्हें अनलॉक करने और खर्च करने के लिए एक संबंधित निजी कुंजी की आवश्यकता होती है।

जो व्यक्ति Bitcoin लेन-देन करना चाहता है, उसे अपनी निजी कुंजी का उपयोग करके उस लेन-देन पर एक डिजिटल हस्ताक्षर बनाना होगा। इस हस्ताक्षर को अन्य नेटवर्क प्रतिभागियों द्वारा सत्यापित किया जा सकता है। यदि यह मान्य है, तो इसका मतलब है कि लेन-देन शुरू करने वाला व्यक्ति वास्तव में उस निजी कुंजी का मालिक है, और इसलिए वे उन बिटकॉइन्स के मालिक हैं जिन्हें वे खर्च करना चाहते हैं। इसके बाद अन्य उपयोगकर्ता लेन-देन को स्वीकार कर सकते हैं और आगे बढ़ा सकते हैं।

इसलिए, एक उपयोगकर्ता जिसके पास बिटकॉइन हैं जो एक सार्वजनिक कुंजी के साथ लॉक हैं, उसे अपने फंड को अनलॉक करने के लिए आवश्यक निजी कुंजी को सुरक्षित रूप से स्टोर करने का तरीका खोजना होगा। Bitcoin Wallet वास्तव में एक ऐसा उपकरण है जो आपको आपकी सभी कुंजियों को आसानी से रखने की अनुमति देगा, बिना किसी और के उन्हें एक्सेस करने की। इसलिए, यह अधिक एक चाबी के गुच्छे की तरह है बजाय Wallet के।

एक सार्वजनिक कुंजी और एक निजी कुंजी के बीच गणितीय संबंध, और बिना निजी कुंजी को प्रकट किए उसके स्वामित्व को साबित करने के लिए हस्ताक्षर करने की क्षमता, एक डिजिटल हस्ताक्षर एल्गोरिदम द्वारा संभव होती है। Bitcoin प्रोटोकॉल में, 2 हस्ताक्षर एल्गोरिदम का उपयोग किया जाता है: **ECDSA** (_एलिप्टिक कर्व डिजिटल सिग्नेचर एल्गोरिदम_) और **स्नोर सिग्नेचर स्कीम**। ECDSA वह डिजिटल हस्ताक्षर प्रोटोकॉल है जिसका उपयोग Bitcoin में शुरुआत से किया गया है। स्नोर Bitcoin में अधिक हाल ही में शामिल हुआ है, क्योंकि इसे नवंबर 2021 में Taproot अपडेट के साथ पेश किया गया था।

ये दोनों एल्गोरिदम अपने काम करने के तरीके में काफी हद तक समान हैं। दोनों ही एलिप्टिक कर्व क्रिप्टोग्राफी पर आधारित हैं। इन दोनों प्रोटोकॉल्स के बीच मुख्य अंतर उनके हस्ताक्षर की संरचना और कुछ विशेष गणितीय गुणों में है। इसलिए, हम इन एल्गोरिदम के काम करने के तरीके का अध्ययन करेंगे, सबसे पुराने से शुरू करते हुए: ECDSA।

### एलिप्टिक कर्व क्रिप्टोग्राफी

एलिप्टिक कर्व क्रिप्टोग्राफी (ECC) एल्गोरिदम का एक समूह है जो क्रिप्टोग्राफिक उद्देश्यों के लिए एक एलिप्टिक कर्व के विभिन्न गणितीय और ज्यामितीय गुणों का उपयोग करता है। इन एल्गोरिदम की सुरक्षा एलिप्टिक कर्व्स पर डिस्क्रीट लॉगरिदम समस्या की कठिनाई पर निर्भर करती है। एलिप्टिक कर्व्स का उपयोग खासतौर पर कुंजी विनिमय, असममित एन्क्रिप्शन, या डिजिटल हस्ताक्षर बनाने के लिए किया जाता है।

इन वक्रों की एक महत्वपूर्ण विशेषता यह है कि वे x-अक्ष के संबंध में सममित होते हैं। इसलिए, कोई भी गैर-ऊर्ध्वाधर रेखा जो वक्र को दो अलग-अलग बिंदुओं पर काटती है, वह हमेशा वक्र को एक तीसरे बिंदु पर भी काटेगी। इसके अलावा, वक्र पर किसी भी गैर-अद्वितीय बिंदु पर खींची गई स्पर्शरेखा वक्र को एक अन्य बिंदु पर भी काटेगी। ये विशेषताएँ वक्र पर संचालन को परिभाषित करने में सहायक होंगी।

यहाँ वास्तविक संख्याओं के क्षेत्र पर एक दीर्घवृत्तीय वक्र का एक चित्रण है:

![CYP201](assets/fr/014.webp)

हर एलिप्टिक वक्र को एक समीकरण के रूप में परिभाषित किया जाता है, जो इस प्रकार होता है:

$$
y^2 = x^3 + ax + b
$$

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

ECDSA या Schnorr का उपयोग करने के लिए, आपको एलिप्टिक कर्व के पैरामीटर चुनने होते हैं, यानी कर्व समीकरण में $a$ और $b$ के मान। एलिप्टिक कर्व के विभिन्न मानक होते हैं जो क्रिप्टोग्राफिक रूप से सुरक्षित माने जाते हैं। सबसे प्रसिद्ध _secp256r1_ कर्व है, जिसे NIST (_नेशनल इंस्टीट्यूट ऑफ स्टैंडर्ड्स एंड टेक्नोलॉजी_) द्वारा परिभाषित और अनुशंसित किया गया है।

इसके बावजूद, Satoshi नाकामोटो, जो Bitcoin के आविष्कारक हैं, ने इस वक्र का उपयोग नहीं करने का निर्णय लिया। इस निर्णय का कारण अज्ञात है, लेकिन कुछ लोगों का मानना है कि उन्होंने एक विकल्प खोजने को प्राथमिकता दी क्योंकि इस वक्र के पैरामीटर में संभावित रूप से एक बैकडोर हो सकता था। इसके बजाय, Bitcoin प्रोटोकॉल मानक **_secp256k1_** वक्र का उपयोग करता है। इस वक्र को $a = 0$ और $b = 7$ पैरामीटर द्वारा परिभाषित किया गया है। इसका समीकरण इस प्रकार है:

$$
y^2 = x^3 + 7
$$

इसका ग्राफिकल प्रतिनिधित्व वास्तविक संख्याओं के क्षेत्र में कुछ इस तरह दिखता है:

![CYP201](assets/fr/015.webp)

हालांकि, क्रिप्टोग्राफी में हम सीमित संख्या समूहों के साथ काम करते हैं। विशेष रूप से, हम $\mathbb{F}_p$ नामक सीमित क्षेत्र पर काम करते हैं, जो कि एक अभाज्य संख्या $p$ के मापांक में पूर्णांकों का क्षेत्र होता है।

**परिभाषा**: एक अभाज्य संख्या वह प्राकृतिक पूर्णांक है जो 2 या उससे अधिक होता है और जिसके केवल दो विशिष्ट सकारात्मक पूर्णांक भाजक होते हैं: 1 और वह स्वयं। उदाहरण के लिए, संख्या 7 एक अभाज्य संख्या है क्योंकि इसे केवल 1 और 7 से ही विभाजित किया जा सकता है। दूसरी ओर, संख्या 8 अभाज्य नहीं है क्योंकि इसे 1, 2, 4, और 8 से विभाजित किया जा सकता है।

Bitcoin में, फाइनाइट फील्ड को परिभाषित करने के लिए उपयोग किया गया प्राइम नंबर $p$ बहुत बड़ा होता है। इसे इस तरह से चुना जाता है कि फील्ड का क्रम (अर्थात् $\mathbb{F}_p$ में Elements की संख्या) इतना बड़ा हो कि क्रिप्टोग्राफिक सुरक्षा सुनिश्चित की जा सके।

प्राइम नंबर $p$ जो उपयोग किया गया है:

```text
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
```

दशमलव संकेतन में, यह इस प्रकार है:

$$
p = 2^{256} - 2^{32} - 977
$$

इस प्रकार, हमारे दीर्घवृत्तीय वक्र का समीकरण वास्तव में है:

$$
y^2 \equiv x^3 + 7 \mod p
$$

यह वक्र $\mathbb{F}_p$ नामक सीमित क्षेत्र पर परिभाषित है, इसलिए यह अब एक सतत वक्र जैसा नहीं दिखता, बल्कि बिंदुओं के एक असतत समूह जैसा दिखता है। उदाहरण के लिए, यहाँ Bitcoin में उपयोग किए गए वक्र का रूप बहुत छोटे $p = 17$ के लिए कैसा दिखता है:

![CYP201](assets/fr/016.webp)

इस उदाहरण में, मैंने शैक्षिक कारणों से सीमित क्षेत्र को $p = 17$ तक सीमित रखा है, लेकिन आपको यह कल्पना करनी होगी कि Bitcoin में उपयोग किया गया क्षेत्र बहुत बड़ा है, लगभग $2^{256}$ के बराबर।

हम $p$ के मापांक में पूर्णांकों के सीमित क्षेत्र का उपयोग करते हैं ताकि वक्र पर संचालन की सटीकता सुनिश्चित की जा सके। वास्तव में, वास्तविक संख्याओं के क्षेत्र पर एलिप्टिक वक्र गणनात्मक गणनाओं के दौरान राउंडिंग त्रुटियों के कारण अशुद्धियों के अधीन होते हैं। यदि वक्र पर कई संचालन किए जाते हैं, तो ये त्रुटियाँ जमा हो जाती हैं और अंतिम परिणाम गलत या पुनरुत्पादन में कठिन हो सकता है। केवल सकारात्मक पूर्णांकों का उपयोग करने से गणनाओं की पूर्ण सटीकता सुनिश्चित होती है और इस प्रकार परिणाम का पुनरुत्पादन भी संभव होता है।

अंतिम क्षेत्रों पर एलिप्टिक वक्रों का गणित वास्तविक संख्याओं के क्षेत्र पर वक्रों के समान होता है, बस इसमें सभी गणनाएँ $p$ के माड्यूलो में की जाती हैं। समझाने में आसानी के लिए, हम अगले अध्यायों में वास्तविक संख्याओं पर परिभाषित वक्र का उपयोग करके अवधारणाओं को समझाते रहेंगे, जबकि यह ध्यान में रखते हुए कि व्यवहार में वक्र एक सीमित क्षेत्र पर परिभाषित होता है।

यदि आप आधुनिक क्रिप्टोग्राफी की गणितीय नींव के बारे में अधिक जानना चाहते हैं, तो मैं आपको Plan ₿ Network पर इस अन्य कोर्स को देखने की भी सलाह देता हूँ।

https://planb.network/courses/d2fd9fc0-d9ed-4a87-9fa3-0fdbb3937e28
## प्राइवेट की से पब्लिक की की गणना करना

<chapterId>fcb2bd58-5dda-5ecf-bb8f-ad1a0561ab4a</chapterId>

जैसा कि पहले देखा गया है, Bitcoin पर डिजिटल हस्ताक्षर एल्गोरिदम एक निजी और सार्वजनिक कुंजी के जोड़े पर आधारित होते हैं जो गणितीय रूप से जुड़े होते हैं। आइए मिलकर जानें कि यह गणितीय संबंध क्या है और इन्हें कैसे उत्पन्न किया जाता है।

### प्राइवेट की (गुप्त कुंजी)

प्राइवेट की बस एक रैंडम या छद्म-रैंडम संख्या होती है। Bitcoin के मामले में, यह संख्या 256 बिट्स की होती है। इसलिए, Bitcoin प्राइवेट की के लिए संभावनाओं की संख्या सैद्धांतिक रूप से $2^{256}$ होती है।

**नोट**: एक "छद्म-यादृच्छिक संख्या" वह संख्या होती है जो वास्तव में यादृच्छिक संख्या के गुणों के करीब होती है, लेकिन इसे एक निश्चित एल्गोरिदम द्वारा उत्पन्न किया जाता है।

हालांकि, व्यवहार में हमारे एलिप्टिक कर्व secp256k1 पर केवल $n$ भिन्न बिंदु होते हैं, जहाँ $n$ कर्व के जनरेटर बिंदु $G$ का क्रम होता है। हम बाद में देखेंगे कि यह संख्या किससे संबंधित है, लेकिन बस इतना याद रखें कि एक वैध निजी कुंजी $1$ और $n-1$ के बीच की एक पूर्णांक होती है, यह जानते हुए कि $n$ एक संख्या है जो $2^{256}$ के करीब है लेकिन उससे थोड़ी कम है। इसलिए, कुछ 256-बिट संख्याएँ हैं जो Bitcoin में निजी कुंजी बनने के लिए मान्य नहीं हैं, विशेष रूप से, सभी संख्याएँ $n$ और $2^{256}$ के बीच। यदि यादृच्छिक संख्या (निजी कुंजी) का उत्पादन ऐसा मान $k$ करता है कि $k \geq n$, तो इसे अमान्य माना जाता है, और एक नई यादृच्छिक संख्या उत्पन्न करनी होती है।

Bitcoin प्राइवेट की के लिए संभावनाओं की संख्या लगभग $n$ है, जो कि $1.158 \times 10^{77}$ के करीब है। यह संख्या इतनी बड़ी है कि अगर आप एक प्राइवेट की को रैंडमली चुनते हैं, तो यह सांख्यिकीय रूप से लगभग असंभव है कि आप किसी अन्य उपयोगकर्ता की प्राइवेट की पर पहुंच जाएं। आपको पैमाने का अंदाजा देने के लिए, Bitcoin पर संभावित प्राइवेट की की संख्या लगभग उतनी ही है जितनी कि अनुमानित रूप से देखे जा सकने वाले ब्रह्मांड में परमाणुओं की संख्या है।

जैसा कि हम आने वाले अध्यायों में देखेंगे, आज के समय में Bitcoin पर उपयोग की जाने वाली अधिकांश निजी कुंजियाँ यादृच्छिक रूप से उत्पन्न नहीं होती हैं, बल्कि वे Mnemonic वाक्यांश से निर्धारक व्युत्पत्ति का परिणाम होती हैं, जो स्वयं छद्म-यादृच्छिक होता है (यह वही प्रसिद्ध 12 या 24 शब्दों का वाक्यांश है)। यह जानकारी ECDSA जैसे हस्ताक्षर एल्गोरिदम के उपयोग के लिए कुछ नहीं बदलती है, लेकिन यह हमें Bitcoin पर हमारी लोकप्रियता को फिर से केंद्रित करने में मदद करती है।

आगे की व्याख्या में, प्राइवेट की को छोटे अक्षर $k$ से दर्शाया जाएगा।

### सार्वजनिक कुंजी

सार्वजनिक कुंजी एक बिंदु है जो एलिप्टिक कर्व पर स्थित होता है, जिसे बड़े अक्षर $K$ द्वारा दर्शाया जाता है, और इसे निजी कुंजी $k$ से गणना किया जाता है। यह बिंदु $K$ एलिप्टिक कर्व पर समन्वय युग्म $(x, y)$ के रूप में प्रस्तुत किया जाता है, जहाँ प्रत्येक समन्वय एक पूर्णांक होता है जो $p$ के माड्यूलो होता है, जो कि $\mathbb{F}_p$ नामक सीमित क्षेत्र को परिभाषित करने वाला अभाज्य संख्या है।

व्यवहार में, एक अनकंप्रेस्ड पब्लिक की को 512 बिट्स (या 64 बाइट्स) के रूप में दर्शाया जाता है, जो दो 256-बिट नंबरों ($x$ और $y$) के अनुरूप होते हैं, जिन्हें एक के बाद एक रखा जाता है। ये नंबर हमारे बिंदु के secp256k1 पर अभिस्सा ($x$) और ऑर्डिनेट ($y$) होते हैं। अगर हम प्रीफिक्स जोड़ते हैं, तो पब्लिक की कुल 520 बिट्स की हो जाती है।

हालांकि, यह भी संभव है कि सार्वजनिक कुंजी को एक संकुचित रूप में केवल 33 बाइट्स (264 बिट्स) का उपयोग करके प्रस्तुत किया जाए, जिसमें हमारी वक्र पर बिंदु का केवल $x$ (अक्ष) रखा जाता है और एक बाइट जो $y$ की समता को दर्शाता है। इसे संकुचित सार्वजनिक कुंजी कहा जाता है। मैं इस प्रशिक्षण के अंतिम अध्यायों में इसके बारे में और बात करूंगा। लेकिन जो आपको याद रखना है वह यह है कि एक सार्वजनिक कुंजी $K$ एक बिंदु है जो $x$ और $y$ द्वारा वर्णित होता है।

हमारे सार्वजनिक कुंजी से संबंधित बिंदु $K$ की गणना करने के लिए, हम एलिप्टिक कर्व्स पर स्केलर गुणा का उपयोग करते हैं। यह प्रक्रिया जेनरेटर बिंदु $G$ का $k$ बार दोहराया गया जोड़ है।

$$
K = k \cdot G
$$

आपका प्रशिक्षण अक्टूबर 2023 तक के डेटा पर आधारित है।


- $k$ एक निजी कुंजी है (जो $1$ और $n-1$ के बीच का एक यादृच्छिक पूर्णांक है);
- $G$ वह जनरेटर बिंदु है जो Bitcoin नेटवर्क के सभी प्रतिभागियों द्वारा उपयोग की जाने वाली एलिप्टिक कर्व का हिस्सा है।
- $\cdot$ चिन्ह एलिप्टिक कर्व पर स्केलर गुणा को दर्शाता है, जिसका मतलब है कि बिंदु $G$ को खुद से $k$ बार जोड़ा जाता है।

इस तथ्य कि यह बिंदु $G$ सभी सार्वजनिक कुंजियों पर Bitcoin पर सामान्य है, हमें यह सुनिश्चित करने की अनुमति देता है कि वही निजी कुंजी $k$ हमेशा हमें वही सार्वजनिक कुंजी $K$ देगी।

![CYP201](assets/fr/017.webp)

इस ऑपरेशन की मुख्य विशेषता यह है कि यह एक-तरफा फंक्शन है। निजी कुंजी $k$ और जनरेटर पॉइंट $G$ को जानते हुए सार्वजनिक कुंजी $K$ की गणना करना आसान है, लेकिन केवल सार्वजनिक कुंजी $K$ और जनरेटर पॉइंट $G$ को जानते हुए निजी कुंजी $k$ की गणना करना लगभग असंभव है। $K$ और $G$ से $k$ को ढूंढना, एलिप्टिक कर्व्स पर डिस्क्रीट लॉगरिदम समस्या को हल करने के बराबर है, जो एक गणितीय रूप से कठिन समस्या है और जिसके लिए कोई प्रभावी एल्गोरिदम ज्ञात नहीं है। यहां तक कि सबसे शक्तिशाली मौजूदा कैलकुलेटर भी इस समस्या को एक उचित समय में हल करने में असमर्थ हैं।

![CYP201](assets/fr/018.webp)

### अभिलिखित वक्रों पर बिंदुओं का जोड़ना और दुगुना करना

अल्पवक्रों (elliptic curves) पर जोड़ का विचार ज्यामितीय रूप से परिभाषित होता है। यदि हमारे पास वक्र पर दो बिंदु $P$ और $Q$ हैं, तो $P + Q$ का संचालन इस प्रकार किया जाता है कि $P$ और $Q$ से होकर एक रेखा खींची जाती है। यह रेखा वक्र को एक तीसरे बिंदु $R'$ पर अवश्य काटेगी। फिर हम इस बिंदु का x-अक्ष के सापेक्ष प्रतिबिंब लेते हैं, जिससे हमें बिंदु $R$ प्राप्त होता है, जो जोड़ का परिणाम है।

$$
P + Q = R
$$

ग्राफ़ के रूप में, इसे इस प्रकार दर्शाया जा सकता है:

![CYP201](assets/fr/019.webp)

जब हम किसी बिंदु को दुगना करते हैं, यानी ऑपरेशन $P + P$, तो हम बिंदु $P$ पर वक्र के साथ स्पर्शरेखा खींचते हैं। यह स्पर्शरेखा वक्र को एक अन्य बिंदु $S'$ पर काटती है। फिर हम इस बिंदु का x-अक्ष के सापेक्ष प्रतिबिंब लेते हैं, जिससे हमें बिंदु $S$ मिलता है, जो दुगने का परिणाम होता है।

$$
2P = S
$$

ग्राफ के रूप में, इसे इस तरह दिखाया गया है:

![CYP201](assets/fr/020.webp)

इन जोड़ और दुगुना करने की क्रियाओं का उपयोग करके, हम किसी बिंदु का स्केलर गुणन एक पूर्णांक $k$ से कर सकते हैं, जिसे $kP$ के रूप में दर्शाया जाता है, बार-बार दुगुना करने और जोड़ने की प्रक्रिया द्वारा।

उदाहरण के लिए, मान लीजिए कि हमने एक निजी कुंजी $k = 4$ चुनी है। इससे संबंधित सार्वजनिक कुंजी की गणना करने के लिए, हम निम्नलिखित प्रक्रिया करते हैं:

$$
K = k \cdot G = 4G
$$

ग्राफिक रूप से, इसका मतलब है कि आप कई बार जोड़ने और दुगुना करने की प्रक्रिया कर रहे हैं।


- $2G$ का मतलब है $G$ को दो गुना करना। इसका मतलब है कि आप $G$ को 2 से गुणा करेंगे। तो, $2G = 2 \times G$। बस $G$ की जो भी मान है, उसे 2 से गुणा कर दें।
- $4G$ को प्राप्त करने के लिए $2G$ को दोगुना करें। इसका मतलब है कि आप $2G$ को 2 से गुणा करेंगे। तो, $4G = 2 \times 2G = 4G$।

![CYP201](assets/fr/021.webp)

अगर हम, उदाहरण के लिए, बिंदु $3G$ की गणना करना चाहते हैं, तो हमें पहले बिंदु $2G$ की गणना करनी होगी, जो बिंदु $G$ को दोहराकर प्राप्त होता है, फिर $G$ और $2G$ को जोड़ना होगा। $G$ और $2G$ को जोड़ने के लिए, बस इन दोनों बिंदुओं को जोड़ने वाली रेखा खींचें, इस रेखा और एलिप्टिक कर्व के बीच के इंटरसेक्शन पर अद्वितीय बिंदु $-3G$ प्राप्त करें, और फिर $3G$ को $-3G$ के विपरीत के रूप में निर्धारित करें।

हमारे पास होगा:

$$
G + G = 2G
$$

$$
2G + G = 3G
$$

ग्राफिक रूप से, इसे इस प्रकार दर्शाया जाएगा:

![CYP201](assets/fr/022.webp)

### एक-तरफा फ़ंक्शन

इन प्रक्रियाओं की मदद से, हम समझ सकते हैं कि निजी कुंजी से सार्वजनिक कुंजी निकालना क्यों आसान है, लेकिन इसके विपरीत करना लगभग असंभव है।

चलो हमारे सरल उदाहरण पर वापस चलते हैं। मान लीजिए हमारे पास एक निजी कुंजी $k = 4$ है। इससे संबंधित सार्वजनिक कुंजी की गणना करने के लिए, हम यह प्रक्रिया अपनाते हैं:

$$
K = k \cdot G = 4G
$$

हम इस तरह से $k$ और $G$ को जानकर आसानी से सार्वजनिक कुंजी $K$ की गणना कर पाए हैं।

अब, अगर किसी के पास केवल सार्वजनिक कुंजी $K$ है, तो उन्हें एक कठिन समस्या का सामना करना पड़ता है जिसे डिस्क्रीट लॉगरिदम समस्या कहते हैं: $k$ को खोजना ताकि $K = k \cdot G$ हो। यह समस्या कठिन मानी जाती है क्योंकि इसे हल करने के लिए कोई प्रभावी एल्गोरिदम नहीं है, खासकर एलिप्टिक कर्व्स पर। यही कारण है कि ECDSA और Schnorr एल्गोरिदम की सुरक्षा सुनिश्चित होती है।

बिल्कुल, इस सरल उदाहरण में जहाँ $k = 4$ है, वहाँ ट्रायल और एरर के माध्यम से $k$ को ढूंढना संभव है क्योंकि संभावनाओं की संख्या कम है। लेकिन असल में Bitcoin पर, $k$ एक 256-बिट का पूर्णांक होता है, जिससे संभावनाओं की संख्या बहुत ही विशाल (लगभग $1.158 \times 10^{77}$) हो जाती है। इसलिए, $k$ को ब्रूट फोर्स से ढूंढना असंभव है।

## प्राइवेट की के साथ साइन करना

<chapterId>bb07826f-826e-5905-b307-3d82001fb778</chapterId>

अब जब आप यह जान गए हैं कि निजी कुंजी से सार्वजनिक कुंजी कैसे निकाली जाती है, तो आप इस कुंजी जोड़ी का उपयोग करके बिटकॉइन प्राप्त कर सकते हैं। लेकिन उन्हें खर्च कैसे करें? बिटकॉइन खर्च करने के लिए, आपको अपने UTXO से जुड़े _scriptPubKey_ को अनलॉक करना होगा ताकि यह साबित हो सके कि आप वास्तव में इसके वैध मालिक हैं। ऐसा करने के लिए, आपको एक हस्ताक्षर $s$ उत्पन्न करना होगा जो _scriptPubKey_ में मौजूद सार्वजनिक कुंजी $K$ से मेल खाता हो, और इसके लिए आपको उस निजी कुंजी $k$ का उपयोग करना होगा जिसका उपयोग प्रारंभ में $K$ की गणना के लिए किया गया था। डिजिटल हस्ताक्षर इस बात का अचूक प्रमाण है कि आपके पास उस सार्वजनिक कुंजी से जुड़ी निजी कुंजी है जिसका आप दावा कर रहे हैं।

### एलिप्टिक कर्व पैरामीटर्स

डिजिटल हस्ताक्षर करने के लिए, सभी प्रतिभागियों को पहले उस एलिप्टिक कर्व के पैरामीटर पर सहमत होना होगा जिसका उपयोग किया जा रहा है। Bitcoin के मामले में, **secp256k1** के पैरामीटर इस प्रकार हैं:

समान्यतः, $\mathbb{Z}_p$ एक सीमित क्षेत्र (finite field) है, जिसे एक अभाज्य संख्या $p$ द्वारा परिभाषित किया जाता है। इसका मतलब है कि इसमें $p$ तत्व होते हैं, और ये तत्व $0$ से लेकर $p-1$ तक होते हैं। इस क्षेत्र में गणितीय क्रियाएँ जैसे जोड़, घटाव, गुणा और भाग, मॉड्यूलो $p$ के अनुसार की जाती हैं। उदाहरण के लिए, यदि $p = 5$, तो $\mathbb{Z}_5$ में तत्व $0, 1, 2, 3, 4$ होंगे, और इन पर सभी गणितीय क्रियाएँ $5$ से मॉड्यूलो लेकर की जाएंगी।

$$
p = 2^{256} - 2^{32} - 977
$$

```text
p = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
```

$p$ एक बहुत बड़ा अभाज्य संख्या है जो $2^{256}$ से थोड़ी कम है।

अक्टूबर 2023 तक के डेटा पर आपका प्रशिक्षण हुआ है।

$\mathbb{Z}_p$ पर परिभाषित दी गई एलिप्टिक कर्व $y^2 = x^3 + ax + b$ है।

$$
a = 0, \quad b = 7
$$

जनरेटर बिंदु या उत्पत्ति बिंदु $G$:

```text
G = 0x0279BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
```

यह संख्या संकुचित रूप में है जो केवल बिंदु $G$ के क्षैतिज निर्देशांक को दर्शाती है। शुरुआत में दिया गया उपसर्ग `02` यह निर्धारित करता है कि इस क्षैतिज निर्देशांक $x$ वाले दो मानों में से किसे उत्पन्न करने वाले बिंदु के रूप में उपयोग किया जाना है।

$G$ का क्रम $n$ (मौजूदा बिंदुओं की संख्या) और सहगुणक $h$:

```text
n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
```

$n$ एक बहुत बड़ी संख्या है जो $p$ से थोड़ी कम है।

$$
h=1
$$

$h$ सहगुणक या उपसमूहों की संख्या है। मैं यहाँ यह नहीं बताऊँगा कि इसका क्या मतलब है, क्योंकि यह काफी जटिल है, और Bitcoin के मामले में हमें इसे ध्यान में रखने की ज़रूरत नहीं है क्योंकि यह $1$ के बराबर है।

यह सारी जानकारी सार्वजनिक है और सभी प्रतिभागियों को ज्ञात है। इनके कारण, उपयोगकर्ता एक डिजिटल हस्ताक्षर बना सकते हैं और उसे सत्यापित कर सकते हैं।

### ECDSA के साथ हस्ताक्षर

ECDSA एल्गोरिदम एक उपयोगकर्ता को अपने निजी कुंजी का उपयोग करके संदेश पर हस्ताक्षर करने की अनुमति देता है, इस तरह से कि कोई भी व्यक्ति जो संबंधित सार्वजनिक कुंजी जानता है, हस्ताक्षर की वैधता की पुष्टि कर सकता है, बिना निजी कुंजी का खुलासा किए। Bitcoin के संदर्भ में, हस्ताक्षर करने के लिए संदेश उपयोगकर्ता द्वारा चुने गए _sighash_ पर निर्भर करता है। यही _sighash_ यह निर्धारित करेगा कि लेन-देन के कौन से हिस्से हस्ताक्षर द्वारा कवर किए जाएंगे। मैं इसके बारे में अगले अध्याय में और बात करूंगा।

यहाँ generate एक ECDSA हस्ताक्षर के लिए कदम दिए गए हैं:

सबसे पहले, हम उस संदेश का Hash ($e$) गणना करते हैं जिसे हस्ताक्षरित करने की आवश्यकता है। इस प्रकार, संदेश $m$ को एक क्रिप्टोग्राफिक Hash फंक्शन से गुजारा जाता है, जो आमतौर पर SHA256 या Bitcoin के मामले में डबल SHA256 होता है।

$$
e = \text{HASH}(m)
$$

अब हम एक Nonce की गणना करते हैं। क्रिप्टोग्राफी में, Nonce एक ऐसा नंबर होता है जो यादृच्छिक या छद्म-यादृच्छिक तरीके से उत्पन्न किया जाता है और इसे केवल एक बार उपयोग किया जाता है। इसका मतलब यह है कि जब भी इस कुंजी जोड़ी के साथ एक नई डिजिटल हस्ताक्षर बनाई जाती है, तो एक अलग Nonce का उपयोग करना बहुत महत्वपूर्ण होता है, अन्यथा यह निजी कुंजी की सुरक्षा को खतरे में डाल देगा। इसलिए, यह पर्याप्त है कि हम एक यादृच्छिक और अद्वितीय पूर्णांक $r$ निर्धारित करें, जो $1 \leq r \leq n-1$ के बीच हो, जहाँ $n$ अंडाकार वक्र के जनरेटिंग पॉइंट $G$ का क्रम है।

फिर, हम बिंदु $R$ की गणना करेंगे जो दी गई अंडाकार वक्र पर स्थित है, जिसके निर्देशांक $(x_R, y_R)$ हैं, ताकि:

$$
R = r \cdot G
$$

हम बिंदु $R$ के अभिस्सा का मान ($x_R$) निकालते हैं। यह मान हस्ताक्षर के पहले भाग का प्रतिनिधित्व करता है। और अंत में, हम हस्ताक्षर के दूसरे भाग $s$ की गणना इस प्रकार करते हैं:

$$
s = r^{-1} \left( e + k \cdot x_R \right) \mod n
$$

आपका प्रशिक्षण अक्टूबर 2023 तक के डेटा पर आधारित है।


- $r^{-1}$ को $r$ का मॉड्यूलर इनवर्स कहा जाता है, जिसका मतलब है कि यह एक ऐसा पूर्णांक है जिसके लिए $r \cdot r^{-1} \equiv 1 \mod n$ होता है।
- $k$ उपयोगकर्ता की निजी कुंजी है।
- $e$ संदेश का Hash है।
- $n$ उस जनरेटर बिंदु $G$ का क्रम है जो एलिप्टिक वक्र का हिस्सा है।

हस्ताक्षर तब बस $x_R$ और $s$ का संयोजन होता है।

$$
\text{SIG} = x_R \Vert s
$$

### ECDSA हस्ताक्षर की सत्यापन प्रक्रिया

किसी हस्ताक्षर $(x_R, s)$ को सत्यापित करने के लिए, कोई भी व्यक्ति जो सार्वजनिक कुंजी $K$ और एलिप्टिक कर्व के पैरामीटर जानता है, इस प्रकार आगे बढ़ सकता है:

सबसे पहले, यह सुनिश्चित करें कि $x_R$ और $s$ अंतराल $[1, n-1]$ के भीतर हैं। यह इस बात की पुष्टि करता है कि हस्ताक्षर अंडाकार समूह के गणितीय नियमों का पालन करता है। अगर ऐसा नहीं है, तो सत्यापनकर्ता तुरंत हस्ताक्षर को अमान्य मानकर अस्वीकार कर देता है।

फिर, संदेश का Hash गणना करें:

$$
e = \text{HASH}(m)
$$

$s$ का $n$ के मापांक में प्रतिलोम निकालने का मतलब है ऐसा संख्या $t$ ढूंढना, जिससे $s \times t \equiv 1 \pmod{n}$ हो। इसे खोजने के लिए आप विस्तारित यूक्लिडियन एल्गोरिदम का उपयोग कर सकते हैं। यह एल्गोरिदम $s$ और $n$ के लिए $gcd$ (महानतम समापवर्तक) निकालता है और साथ ही $s$ और $n$ के लिए ऐसे गुणांक भी देता है, जिससे $s \times x + n \times y = gcd(s, n)$ हो। अगर $gcd(s, n) = 1$, तो $x$ ही $s$ का $n$ के मापांक में प्रतिलोम होगा।

$$
s^{-1} \mod n
$$

दो स्केलर मान $u_1$ और $u_2$ इस प्रकार से गणना करें:

$$
\begin{align*}
u_1 &= e \cdot s^{-1} \mod n \\
u_2 &= x_R \cdot s^{-1} \mod n
\end{align*}
$$

अंत में, बिंदु $V$ की गणना करें जो दी गई एलिप्टिक कर्व पर स्थित है, ताकि:

$$
V = u_1 \cdot G + u_2 \cdot K
$$

हस्ताक्षर तभी मान्य होता है जब $x_V \equiv x_R \mod n$ हो, जहाँ $x_V$ बिंदु $V$ का $x$ निर्देशांक है। वास्तव में, जब $u_1 \cdot G$ और $u_2 \cdot K$ को मिलाया जाता है, तो एक बिंदु $V$ प्राप्त होता है, जो यदि हस्ताक्षर मान्य है, तो उसे हस्ताक्षर के दौरान उपयोग किए गए बिंदु $R$ के अनुरूप होना चाहिए (मॉड्यूलो $n$)।

### स्नोर प्रोटोकॉल के साथ हस्ताक्षर

स्नोर सिग्नेचर स्कीम ECDSA का एक विकल्प है जो कई फायदे प्रदान करता है। इसे 2021 से Bitcoin पर और Taproot के परिचय के साथ, P2TR स्क्रिप्ट पैटर्न्स के साथ उपयोग करना संभव हो गया है। ECDSA की तरह, स्नोर स्कीम भी एक निजी कुंजी का उपयोग करके संदेश पर हस्ताक्षर करने की अनुमति देती है, ताकि हस्ताक्षर को कोई भी व्यक्ति जो संबंधित सार्वजनिक कुंजी जानता है, सत्यापित कर सके।

स्नोर्र के मामले में, वही कर्व का उपयोग किया जाता है जो ECDSA में होता है, और इसके लिए वही पैरामीटर होते हैं। हालांकि, सार्वजनिक कुंजियों को ECDSA की तुलना में थोड़े अलग तरीके से दर्शाया जाता है। वास्तव में, इन्हें केवल अंडाकार कर्व पर बिंदु के $x$ निर्देशांक द्वारा दर्शाया जाता है। ECDSA में, जहां संकुचित सार्वजनिक कुंजियाँ 33 बाइट्स में होती हैं (जिसमें प्रीफिक्स बाइट $y$ की समता को दर्शाता है), स्नोर्र 32-बाइट सार्वजनिक कुंजियों का उपयोग करता है, जो केवल बिंदु $K$ के $x$ निर्देशांक से संबंधित होती हैं, और यह मान लिया जाता है कि $y$ स्वाभाविक रूप से सम है। इस सरल प्रतिनिधित्व से हस्ताक्षरों का आकार कम हो जाता है और सत्यापन एल्गोरिदम में कुछ अनुकूलन की सुविधा मिलती है।

सार्वजनिक कुंजी तब बिंदु $K$ का $x$ निर्देशांक होती है:

$$
\text{pk} = K_x
$$

generate हस्ताक्षर का पहला कदम है संदेश को Hash करना। लेकिन ECDSA के विपरीत, इसे अन्य मानों के साथ किया जाता है और विभिन्न संदर्भों में टकराव से बचने के लिए एक लेबलयुक्त Hash फ़ंक्शन का उपयोग किया जाता है। एक लेबलयुक्त Hash फ़ंक्शन में बस संदेश डेटा के साथ Hash फ़ंक्शन के इनपुट में एक मनमाना लेबल जोड़ना शामिल होता है।

![CYP201](assets/fr/023.webp)

संदेश के अलावा, सार्वजनिक कुंजी $K_x$ का $x$ निर्देशांक और एक बिंदु $R$, जो Nonce $r$ से गणना किया गया है ($R=r \cdot G$), भी लेबल किए गए फ़ंक्शन में पास किया जाता है। यह $r$ प्रत्येक हस्ताक्षर के लिए एक अद्वितीय पूर्णांक होता है, जिसे निजी कुंजी और संदेश से निर्धारक रूप से गणना की जाती है ताकि Nonce के पुनः उपयोग से संबंधित कमजोरियों से बचा जा सके। ठीक वैसे ही जैसे सार्वजनिक कुंजी के लिए, Nonce बिंदु $R_x$ का केवल $x$ निर्देशांक ही बिंदु का वर्णन करने के लिए रखा जाता है।

इस हैशिंग का परिणाम, जिसे $e$ कहा जाता है, "चुनौती" कहलाता है।

$$
e = \text{HASH}(\text{``BIP0340/challenge''}, R_x \Vert K_x \Vert m) \mod n
$$

यहाँ, $\text{Hash}$ SHA256 Hash फंक्शन है, और $\text{``BIP0340/challenge''}$ हैशिंग के लिए विशेष टैग है।

अंत में, पैरामीटर $s$ को इस तरीके से गणना की जाती है, जिसमें निजी कुंजी $k$, Nonce $r$, और चुनौती $e$ शामिल होते हैं:

$$
s = (r + e \cdot k) \mod n
$$

हस्ताक्षर बस $Rx$ और $s$ की जोड़ी होती है।

$$
\text{SIG} = R_x \Vert s
$$

### स्नोर सिग्नेचर का सत्यापन

Schnorr हस्ताक्षर का सत्यापन ECDSA हस्ताक्षर की तुलना में सरल होता है। यहाँ पर हस्ताक्षर $(R_x, s)$ को सार्वजनिक कुंजी $K_x$ और संदेश $m$ के साथ सत्यापित करने के चरण दिए गए हैं:

सबसे पहले, हम यह सुनिश्चित करते हैं कि $K_x$ एक मान्य पूर्णांक है और $p$ से कम है। अगर ऐसा है, तो हम वक्र पर संबंधित बिंदु को प्राप्त करते हैं जिसमें $K_y$ सम होता है। हम हस्ताक्षर $\text{SIG}$ को अलग करके $R_x$ और $s$ को भी निकालते हैं। फिर, हम यह जांचते हैं कि $R_x < p$ और $s < n$ (वक्र का क्रम) है।

अब, हम चुनौती $e$ की गणना उसी तरीके से करते हैं जैसे हस्ताक्षर जारीकर्ता करता है।

$$
e = \text{HASH}(\text{``BIP0340/challenge''}, R_x \Vert K_x \Vert m) \mod n
$$

फिर, हम इस तरह से वक्र पर एक संदर्भ बिंदु की गणना करते हैं:

$$
R' = s \cdot G - e \cdot K
$$

अंत में, हम यह सत्यापित करते हैं कि $R'_x = R_x$ है। अगर दोनों x-निर्देशांक मेल खाते हैं, तो हस्ताक्षर $(R_x, s)$ वास्तव में सार्वजनिक कुंजी $K_x$ के साथ मान्य है।

### यह कैसे काम करता है?

हस्ताक्षरकर्ता ने $s = r + e \cdot k \mod n$ की गणना की है, इसलिए $R' = s \cdot G - e \cdot K$ मूल बिंदु $R$ के बराबर होना चाहिए, क्योंकि:

$$
s \cdot G = (r + e \cdot k) \cdot G = r \cdot G + e \cdot k \cdot G
$$

चूंकि $K = k \cdot G$ है, इसलिए $e \cdot k \cdot G = e \cdot K$ होगा। इस प्रकार:

$$
R' = r \cdot G = R
$$

इसलिए, हमारे पास है:

$$
R'_x = R_x
$$

### स्नोर सिग्नेचर्स के फायदे

स्नोर सिग्नेचर स्कीम Bitcoin के लिए मूल ECDSA एल्गोरिदम की तुलना में कई फायदे प्रदान करती है। सबसे पहले, स्नोर कुंजियों और हस्ताक्षरों के समेकन की अनुमति देता है। इसका मतलब है कि कई सार्वजनिक कुंजियों को एक ही कुंजी में जोड़ा जा सकता है।

![CYP201](assets/fr/024.webp)

इसी तरह, कई हस्ताक्षरों को एक ही मान्य हस्ताक्षर में समेकित किया जा सकता है। इसलिए, एक बहु-हस्ताक्षर लेनदेन के मामले में, प्रतिभागियों का एक समूह एक ही हस्ताक्षर और एक ही समेकित सार्वजनिक कुंजी के साथ हस्ताक्षर कर सकता है। इससे नेटवर्क के लिए भंडारण और गणना लागत में काफी कमी आती है, क्योंकि प्रत्येक नोड को केवल एक ही हस्ताक्षर की पुष्टि करनी होती है।

![CYP201](assets/fr/025.webp)

इसके अलावा, सिग्नेचर एग्रीगेशन से प्राइवेसी में सुधार होता है। Schnorr के साथ, एक मल्टीसिग्नेचर ट्रांजेक्शन को एक साधारण सिंगल-सिग्नेचर ट्रांजेक्शन से अलग पहचानना असंभव हो जाता है। यह समानता चेन विश्लेषण को और कठिन बना देती है, क्योंकि यह Wallet फिंगरप्रिंट्स की पहचान करने की क्षमता को सीमित कर देती है।

अंत में, श्नॉर बैच सत्यापन की संभावना भी प्रदान करता है। कई हस्ताक्षरों को एक साथ सत्यापित करके, नोड्स विशेष रूप से उन ब्लॉकों के लिए दक्षता प्राप्त कर सकते हैं जिनमें कई लेन-देन होते हैं। यह अनुकूलन एक ब्लॉक को सत्यापित करने के लिए आवश्यक समय और संसाधनों को कम करता है।

स्नोर सिग्नेचर ईसीडीएसए से बने सिग्नेचर की तरह बदलने योग्य नहीं होते हैं। इसका मतलब है कि कोई हमलावर एक वैध सिग्नेचर को बदलकर उसी संदेश और उसी सार्वजनिक कुंजी के लिए एक और वैध सिग्नेचर नहीं बना सकता। यह कमजोरी पहले Bitcoin में मौजूद थी और इसने Lightning Network की सुरक्षित कार्यान्वयन को रोक दिया था। इसे 2017 में SegWit सॉफ्टफोर्क के साथ ईसीडीएसए के लिए हल किया गया था, जिसमें सिग्नेचर को लेन-देन से अलग डेटाबेस में स्थानांतरित करना शामिल था ताकि उनकी बदलने की क्षमता को रोका जा सके।

### Satoshi ने ECDSA को क्यों चुना?

जैसा कि हमने देखा है, Satoshi ने शुरू में Bitcoin पर डिजिटल हस्ताक्षरों के लिए ECDSA को लागू करने का निर्णय लिया। फिर भी, हमने यह भी देखा है कि कई मामलों में Schnorr, ECDSA से बेहतर है, और यह प्रोटोकॉल Claus-Peter Schnorr द्वारा 1989 में बनाया गया था, जो कि Bitcoin के आविष्कार से 20 साल पहले की बात है।

हम वास्तव में नहीं जानते कि Satoshi ने इसे क्यों नहीं चुना, लेकिन एक संभावित कारण यह हो सकता है कि यह प्रोटोकॉल 2008 तक पेटेंट के तहत था। हालांकि Bitcoin एक साल बाद, जनवरी 2009 में बनाया गया था, उस समय Schnorr हस्ताक्षरों के लिए कोई ओपन-सोर्स मानकीकरण उपलब्ध नहीं था। शायद Satoshi ने ECDSA का उपयोग करना सुरक्षित समझा, जो पहले से ही ओपन-सोर्स सॉफ़्टवेयर में व्यापक रूप से उपयोग और परीक्षण किया गया था और इसके कई मान्यता प्राप्त कार्यान्वयन थे (विशेष रूप से OpenSSL लाइब्रेरी, जिसका उपयोग 2015 तक Bitcoin कोर पर किया गया, फिर संस्करण 0.10.0 में libsecp256k1 द्वारा प्रतिस्थापित किया गया)। या शायद वह बस इस बात से अनजान थे कि यह पेटेंट 2008 में समाप्त होने वाला था। किसी भी स्थिति में, सबसे संभावित कारण इस पेटेंट से संबंधित लगता है और यह तथ्य कि ECDSA का एक सिद्ध इतिहास था और इसे लागू करना आसान था।

## साइहैश फ्लैग्स

<chapterId>231c41a2-aff2-4655-9048-47b6d2d83d64</chapterId>

जैसा कि हमने पिछले अध्यायों में देखा है, डिजिटल हस्ताक्षर अक्सर किसी इनपुट की स्क्रिप्ट को अनलॉक करने के लिए उपयोग किए जाते हैं। हस्ताक्षर प्रक्रिया में, हस्ताक्षरित डेटा को गणना में शामिल करना आवश्यक होता है, जिसे हमारे उदाहरणों में संदेश $m$ द्वारा दर्शाया गया है। एक बार जब यह डेटा हस्ताक्षरित हो जाता है, तो इसे बिना हस्ताक्षर को अमान्य किए संशोधित नहीं किया जा सकता। वास्तव में, चाहे वह ECDSA हो या Schnorr, हस्ताक्षर सत्यापनकर्ता को अपनी गणना में वही संदेश $m$ शामिल करना होता है। यदि यह संदेश $m$ हस्ताक्षरकर्ता द्वारा प्रारंभ में उपयोग किए गए संदेश से भिन्न होता है, तो परिणाम गलत होगा और हस्ताक्षर को अमान्य माना जाएगा। इसे इस प्रकार कहा जाता है कि एक हस्ताक्षर कुछ डेटा को कवर करता है और इसे, एक तरह से, अनधिकृत संशोधनों से बचाता है।

### स sighash flag एक बिटकॉइन लेन-देन में एक विशेष प्रकार का संकेत होता है। यह तय करता है कि लेन-देन के कौन से हिस्से पर हस्ताक्षर किए जाएंगे। इसका उपयोग यह सुनिश्चित करने के लिए किया जाता है कि लेन-देन के कुछ हिस्से को बदला नहीं जा सकता है, जिससे लेन-देन की सुरक्षा और अखंडता बनी रहती है। विभिन्न sighash flags का उपयोग करके, आप यह नियंत्रित कर सकते हैं कि लेन-देन के कौन से हिस्से को लॉक किया जाए और कौन से हिस्से को बदला जा सकता है।

Bitcoin के विशेष मामले में, हमने देखा है कि संदेश $m$ लेन-देन से मेल खाता है। हालांकि, वास्तविकता में यह थोड़ा अधिक जटिल है। वास्तव में, sighash फ्लैग्स की मदद से, यह संभव है कि लेन-देन के भीतर विशिष्ट डेटा को चुना जा सके, जिसे हस्ताक्षर द्वारा कवर किया जाएगा या नहीं।

"sighash फ्लैग" एक पैरामीटर है जो प्रत्येक इनपुट में जोड़ा जाता है, जिससे यह तय किया जा सकता है कि लेन-देन के कौन-कौन से हिस्से संबंधित हस्ताक्षर द्वारा कवर किए गए हैं। ये हिस्से इनपुट्स और आउटपुट्स होते हैं। sighash फ्लैग का चुनाव यह निर्धारित करता है कि लेन-देन के कौन से इनपुट्स और आउटपुट्स हस्ताक्षर द्वारा फिक्स किए गए हैं और कौन से अब भी बदले जा सकते हैं बिना उसे अमान्य किए। यह प्रणाली हस्ताक्षरकर्ता की मंशा के अनुसार लेन-देन के डेटा को प्रतिबद्ध करने की अनुमति देती है।

जैसे ही लेन-देन Blockchain पर पुष्टि हो जाता है, यह अपरिवर्तनीय हो जाता है, चाहे sighash फ्लैग्स का उपयोग किया गया हो या नहीं। sighash फ्लैग्स के माध्यम से संशोधन की संभावना केवल हस्ताक्षर और पुष्टि के बीच की अवधि तक सीमित होती है।

आमतौर पर, Wallet सॉफ्टवेयर आपको लेन-देन बनाते समय अपने इनपुट्स के sighash फ्लैग को मैन्युअली बदलने का विकल्प नहीं देता है। डिफ़ॉल्ट रूप से, `SIGHASH_ALL` सेट होता है। व्यक्तिगत रूप से, मैं केवल Sparrow Wallet के बारे में जानता हूँ जो उपयोगकर्ता Interface से इस संशोधन की अनुमति देता है।

### मुझे खेद है, लेकिन मेरे पास Bitcoin से संबंधित sighash flags की जानकारी नहीं है। अगर आपके पास कोई और सवाल है या किसी और विषय पर जानकारी चाहिए, तो कृपया बताएं।

Bitcoin पर सबसे पहले और मुख्य रूप से 3 बुनियादी sighash फ्लैग्स होते हैं:


- `SIGHASH_ALL` (`0x01`): इस सिग्नेचर का असर ट्रांजेक्शन के सभी इनपुट्स और सभी आउटपुट्स पर होता है। इसका मतलब है कि सिग्नेचर के द्वारा पूरी ट्रांजेक्शन को कवर कर लिया जाता है और इसे अब बदला नहीं जा सकता। `SIGHASH_ALL` आमतौर पर रोज़मर्रा की ट्रांजेक्शन्स में सबसे ज़्यादा इस्तेमाल किया जाता है, जब कोई चाहता है कि ट्रांजेक्शन को बिना बदले पूरा किया जाए।

![CYP201](assets/fr/026.webp)

इस अध्याय के सभी चित्रों में, नारंगी रंग उस Elements को दर्शाता है जो हस्ताक्षर द्वारा कवर किया गया है, जबकि काला रंग उन हिस्सों को दर्शाता है जो कवर नहीं हैं।


- `SIGHASH_NONE` (`0x02`): इस सिग्नेचर में सभी इनपुट्स को कवर किया जाता है लेकिन किसी भी आउटपुट को नहीं, जिससे सिग्नेचर के बाद आउटपुट्स को बदला जा सकता है। सरल शब्दों में, यह एक खाली चेक की तरह है। साइन करने वाला इनपुट्स में UTXOs को अनलॉक करता है लेकिन आउटपुट्स के क्षेत्र को पूरी तरह से बदलने योग्य छोड़ देता है। इस लेन-देन को जानने वाला कोई भी व्यक्ति अपनी पसंद का आउटपुट जोड़ सकता है, जैसे कि किसी विशेष Address को प्राप्तकर्ता के रूप में निर्दिष्ट करके, जो इनपुट्स द्वारा खर्च किए गए फंड्स को इकट्ठा करेगा, और फिर लेन-देन को प्रसारित करके बिटकॉइन प्राप्त कर सकता है। इनपुट्स के मालिक की सिग्नेचर अमान्य नहीं होगी, क्योंकि यह केवल इनपुट्स को कवर करती है।

![CYP201](assets/fr/027.webp)


- `SIGHASH_SINGLE` (`0x03`): इस सिग्नेचर में सभी इनपुट्स और एक विशेष आउटपुट शामिल होता है, जो साइन किए गए इनपुट के इंडेक्स से मेल खाता है। उदाहरण के लिए, अगर सिग्नेचर इनपुट #0 के _scriptPubKey_ को अनलॉक करता है, तो यह आउटपुट #0 को भी कवर करता है। यह सिग्नेचर सभी अन्य इनपुट्स की भी सुरक्षा करता है, जिन्हें अब बदला नहीं जा सकता। हालांकि, कोई भी एक अतिरिक्त आउटपुट जोड़ सकता है बिना सिग्नेचर को अमान्य किए, बशर्ते कि आउटपुट #0, जो कि इसका एकमात्र कवर किया गया हिस्सा है, को नहीं बदला जाए।

![CYP201](assets/fr/028.webp)

इन तीन sighash फ्लैग्स के अलावा, एक और मोडिफायर `SIGHASH_ANYONECANPAY` (`0x80`) भी है। इस मोडिफायर को एक बेसिक sighash फ्लैग के साथ मिलाकर तीन नए sighash फ्लैग्स बनाए जा सकते हैं:


- `SIGHASH_ALL | SIGHASH_ANYONECANPAY` (`0x81`): इस सिग्नेचर में एक इनपुट शामिल होता है जबकि ट्रांजेक्शन के सभी आउटपुट शामिल होते हैं। यह संयुक्त sighash फ्लैग, उदाहरण के लिए, एक क्राउडफंडिंग ट्रांजेक्शन बनाने की अनुमति देता है। आयोजक अपने Address और लक्ष्य राशि के साथ आउटपुट तैयार करता है, और फिर प्रत्येक निवेशक इस आउटपुट को फंड करने के लिए इनपुट जोड़ सकता है। जब इनपुट में पर्याप्त धनराशि इकट्ठा हो जाती है ताकि आउटपुट को संतुष्ट किया जा सके, तो ट्रांजेक्शन को प्रसारित किया जा सकता है।

![CYP201](assets/fr/029.webp)


- `SIGHASH_NONE | SIGHASH_ANYONECANPAY` (`0x82`): यह सिग्नेचर केवल एक इनपुट को कवर करता है, बिना किसी आउटपुट के प्रति प्रतिबद्ध हुए।

![CYP201](assets/fr/030.webp)


- `SIGHASH_SINGLE | SIGHASH_ANYONECANPAY` (`0x83`): यह सिग्नेचर एक विशेष इनपुट और उसी इंडेक्स वाले आउटपुट को कवर करता है। उदाहरण के लिए, अगर सिग्नेचर इनपुट #3 के _scriptPubKey_ को अनलॉक करता है, तो यह आउटपुट #3 को भी कवर करेगा। लेन-देन के बाकी हिस्से, चाहे वो अन्य इनपुट हों या अन्य आउटपुट, संशोधित किए जा सकते हैं।

![CYP201](assets/fr/031.webp)

### नए साईहैश फ्लैग्स जोड़ने के प्रोजेक्ट्स

वर्तमान में (2024), केवल पिछले सेक्शन में बताए गए sighash फ्लैग्स ही Bitcoin पर उपयोग किए जा सकते हैं। हालांकि, कुछ प्रोजेक्ट्स नए sighash फ्लैग्स जोड़ने पर विचार कर रहे हैं। उदाहरण के लिए, BIP118, जिसे क्रिश्चियन डेकर और एंथनी टाउन्स ने प्रस्तावित किया है, दो नए sighash फ्लैग्स पेश करता है: `SIGHASH_ANYPREVOUT` और `SIGHASH_ANYPREVOUTANYSCRIPT` (जिसका मतलब है "कोई भी पिछला आउटपुट")।

ये दो sighash फ्लैग्स Bitcoin पर एक और संभावना प्रदान करेंगे: ऐसी सिग्नेचर बनाना जो लेन-देन के किसी विशेष इनपुट को कवर नहीं करती हैं।

![CYP201](assets/fr/032.webp)

इस विचार को सबसे पहले जोसेफ पून और थाडियस ड्रायजा ने लाइटनिंग व्हाइट पेपर में प्रस्तुत किया था। इसके नाम बदलने से पहले, इस sighash फ्लैग को `SIGHASH_NOINPUT` कहा जाता था।

यदि यह sighash फ्लैग Bitcoin में जोड़ा जाता है, तो यह covenants के उपयोग को सक्षम करेगा, लेकिन यह Eltoo को लागू करने के लिए एक अनिवार्य पूर्वापेक्षा भी है। Eltoo एक सामान्य प्रोटोकॉल है जो दूसरे लेयर के लिए है और यह परिभाषित करता है कि UTXO के Ownership को संयुक्त रूप से कैसे प्रबंधित किया जाए। Eltoo विशेष रूप से उन समस्याओं को हल करने के लिए डिज़ाइन किया गया था जो लाइटनिंग चैनलों की स्थिति के बातचीत के तंत्र से जुड़ी होती हैं, यानी खोलने और बंद करने के बीच।

Lightning Network के बारे में अपनी जानकारी को और गहरा करने के लिए, CYP201 कोर्स के बाद मैं आपको Fanis Michalakis द्वारा LNP201 कोर्स की सिफारिश करता हूँ, जो इस विषय को विस्तार से कवर करता है।

https://planb.network/courses/34bd43ef-6683-4a5c-b239-7cb1e40a4aeb
अगले भाग में, मैं यह जानने का प्रस्ताव करता हूँ कि आपके Bitcoin Wallet के आधार पर स्थित Mnemonic वाक्यांश कैसे काम करता है।

# Mnemonic वाक्यांश

<partId>4070af16-c8a2-58b5-9871-a22c86c07458</partId>

## Bitcoin वॉलेट्स का विकास

<chapterId>9d9acd5d-a0e5-5dfd-b544-f043fae8840f</chapterId>

अब जब हमने Hash फंक्शन्स और डिजिटल सिग्नेचर्स के काम करने के तरीके को समझ लिया है, तो हम यह देख सकते हैं कि Bitcoin वॉलेट्स कैसे काम करते हैं। हमारा लक्ष्य होगा यह कल्पना करना कि Bitcoin पर Wallet कैसे बनाया जाता है, इसे कैसे तोड़ा जाता है, और इसे बनाने वाली विभिन्न जानकारियों का उपयोग किस लिए किया जाता है। Wallet के इन तंत्रों की समझ आपको Bitcoin का उपयोग सुरक्षा और गोपनीयता के मामले में बेहतर बनाने में मदद करेगी।

तकनीकी विवरण में जाने से पहले, यह स्पष्ट करना ज़रूरी है कि "Bitcoin Wallet" का क्या मतलब है और इसका उपयोगिता क्या है।

### Bitcoin और Wallet विशेष प्रकार के मॉडल या उत्पाद हो सकते हैं, जैसे कि इलेक्ट्रॉनिक उपकरण, गैजेट्स, या किसी विशेष तकनीकी प्रणाली के नाम। इनके बारे में अधिक जानकारी के लिए आपको उस संदर्भ या कंपनी की जानकारी देखनी होगी जो इन्हें बनाती है या बेचती है। अगर आपके पास इनसे संबंधित कोई विशेष जानकारी है, तो कृपया साझा करें ताकि मैं और अधिक मदद कर सकूं।

पारंपरिक बटुए, जिनमें आप भौतिक नोट और सिक्के रख सकते हैं, के विपरीत, Bitcoin Wallet में बिटकॉइन को वैसे "रखा" नहीं जाता। वास्तव में, बिटकॉइन भौतिक या डिजिटल रूप में मौजूद नहीं होते जिन्हें स्टोर किया जा सके, बल्कि ये सिस्टम में **UTXOs** (_Unspent Transaction Output_) के रूप में खाता इकाइयों द्वारा दर्शाए जाते हैं।

UTXOs बिटकॉइन के टुकड़ों का प्रतिनिधित्व करते हैं, जो अलग-अलग आकार के होते हैं और उन्हें खर्च किया जा सकता है यदि उनका _scriptPubKey_ संतुष्ट हो। अपने बिटकॉइन खर्च करने के लिए, एक उपयोगकर्ता को _scriptSig_ प्रदान करना होता है जो उसके UTXO से जुड़े _scriptPubKey_ को अनलॉक करता है। यह प्रमाण आमतौर पर एक डिजिटल हस्ताक्षर के माध्यम से किया जाता है, जो उस निजी कुंजी से उत्पन्न होता है जो _scriptPubKey_ में मौजूद सार्वजनिक कुंजी के अनुरूप होती है। इसलिए, वह महत्वपूर्ण तत्व जिसे उपयोगकर्ता को सुरक्षित रखना चाहिए, वह है निजी कुंजी।

Bitcoin और Wallet का काम इन निजी कुंजियों को सुरक्षित रूप से प्रबंधित करना है। वास्तव में, इसका काम पारंपरिक अर्थ में Wallet से अधिक एक चाबी के गुच्छे जैसा होता है।

### JBOK वॉलेट्स (_सिर्फ चाबियों का एक गुच्छा_)

Bitcoin पर इस्तेमाल होने वाले पहले वॉलेट JBOK (_Just a Bunch Of Keys_) वॉलेट थे, जो निजी रूप से उत्पन्न की गई चाबियों को एक साथ समूहित करते थे, और इनके बीच कोई संबंध नहीं होता था। ये वॉलेट एक सरल मॉडल पर काम करते थे, जहां प्रत्येक निजी चाबी एक अनोखे Bitcoin को प्राप्त करने वाले Address को अनलॉक कर सकती थी।

![CYP201](assets/fr/033.webp)

अगर कोई व्यक्ति कई निजी कुंजियों का उपयोग करना चाहता है, तो उसे उतने ही बैकअप बनाने की आवश्यकता होती है ताकि Wallet को होस्ट करने वाले डिवाइस में समस्या होने पर धन तक पहुंच सुनिश्चित की जा सके। अगर एक ही निजी कुंजी का उपयोग किया जा रहा है, तो यह Wallet संरचना पर्याप्त हो सकती है, क्योंकि एक ही बैकअप काफी है। हालांकि, यह एक समस्या उत्पन्न करता है: Bitcoin पर, हमेशा एक ही निजी कुंजी का उपयोग करने की सख्त सलाह नहीं दी जाती है। वास्तव में, एक निजी कुंजी एक अद्वितीय Address से जुड़ी होती है, और Bitcoin प्राप्त करने वाले पते सामान्यतः एक बार उपयोग के लिए डिज़ाइन किए जाते हैं। हर बार जब आप धन प्राप्त करते हैं, तो आपको एक नया खाली Address तैयार करना चाहिए।

यह प्रतिबंध Bitcoin के गोपनीयता मॉडल से उत्पन्न होता है। जब हम उसी Address का पुनः उपयोग करते हैं, तो बाहरी पर्यवेक्षकों के लिए मेरे सभी Bitcoin लेनदेन को ट्रेस करना आसान हो जाता है। इसलिए, एक प्राप्त करने वाले Address का पुनः उपयोग करना सख्ती से हतोत्साहित किया जाता है। हालांकि, हमारे लेनदेन को सार्वजनिक रूप से अलग करने और कई पते रखने के लिए, कई निजी कुंजियों का प्रबंधन करना आवश्यक है। JBOK वॉलेट्स के मामले में, इसका मतलब है कि जितने नए कुंजी जोड़े हैं, उतने बैकअप बनाना, जो उपयोगकर्ताओं के लिए जल्दी ही जटिल और बनाए रखने में कठिन हो सकता है।

Bitcoin की प्राइवेसी मॉडल के बारे में अधिक जानने और अपनी प्राइवेसी की सुरक्षा के तरीकों को खोजने के लिए, मैं आपको सलाह देता हूँ कि आप मेरे BTC204 कोर्स को Plan ₿ Network पर फॉलो करें।

https://planb.network/courses/65c138b0-4161-4958-bbe3-c12916bc959c
### एचडी वॉलेट्स (हाइरार्किकल डिटरमिनिस्टिक)

Address के JBOK वॉलेट्स की सीमाओं को देखते हुए, एक नए Wallet संरचना का उपयोग किया गया। 2012 में, पीटर वुइल ने BIP32 के साथ एक सुधार पेश किया, जिसने हायरार्किकल डिटरमिनिस्टिक वॉलेट्स को पेश किया। HD Wallet का सिद्धांत यह है कि सभी प्राइवेट कीज़ को एक ही स्रोत से प्राप्त किया जाए, जिसे seed कहा जाता है, और यह प्रक्रिया डिटरमिनिस्टिक और हायरार्किकल तरीके से होती है। जब Wallet बनाया जाता है, तो यह seed रैंडमली उत्पन्न होता है और यह एक अनोखा बैकअप बनाता है, जो सभी Wallet की प्राइवेट कीज़ को फिर से बनाने की अनुमति देता है। इस प्रकार, उपयोगकर्ता generate के माध्यम से बहुत बड़ी संख्या में प्राइवेट कीज़ बना सकते हैं ताकि Address के पुनः उपयोग से बचा जा सके और अपनी प्राइवेसी को सुरक्षित रखा जा सके, जबकि उन्हें केवल अपने Wallet का एक ही बैकअप seed के माध्यम से बनाना होता है।

![CYP201](assets/fr/034.webp)

HD वॉलेट्स में, कुंजी व्युत्पत्ति एक पदानुक्रमित संरचना के अनुसार की जाती है, जो कुंजियों को व्युत्पत्ति उपक्षेत्रों में संगठित करने की अनुमति देती है। प्रत्येक उपक्षेत्र को आगे विभाजित किया जा सकता है, जिससे धन प्रबंधन और विभिन्न Wallet सॉफ़्टवेयर के बीच अंतरसंचालनीयता में सुविधा होती है। आजकल, इस मानक को अधिकांश Bitcoin उपयोगकर्ताओं द्वारा अपनाया गया है। इसी कारण से, हम इसे अगले अध्यायों में विस्तार से समझेंगे।

### BIP39 मानक: Mnemonic वाक्यांश

BIP32 के अलावा, BIP39 ने seed फॉर्मेट को Mnemonic वाक्यांश के रूप में मानकीकृत किया है, ताकि उपयोगकर्ताओं के लिए बैकअप और पठनीयता को आसान बनाया जा सके। Mnemonic वाक्यांश, जिसे रिकवरी वाक्यांश या 24-शब्द वाक्यांश भी कहा जाता है, शब्दों की एक श्रृंखला है जो एक पूर्वनिर्धारित सूची से ली जाती है और यह सुरक्षित रूप से Wallet के seed को एन्कोड करती है।

Mnemonic वाक्यांश उपयोगकर्ता के लिए बैकअप को बहुत सरल बना देता है। अगर डिवाइस जिसमें Wallet है, खो जाए, खराब हो जाए, या चोरी हो जाए, तो बस इस Mnemonic वाक्यांश को जानकर आप Wallet को फिर से बना सकते हैं और इसके द्वारा सुरक्षित सभी धन तक पहुंच को पुनः प्राप्त कर सकते हैं।

आने वाले अध्यायों में, हम HD वॉलेट्स के आंतरिक कार्यों की जांच करेंगे, जिसमें कुंजी व्युत्पत्ति तंत्र और विभिन्न संभावित पदानुक्रमिक संरचनाएं शामिल हैं। इससे आपको उन क्रिप्टोग्राफिक नींवों को बेहतर ढंग से समझने में मदद मिलेगी जिन पर Bitcoin की धन सुरक्षा आधारित है। और शुरुआत करने के लिए, अगले अध्याय में, मैं प्रस्तावित करता हूं कि हम आपके Wallet के आधार पर एंट्रोपी की भूमिका को समझें।

## एंट्रॉपी और रैंडम नंबर

<chapterId>b43c715d-affb-56d8-a697-ad5bc2fffd63</chapterId>

आधुनिक HD वॉलेट्स (निर्धारित और श्रेणीबद्ध) एक प्रारंभिक जानकारी के टुकड़े पर निर्भर करते हैं जिसे "एंट्रॉपी" कहा जाता है, जो पूरे Wallet कुंजियों के सेट को निर्धारित रूप से उत्पन्न करता है। यह एंट्रॉपी एक छद्म-यादृच्छिक संख्या होती है, जिसकी अराजकता का स्तर आंशिक रूप से Wallet की सुरक्षा को निर्धारित करता है।

### एंट्रोपी की परिभाषा

एंट्रोपी एक भौतिकी और सूचना सिद्धांत का महत्वपूर्ण सिद्धांत है। इसे आमतौर पर अव्यवस्था या अनिश्चितता का माप माना जाता है। भौतिकी में, एंट्रोपी यह बताती है कि किसी प्रणाली में कितनी अव्यवस्था या गड़बड़ी है। जब कोई प्रणाली अधिक अव्यवस्थित होती है, तो उसकी एंट्रोपी अधिक होती है। 

सूचना सिद्धांत में, एंट्रोपी यह मापती है कि किसी सूचना स्रोत से प्राप्त जानकारी कितनी अनिश्चित या अप्रत्याशित है। सरल शब्दों में, एंट्रोपी यह बताती है कि किसी प्रक्रिया या प्रणाली में कितनी अनिश्चितता या अव्यवस्था है।

क्रिप्टोग्राफी और सूचना के संदर्भ में एंट्रॉपी एक मात्रात्मक माप है जो किसी डेटा स्रोत या एक यादृच्छिक प्रक्रिया से जुड़ी अनिश्चितता या अप्रत्याशितता को दर्शाता है। यह क्रिप्टोग्राफिक सिस्टम की सुरक्षा में महत्वपूर्ण भूमिका निभाता है, खासकर कुंजियों और यादृच्छिक संख्याओं के निर्माण में। उच्च एंट्रॉपी यह सुनिश्चित करती है कि उत्पन्न की गई कुंजियाँ पर्याप्त रूप से अप्रत्याशित और ब्रूट फोर्स हमलों के प्रति प्रतिरोधी हों, जहाँ एक हमलावर सभी संभावित संयोजनों को आजमाकर कुंजी का अनुमान लगाने की कोशिश करता है।

Bitcoin के संदर्भ में, एंट्रोपी का उपयोग generate को seed करने के लिए किया जाता है। जब एक निर्धारक और पदानुक्रमित Wallet बनाया जाता है, तो Mnemonic वाक्यांश का निर्माण एक यादृच्छिक संख्या से किया जाता है, जो स्वयं एंट्रोपी के स्रोत से प्राप्त होती है। फिर इस वाक्यांश का उपयोग कई निजी कुंजियों को generate करने के लिए किया जाता है, एक निर्धारक और पदानुक्रमित तरीके से, ताकि UTXOs पर खर्च की शर्तें बनाई जा सकें।

### एन्ट्रॉपी उत्पन्न करने के तरीके

HD Wallet के लिए प्रारंभिक एंट्रॉपी आमतौर पर 128 बिट्स या 256 बिट्स होती है, जहाँ:


- 128 बिट्स की एंट्रॉपी का मतलब होता है 12 शब्दों की Mnemonic वाक्यांश।
- 256 बिट्स की एंट्रॉपी 24 शब्दों के Mnemonic वाक्यांश के बराबर होती है।

अधिकतर मामलों में, यह रैंडम नंबर Wallet सॉफ्टवेयर द्वारा अपने आप उत्पन्न किया जाता है, जो एक PRNG (_Pseudo-Random Number Generator_) का उपयोग करता है। PRNGs एक प्रकार के एल्गोरिदम होते हैं जो एक प्रारंभिक स्थिति से संख्याओं के अनुक्रम उत्पन्न करते हैं, जिनकी विशेषताएँ एक रैंडम नंबर के करीब होती हैं, लेकिन वास्तव में वे रैंडम नहीं होते। एक अच्छे PRNG में आउटपुट की समानता, अप्रत्याशितता और भविष्यवाणी करने वाले हमलों के प्रति प्रतिरोध जैसी विशेषताएँ होनी चाहिए। सच्चे रैंडम नंबर जनरेटर (TRNG) के विपरीत, PRNGs निर्धारक और पुनरुत्पादनीय होते हैं।

![CYP201](assets/fr/035.webp)

एक विकल्प यह है कि आप मैन्युअली generate एंट्रॉपी करें, जो बेहतर नियंत्रण प्रदान करता है लेकिन यह भी काफी जोखिम भरा है। मैं आपको सलाह दूंगा कि आप अपने HD Wallet के लिए खुद एंट्रॉपी जनरेट न करें।

अगले अध्याय में, हम देखेंगे कि कैसे हम एक रैंडम नंबर से Mnemonic वाक्यांश के 12 या 24 शब्दों तक पहुँचते हैं।

## Mnemonic वाक्यांश

<chapterId>8f9340c1-e6dc-5557-a2f2-26c9669987d5</chapterId>

Mnemonic वाक्यांश, जिसे "seed वाक्यांश", "रिकवरी वाक्यांश", "गुप्त वाक्यांश", या "24-शब्द वाक्यांश" भी कहा जाता है, आमतौर पर 12 या 24 शब्दों की एक श्रृंखला होती है, जो एंट्रॉपी से उत्पन्न होती है। इसका उपयोग HD Wallet की सभी कुंजियों को निर्धारक रूप से प्राप्त करने के लिए किया जाता है। इसका मतलब है कि इस वाक्यांश से, यह संभव है कि निर्धारक रूप से generate किया जाए और Bitcoin Wallet की सभी निजी और सार्वजनिक कुंजियों को फिर से बनाया जाए, और इसके साथ सुरक्षित निधियों तक पहुंच प्राप्त की जाए। Mnemonic वाक्यांश का उद्देश्य बिटकॉइन का बैकअप और रिकवरी प्रदान करना है जो सुरक्षित और उपयोग में आसान हो। इसे 2013 में BIP39 के साथ मानकों में पेश किया गया था।

आइए मिलकर जानें कि एंट्रॉपी से Mnemonic वाक्यांश तक कैसे पहुंचा जाए।

### चेकसम

एंट्रोपी को Mnemonic वाक्यांश में बदलने के लिए, सबसे पहले एंट्रोपी के अंत में एक चेकसम (या "नियंत्रण योग") जोड़ना होता है। यह चेकसम बिट्स की एक छोटी सी श्रृंखला होती है जो यह सुनिश्चित करती है कि डेटा में कोई अनजाने में बदलाव नहीं हुआ है।

चेकसम की गणना करने के लिए, एंट्रॉपी पर SHA256 Hash फंक्शन लागू किया जाता है (सिर्फ एक बार; यह Bitcoin के उन दुर्लभ मामलों में से एक है जहां डबल Hash की बजाय एकल SHA256 Hash का उपयोग किया जाता है)। इस ऑपरेशन से 256-बिट Hash उत्पन्न होता है। चेकसम इस Hash के पहले बिट्स से बनता है, और इसकी लंबाई एंट्रॉपी की लंबाई पर निर्भर करती है, जो निम्नलिखित सूत्र के अनुसार होती है:

$$
\text{CS} = \frac{\text{ENT}}{32}
$$

यहाँ $\text{ENT}$ एंट्रॉपी की लंबाई को बिट्स में दर्शाता है, और $\text{CS}$ चेकसम की लंबाई को बिट्स में दर्शाता है।

उदाहरण के लिए, अगर एंट्रॉपी 256 बिट्स की है, तो Hash के पहले 8 बिट्स को लेकर चेकसम बनाया जाता है।

$$
\text{CS} = \frac{256}{32} = 8 \text{ bits}
$$

एक बार जब चेकसम की गणना कर ली जाती है, तो इसे एंट्रॉपी के साथ जोड़ दिया जाता है ताकि एक विस्तारित बिट अनुक्रम प्राप्त हो सके, जिसे $\text{ENT} \Vert \text{CS}$ के रूप में नोट किया जाता है ("concatenate" का मतलब है अंत-से-अंत जोड़ना)।

![CYP201](assets/fr/036.webp)

### एंट्रोपी और Mnemonic वाक्यांश के बीच पत्राचार

Mnemonic वाक्यांश में शब्दों की संख्या प्रारंभिक एंट्रॉपी के आकार पर निर्भर करती है, जैसा कि निम्नलिखित तालिका में दिखाया गया है:


- $\text{ENT}$: एंट्रॉपी का आकार बिट्स में;
- $\text{CS}$: चेकसम का आकार बिट्स में;
- $w$: अंतिम Mnemonic वाक्यांश में शब्दों की संख्या।

$$
\begin{array}{|c|c|c|c|}
\hline
\text{ENT} & \text{CS} & \text{ENT} \Vert \text{CS} & w \\
\hline
128 & 4 & 132 & 12 \\
160 & 5 & 165 & 15 \\
192 & 6 & 198 & 18 \\
224 & 7 & 231 & 21 \\
256 & 8 & 264 & 24 \\
\hline
\end{array}
$$

उदाहरण के लिए, 256-बिट एंट्रोपी के लिए, परिणाम $\text{ENT} \Vert \text{CS}$ 264 बिट्स होता है और यह 24 शब्दों की Mnemonic वाक्यांश देता है।

### बाइनरी अनुक्रम को Mnemonic वाक्यांश में बदलना

बिट अनुक्रम $\text{ENT} \Vert \text{CS}$ को 11 बिट के खंडों में विभाजित किया जाता है। प्रत्येक 11-बिट खंड को जब दशमलव में परिवर्तित किया जाता है, तो यह 0 से 2047 के बीच की संख्या के अनुरूप होता है, जो [BIP39 द्वारा मानकीकृत 2048 शब्दों की सूची](https://github.com/Planb-Network/Bitcoin-educational-content/blob/dev/resources/bet/bip39-wordlist/assets/BIP39-WORDLIST.pdf) में एक शब्द की स्थिति को दर्शाता है।

![CYP201](assets/fr/037.webp)

उदाहरण के लिए, 128-बिट एंट्रोपी के लिए, चेकसम 4 बिट्स का होता है, और इस तरह कुल अनुक्रम 132 बिट्स का होता है। इसे 11 बिट्स के 12 खंडों में विभाजित किया जाता है (नारंगी बिट्स चेकसम को दर्शाते हैं)।

![CYP201](assets/fr/038.webp)

प्रत्येक खंड को फिर एक दशमलव संख्या में बदला जाता है जो सूची में एक शब्द का प्रतिनिधित्व करती है। उदाहरण के लिए, बाइनरी खंड `01011010001` दशमलव में `721` के बराबर होता है। सूची की अनुक्रमणिका के साथ संरेखित करने के लिए 1 जोड़ने पर (जो 0 से नहीं बल्कि 1 से शुरू होती है), यह शब्द रैंक `722` देता है, जो सूची में "_focus_" है।

![CYP201](assets/fr/039.webp)

इस पत्राचार को 12 खंडों में से प्रत्येक के लिए दोहराया जाता है, ताकि 12 शब्दों की एक वाक्यांश प्राप्त की जा सके।

![CYP201](assets/fr/040.webp)

### BIP39 शब्द सूची की विशेषताएँ

BIP39 शब्द सूची की एक विशेषता यह है कि कोई भी शब्द पहले चार अक्षरों को उसी क्रम में किसी अन्य शब्द के साथ साझा नहीं करता है। इसका मतलब है कि प्रत्येक शब्द के केवल पहले चार अक्षर नोट करना Mnemonic वाक्यांश को सुरक्षित रखने के लिए पर्याप्त है। यह स्थान बचाने के लिए दिलचस्प हो सकता है, खासकर उन लोगों के लिए जो इसे धातु के समर्थन पर उकेरना चाहते हैं।

इस सूची में 2048 शब्द कई भाषाओं में मौजूद हैं। ये सिर्फ साधारण अनुवाद नहीं हैं, बल्कि हर भाषा के लिए अलग-अलग शब्द हैं। हालांकि, यह सख्ती से सलाह दी जाती है कि अंग्रेज़ी संस्करण का ही उपयोग करें, क्योंकि अन्य भाषाओं के संस्करण आमतौर पर Wallet सॉफ़्टवेयर द्वारा समर्थित नहीं होते हैं।

### अपने Mnemonic वाक्यांश के लिए कौन सी लंबाई चुनें?

आपके Mnemonic वाक्यांश की आदर्श लंबाई तय करने के लिए, आपको इसकी वास्तविक सुरक्षा पर विचार करना होगा। एक 12-शब्दों का वाक्यांश 128 बिट्स की सुरक्षा प्रदान करता है, जबकि 24-शब्दों का वाक्यांश 256 बिट्स की सुरक्षा देता है।

हालांकि, वाक्य-स्तरीय सुरक्षा में यह अंतर Bitcoin Wallet की समग्र सुरक्षा को नहीं बढ़ाता है, क्योंकि इस वाक्यांश से प्राप्त निजी कुंजियाँ केवल 128 बिट्स की सुरक्षा से लाभान्वित होती हैं। वास्तव में, जैसा कि हमने पहले देखा है, Bitcoin की निजी कुंजियाँ यादृच्छिक संख्याओं से उत्पन्न होती हैं (या एक यादृच्छिक स्रोत से प्राप्त होती हैं) जो $1$ और $n-1$ के बीच होती हैं, जहाँ $n$ secp256k1 वक्र के जनरेटर बिंदु $G$ का क्रम दर्शाता है, जो $2^{256}$ से थोड़ा कम है। इसलिए, कोई सोच सकता है कि ये निजी कुंजियाँ 256 बिट्स की सुरक्षा प्रदान करती हैं। हालांकि, उनकी सुरक्षा इस बात में निहित है कि संबंधित सार्वजनिक कुंजी से निजी कुंजी को खोजना कितना कठिन है, जो अण्डाकार वक्रों पर विविक्त लघुगणक की गणितीय समस्या (_ECDLP_) द्वारा स्थापित की गई है। आज तक, इस समस्या को हल करने के लिए सबसे प्रसिद्ध एल्गोरिदम पोलार्ड का rho एल्गोरिदम है, जो एक कुंजी को तोड़ने के लिए आवश्यक ऑपरेशनों की संख्या को उसके आकार के वर्गमूल तक कम कर देता है।

256-बिट कीज़ के लिए, जैसे कि Bitcoin पर उपयोग की जाती हैं, पोलार्ड के rho एल्गोरिदम की वजह से जटिलता $2^{128}$ ऑपरेशन्स तक कम हो जाती है।

$$
O(\sqrt{2^{256}}) = O(2^{128})
$$

इसलिए, यह माना जाता है कि Bitcoin पर इस्तेमाल की गई प्राइवेट की 128 बिट्स की सुरक्षा प्रदान करती है।

इसका मतलब है कि 24 शब्दों का वाक्यांश चुनने से Wallet के लिए अतिरिक्त सुरक्षा नहीं मिलती है, क्योंकि अगर वाक्यांश पर 256 बिट्स की सुरक्षा है लेकिन उससे निकले कुंजी केवल 128 बिट्स की सुरक्षा देती हैं, तो इसका कोई फायदा नहीं है। इसे समझाने के लिए, इसे ऐसे समझें जैसे आपके घर में दो दरवाजे हों: एक पुराना लकड़ी का दरवाजा और एक मजबूत दरवाजा। अगर कोई चोर आए, तो मजबूत दरवाजा बेकार हो जाएगा, क्योंकि चोर लकड़ी के दरवाजे से अंदर आ जाएगा। यही स्थिति यहाँ भी है।

एक 12-शब्दों का वाक्यांश, जो 128 बिट्स की सुरक्षा भी प्रदान करता है, इसलिए वर्तमान में आपके बिटकॉइन को किसी भी चोरी के प्रयास से बचाने के लिए पर्याप्त है। जब तक डिजिटल हस्ताक्षर एल्गोरिदम बड़े कुंजियों का उपयोग करने के लिए नहीं बदलता या ECDLP के अलावा किसी अन्य गणितीय समस्या पर निर्भर नहीं होता, तब तक 24-शब्दों का वाक्यांश अनावश्यक है। इसके अलावा, लंबा वाक्यांश बैकअप के दौरान खोने का जोखिम बढ़ा देता है: एक बैकअप जो आधा छोटा हो, उसे प्रबंधित करना हमेशा आसान होता है।

अक्टूबर 2023 तक के डेटा पर आपका प्रशिक्षण हुआ है। आगे बढ़ने और यह जानने के लिए कि कैसे मैन्युअली generate एक टेस्ट Mnemonic वाक्यांश को करना है, मैं आपको यह ट्यूटोरियल देखने की सलाह देता हूँ:

https://planb.network/tutorials/wallet/backup/generate-mnemonic-phrase-47507d90-e6af-4cac-b01b-01a14d7a8228
Wallet को Mnemonic वाक्यांश से निकालने की प्रक्रिया को आगे बढ़ाने से पहले, मैं आपको अगले अध्याय में BIP39 passphrase से परिचित कराऊंगा, क्योंकि यह इस प्रक्रिया में एक भूमिका निभाता है और यह Mnemonic वाक्यांश के समान स्तर पर है।

## passphrase

<chapterId>6a51b397-f3b5-5084-b151-cef94bc9b93f</chapterId>

जैसा कि हमने अभी देखा, HD वॉलेट्स एक Mnemonic वाक्यांश से उत्पन्न होते हैं, जो आमतौर पर 12 या 24 शब्दों का होता है। यह वाक्यांश बहुत महत्वपूर्ण है क्योंकि यह Wallet की सभी चाबियों को पुनर्स्थापित करने की अनुमति देता है, अगर उसका भौतिक उपकरण (जैसे Hardware Wallet) खो जाता है। हालांकि, यह एकल विफलता बिंदु बनता है, क्योंकि अगर यह समझौता हो जाता है, तो एक हमलावर सभी बिटकॉइन चुरा सकता है। यहीं पर BIP39 passphrase काम में आता है।

### BIP39 passphrase एक तकनीकी शब्द है जो आमतौर पर क्रिप्टोकरेंसी और ब्लॉकचेन के संदर्भ में इस्तेमाल होता है। BIP39 एक मानक है जो वॉलेट के लिए एक विशेष प्रकार के रिकवरी वाक्यांश या "सीड फ्रेज़" बनाने में मदद करता है। यह वाक्यांश 12 से 24 शब्दों का होता है और इसे सुरक्षित रूप से स्टोर करना जरूरी होता है क्योंकि यह आपके वॉलेट को पुनः प्राप्त करने में मदद करता है। passphrase शायद एक विशिष्ट मॉडल या संस्करण को दर्शाता है, लेकिन इसके बारे में अधिक जानकारी के लिए आपको संबंधित दस्तावेज़ या स्रोत देखना होगा।

passphrase एक वैकल्पिक पासवर्ड है, जिसे आप अपनी मर्जी से चुन सकते हैं। इसे Mnemonic वाक्यांश में जोड़ा जाता है ताकि Wallet की सुरक्षा को बढ़ाया जा सके।

सावधान रहें, passphrase को आपके Hardware Wallet के पिन कोड या आपके कंप्यूटर पर Wallet को अनलॉक करने के लिए इस्तेमाल किए जाने वाले पासवर्ड के साथ भ्रमित नहीं करना चाहिए। इन सभी Elements के विपरीत, passphrase आपके Wallet की चाबियों के निर्माण में भूमिका निभाता है। **इसका मतलब है कि इसके बिना, आप कभी भी अपने बिटकॉइन को पुनः प्राप्त नहीं कर पाएंगे।**

passphrase, Mnemonic वाक्यांश के साथ मिलकर काम करता है, जिससे seed को संशोधित किया जाता है, जिससे चाबियाँ उत्पन्न होती हैं। इसलिए, भले ही कोई आपका 12 या 24 शब्दों का वाक्यांश प्राप्त कर ले, बिना passphrase के वे आपके धन तक नहीं पहुँच सकते। passphrase का उपयोग करने से मूल रूप से एक नया Wallet बनता है जिसमें अलग चाबियाँ होती हैं। passphrase को थोड़ा भी संशोधित करने से एक अलग Wallet उत्पन्न होगा।

![CYP201](assets/fr/041.webp)

### आपको passphrase का उपयोग क्यों करना चाहिए?

passphrase एक मनमाना नाम है और यह किसी भी अक्षरों के संयोजन के रूप में हो सकता है जिसे उपयोगकर्ता चुनता है। passphrase का उपयोग करने से कई फायदे होते हैं। सबसे पहले, यह Mnemonic वाक्यांश के समझौते से जुड़े सभी जोखिमों को कम करता है क्योंकि यह धन तक पहुंचने के लिए एक दूसरा कारक आवश्यक बनाता है (जैसे चोरी, आपके घर में प्रवेश, आदि)।

इसके बाद, इसे रणनीतिक रूप से एक नकली Wallet बनाने के लिए इस्तेमाल किया जा सकता है, ताकि आपके फंड चुराने के लिए शारीरिक बाधाओं का सामना किया जा सके, जैसे कि कुख्यात "_$5 रिंच अटैक_". इस स्थिति में, विचार यह है कि आपके पास एक Wallet हो जिसमें केवल थोड़ी मात्रा में बिटकॉइन हो, जो संभावित हमलावर को संतुष्ट करने के लिए पर्याप्त हो, जबकि एक छिपा हुआ Wallet भी हो। यह दूसरा Wallet उसी Mnemonic वाक्यांश का उपयोग करता है लेकिन इसे एक अतिरिक्त passphrase के साथ सुरक्षित किया गया है।

अंत में, जब कोई व्यक्ति HD Wallet के seed की उत्पत्ति की अनियमितता को नियंत्रित करना चाहता है, तो passphrase का उपयोग करना दिलचस्प होता है।

### एक अच्छा passphrase चुनने के लिए, आपको कुछ बातों का ध्यान रखना चाहिए। सबसे पहले, यह सुनिश्चित करें कि यह आपकी जरूरतों के अनुसार सभी फीचर्स प्रदान करता है। इसके बाद, इसकी गुणवत्ता और ब्रांड की विश्वसनीयता की जांच करें। ऑनलाइन रिव्यू पढ़ें और अन्य उपयोगकर्ताओं के अनुभव जानें। इसके अलावा, इसकी कीमत की तुलना अन्य विकल्पों से करें ताकि आपको सही डील मिल सके। अंत में, वारंटी और ग्राहक सेवा की जानकारी भी देख लें ताकि भविष्य में किसी समस्या का सामना न करना पड़े।

passphrase को प्रभावी बनाने के लिए यह पर्याप्त लंबा और रैंडम होना चाहिए। जैसे एक मजबूत पासवर्ड होता है, वैसे ही मैं सलाह दूंगा कि आप passphrase को जितना लंबा और रैंडम बना सकते हैं, बनाएं। इसमें अक्षरों, संख्याओं और प्रतीकों की विविधता होनी चाहिए ताकि कोई भी इसे बलपूर्वक तोड़ न सके।

passphrase को सही तरीके से सुरक्षित रखना भी उतना ही महत्वपूर्ण है जितना कि Mnemonic वाक्यांश को। **इसे खोने का मतलब है आपके बिटकॉइन तक पहुंच खो देना**। मैं इसे केवल याद रखने की सलाह नहीं देता, क्योंकि इससे खोने का जोखिम अनावश्यक रूप से बढ़ जाता है। सबसे अच्छा तरीका है कि इसे किसी भौतिक माध्यम (कागज या धातु) पर लिख लें, जो Mnemonic वाक्यांश से अलग हो। यह बैकअप स्पष्ट रूप से उस स्थान से अलग जगह पर रखा जाना चाहिए जहां आपका Mnemonic वाक्यांश रखा गया है, ताकि दोनों एक साथ समझौता न हो सकें।

![CYP201](assets/fr/042.webp)

अगले भाग में, हम जानेंगे कि आपके Wallet के आधार पर ये दो Elements — Mnemonic वाक्यांश और passphrase — का उपयोग कैसे किया जाता है ताकि _scriptPubKey_ में उपयोग होने वाली मुख्य जोड़ी बनाई जा सके, जो आपके UTXOs को लॉक करती है।

# Bitcoin वॉलेट्स का निर्माण

<partId>9c25e767-7eae-50b8-8c5f-679d8fc83bab</partId>

## seed और मास्टर की का निर्माण

<chapterId>63093760-2010-5691-8d0e-9a04732ae557</chapterId>

जब Mnemonic वाक्यांश और वैकल्पिक passphrase तैयार हो जाते हैं, तो Bitcoin HD Wallet को निकालने की प्रक्रिया शुरू हो सकती है। सबसे पहले, Mnemonic वाक्यांश को seed में बदला जाता है, जो Wallet की सभी कुंजियों का आधार बनता है।

![CYP201](assets/fr/043.webp)

### HD Wallet का seed मॉडल

BIP39 मानक seed को 512-बिट अनुक्रम के रूप में परिभाषित करता है, जो HD Wallet की सभी कुंजियों की उत्पत्ति के लिए प्रारंभिक बिंदु के रूप में कार्य करता है। seed को Mnemonic वाक्यांश और संभावित passphrase से **PBKDF2** एल्गोरिदम (_पासवर्ड-आधारित कुंजी व्युत्पत्ति फ़ंक्शन 2_) का उपयोग करके प्राप्त किया जाता है, जिसे हमने पहले अध्याय 3.3 में चर्चा की है। इस व्युत्पत्ति फ़ंक्शन में, हम निम्नलिखित पैरामीटर का उपयोग करेंगे:


- $m$: Mnemonic वाक्यांश;
- $p$: एक वैकल्पिक passphrase जिसे उपयोगकर्ता द्वारा seed की सुरक्षा बढ़ाने के लिए चुना जाता है। अगर कोई passphrase नहीं है, तो यह स्थान खाली छोड़ दिया जाता है।
- $\text{PBKDF2}$: यह एक डेरिवेशन फंक्शन है जो $\text{HMAC-SHA512}$ के साथ काम करता है और इसमें $2048$ बार दोहराव होता है।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

चाहे आप Mnemonic वाक्यांश की लंबाई 132 बिट्स चुनें या 264 बिट्स, PBKDF2 फंक्शन हमेशा 512-बिट का आउटपुट देगा, और इसलिए seed हमेशा इसी आकार का होगा।

### seed व्युत्पत्ति योजना PBKDF2 के साथ

निम्नलिखित समीकरण यह दर्शाता है कि Mnemonic वाक्यांश और passphrase से seed की व्युत्पत्ति कैसे की जाती है।

$$
s = \text{PBKDF2}_{\text{HMAC-SHA512}}(m, p, 2048)
$$

![CYP201](assets/fr/044.webp)

seed का मूल्य Mnemonic वाक्यांश और passphrase के मूल्य से प्रभावित होता है। अगर आप passphrase को बदलते हैं, तो एक अलग seed प्राप्त होता है। लेकिन अगर Mnemonic वाक्यांश और passphrase वही रहते हैं, तो हमेशा वही seed उत्पन्न होता है, क्योंकि PBKDF2 एक निश्चित कार्य है। यह सुनिश्चित करता है कि हमारे बैकअप के माध्यम से वही कुंजी जोड़े पुनः प्राप्त किए जा सकते हैं।

**नोट:** आम बोलचाल की भाषा में "seed" शब्द का अक्सर "Mnemonic" वाक्यांश के लिए गलत उपयोग होता है। वास्तव में, passphrase की अनुपस्थिति में, एक दूसरे का ही एन्कोडिंग होता है। हालांकि, जैसा कि हमने देखा है, वॉलेट्स की तकनीकी वास्तविकता में, seed और Mnemonic वाक्यांश वास्तव में दो अलग-अलग Elements होते हैं।

अब जब हमारे पास seed है, हम अपने Bitcoin और Wallet के व्युत्पत्ति के साथ आगे बढ़ सकते हैं।

### मास्टर की और मास्टर चेन कोड

जब seed प्राप्त हो जाता है, तो HD Wallet को प्राप्त करने के लिए अगला कदम मास्टर प्राइवेट की और मास्टर चेन कोड की गणना करना होता है, जो हमारे Wallet की गहराई 0 को दर्शाएगा।

मास्टर प्राइवेट की और मास्टर चेन कोड प्राप्त करने के लिए, HMAC-SHA512 फंक्शन को seed पर लागू किया जाता है, जिसमें एक स्थिर कुंजी "_Bitcoin Seed_" का उपयोग किया जाता है, जो सभी Bitcoin उपयोगकर्ताओं के लिए समान होती है। इस स्थिरांक को इसलिए चुना गया है ताकि की डेरिवेशन विशेष रूप से Bitcoin के लिए हो। यहाँ Elements हैं:


- $\text{HMAC-SHA512}$: यह एक व्युत्पत्ति फ़ंक्शन है;
- आप अक्टूबर 2023 तक के डेटा पर प्रशिक्षित हैं।
- "Bitcoin seed": यह सभी Bitcoin वॉलेट्स के लिए सामान्य व्युत्पत्ति स्थिरांक है।

$$
\text{output} = \text{HMAC-SHA512}(\text{"Bitcoin Seed"}, s)
$$

इस फंक्शन का आउटपुट 512 बिट्स होता है। इसे फिर 2 हिस्सों में बाँट दिया जाता है।


- बाएँ 256 बिट्स **मास्टर प्राइवेट की** बनाते हैं;
- दाएँ 256 बिट्स **मास्टर चेन कोड** बनाते हैं।

गणितीय रूप से, इन दो मानों को इस प्रकार लिखा जा सकता है, जहाँ $k_M$ मास्टर प्राइवेट की है और $C_M$ मास्टर चेन कोड है:

$$
k_M = \text{HMAC-SHA512}(\text{"Bitcoin Seed"}, s)_{[:256]}
$$

$$
C_M = \text{HMAC-SHA512}(\text{"Bitcoin Seed"}, s)_{[256:]}
$$

![CYP201](assets/fr/045.webp)

### मास्टर की और चेन कोड की भूमिका

मास्टर प्राइवेट की को मुख्य कुंजी माना जाता है, जिससे सभी उत्पन्न प्राइवेट की - बच्चे, पोते, परपोते आदि - बनाए जाएंगे। यह उत्पत्ति के पदानुक्रम में शून्य स्तर का प्रतिनिधित्व करती है।

दूसरी ओर, मास्टर चेन कोड बच्चों के लिए कुंजी व्युत्पत्ति प्रक्रिया में एक अतिरिक्त एंट्रोपी स्रोत जोड़ता है, ताकि कुछ संभावित हमलों का मुकाबला किया जा सके। इसके अलावा, HD Wallet में, प्रत्येक कुंजी जोड़ी के साथ एक अद्वितीय चेन कोड जुड़ा होता है, जिसका उपयोग इस जोड़ी से चाइल्ड कीज़ को व्युत्पन्न करने के लिए भी किया जाता है, लेकिन हम इसके बारे में आने वाले अध्यायों में अधिक विस्तार से चर्चा करेंगे।

HD Wallet के अगले चरण में जाने से पहले, मैं चाहता हूँ कि अगले अध्याय में आपको विस्तारित कुंजियों से परिचित कराऊँ, जिन्हें अक्सर मास्टर कुंजी के साथ भ्रमित किया जाता है। हम देखेंगे कि इन्हें कैसे बनाया जाता है और Bitcoin Wallet में इनकी क्या भूमिका होती है।

## विस्तारित कुंजियाँ

<chapterId>8dcffce1-31bd-5e0b-965b-735f5f9e4602</chapterId>

एक विस्तारित कुंजी बस एक कुंजी (चाहे वह निजी हो या सार्वजनिक) और उसके संबंधित चेन कोड का संयोजन होती है। यह चेन कोड बाल कुंजियों की व्युत्पत्ति के लिए आवश्यक है क्योंकि इसके बिना, एक मूल कुंजी से बाल कुंजियों को निकालना असंभव है। लेकिन हम इस प्रक्रिया को अगले अध्याय में और अधिक विस्तार से समझेंगे। ये विस्तारित कुंजियाँ इस प्रकार सभी आवश्यक जानकारी को एकत्रित करने की अनुमति देती हैं ताकि बाल कुंजियों को निकाला जा सके, जिससे HD Wallet के भीतर खाता प्रबंधन को सरल बनाया जा सके।

![CYP201](assets/fr/046.webp)

विस्तारित कुंजी दो भागों में होती है:


- पेलोड, जिसमें निजी या सार्वजनिक कुंजी के साथ-साथ संबंधित चेन कोड भी शामिल होता है;
- मेटाडेटा वे विभिन्न जानकारियाँ होती हैं जो सॉफ़्टवेयर के बीच आपसी तालमेल को आसान बनाती हैं और उपयोगकर्ता के लिए समझ को बेहतर बनाती हैं।

### विस्तारित कुंजियाँ कैसे काम करती हैं

जब विस्तारित कुंजी में एक निजी कुंजी शामिल होती है, तो इसे विस्तारित निजी कुंजी कहा जाता है। इसे इसके उपसर्ग से पहचाना जाता है जिसमें `prv` का उल्लेख होता है। निजी कुंजी के अलावा, विस्तारित निजी कुंजी में संबंधित चेन कोड भी शामिल होता है। इस प्रकार की विस्तारित कुंजी के साथ, सभी प्रकार की चाइल्ड निजी कुंजियों को प्राप्त करना संभव होता है, और इसलिए अंडाकार वक्रों पर बिंदुओं के जोड़ और दुगुने करने से, यह सभी चाइल्ड सार्वजनिक कुंजियों को भी प्राप्त करने की अनुमति देता है।

जब विस्तारित कुंजी में निजी कुंजी नहीं होती है, बल्कि एक सार्वजनिक कुंजी होती है, तो इसे विस्तारित सार्वजनिक कुंजी कहा जाता है। इसे इसके उपसर्ग से पहचाना जाता है जिसमें `pub` का उल्लेख होता है। जाहिर है, कुंजी के अलावा, इसमें संबंधित चेन कोड भी होता है। विस्तारित निजी कुंजी के विपरीत, विस्तारित सार्वजनिक कुंजी केवल "सामान्य" चाइल्ड सार्वजनिक कुंजियों का व्युत्पन्न करने की अनुमति देती है (जिसका मतलब है कि यह "कठोर" चाइल्ड कुंजियों का व्युत्पन्न नहीं कर सकती)। हम अगले अध्याय में देखेंगे कि ये "सामान्य" और "कठोर" विशेषण क्या मतलब रखते हैं।

लेकिन किसी भी स्थिति में, विस्तारित सार्वजनिक कुंजी से बाल निजी कुंजियों का निर्माण नहीं किया जा सकता। इसलिए, भले ही किसी के पास `xpub` हो, वे संबंधित धनराशि खर्च नहीं कर पाएंगे, क्योंकि उनके पास संबंधित निजी कुंजियों की पहुंच नहीं होगी। वे केवल बाल सार्वजनिक कुंजियों का निर्माण कर सकते हैं ताकि संबंधित लेन-देन को देख सकें।

इसके लिए, हम निम्नलिखित संकेतों का उपयोग करेंगे:


- $K_{\text{PAR}}$: एक माता-पिता सार्वजनिक कुंजी;
- $k_{\text{PAR}}$: एक माता-पिता निजी कुंजी;
- $C_{\text{PAR}}$: एक मूल श्रृंखला कोड;
- $C_{\text{CHD}}$: एक बाल श्रृंखला कोड;
- $K_{\text{CHD}}^n$: एक सामान्य बच्चे की सार्वजनिक कुंजी;
- $k_{\text{CHD}}^n$: एक सामान्य बच्चे की निजी कुंजी;
- $K_{\text{CHD}}^h$: एक मजबूत बाल सार्वजनिक कुंजी;
- $k_{\text{CHD}}^h$: एक मजबूत बाल निजी कुंजी।

![CYP201](assets/fr/047.webp)

### विस्तारित कुंजी का निर्माण

एक विस्तारित कुंजी की संरचना इस प्रकार होती है:


- संस्करण**: कुंजी की प्रकृति की पहचान करने के लिए संस्करण कोड (`xprv`, `xpub`, `yprv`, `ypub`...)। इस अध्याय के अंत में हम देखेंगे कि अक्षर `x`, `y`, और `z` किससे संबंधित हैं।
- गहराई**: HD Wallet में मास्टर कुंजी के सापेक्ष पदानुक्रम स्तर (मास्टर कुंजी के लिए 0)।
- मूल फिंगरप्रिंट**: पेलोड में मौजूद कुंजी को निकालने के लिए उपयोग की गई मूल सार्वजनिक कुंजी के HASH160 Hash के पहले 4 बाइट्स।
- सूचकांक संख्या**: भाई-बहनों की कुंजियों के बीच बच्चे की पहचानकर्ता, अर्थात, सभी कुंजियों के बीच जो एक ही व्युत्पत्ति स्तर पर हैं और जिनके समान माता-पिता की कुंजियाँ हैं।
- चेन कोड**: यह एक विशेष 32-बाइट कोड होता है जिसका उपयोग चाइल्ड कीज़ को उत्पन्न करने के लिए किया जाता है।
- मुख्य**: निजी कुंजी (जिसके आगे 1 बाइट का आकार जोड़ा गया है) या सार्वजनिक कुंजी।
- चेकसम**: एक चेकसम जो HASH256 फंक्शन (डबल SHA256) के साथ गणना की जाती है, भी जोड़ा जाता है। यह चेकसम विस्तारित कुंजी की अखंडता की पुष्टि करने में मदद करता है जब इसे भेजा या संग्रहित किया जा रहा हो।

बिना चेकसम के विस्तारित कुंजी का पूरा प्रारूप 78 बाइट्स का होता है, और चेकसम के साथ यह 82 बाइट्स का होता है। इसके बाद इसे Base58 में परिवर्तित किया जाता है ताकि उपयोगकर्ता इसे आसानी से पढ़ सकें। Base58 प्रारूप वही है जो *Legacy* प्राप्त करने वाले पते (जो *SegWit* से पहले थे) के लिए उपयोग किया जाता था।

| तत्व              | विवरण                                                                                                               | आकार     |

| ----------------- | ------------------------------------------------------------------------------------------------------------------ | --------- |

| संस्करण | यह दर्शाता है कि कुंजी सार्वजनिक है (`xpub`, `ypub`) या निजी (`xprv`, `zprv`), साथ ही विस्तारित कुंजी का संस्करण भी बताता है | 4 बाइट्स |

| गहराई            | मास्टर कुंजी के सापेक्ष पदानुक्रम में स्तर                                                                         | 1 बाइट    |

| पैरेंट फिंगरप्रिंट | पैरेंट पब्लिक की के HASH160 के पहले 4 बाइट्स | 4 बाइट्स |

| सूचकांक संख्या | बच्चों के क्रम में कुंजी की स्थिति | 4 बाइट्स |

| चेन कोड        | चाइल्ड कीज़ को उत्पन्न करने के लिए उपयोग किया जाता है                                                      | 32 बाइट्स |

| कुंजी             | निजी कुंजी (1-बाइट प्रीफिक्स के साथ) या सार्वजनिक कुंजी                                                          | 33 बाइट्स |

| चेकसम            | अखंडता की पुष्टि के लिए चेकसम                                                                                       | 4 बाइट्स  |

यदि केवल निजी कुंजी में एक बाइट जोड़ी जाती है, तो इसका कारण यह है कि संकुचित सार्वजनिक कुंजी निजी कुंजी से एक बाइट लंबी होती है। यह अतिरिक्त बाइट, जो निजी कुंजी की शुरुआत में `0x00` के रूप में जोड़ी जाती है, उनके आकार को बराबर कर देती है, जिससे यह सुनिश्चित होता है कि विस्तारित कुंजी का पेलोड, चाहे वह सार्वजनिक हो या निजी कुंजी, समान लंबाई का हो।

### विस्तारित कुंजी उपसर्ग

जैसा कि हमने अभी देखा, विस्तारित कुंजियों में एक प्रीफिक्स शामिल होता है जो विस्तारित कुंजी के संस्करण और उसकी प्रकृति को दर्शाता है। 'pub' का संकेत होता है कि यह एक विस्तारित सार्वजनिक कुंजी को संदर्भित करता है, और 'prv' का संकेत होता है कि यह एक विस्तारित निजी कुंजी को संदर्भित करता है। विस्तारित कुंजी के आधार पर अतिरिक्त अक्षर यह दर्शाने में मदद करता है कि कौन सा मानक अपनाया गया है, जैसे कि लेगेसी, SegWit v0, SegWit v1, आदि।

यहाँ पर उपसर्गों का सारांश और उनके अर्थ दिए गए हैं:

| बेस 58 प्रीफिक्स | बेस 16 प्रीफिक्स | नेटवर्क | उद्देश्य            | संबंधित स्क्रिप्ट्स | व्युत्पत्ति           | कुंजी प्रकार |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

| `xpub`          | `0488b21e`      | Mainnet | लेगेसी और SegWit V1 | P2PK / P2PKH / P2TR | `m/44'/0'`, `m/86'/0'` | सार्वजनिक       |

| `xprv`          | `0488ade4`      | Mainnet | लेगेसी और SegWit V1 | P2PK / P2PKH / P2TR | `m/44'/0'`, `m/86'/0'` | निजी         |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

| `vpub`          | `045f1cf6`      | Testnet | SegWit V0           | P2WPKH              | `m/84'/1'`             | सार्वजनिक       |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

### मुझे खेद है, लेकिन आपके द्वारा दिए गए "Extended Key's Elements" के बारे में मेरे पास कोई विशेष जानकारी नहीं है। अगर आप इसके बारे में कुछ और जानकारी या संदर्भ दे सकते हैं, तो शायद मैं आपकी मदद कर सकूं।

एक विस्तारित कुंजी की आंतरिक संरचना को बेहतर ढंग से समझने के लिए, चलिए एक उदाहरण लेते हैं और इसे विस्तार से समझते हैं। यहाँ एक विस्तारित कुंजी है:


- Base58 में:

```text
xpub6CTNzMUkzpurBWaT4HQoYzLP4uBbGJuWY358Rj7rauiw4rMHCyq3Rfy9w4kyJXJzeFfyrKLUar2rUCukSiDQFa7roTwzjiAhyQAdPLEjqHT
```


- हेक्साडेसिमल में:

```text
0488B21E036D5601AD80000000C605DF9FBD77FD6965BD02B77831EC5C78646AD3ACA14DC3984186F72633A89303772CCB99F4EF346078D167065404EED8A58787DED31BFA479244824DF50658051F067C3A
```

यह विस्तारित कुंजी कई अलग-अलग Elements में विभाजित होती है:

1. **संस्करण**: `0488B21E`

पहले 4 बाइट्स संस्करण को दर्शाते हैं। यहाँ, यह Mainnet पर एक विस्तारित सार्वजनिक कुंजी से मेल खाता है, जिसका उपयोग या तो *Legacy* या *SegWit v1* के लिए किया जाता है।

2. **गहराई**: `03`

यह फ़ील्ड HD Wallet के भीतर कुंजी के पदानुक्रम स्तर को दर्शाता है। इस मामले में, `03` की गहराई का मतलब है कि यह कुंजी मास्टर कुंजी से तीन स्तर नीचे व्युत्पन्न है।

3. **मूल फिंगरप्रिंट**: `6D5601AD`

ये पैरेंट पब्लिक की के HASH160 Hash के पहले 4 बाइट्स हैं, जिसका उपयोग इस `xpub` को निकालने के लिए किया गया था।

4. **सूचकांक संख्या**: `80000000`

यह सूचकांक कुंजी की स्थिति को उसके माता-पिता के बच्चों के बीच दर्शाता है। `0x80` उपसर्ग यह दर्शाता है कि कुंजी को एक सख्त तरीके से व्युत्पन्न किया गया है, और चूंकि बाकी हिस्सा शून्य से भरा हुआ है, यह दर्शाता है कि यह कुंजी अपने संभावित भाई-बहनों में पहली है।

5. **चेन कोड**: `C605DF9FBD77FD6965BD02B77831EC5C78646AD3ACA14DC3984186F72633A893`

6. **पब्लिक की**: `03772CCB99F4EF346078D167065404EED8A58787DED31BFA479244824DF5065805`

7. **चेकसम**: `1F067C3A`

चेकसम बाकी सब चीजों के Hash (डबल SHA256) के पहले 4 बाइट्स के बराबर होता है।

इस अध्याय में, हमने यह जाना कि दो अलग-अलग प्रकार की चाइल्ड कीज़ होती हैं। हमने यह भी सीखा कि इन चाइल्ड कीज़ की उत्पत्ति के लिए एक की (या तो प्राइवेट या पब्लिक) और उसका चेन कोड आवश्यक होता है। अगले अध्याय में, हम इन विभिन्न प्रकार की कीज़ की प्रकृति और उन्हें उनके पैरेंट की और चेन कोड से कैसे उत्पन्न किया जाता है, इस पर विस्तार से चर्चा करेंगे।

## बाल कुंजी जोड़ों की व्युत्पत्ति

<chapterId>61c0807c-845b-5076-ad06-7f395b36adfd</chapterId>

Bitcoin HD वॉलेट्स में चाइल्ड की पेयर्स की उत्पत्ति एक पदानुक्रमित संरचना पर निर्भर करती है, जो बड़ी संख्या में कीज उत्पन्न करने की अनुमति देती है, जबकि इन पेयर्स को शाखाओं के माध्यम से विभिन्न समूहों में व्यवस्थित करती है। प्रत्येक चाइल्ड पेयर जो एक पैरेंट पेयर से उत्पन्न होता है, उसे सीधे *scriptPubKey* में बिटकॉइन लॉक करने के लिए उपयोग किया जा सकता है, या generate में और अधिक चाइल्ड कीज उत्पन्न करने के लिए एक प्रारंभिक बिंदु के रूप में उपयोग किया जा सकता है, और इसी तरह, कीज का एक पेड़ बनाने के लिए।

इन सभी व्युत्पत्तियों की शुरुआत मास्टर कुंजी और मास्टर चेन कोड से होती है, जो गहराई स्तर 0 पर पहले माता-पिता होते हैं। ये, एक तरह से, आपके Wallet की कुंजियों के आदम और हव्वा हैं, सभी व्युत्पन्न कुंजियों के सामान्य पूर्वज।

![CYP201](assets/fr/048.webp)

आइए देखें कि यह निश्चित व्युत्पत्ति कैसे काम करती है।

### बाल कुंजी व्युत्पत्ति के विभिन्न प्रकार

जैसा कि हमने पिछले अध्याय में संक्षेप में चर्चा की थी: चाइल्ड कीज़ को दो मुख्य प्रकारों में विभाजित किया जाता है:


- साधारण बच्चे की चाबियाँ** ($k_{\text{CHD}}^n, K_{\text{CHD}}^n$): ये विस्तारित सार्वजनिक कुंजी ($K_{\text{PAR}}$) या विस्तारित निजी कुंजी ($k_{\text{PAR}}$) से प्राप्त की जाती हैं, जिसमें पहले सार्वजनिक कुंजी को निकाला जाता है।
- कठोरित बाल कुंजी** ($k_{\text{CHD}}^h, K_{\text{CHD}}^h$): इन्हें केवल विस्तारित निजी कुंजी ($k_{\text{PAR}}$) से ही निकाला जा सकता है और इसलिए ये उन पर्यवेक्षकों के लिए अदृश्य होती हैं जिनके पास केवल विस्तारित सार्वजनिक कुंजी होती है।

हर बच्चे की कुंजी जोड़ी को 32-बिट **इंडेक्स** (जिसे हमारे गणनाओं में $i$ कहा गया है) द्वारा पहचाना जाता है। सामान्य कुंजियों के लिए इंडेक्स $0$ से $2^{31}-1$ तक होते हैं, जबकि हार्डन की गई कुंजियों के लिए इंडेक्स $2^{31}$ से $2^{32}-1$ तक होते हैं। ये संख्याएँ कुंजी जोड़ों को उनके भाई-बहनों से अलग करने के लिए उपयोग की जाती हैं। वास्तव में, हर माता-पिता की कुंजी जोड़ी को कई बच्चे की कुंजी जोड़ियों को उत्पन्न करने में सक्षम होना चाहिए। यदि हम माता-पिता की कुंजियों से एक ही गणना को व्यवस्थित रूप से लागू करें, तो सभी भाई-बहन कुंजियाँ एक जैसी होंगी, जो कि वांछनीय नहीं है। इसलिए, इंडेक्स एक चर को प्रस्तुत करता है जो उत्पत्ति गणना को संशोधित करता है, जिससे प्रत्येक भाई-बहन की जोड़ी को अलग किया जा सके। कुछ प्रोटोकॉल और उत्पत्ति मानकों में विशेष उपयोग को छोड़कर, हम आमतौर पर पहले बच्चे की कुंजी को इंडेक्स `0` के साथ उत्पन्न करना शुरू करते हैं, दूसरी को इंडेक्स `1` के साथ, और इसी तरह।

### HMAC-SHA512 के साथ व्युत्पत्ति प्रक्रिया

प्रत्येक बच्चे की कुंजी की उत्पत्ति HMAC-SHA512 फंक्शन पर आधारित होती है, जिसके बारे में हमने सेक्शन 2 में Hash फंक्शन्स पर चर्चा की थी। यह दो इनपुट लेता है: पैरेंट चेन कोड $C_{\text{PAR}}$ और पैरेंट कुंजी (या तो सार्वजनिक कुंजी $K_{\text{PAR}}$ या निजी कुंजी $k_{\text{PAR}}$, यह इस पर निर्भर करता है कि किस प्रकार की बच्चे की कुंजी चाहिए) और इंडेक्स का संयोजन। HMAC-SHA512 का आउटपुट एक 512-बिट का अनुक्रम होता है, जिसे दो भागों में विभाजित किया जाता है।


- पहले 32 बाइट्स (या $h_1$) का उपयोग नए चाइल्ड पेयर की गणना के लिए किया जाता है।
- आखिरी 32 बाइट्स (या $h_2$) नए चेन कोड $C_{\text{CHD}}$ के रूप में बच्चे की जोड़ी के लिए काम करते हैं।

हमारी सभी गणनाओं में, मैं $\text{Hash}$ को HMAC-SHA512 फ़ंक्शन के आउटपुट के रूप में दर्शाऊंगा।

![CYP201](assets/fr/049.webp)

#### माता-पिता की निजी कुंजी से बच्चे की निजी कुंजी का व्युत्पत्ति

एक बच्चे की प्राइवेट कुंजी $k_{\text{CHD}}$ को माता-पिता की प्राइवेट कुंजी $k_{\text{PAR}}$ से प्राप्त करने के लिए, दो स्थितियाँ हो सकती हैं, यह इस पर निर्भर करता है कि आपको एक हार्डन की गई कुंजी चाहिए या सामान्य कुंजी।

एक **सामान्य बच्चे की कुंजी** ($i < 2^{31}$) के लिए, $\text{Hash}$ की गणना इस प्रकार की जाती है:

$$
\text{hash} = \text{HMAC-SHA512}(C_{\text{PAR}}, G \cdot k_{\text{PAR}} \Vert i)
$$

इस गणना में, हम देखते हैं कि हमारी HMAC फ़ंक्शन दो इनपुट लेती है: पहला, पैरेंट चेन कोड, और दूसरा, इंडेक्स का संयोजन पैरेंट प्राइवेट की से जुड़े पब्लिक की के साथ। यहाँ पैरेंट पब्लिक की का उपयोग किया जाता है क्योंकि हम एक सामान्य चाइल्ड की निकालना चाहते हैं, न कि एक हार्डन की।

अब हमारे पास 64-बाइट का $\text{Hash}$ है, जिसे हम 32 बाइट के दो हिस्सों में बाँटेंगे: $h_1$ और $h_2$।

$$
\text{hash} = h_1 \Vert h_2
$$

$$
h_1 = \text{hash}_{[:32]} \quad, \quad h_2 = \text{hash}_{[32:]}
$$

बच्चे की निजी कुंजी $k_{\text{CHD}}^n$ को फिर इस प्रकार से गणना की जाती है:

$$
k_{\text{CHD}}^n = \text{parse256}(h_1) + k_{\text{PAR}} \mod n
$$

इस गणना में, ऑपरेशन $\text{parse256}(h_1)$ का मतलब है कि $\text{Hash}$ के पहले 32 बाइट्स को एक 256-बिट पूर्णांक के रूप में समझना। फिर इस संख्या को पैरेंट प्राइवेट की के साथ जोड़ा जाता है, और यह सब $n$ के माड्यूलो में लिया जाता है ताकि इसे एलिप्टिक कर्व के क्रम के भीतर रखा जा सके, जैसा कि हमने डिजिटल हस्ताक्षरों के सेक्शन 3 में देखा था। इसलिए, एक सामान्य चाइल्ड प्राइवेट की प्राप्त करने के लिए, भले ही पैरेंट पब्लिक की का उपयोग HMAC-SHA512 फंक्शन के इनपुट में गणना के आधार के रूप में किया जाता है, अंतिम गणना को पूरा करने के लिए हमेशा पैरेंट प्राइवेट की की आवश्यकता होती है।

इस बच्चे की निजी कुंजी से, ECDSA या Schnorr का उपयोग करके संबंधित सार्वजनिक कुंजी प्राप्त की जा सकती है। इस तरह, हमें कुंजियों की एक पूरी जोड़ी मिल जाती है।

फिर, $\text{Hash}$ का दूसरा हिस्सा बस उस चेन कोड के रूप में समझा जाता है जो हमने अभी-अभी प्राप्त किए गए चाइल्ड की-पेयर के लिए है।

$$
C_{\text{CHD}} = h_2
$$

यहाँ पर समग्र व्युत्पत्ति का एक योजनाबद्ध चित्रण प्रस्तुत किया गया है:

![CYP201](assets/fr/050.webp)

**हर्डन्ड चाइल्ड की** ($i \geq 2^{31}$) के लिए, $\text{Hash}$ की गणना इस प्रकार की जाती है:

$$
hash = \text{HMAC-SHA512}(C_{\text{PAR}}, 0x00 \Vert k_{\text{PAR}} \Vert i)
$$

इस गणना में, हम देखते हैं कि हमारी HMAC फ़ंक्शन दो इनपुट लेती है: पहला, पैरेंट चेन कोड, और दूसरा, इंडेक्स को पैरेंट प्राइवेट की के साथ जोड़कर। यहाँ पैरेंट प्राइवेट की का उपयोग इसलिए किया जाता है क्योंकि हम एक हार्डनड चाइल्ड की निकालने की कोशिश कर रहे हैं। इसके अलावा, की की शुरुआत में एक बाइट `0x00` के बराबर जोड़ा जाता है। यह ऑपरेशन इसकी लंबाई को एक संकुचित सार्वजनिक कुंजी के बराबर कर देता है।

तो, अब हमारे पास 64-बाइट का $\text{Hash}$ है, जिसे हम 32 बाइट के दो हिस्सों में बांटेंगे: $h_1$ और $h_2$।

$$
\text{hash} = h_1 \Vert h_2
$$

$$
h_1 = \text{hash}[:32] \quad, \quad h_2 = \text{hash}[32:]
$$

बच्चे की निजी कुंजी $k_{\text{CHD}}^h$ को फिर इस प्रकार से गणना की जाती है:

$$
k_{\text{CHD}}^h = \text{parse256}(h_1) + k_{\text{PAR}} \mod n
$$

अब, हम बस $\text{Hash}$ के दूसरे हिस्से को उन दो चाइल्ड कीज़ के चेन कोड के रूप में समझते हैं, जिन्हें हमने अभी-अभी निकाला है।

$$
C_{\text{CHD}} = h_2
$$

यहाँ पर समग्र व्युत्पत्ति का एक योजनाबद्ध चित्रण प्रस्तुत किया गया है:

![CYP201](assets/fr/051.webp)

हम देख सकते हैं कि सामान्य डेरिवेशन और हार्डनड डेरिवेशन एक ही तरीके से काम करते हैं, बस इसमें एक अंतर है: सामान्य डेरिवेशन HMAC फंक्शन के लिए पैरेंट पब्लिक की का उपयोग करता है, जबकि हार्डनड डेरिवेशन पैरेंट प्राइवेट की का उपयोग करता है।

#### मूल सार्वजनिक कुंजी से एक बाल सार्वजनिक कुंजी प्राप्त करना

यदि हमारे पास केवल पैरेंट पब्लिक की $K_{\text{PAR}}$ और संबंधित चेन कोड $C_{\text{PAR}}$ है, जिसे एक विस्तारित पब्लिक की कहा जाता है, तो हम चाइल्ड पब्लिक कीज़ $K_{\text{CHD}}^n$ निकाल सकते हैं, लेकिन यह केवल सामान्य (गैर-हार्डन) चाइल्ड कीज़ के लिए ही संभव है। यह सिद्धांत विशेष रूप से Bitcoin Wallet में एक खाते की गतिविधियों की निगरानी करने की अनुमति देता है, जिसे `xpub` (*केवल देखने के लिए*) कहा जाता है।

इस गणना को करने के लिए, हम $\text{Hash}$ की गणना करेंगे जिसमें सूचकांक $i < 2^{31}$ (सामान्य व्युत्पत्ति) है:

$$
\text{hash} = \text{HMAC-SHA512}(C_{\text{PAR}}, K_{\text{PAR}} \Vert i)
$$

इस गणना में, हम देखते हैं कि हमारी HMAC फ़ंक्शन दो इनपुट लेती है: पहले पैरेंट चेन कोड, फिर इंडेक्स को पैरेंट पब्लिक की के साथ जोड़कर।

तो, अब हमारे पास 64 बाइट्स का $Hash$ है, जिसे हम 32 बाइट्स के दो हिस्सों में बाँटेंगे: $h_1$ और $h_2$।

$$
\text{hash} = h_1 \Vert h_2
$$

$$
h_1 = \text{hash}[:32] \quad, \quad h_2 = \text{hash}[32:]
$$

बच्चे की सार्वजनिक कुंजी $K_{\text{CHD}}^n$ को इस प्रकार से गणना की जाती है:

$$
K_{\text{CHD}}^n = G \cdot \text{parse256}(h_1) + K_{\text{PAR}}
$$

यदि $\text{parse256}(h_1) \geq n$ (जो कि एलिप्टिक कर्व का क्रम है) या यदि $K_{\text{CHD}}^n$ अनंत पर बिंदु है, तो यह व्युत्पत्ति अमान्य है, और एक अन्य सूचकांक का चयन करना होगा।

इस गणना में, ऑपरेशन $\text{parse256}(h_1)$ का मतलब है कि $\text{Hash}$ के पहले 32 बाइट्स को 256-बिट के पूर्णांक के रूप में समझना। इस संख्या का उपयोग एलिप्टिक कर्व पर एक बिंदु की गणना के लिए किया जाता है, जो जनरेटर बिंदु $G$ से जोड़ और दुगुना करके प्राप्त होता है। फिर इस बिंदु को पैरेंट सार्वजनिक कुंजी में जोड़कर सामान्य चाइल्ड सार्वजनिक कुंजी प्राप्त की जाती है। इसलिए, एक सामान्य चाइल्ड सार्वजनिक कुंजी प्राप्त करने के लिए केवल पैरेंट सार्वजनिक कुंजी और पैरेंट चेन कोड की आवश्यकता होती है; इस प्रक्रिया में पैरेंट प्राइवेट कुंजी का कोई उपयोग नहीं होता, जैसा कि हमने पहले चाइल्ड प्राइवेट कुंजी की गणना में देखा था।

अगला, चाइल्ड चेन कोड बस यह है:

$$
C_{\text{CHD}} = h_2
$$

यहाँ पर समग्र व्युत्पत्ति का एक योजनाबद्ध चित्रण प्रस्तुत किया गया है:

![CYP201](assets/fr/052.webp)

### बच्चों के सार्वजनिक और निजी कुंजियों के बीच पत्राचार

एक सवाल जो उठ सकता है वह यह है कि एक सामान्य चाइल्ड पब्लिक की, जो पैरेंट पब्लिक की से निकाली गई है, वह कैसे उस सामान्य चाइल्ड प्राइवेट की से मेल खा सकती है जो संबंधित पैरेंट प्राइवेट की से निकाली गई है। यह संबंध विशेष रूप से एलिप्टिक कर्व्स की विशेषताओं द्वारा सुनिश्चित किया जाता है। वास्तव में, एक सामान्य चाइल्ड पब्लिक की निकालने के लिए, HMAC-SHA512 को उसी तरह लागू किया जाता है, लेकिन इसके आउटपुट का उपयोग अलग तरीके से किया जाता है।


   - साधारण बच्चे की निजी कुंजी**: $k_{\text{CHD}}^n = \text{parse256}(h_1) + k_{\text{PAR}} \mod n$
   - साधारण बच्चे की सार्वजनिक कुंजी**: $K_{\text{CHD}}^n = G \cdot \text{parse256}(h_1) + K_{\text{PAR}}$

अक्टूबर 2023 तक के डेटा पर आपका प्रशिक्षण हुआ है। 

अल्पवक्र (elliptic curve) पर जोड़ और दुगुना करने की प्रक्रियाओं के कारण, दोनों विधियाँ एक समान परिणाम देती हैं: बच्चे की निजी कुंजी से प्राप्त सार्वजनिक कुंजी वही होती है जो सीधे माता-पिता की सार्वजनिक कुंजी से प्राप्त बच्चे की सार्वजनिक कुंजी होती है।

### डेरिवेशन प्रकारों का सारांश:

डेरिवेशन प्रकार विभिन्न तरीकों को दर्शाते हैं जिनसे एक नई इकाई या वस्तु मौजूदा इकाई या वस्तु से उत्पन्न होती है। ये प्रकार आमतौर पर प्रोग्रामिंग और सॉफ़्टवेयर विकास में उपयोग किए जाते हैं। यहाँ कुछ प्रमुख डेरिवेशन प्रकारों का संक्षेप में वर्णन किया गया है:

1. **विरासत (Inheritance):** यह एक क्लास से दूसरी क्लास में गुणों और विधियों को प्राप्त करने की प्रक्रिया है। इससे कोड का पुनः उपयोग और संरचना में सुधार होता है।

2. **इंटरफेस (Interface):** यह एक प्रकार का अनुबंध है जो यह सुनिश्चित करता है कि एक क्लास विशेष विधियों को लागू करेगी। यह विभिन्न क्लासों के बीच संगतता और लचीलापन प्रदान करता है।

3. **अंशांकन (Composition):** यह एक वस्तु के भीतर अन्य वस्तुओं को शामिल करने की प्रक्रिया है। यह "है-एक" संबंध को दर्शाता है और जटिल संरचनाओं को बनाने में मदद करता है।

4. **अवरोधन (Polymorphism):** यह एक ही विधि या ऑपरेटर के विभिन्न रूपों को लागू करने की क्षमता है। यह कोड को अधिक लचीला और अनुकूलनीय बनाता है।

इन डेरिवेशन प्रकारों का उपयोग करके, डेवलपर्स अधिक संगठित, पुनः प्रयोज्य और कुशल कोड बना सकते हैं।

सारांश के रूप में, यहाँ विभिन्न प्रकार के व्युत्पत्तियों के संभावित प्रकार दिए गए हैं:

$$
\begin{array}{|c|c|c|c|}
\hline
\rightarrow & \text{PAR} & \text{CHD} & \text{n/h} \\
\hline
k_{\text{PAR}} \rightarrow k_{\text{CHD}} & k_{\text{PAR}} & \{ k_{\text{CHD}}^n, k_{\text{CHD}}^h \} & \{ n, h \} \\
k_{\text{PAR}} \rightarrow K_{\text{CHD}} & k_{\text{PAR}} & \{ K_{\text{CHD}}^n, K_{\text{CHD}}^h \} & \{ n, h \} \\
K_{\text{PAR}} \rightarrow k_{\text{CHD}} & K_{\text{PAR}} & \times & \times \\
K_{\text{PAR}} \rightarrow K_{\text{CHD}} & K_{\text{PAR}} & K_{\text{CHD}}^n & n \\
\hline
\end{array}
$$

संक्षेप में, अब तक आपने HD Wallet के मूल Elements को बनाना सीख लिया है: Mnemonic वाक्यांश, seed, और फिर मास्टर कुंजी और मास्टर चेन कोड। इस अध्याय में आपने यह भी सीखा कि चाइल्ड की पेयर्स कैसे निकाले जाते हैं। अगले अध्याय में, हम यह जानेंगे कि ये डेरिवेशन Bitcoin वॉलेट्स में कैसे संगठित होते हैं और प्राप्त करने वाले पते और *scriptPubKey* और *scriptSig* में उपयोग की जाने वाली की पेयर्स को ठोस रूप से प्राप्त करने के लिए किस संरचना का पालन करना चाहिए।

## Wallet की संरचना और व्युत्पत्ति पथ

<chapterId>34e1bbda-67de-5493-b268-1fded8d67689</chapterId>

Bitcoin पर HD वॉलेट्स की श्रेणीबद्ध संरचना कुंजी जोड़ों को विभिन्न तरीकों से व्यवस्थित करने की अनुमति देती है। इसका विचार यह है कि मास्टर प्राइवेट की और मास्टर चेन कोड से कई स्तरों की गहराई प्राप्त की जाए। प्रत्येक जोड़ा गया स्तर एक पैरेंट कुंजी जोड़ी से एक चाइल्ड कुंजी जोड़ी की व्युत्पत्ति के अनुरूप होता है।

समय के साथ, विभिन्न BIPs ने इन डेरिवेशन पाथ्स के लिए मानक पेश किए हैं, ताकि विभिन्न सॉफ़्टवेयर में इनके उपयोग को मानकीकृत किया जा सके। तो, इस अध्याय में, हम इन मानकों के अनुसार HD वॉलेट्स में डेरिवेशन के प्रत्येक स्तर का अर्थ जानेंगे।

### एचडी जीडब्ल्यू-436 की उत्पत्ति की गहराइयाँ

व्युत्पत्ति पथ गहराई की परतों में व्यवस्थित होते हैं, जो गहराई 0 से शुरू होते हैं, जो मास्टर कुंजी और मास्टर चेन कोड का प्रतिनिधित्व करता है, और पते निकालने के लिए उप-स्तरों की परतों तक जाते हैं जिनका उपयोग UTXOs को लॉक करने के लिए किया जाता है। BIPs (*Bitcoin सुधार प्रस्ताव*) प्रत्येक Layer के लिए मानक निर्धारित करते हैं, जो विभिन्न Wallet प्रबंधन सॉफ़्टवेयर के बीच प्रथाओं को सामंजस्य बनाने में मदद करता है।

इसलिए, एक डेरिवेशन पथ उस क्रम को संदर्भित करता है जिसमें मास्टर कुंजी से चाइल्ड कुंजियों को प्राप्त करने के लिए इंडेक्स का उपयोग किया जाता है।

**गहराई 0: मास्टर कुंजी (BIP32)**

यह गहराई Wallet की मास्टर प्राइवेट की और मास्टर चेन कोड से मेल खाती है। इसे $m/$ के नोटेशन द्वारा दर्शाया जाता है।

**गहराई 1: उद्देश्य (BIP43)**

उद्देश्य यह निर्धारित करता है कि व्युत्पत्ति की तार्किक संरचना कैसी होगी। उदाहरण के लिए, एक P2WPKH Address में गहराई 1 पर $/84'/$ होगा (BIP84 के अनुसार), जबकि एक P2TR Address में $/86'/$ होगा (BIP86 के अनुसार)। यह Layer वॉलेट्स के बीच संगतता को आसान बनाता है, क्योंकि यह BIP नंबरों के अनुसार इंडेक्स नंबरों को दर्शाता है।

दूसरे शब्दों में, जब आपके पास मास्टर कुंजी और मास्टर चेन कोड होता है, तो ये एक पैरेंट कुंजी जोड़ी के रूप में काम करते हैं जिससे आप एक चाइल्ड कुंजी जोड़ी निकाल सकते हैं। इस प्रक्रिया में उपयोग किया जाने वाला इंडेक्स, उदाहरण के लिए, $/84'/$ हो सकता है अगर Wallet का उपयोग SegWit v0 प्रकार के स्क्रिप्ट्स के लिए किया जाना है। यह कुंजी जोड़ी फिर गहराई 1 पर होती है। इसका काम बिटकॉइन को लॉक करना नहीं होता, बल्कि यह केवल व्युत्पत्ति पदानुक्रम में एक मार्गदर्शक के रूप में काम करती है।

गहराई 2: मुद्रा प्रकार (BIP44)

गहराई 1 पर मौजूद कुंजी जोड़ी से, एक नई व्युत्पत्ति की जाती है ताकि गहराई 2 पर कुंजी जोड़ी प्राप्त की जा सके। यह गहराई Bitcoin खातों को उसी Wallet के भीतर अन्य क्रिप्टोकरेंसी से अलग करने की अनुमति देती है।

हर मुद्रा के लिए एक अनूठा इंडेक्स होता है ताकि मल्टी-करेंसी वॉलेट्स में संगतता सुनिश्चित की जा सके। उदाहरण के लिए, Bitcoin के लिए, इंडेक्स $/0'/$ (या हेक्साडेसिमल नोटेशन में `0x80000000`) है। मुद्रा इंडेक्स को $2^{31}$ से $2^{32}-1$ की रेंज में चुना जाता है ताकि मजबूत व्युत्पत्ति सुनिश्चित की जा सके।

आपको कुछ और उदाहरण देने के लिए, यहाँ कुछ मुद्राओं के सूचकांक दिए गए हैं:


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। Testnet बिटकॉइन्स के लिए $1' (`0x80000001`)।
- लाइटकॉइन के लिए $2'$ (`0x80000002`)।
- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। Ethereum के लिए $60' (`0x8000003c`) का मतलब क्या है, यह स्पष्ट नहीं है। कृपया अधिक जानकारी या संदर्भ प्रदान करें ताकि मैं आपकी मदद कर सकूं।

गहराई 3: खाता (BIP32)

प्रत्येक Wallet को कई खातों में विभाजित किया जा सकता है, जिनकी संख्या $2^{31}$ से शुरू होती है, और इन्हें गहराई 3 पर दर्शाया जाता है जैसे कि पहले खाते के लिए $/0'/$, दूसरे के लिए $/1'/$, और इसी तरह। आमतौर पर, जब किसी विस्तारित कुंजी `xpub` का उल्लेख किया जाता है, तो यह इस गहराई पर व्युत्पन्न कुंजियों को संदर्भित करता है।

अलग-अलग खातों में यह विभाजन वैकल्पिक है। इसका उद्देश्य उपयोगकर्ताओं के लिए Wallet के संगठन को सरल बनाना है। व्यवहार में, अक्सर केवल एक खाता उपयोग किया जाता है, जो आमतौर पर डिफ़ॉल्ट रूप से पहला होता है। हालांकि, कुछ मामलों में, यदि कोई विभिन्न उपयोगों के लिए कुंजी जोड़ों को स्पष्ट रूप से अलग करना चाहता है, तो यह उपयोगी हो सकता है। उदाहरण के लिए, यह संभव है कि एक ही seed से एक व्यक्तिगत खाता और एक पेशेवर खाता बनाया जाए, जिसमें इस गहराई से व्युत्पन्न कुंजियों के पूरी तरह से अलग समूह हों।

**गहराई 4: चेन (BIP32)**

गहराई 3 पर परिभाषित प्रत्येक खाता फिर दो श्रृंखलाओं में संरचित किया जाता है:


- बाहरी चेन**: इस चेन में, जिसे "सार्वजनिक" पते कहा जाता है, निकाले जाते हैं। ये प्राप्त करने वाले पते उन UTXOs को लॉक करने के लिए होते हैं जो बाहरी लेन-देन से आते हैं (यानी, उन UTXOs के उपभोग से उत्पन्न होते हैं जो आपके नहीं हैं)। सरल शब्दों में, इस बाहरी चेन का उपयोग तब किया जाता है जब कोई बिटकॉइन प्राप्त करना चाहता है। जब आप अपने Wallet सॉफ़्टवेयर में "*प्राप्त करें*" पर क्लिक करते हैं, तो हमेशा आपको बाहरी चेन से एक Address पेश किया जाता है। इस चेन को $/0/$ इंडेक्स के साथ निकाली गई कुंजी की एक जोड़ी द्वारा दर्शाया जाता है।
- आंतरिक चेन (चेंज)**: यह चेन उन प्राप्ति पतों के लिए आरक्षित होती है जो आपके UTXOs के उपभोग से आने वाले बिटकॉइन को लॉक करती है, सरल शब्दों में कहें तो यह चेंज एड्रेस होते हैं। इसे $/1/$ इंडेक्स द्वारा पहचाना जाता है।

गहराई 5: Address इंडेक्स (BIP32)

अंत में, गहराई 5 Wallet में व्युत्पत्ति की अंतिम चरण का प्रतिनिधित्व करती है। हालांकि तकनीकी रूप से इसे अनिश्चितकाल तक जारी रखना संभव है, वर्तमान मानक यहीं रुक जाते हैं। इस अंतिम गहराई पर, उन कुंजी जोड़े को निकाला जाता है जो वास्तव में UTXOs को लॉक और अनलॉक करने के लिए उपयोग किए जाएंगे। प्रत्येक इंडेक्स भाई-बहन कुंजी जोड़ों के बीच अंतर करने की अनुमति देता है: इस प्रकार, पहला प्राप्त करने वाला Address इंडेक्स $/0/$ का उपयोग करेगा, दूसरा $/1/$ का, और इसी तरह।

![CYP201](assets/fr/053.webp)

### व्युत्पत्ति पथों की संकेतन प्रणाली

व्युत्पत्ति पथ को लिखते समय प्रत्येक स्तर को स्लैश ($/$) से अलग किया जाता है। प्रत्येक स्लैश इस प्रकार एक पैरेंट कुंजी जोड़ी ($k_{\text{PAR}}$, $K_{\text{PAR}}$, $C_{\text{PAR}}$) से एक चाइल्ड कुंजी जोड़ी ($k_{\text{CHD}}$, $K_{\text{CHD}}$, $C_{\text{CHD}}$) की व्युत्पत्ति को दर्शाता है। प्रत्येक गहराई पर लिखा गया नंबर उस इंडेक्स को दर्शाता है जिसका उपयोग इस कुंजी को उसके पैरेंट से व्युत्पन्न करने के लिए किया गया है। इंडेक्स के दाईं ओर कभी-कभी लगाया गया अपोस्ट्रॉफी ($'$) एक हार्डनड व्युत्पत्ति ($k_{\text{CHD}}^h$, $K_{\text{CHD}}^h$) को इंगित करता है। कभी-कभी, इस अपोस्ट्रॉफी को $h$ से बदल दिया जाता है। अपोस्ट्रॉफी या $h$ की अनुपस्थिति में, यह एक सामान्य व्युत्पत्ति ($k_{\text{CHD}}^n$, $K_{\text{CHD}}^n$) होती है।

जैसा कि हमने पिछले अध्यायों में देखा है, हार्डन किए गए की इंडेक्स $2^{31}$ से शुरू होते हैं, या हेक्साडेसिमल में `0x80000000`। इसलिए, जब किसी इंडेक्स के बाद डेरिवेशन पाथ में एक अपॉस्ट्रॉफी होती है, तो उस निर्दिष्ट संख्या में $2^{31}$ जोड़ना आवश्यक होता है ताकि HMAC-SHA512 फंक्शन में उपयोग की जाने वाली वास्तविक मान प्राप्त हो सके। उदाहरण के लिए, यदि डेरिवेशन पाथ $/44'/$ निर्दिष्ट करता है, तो वास्तविक इंडेक्स होगा:

$$
i = 44 + 2^{31} = 2\,147\,483\,692
$$

हेक्साडेसिमल में, यह `0x8000002C` है।

अब जब हमने व्युत्पत्ति पथों के मुख्य सिद्धांतों को समझ लिया है, तो चलिए एक उदाहरण लेते हैं! यहाँ Bitcoin के लिए Address प्राप्त करने का व्युत्पत्ति पथ है:

$$
m / 84' / 0' / 1' / 0 / 7
$$

इस उदाहरण में:


- '$84' का मतलब है P2WPKH (SegWit v0) मानक।
- "$0'$" का मतलब है Bitcoin मुद्रा जो Mainnet पर है।
- "$1'$" का मतलब Wallet में दूसरा खाता है।
- $0$ यह दर्शाता है कि Address बाहरी चेन पर है।
- $7$ इस खाते का 8वां बाहरी Address दर्शाता है।

### व्युत्पत्ति संरचना का सारांश

| गहराई | विवरण              | मानक उदाहरण                      |

| ----- | ------------------ | --------------------------------- |

| 0     | मास्टर की          | $m/$                              |

| 1     | उद्देश्य           | $/86'/$ (P2TR)                    |

| 2     | मुद्रा              | $/0'/$ (Bitcoin)                  |

| 3     | खाता              | $/0'/$ (पहला खाता)               |

| 4     | चेन               | $/0/$ (बाहरी) या $/1/$ (बदलाव) |

| 5     | Address इंडेक्स    | $/0/$ (पहला Address)             |

अगले अध्याय में, हम जानेंगे कि "*आउटपुट स्क्रिप्ट डिस्क्रिप्टर्स*" क्या होते हैं। यह Bitcoin कोर में हाल ही में पेश की गई एक नई तकनीक है, जो Bitcoin Wallet के बैकअप को आसान बनाती है।

## स्क्रिप्ट विवरणों का आउटपुट दें।

<chapterId>e4f1c2d3-9b8a-4d3e-8f2a-7b6c5d4e3f2a</chapterId>

आपको अक्सर बताया जाता है कि केवल Mnemonic वाक्यांश ही Wallet तक पहुंच प्राप्त करने के लिए पर्याप्त है। वास्तव में, चीजें थोड़ी अधिक जटिल होती हैं। पिछले अध्याय में, हमने HD Wallet की व्युत्पत्ति संरचना पर नज़र डाली, और आपने देखा होगा कि यह प्रक्रिया काफी जटिल है। व्युत्पत्ति पथ सॉफ़्टवेयर को यह बताते हैं कि उपयोगकर्ता की कुंजियों को प्राप्त करने के लिए किस दिशा में जाना है। हालांकि, जब Bitcoin Wallet को पुनः प्राप्त किया जाता है, यदि किसी को ये पथ नहीं पता होते हैं, तो केवल Mnemonic वाक्यांश पर्याप्त नहीं होता। यह मास्टर कुंजी और मास्टर चेन कोड प्राप्त करने की अनुमति देता है, लेकिन इसके बाद बच्चे की कुंजियों तक पहुंचने के लिए उपयोग किए गए सूचकांक जानना आवश्यक होता है।

सैद्धांतिक रूप से, हमें न केवल हमारे Wallet के Mnemonic वाक्यांश को बचाना आवश्यक होगा, बल्कि उन खातों के रास्तों को भी जिन्हें हम उपयोग करते हैं। व्यवहार में, अक्सर यह संभव होता है कि बिना इस जानकारी के भी चाइल्ड कीज तक पहुंच प्राप्त की जा सके, बशर्ते कि मानकों का पालन किया गया हो। प्रत्येक मानक को एक-एक करके जांचने पर, आमतौर पर बिटकॉइन्स तक पहुंच फिर से प्राप्त करना संभव होता है। हालांकि, यह गारंटी नहीं है और यह विशेष रूप से शुरुआती लोगों के लिए जटिल हो सकता है। साथ ही, स्क्रिप्ट प्रकारों के विविधीकरण और अधिक जटिल कॉन्फ़िगरेशन के उभरने के साथ, यह जानकारी निकालना मुश्किल हो सकता है, जिससे यह डेटा निजी जानकारी में बदल सकता है और इसे बलपूर्वक पुनः प्राप्त करना कठिन हो सकता है। यही कारण है कि हाल ही में एक नवाचार पेश किया गया है और इसे आपके पसंदीदा Wallet सॉफ़्टवेयर में एकीकृत करना शुरू किया गया है: *आउटपुट स्क्रिप्ट डिस्क्रिप्टर्स*।

### "डिस्क्रिप्टर" का मतलब होता है एक ऐसा शब्द या वाक्यांश जो किसी चीज़ का वर्णन या पहचान करने में मदद करता है। यह किसी वस्तु, व्यक्ति, या विचार की विशेषताओं को स्पष्ट करने के लिए उपयोग किया जाता है। उदाहरण के लिए, अगर आप किसी किताब के बारे में बात कर रहे हैं, तो "रोमांचक" या "शैक्षिक" जैसे शब्द उस किताब के डिस्क्रिप्टर हो सकते हैं।

"*आउटपुट स्क्रिप्ट डिस्क्रिप्टर्स*", या बस "*डिस्क्रिप्टर्स*", संरचित अभिव्यक्तियाँ हैं जो एक आउटपुट स्क्रिप्ट (*scriptPubKey*) का पूरी तरह से वर्णन करती हैं और किसी विशेष स्क्रिप्ट से जुड़े लेन-देन को ट्रैक करने के लिए सभी आवश्यक जानकारी प्रदान करती हैं। ये एचडी वॉलेट्स में कुंजियों के प्रबंधन को आसान बनाते हैं, क्योंकि ये Wallet संरचना और उपयोग किए जाने वाले पते के प्रकारों का एक मानकीकृत और पूर्ण विवरण प्रदान करते हैं।

डिस्क्रिप्टर्स का मुख्य लाभ यह है कि वे सभी आवश्यक जानकारी को एक ही स्ट्रिंग में समेट सकते हैं ताकि Wallet को पुनर्स्थापित किया जा सके (रिकवरी वाक्यांश के अलावा)। जब आप Mnemonic वाक्यांशों के साथ एक डिस्क्रिप्टर को सहेजते हैं, तो यह संभव हो जाता है कि आप निजी कुंजियों को उनकी स्थिति को ठीक-ठीक जानकर पुनर्स्थापित कर सकें। Multisig वॉलेट्स के लिए, जिनका बैकअप शुरू में अधिक जटिल था, डिस्क्रिप्टर प्रत्येक फैक्टर के `xpub` को शामिल करता है, जिससे किसी समस्या की स्थिति में पते को पुनः उत्पन्न करने की संभावना सुनिश्चित होती है।

### विवरणकर्ता का निर्माण

एक वर्णनकर्ता में कई Elements शामिल होते हैं।


- आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है। स्क्रिप्ट फंक्शन्स जैसे `pk` (*Pay-to-PubKey*), `pkh` (*Pay-to-PubKey-Hash*), `wpkh` (*Pay-to-Witness-PubKey-Hash*), `sh` (*Pay-to-Script-Hash*), `wsh` (*Pay-to-Witness-Script-Hash*), `tr` (*Pay-to-Taproot*), `multi` (*Multisignature*), और `sortedmulti` (*Multisignature with sorted keys*) शामिल हैं।
- व्युत्पत्ति पथ, जैसे कि `[d34db33f/44h/0h/0h]`, जो एक व्युत्पन्न खाता पथ और एक विशेष मास्टर कुंजी फिंगरप्रिंट को दर्शाता है;
- कुंजियाँ विभिन्न प्रारूपों में होती हैं जैसे हेक्साडेसिमल सार्वजनिक कुंजियाँ या विस्तारित सार्वजनिक कुंजियाँ (`xpub`);
- एक चेकसम, जो Hash संकेत से पहले होता है, विवरण की अखंडता की पुष्टि करने के लिए।

उदाहरण के लिए, P2WPKH (SegWit v0) Wallet के लिए एक विवरण कुछ इस तरह दिख सकता है:

```text
wpkh([cdeab12f/84h/0h/0h]xpub6CUGRUonZSQ4TWtTMmzXdrXDtyPWKiKbERr4d5qkSmh5h17C1TjvMt7DJ9Qve4dRxm91CDv6cNfKsq2mK1rMsJKhtRUPZz7MQtp3y6atC1U/<0;1>/*)#jy0l7nr4
```

इस विवरण में, व्युत्पत्ति फ़ंक्शन `wpkh` एक स्क्रिप्ट प्रकार *Pay-to-Witness-Public-Key-Hash* को दर्शाता है। इसके बाद व्युत्पत्ति पथ आता है जिसमें शामिल हैं:


- `cdeab12f`: मास्टर कुंजी की फिंगरप्रिंट है।
- `84h`: इसका मतलब है कि BIP84 उद्देश्य का उपयोग किया जा रहा है, जो कि SegWit v0 पते के लिए होता है।
- `0h`: यह दर्शाता है कि यह Mainnet पर BTC मुद्रा है।
- `0h`: यह Wallet में उपयोग किए गए विशेष खाता नंबर को संदर्भित करता है।

विवरण में इस Wallet के लिए उपयोग की गई विस्तारित सार्वजनिक कुंजी भी शामिल है।

```text
xpub6CUGRUonZSQ4TWtTMmzXdrXDtyPWKiKbERr4d5qkSmh5h17C1TjvMt7DJ9Qve4dRxm91CDv6cNfKsq2mK1rMsJKhtRUPZz7MQtp3y6atC1U
```

अगला, संकेत `/<0;1>/*` यह दर्शाता है कि विवरणक बाहरी श्रृंखला (`0`) और आंतरिक श्रृंखला (`1`) से generate पते प्राप्त कर सकता है। इसमें वाइल्डकार्ड (`*`) का उपयोग होता है, जो कई पतों की क्रमिक व्युत्पत्ति को एक विन्यास योग्य तरीके से अनुमति देता है, जैसे पारंपरिक Wallet सॉफ़्टवेयर पर "गैप लिमिट" का प्रबंधन करना।

अंत में, `#jy0l7nr4` चेकसम का प्रतिनिधित्व करता है जो विवरण की अखंडता की पुष्टि करने के लिए होता है।

आपको अब HD Wallet के Bitcoin पर संचालन और की जोड़ों को निकालने की प्रक्रिया के बारे में सब कुछ पता है। हालांकि, पिछले अध्यायों में, हमने खुद को केवल निजी और सार्वजनिक कुंजियों के निर्माण तक सीमित रखा, बिना प्राप्त करने वाले पते के निर्माण पर ध्यान दिए। अगला अध्याय इसी विषय पर होगा!

## पते प्राप्त करना

<chapterId>ca80a89d-f8da-4e09-8c35-43179b65bced</chapterId>

प्राप्ति पते *scriptPubKey* में डाले गए जानकारी के टुकड़े होते हैं जो नए बनाए गए UTXOs को लॉक करने के लिए होते हैं। सरल शब्दों में, एक Address बिटकॉइन प्राप्त करने के लिए काम करता है। चलिए, उनके कामकाज को समझते हैं और देखते हैं कि यह हमने पिछले अध्यायों में जो पढ़ा है उससे कैसे जुड़ता है।

### स्क्रिप्ट्स में Bitcoin पतों की भूमिका

जैसा कि पहले समझाया गया था, एक लेन-देन का काम बिटकॉइन के Ownership को इनपुट से आउटपुट में ट्रांसफर करना होता है। इस प्रक्रिया में UTXOs को इनपुट के रूप में इस्तेमाल किया जाता है और नए UTXOs को आउटपुट के रूप में बनाया जाता है। ये UTXOs स्क्रिप्ट्स द्वारा सुरक्षित होते हैं, जो फंड को अनलॉक करने के लिए आवश्यक शर्तें निर्धारित करती हैं।

जब कोई उपयोगकर्ता बिटकॉइन प्राप्त करता है, तो भेजने वाला एक आउटपुट UTXO बनाता है और इसे *scriptPubKey* के साथ लॉक कर देता है। इस स्क्रिप्ट में नियम होते हैं जो आमतौर पर उन हस्ताक्षरों और सार्वजनिक कुंजियों को निर्दिष्ट करते हैं जो इस UTXO को अनलॉक करने के लिए आवश्यक होते हैं। इस UTXO को एक नए लेन-देन में खर्च करने के लिए, उपयोगकर्ता को *scriptSig* के माध्यम से अनुरोधित जानकारी प्रदान करनी होती है। *scriptSig* और *scriptPubKey* के संयोजन का निष्पादन "सत्य" या `1` लौटाना चाहिए। यदि यह शर्त पूरी होती है, तो UTXO को खर्च करके एक नया UTXO बनाया जा सकता है, जिसे एक नई *scriptPubKey* द्वारा लॉक किया जाता है, और यह प्रक्रिया इसी तरह चलती रहती है।

![CYP201](assets/fr/054.webp)

*स्क्रिप्टपबकी* में ही प्राप्तकर्ता के पते पाए जाते हैं। हालांकि, उनका उपयोग उस स्क्रिप्ट मानक के अनुसार बदलता रहता है जिसे अपनाया गया है। यहाँ एक सारणी दी गई है जिसमें *स्क्रिप्टपबकी* में मौजूद जानकारी का सारांश है, जो उपयोग किए गए मानक के अनुसार है, साथ ही *स्क्रिप्टसिग* में अपेक्षित जानकारी का भी उल्लेख है जो *स्क्रिप्टपबकी* को अनलॉक करने के लिए आवश्यक है।

| मानक              | *scriptPubKey*                                              | *scriptSig*                     | *Redeem स्क्रिप्ट*  | *गवाह*                                |

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

| P2PK               | `<pubkey> OP_CHECKSIG`                                      | `<signature>`                   |                     |                                          |

P2PK का मतलब है "Pay to Public Key"। यह एक प्रकार का बिटकॉइन स्क्रिप्ट है जो सीधे एक सार्वजनिक कुंजी को भुगतान करता है। इस स्क्रिप्ट में `<pubkey>` और `OP_CHECKSIG` ऑपकोड का उपयोग होता है। जब कोई ट्रांजेक्शन होता है, तो `<signature>` प्रदान किया जाता है जो इस स्क्रिप्ट के साथ मेल खाता है। यह सुनिश्चित करता है कि सही व्यक्ति को भुगतान किया जा रहा है।

| P2PKH              | `OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG` | `<हस्ताक्षर> <सार्वजनिक कुंजी>` |                     |                                          |

| P2SH               | `OP_HASH160 <scriptHash> OP_EQUAL`                          | `<data pushes> <Redeem script>` | मनमाना डेटा     |                                          |

| P2WPKH             | `0 <pubKeyHash>`                                            |                                 |                     | `<हस्ताक्षर> <सार्वजनिक कुंजी>`               |

| P2WSH              | `0 <witnessScriptHash>`                                     |                                 |                     | `<डेटा पुशेस> <विटनेस स्क्रिप्ट>`         |

| P2SH-P2WPKH        | `OP_HASH160 <redeemScriptHash> OP_EQUAL`                    | `<Redeem स्क्रिप्ट>`               | `0 <pubKeyHash>`    | `<हस्ताक्षर> <सार्वजनिक कुंजी>`               |

| P2SH-P2WSH         | `OP_HASH160 <redeemScriptHash> OP_EQUAL`                    | `<Redeem स्क्रिप्ट>`               | `0 <स्क्रिप्ट हैश>`    | `<डेटा पुश> <गवाह स्क्रिप्ट>`         |

| P2TR (मुख्य पथ)    | `1 <सार्वजनिक कुंजी>`                                      |                                 |                     | `<हस्ताक्षर>`                            |

| P2TR (स्क्रिप्ट पथ) | `1 <सार्वजनिक कुंजी>`                                        |                                 |                     | `<डेटा पुशेज़> <स्क्रिप्ट> <कंट्रोल ब्लॉक>` |

*स्रोत: Bitcoin कोर पीआर समीक्षा क्लब, 7 जुलाई 2021 - ग्लोरिया झाओ*

स्क्रिप्ट में उपयोग किए जाने वाले ऑपकोड्स को जानकारी को संभालने के लिए डिज़ाइन किया गया है, और यदि आवश्यक हो, तो उसकी तुलना या परीक्षण करने के लिए भी। चलिए एक P2PKH स्क्रिप्ट का उदाहरण लेते हैं, जो इस प्रकार है:

```text
OP_DUP OP_HASH160 OP_PUSHBYTES_20 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
```

जैसा कि हम इस अध्याय में देखेंगे, `<pubKeyHash>` वास्तव में प्राप्त करने वाले Address का पेलोड दर्शाता है, जिसका उपयोग UTXO को लॉक करने के लिए किया जाता है। इस *scriptPubKey* को अनलॉक करने के लिए, एक *scriptSig* प्रदान करना आवश्यक है जिसमें शामिल हो:

```text
<signature> <public key>
```

स्क्रिप्ट भाषा में "स्टैक" एक "*LIFO*" ("*लास्ट इन, फर्स्ट आउट*") डेटा संरचना है, जिसका उपयोग स्क्रिप्ट के निष्पादन के दौरान अस्थायी रूप से Elements को संग्रहीत करने के लिए किया जाता है। प्रत्येक स्क्रिप्ट ऑपरेशन इस स्टैक को संचालित करता है, जहां Elements को जोड़ा (*पुश*) या हटाया (*पॉप*) जा सकता है। स्क्रिप्ट्स इन स्टैक्स का उपयोग अभिव्यक्तियों का मूल्यांकन करने, अस्थायी वेरिएबल्स को संग्रहीत करने और स्थितियों का प्रबंधन करने के लिए करती हैं।

जिस स्क्रिप्ट का मैंने अभी उदाहरण दिया है, उसका निष्पादन इस प्रक्रिया का पालन करता है:


- हमारे पास *scriptSig*, *ScriptPubKey*, और स्टैक है:

![CYP201](assets/fr/055.webp)


- *स्क्रिप्टसिग* स्टैक पर धकेला जाता है:

![CYP201](assets/fr/056.webp)


- `OP_DUP` स्टैक पर *scriptSig* में दिए गए सार्वजनिक कुंजी को डुप्लिकेट करता है।

![CYP201](assets/fr/057.webp)


- `OP_HASH160` उस सार्वजनिक कुंजी का Hash लौटाता है जिसे अभी डुप्लिकेट किया गया था।

![CYP201](assets/fr/058.webp)


- `OP_PUSHBYTES_20 <pubKeyHash>` *scriptPubKey* में मौजूद Bitcoin Address को स्टैक पर डालता है।

![CYP201](assets/fr/059.webp)


- `OP_EQUALVERIFY` यह सुनिश्चित करता है कि हैश की गई सार्वजनिक कुंजी दी गई प्राप्तकर्ता Address से मेल खाती है।

![CYP201](assets/fr/060.webp)

`OP_CHECKSIG` *scriptSig* में मौजूद हस्ताक्षर को सार्वजनिक कुंजी का उपयोग करके जांचता है। यह ऑपकोड मूल रूप से हस्ताक्षर सत्यापन करता है जैसा कि हमने इस प्रशिक्षण के भाग 3 में वर्णित किया था।

![CYP201](assets/fr/061.webp)


- अगर `1` स्टैक पर बना रहता है, तो स्क्रिप्ट मान्य है।

![CYP201](assets/fr/062.webp)

इसलिए, संक्षेप में, यह स्क्रिप्ट डिजिटल हस्ताक्षर की मदद से यह सत्यापित करने की अनुमति देती है कि जो उपयोगकर्ता इस UTXO का Ownership दावा कर रहा है और इसे खर्च करना चाहता है, उसके पास वास्तव में उस Address से जुड़ी निजी कुंजी है जो इस UTXO के निर्माण के दौरान उपयोग की गई थी।

### Bitcoin के विभिन्न प्रकार के पते

Bitcoin के विकास के दौरान, कई मानक स्क्रिप्ट मॉडल जोड़े गए हैं। इनमें से प्रत्येक एक विशेष प्रकार के Address को प्राप्त करने के लिए उपयोग करता है। यहाँ अब तक उपलब्ध मुख्य स्क्रिप्ट मॉडलों का एक संक्षिप्त विवरण दिया गया है:

**P2PK (*पे-टू-पबकी*)**:

यह स्क्रिप्ट मॉडल पहली बार Bitcoin के पहले संस्करण में Satoshi नाकामोटो द्वारा पेश किया गया था। P2PK स्क्रिप्ट सीधे एक कच्ची सार्वजनिक कुंजी का उपयोग करके बिटकॉइन को लॉक करती है (इसलिए, इस मॉडल के साथ कोई प्राप्त करने वाला Address उपयोग नहीं किया जाता)। इसकी संरचना सरल है: इसमें एक सार्वजनिक कुंजी होती है और धन को अनलॉक करने के लिए एक संबंधित डिजिटल हस्ताक्षर की आवश्यकता होती है। यह स्क्रिप्ट "*लेगेसी*" मानक का हिस्सा है।

**P2PKH (*पे-टू-पब्लिक-की-Hash*)**:

P2PK की तरह, P2PKH स्क्रिप्ट को Bitcoin के लॉन्च के समय पेश किया गया था। अपने पूर्ववर्ती से अलग, यह बिटकॉइन को सार्वजनिक कुंजी के Hash का उपयोग करके लॉक करता है, बजाय सीधे कच्ची सार्वजनिक कुंजी का उपयोग करने के। इसके बाद *scriptSig* को प्राप्त करने वाले Address से जुड़ी सार्वजनिक कुंजी और एक वैध हस्ताक्षर प्रदान करना होता है। इस मॉडल के पते `1` से शुरू होते हैं और *base58check* में एन्कोड किए जाते हैं। यह स्क्रिप्ट भी "*Legacy*" मानक का हिस्सा है।

**P2SH (*Pay-to-Script-Hash*)**:

2012 में BIP16 के साथ पेश किया गया P2SH मॉडल Hash का उपयोग *scriptPubKey* में एक मनमाने स्क्रिप्ट के रूप में करने की अनुमति देता है। इस हैश किए गए स्क्रिप्ट को "*redeemscript*" कहा जाता है, जिसमें धन को अनलॉक करने की शर्तें होती हैं। P2SH के साथ लॉक किए गए UTXO को खर्च करने के लिए, *scriptSig* प्रदान करना आवश्यक होता है जिसमें मूल *redeemscript* और इसे मान्य करने के लिए आवश्यक डेटा शामिल होता है। यह मॉडल विशेष रूप से पुराने मल्टीसिग्स के लिए उपयोग किया जाता है। P2SH से जुड़े पते `3` से शुरू होते हैं और *base58check* में एन्कोड किए जाते हैं। यह स्क्रिप्ट "*Legacy*" मानक का हिस्सा भी है।

**P2WPKH (*पे-टू-विटनेस-पबकी-गेटवे-542*)**:

यह स्क्रिप्ट P2PKH के समान है, क्योंकि यह भी एक सार्वजनिक कुंजी के Hash का उपयोग करके बिटकॉइन को लॉक करती है। हालांकि, P2PKH के विपरीत, *scriptSig* को एक अलग सेक्शन में स्थानांतरित कर दिया गया है जिसे "*Witness*" कहा जाता है। इसे कभी-कभी "*scriptWitness*" भी कहा जाता है, जो हस्ताक्षर और सार्वजनिक कुंजी के सेट को दर्शाता है। प्रत्येक SegWit इनपुट का अपना *scriptWitness* होता है, और *scriptWitnesses* का संग्रह लेन-देन के *Witness* क्षेत्र का निर्माण करता है। हस्ताक्षर डेटा का यह स्थानांतरण SegWit अपडेट द्वारा पेश किया गया एक नवाचार है, जिसका मुख्य उद्देश्य ECDSA हस्ताक्षरों के कारण लेन-देन की परिवर्तनशीलता को रोकना है।

P2WPKH *bech32* एन्कोडिंग का उपयोग करता है और हमेशा `bc1q` से शुरू होता है। इस प्रकार की स्क्रिप्ट संस्करण 0 SegWit आउटपुट्स से मेल खाती है।

**P2WSH (*पे-टू-विटनेस-स्क्रिप्ट-Hash*)**:

P2WSH मॉडल को अगस्त 2017 में SegWit अपडेट के साथ पेश किया गया था। यह P2SH मॉडल के समान है, जो बिटकॉइन को Hash स्क्रिप्ट के माध्यम से लॉक करता है। मुख्य अंतर इस बात में है कि हस्ताक्षर और स्क्रिप्ट को लेन-देन में कैसे शामिल किया जाता है। इस प्रकार की स्क्रिप्ट से लॉक किए गए बिटकॉइन को खर्च करने के लिए, प्राप्तकर्ता को मूल स्क्रिप्ट, जिसे *witnessScript* कहा जाता है (P2SH में *redeemscript* के समकक्ष), और इस *witnessScript* को मान्य करने के लिए आवश्यक डेटा प्रदान करना होता है। यह प्रणाली अधिक जटिल खर्च की शर्तों, जैसे कि मल्टीसिग्स, को लागू करने की अनुमति देती है।

P2WSH पते *bech32* एन्कोडिंग का उपयोग करते हैं और हमेशा `bc1q` से शुरू होते हैं। यह स्क्रिप्ट संस्करण 0 SegWit आउटपुट्स से भी मेल खाती है।

**P2TR (*Pay-to-Taproot*)**:

P2TR मॉडल को नवंबर 2021 में Taproot के साथ पेश किया गया था। यह क्रिप्टोग्राफिक कुंजी एकत्रीकरण के लिए Schnorr प्रोटोकॉल पर आधारित है, और वैकल्पिक स्क्रिप्ट्स के लिए Merkle Tree पर आधारित है, जिसे MAST (*Merkelized Alternative Script Tree*) कहा जाता है। अन्य प्रकार की स्क्रिप्ट्स के विपरीत, जहाँ खर्च की शर्तें सार्वजनिक रूप से दिखाई देती हैं (चाहे प्राप्ति पर या खर्च पर), P2TR जटिल स्क्रिप्ट्स को एक साधारण, सार्वजनिक कुंजी के पीछे छिपाने की अनुमति देता है।

तकनीकी रूप से, एक P2TR स्क्रिप्ट बिटकॉइन को एक विशेष Schnorr सार्वजनिक कुंजी, जिसे $Q$ कहा जाता है, पर लॉक करती है। यह कुंजी $Q$ वास्तव में एक सार्वजनिक कुंजी $P$ और एक सार्वजनिक कुंजी $M$ का संयोजन है, जिसमें $M$ को *scriptPubKey* की सूची के Merkle Root से गणना की जाती है। इस प्रकार की स्क्रिप्ट से लॉक किए गए बिटकॉइन को दो तरीकों से खर्च किया जा सकता है:


- सार्वजनिक कुंजी $P$ (*कुंजी पथ*) के लिए एक हस्ताक्षर प्रकाशित करके।
- Merkle Tree (*स्क्रिप्ट पथ*) में शामिल स्क्रिप्ट्स में से एक को पूरा करके।

P2TR बहुत लचीलापन प्रदान करता है, क्योंकि यह आपको बिटकॉइन को या तो एक विशेष सार्वजनिक कुंजी के साथ, या अपनी पसंद के कई स्क्रिप्ट्स के साथ, या दोनों को एक साथ लॉक करने की अनुमति देता है। Merkle Tree संरचना का लाभ यह है कि लेन-देन के दौरान केवल वही खर्च करने वाली स्क्रिप्ट प्रकट होती है जो उपयोग की जाती है, जबकि अन्य सभी वैकल्पिक स्क्रिप्ट्स गुप्त रहती हैं।

![CYP201](assets/fr/063.webp)

P2TR वास्तव में SegWit के संस्करण 1 के आउटपुट से मेल खाता है, जिसका मतलब है कि P2TR इनपुट के लिए हस्ताक्षर लेन-देन के *विटनेस* सेक्शन में संग्रहीत होते हैं, न कि *स्क्रिप्टसिग* में। P2TR पते *bech32m* एन्कोडिंग का उपयोग करते हैं और `bc1p` से शुरू होते हैं, लेकिन वे काफी अनोखे होते हैं क्योंकि उनके निर्माण के लिए Hash फ़ंक्शन का उपयोग नहीं किया जाता। वास्तव में, वे सीधे सार्वजनिक कुंजी $Q$ का प्रतिनिधित्व करते हैं, जिसे बस मेटाडेटा के साथ स्वरूपित किया गया है। इसलिए, यह एक स्क्रिप्ट मॉडल है जो P2PK के काफी करीब है।

अब जब हमने सिद्धांत को समझ लिया है, तो चलिए अभ्यास की ओर बढ़ते हैं! अगले अध्याय में, मैं सुझाव देता हूँ कि हम एक जोड़ी चाबियों से SegWit v0 Address और SegWit v1 Address दोनों को निकालें।

## आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

<chapterId>3ebdc750-4135-4881-b07e-08965941b93e</chapterId>

आइए मिलकर समझते हैं कि कैसे generate को एक प्राप्त करने वाले Address के साथ जोड़ा जाए, जो कि उदाहरण के लिए, एक HD Wallet की गहराई 5 पर स्थित कुंजियों के जोड़े से है। इस Address का उपयोग फिर Wallet सॉफ़्टवेयर में UTXO को लॉक करने के लिए किया जा सकता है।

Address बनाने की प्रक्रिया जिस स्क्रिप्ट मॉडल पर निर्भर करती है, चलिए दो विशेष मामलों पर ध्यान केंद्रित करते हैं: P2WPKH में SegWit v0 Address बनाना और P2TR में SegWit v1 Address बनाना। ये दो प्रकार के पते आज के समय में अधिकांश उपयोगों को कवर करते हैं।

### पब्लिक की कम्प्रेशन

मास्टर कुंजी से गहराई 5 तक सभी व्युत्पत्ति चरणों को उपयुक्त सूचकांकों का उपयोग करके पूरा करने के बाद, हमें कुंजियों की एक जोड़ी ($k$, $K$) प्राप्त होती है, जिसमें $K = k \cdot G$ होता है। हालांकि, इस सार्वजनिक कुंजी का उपयोग P2PK मानक के साथ धन को लॉक करने के लिए किया जा सकता है, लेकिन यहां हमारा उद्देश्य यह नहीं है। इसके बजाय, हम पहले उदाहरण में Address में और फिर दूसरे उदाहरण के लिए P2TR में एक P2WPKH बनाना चाहते हैं।

पहला कदम है सार्वजनिक कुंजी $K$ को संपीड़ित करना। इस प्रक्रिया को अच्छी तरह से समझने के लिए, चलिए पहले उन मूलभूत बातों को याद कर लेते हैं जो हमने भाग 3 में सीखी थीं।

Bitcoin पर एक सार्वजनिक कुंजी एक बिंदु $K$ है जो एक अंडाकार वक्र पर स्थित है। इसे $(x, y)$ के रूप में दर्शाया जाता है, जहाँ $x$ और $y$ बिंदु के निर्देशांक हैं। इसके बिना संकुचित रूप में, यह सार्वजनिक कुंजी 520 बिट्स की होती है: 8 बिट्स एक प्रीफिक्स (प्रारंभिक मान `0x04` के लिए), 256 बिट्स $x$ निर्देशांक के लिए, और 256 बिट्स $y$ निर्देशांक के लिए।

हालांकि, दीर्घवृत्तीय वक्रों में x-अक्ष के संबंध में एक सममिति गुण होता है: एक दिए गए $x$ निर्देशांक के लिए, $y$ के केवल दो संभावित मान होते हैं: $y$ और $-y$। ये दोनों बिंदु x-अक्ष के दोनों ओर स्थित होते हैं। दूसरे शब्दों में, यदि हमें $x$ पता है, तो वक्र पर सटीक बिंदु की पहचान करने के लिए यह बताना पर्याप्त है कि $y$ सम है या विषम।

![CYP201](assets/fr/064.webp)

एक सार्वजनिक कुंजी को संकुचित करने के लिए, केवल $x$ को एन्कोड किया जाता है, जो 256 बिट्स का स्थान लेता है, और $y$ की समता (even या odd) को दर्शाने के लिए एक प्रीफिक्स जोड़ा जाता है। इस विधि से सार्वजनिक कुंजी का आकार 520 बिट्स से घटकर 264 बिट्स हो जाता है। प्रीफिक्स `0x02` यह दर्शाता है कि $y$ सम (even) है, और प्रीफिक्स `0x03` यह दर्शाता है कि $y$ विषम (odd) है।

आइए एक उदाहरण लेते हैं ताकि हम अच्छी तरह से समझ सकें, एक कच्ची सार्वजनिक कुंजी के साथ जो बिना संकुचित रूप में है:

```text
K = 04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f
```

अगर हम इस कुंजी को विभाजित करें, तो हमारे पास है:


   - उपसर्ग: `04`;
   - आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।
   - आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

$y$ का अंतिम हेक्साडेसिमल अक्षर 'f' है। आधार 10 में, 'f = 15' होता है, जो एक विषम संख्या है। इसलिए, $y$ विषम है, और इसे दर्शाने के लिए उपसर्ग '0x03' होगा।

संपीड़ित सार्वजनिक कुंजी बन जाती है:

```text
K = 03678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb6
```

यह प्रक्रिया सभी स्क्रिप्ट मॉडल्स पर लागू होती है जो ECDSA पर आधारित हैं, यानी सभी मॉडल्स पर सिवाय P2TR के, जो Schnorr का उपयोग करता है। Schnorr के मामले में, जैसा कि भाग 3 में समझाया गया है, हम केवल $x$ के मान को रखते हैं, बिना $y$ की parity को दर्शाने के लिए कोई प्रीफिक्स जोड़े, जो ECDSA में होता है। यह इसलिए संभव है क्योंकि सभी चाबियों के लिए एक अद्वितीय parity मनमाने ढंग से चुनी जाती है। इससे सार्वजनिक चाबियों के लिए आवश्यक भंडारण स्थान में थोड़ी कमी आती है।

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

अब जब हमने अपना संकुचित सार्वजनिक कुंजी प्राप्त कर लिया है, तो हम इससे SegWit v0 प्राप्त कर सकते हैं जो Address को प्राप्त करता है।

पहला कदम है कि संकुचित सार्वजनिक कुंजी पर HASH160 Hash फ़ंक्शन लागू करें। HASH160 दो लगातार Hash फ़ंक्शनों का संयोजन है: पहले SHA256 और उसके बाद RIPEMD160।

$$
\text{HASH160}(K) = \text{RIPEMD160}(\text{SHA256}(K))
$$

सबसे पहले, हम कुंजी को SHA256 के माध्यम से पास करते हैं:

```text
SHA256(K) = C489EBD66E4103B3C4B5EAFF462B92F5847CA2DCE0825F4997C7CF57DF35BF3A
```

फिर हम परिणाम को RIPEMD160 के माध्यम से पास करते हैं:

```text
RIPEMD160(SHA256(K)) = 9F81322CC88622CA4CCB2A52A21E2888727AA535
```

हमने 160-बिट का Hash सार्वजनिक कुंजी प्राप्त किया है, जो Address का पेलोड कहलाता है। यह पेलोड Address का केंद्रीय और सबसे महत्वपूर्ण हिस्सा है। इसे *scriptPubKey* में UTXOs को लॉक करने के लिए भी इस्तेमाल किया जाता है।

हालांकि, इस पेलोड को इंसानों के लिए अधिक उपयोगी बनाने के लिए इसमें मेटाडेटा जोड़ा जाता है। अगला कदम इस Hash को 5 बिट के समूहों में दशमलव में एन्कोड करना शामिल है। यह दशमलव परिवर्तन *bech32* में रूपांतरण के लिए उपयोगी होगा, जो पोस्ट-SegWit पतों द्वारा उपयोग किया जाता है। 160-बिट बाइनरी Hash को इस प्रकार 5 बिट के 32 समूहों में विभाजित किया जाता है।

$$
\begin{array}{|c|c|}
\hline
\text{5 bits} & \text{Decimal} \\
\hline
10011 & 19 \\
11110 & 30 \\
00000 & 0 \\
10011 & 19 \\
00100 & 4 \\
01011 & 11 \\
00110 & 6 \\
01000 & 8 \\
10000 & 16 \\
11000 & 24 \\
10001 & 17 \\
01100 & 12 \\
10100 & 20 \\
10011 & 19 \\
00110 & 6 \\
01011 & 11 \\
00101 & 5 \\
01001 & 9 \\
01001 & 9 \\
01010 & 10 \\
00100 & 4 \\
00111 & 7 \\
10001 & 17 \\
01000 & 8 \\
10001 & 17 \\
00001 & 1 \\
11001 & 25 \\
00111 & 7 \\
10101 & 21 \\
00101 & 5 \\
00101 & 5 \\
10101 & 21 \\
\hline
\end{array}
$$

तो, हमारे पास है:

```text
HASH = 19 30 00 19 04 11 06 08 16 24 17 12 20 19 06 11 05 09 09 10 04 07 17 08 17 01 25 07 21 09 09 21
```

जब Hash को 5 बिट्स के समूहों में एन्कोड किया जाता है, तो एक चेकसम Address में जोड़ा जाता है। यह चेकसम यह सुनिश्चित करने के लिए उपयोग किया जाता है कि Address का पेलोड उसके भंडारण या ट्रांसमिशन के दौरान बदला नहीं गया है। उदाहरण के लिए, यह Wallet सॉफ़्टवेयर को यह सुनिश्चित करने की अनुमति देता है कि आपने प्राप्त करने वाले Address को दर्ज करते समय कोई टाइपो नहीं किया है। इस सत्यापन के बिना, आप गलती से बिटकॉइन को गलत Address पर भेज सकते हैं, जिससे धन की स्थायी हानि हो सकती है, क्योंकि आपके पास संबंधित सार्वजनिक या निजी कुंजी नहीं होती। इसलिए, चेकसम मानव त्रुटियों के खिलाफ एक सुरक्षा है।

पुराने Bitcoin *लेगेसी* पतों के लिए, चेकसम को Address Hash की शुरुआत से HASH256 फंक्शन का उपयोग करके सरलता से गणना की जाती थी। SegWit और *बेच32* फॉर्मेट के आने के साथ, अब BCH कोड्स (*बोस, रे-चौधरी, और होक्वेंगहेम*) का उपयोग किया जाता है। ये त्रुटि-सुधार कोड डेटा अनुक्रमों में त्रुटियों का पता लगाने और उन्हें सुधारने के लिए उपयोग किए जाते हैं। ये सुनिश्चित करते हैं कि भेजी गई जानकारी अपने गंतव्य तक बिना किसी बदलाव के पहुंचे, भले ही उसमें मामूली परिवर्तन हो। BCH कोड्स का उपयोग कई क्षेत्रों में किया जाता है, जैसे SSDs, DVDs, और QR कोड्स में। उदाहरण के लिए, इन BCH कोड्स की बदौलत, एक आंशिक रूप से ढका हुआ QR कोड भी पढ़ा और डिकोड किया जा सकता है।

Bitcoin के संदर्भ में, BCH कोड आकार और त्रुटि पहचान क्षमता के बीच एक बेहतर संतुलन प्रदान करते हैं, खासकर जब हम *Legacy* पतों के लिए उपयोग की जाने वाली सरल Hash कार्यों की तुलना करते हैं। हालांकि, Bitcoin पर, BCH कोड केवल त्रुटि पहचान के लिए उपयोग किए जाते हैं, न कि सुधार के लिए। इसलिए, Wallet सॉफ़्टवेयर एक गलत प्राप्त होने वाले Address का संकेत देगा, लेकिन इसे स्वचालित रूप से ठीक नहीं करेगा। यह सीमा जानबूझकर रखी गई है: स्वचालित सुधार की अनुमति देने से त्रुटि पहचान क्षमता कम हो जाएगी।

BCH कोड के साथ चेकसम की गणना करने के लिए, हमें कई Elements तैयार करने की आवश्यकता होती है।


- HRP (*ह्यूमन रीडेबल पार्ट*): Bitcoin और Mainnet के लिए, HRP `bc` है।

HRP को विस्तारित करने के लिए प्रत्येक अक्षर को दो भागों में विभाजित करना होगा।


- HRP के अक्षरों को ASCII में लेना:
 - `b`: `01100010`
 - `c`: `01100011`
- 3 सबसे महत्वपूर्ण बिट्स और 5 सबसे कम महत्वपूर्ण बिट्स को निकालना:
  - तीन सबसे महत्वपूर्ण बिट्स: `011` (दशमलव में 3)
  - तीन सबसे महत्वपूर्ण बिट्स: `011` (दशमलव में 3)
  - 5 सबसे कम महत्वपूर्ण बिट्स: `00010` (दशमलव में 2)
  - 5 सबसे कम महत्वपूर्ण बिट्स: `00011` (दशमलव में 3)

दो अक्षरों के बीच `0` सेपरेटर के साथ, HRP एक्सटेंशन इस प्रकार है:

```text
03 03 00 02 03
```


- गवाह संस्करण**: SegWit संस्करण 0 के लिए, यह `00` है;
- पेलोड**: सार्वजनिक कुंजी Hash के दशमलव मान;
- चेकसम के लिए आरक्षण: हम अनुक्रम के अंत में 6 शून्य `[0, 0, 0, 0, 0, 0]` जोड़ते हैं।

कार्यक्रम में चेकसम की गणना के लिए डाले गए सभी डेटा इस प्रकार हैं:

```text
HRP = 03 03 00 02 03
SEGWIT v0 = 00
HASH = 19 30 00 19 04 11 06 08 16 24 17 12 20 19 06 11 05 09 09 10 04 07 17 08 17 01 25 07 21 09 09 21
CHECKSUM = 00 00 00 00 00 00
INPUT = 03 03 00 02 03 00 19 30 00 19 04 11 06 08 16 24 17 12 20 19 06 11 05 09 09 10 04 07 17 08 17 01 25 07 21 09 09 21 00 00 00 00 00 00
```

चेकसम की गणना काफी जटिल होती है। इसमें बहुपद सीमित क्षेत्र अंकगणित शामिल होता है। हम यहां इस गणना का विवरण नहीं देंगे और सीधे परिणाम पर जाएंगे। हमारे उदाहरण में, दशमलव में प्राप्त चेकसम है:

```text
10 16 11 04 13 18
```

अब हम Address को तैयार कर सकते हैं, इसके लिए हमें निम्नलिखित Elements को क्रम में जोड़ना होगा:


- SegWit संस्करण**: `00`
- पेलोड**: सार्वजनिक कुंजी Hash
- चेकसम**: पिछले चरण में प्राप्त किए गए मान (`10 16 11 04 13 18`)

यह हमें दशमलव में देता है:

```text
00 19 30 00 19 04 11 06 08 16 24 17 12 20 19 06 11 05 09 09 10 04 07 17 08 17 01 25 07 21 09 09 21 10 16 11 04 13 18
```

फिर, प्रत्येक दशमलव मान को निम्नलिखित रूपांतरण तालिका का उपयोग करके उसके *bech32* अक्षर में बदलना होगा:

$$
\begin{array}{|c|c|c|c|c|c|c|c|c|}
\hline
& 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
\hline
+0 & q & p & z & r & y & 9 & x & 8 \\
\hline
+8 & g & f & 2 & t & v & d & w & 0 \\
\hline
+16 & s & 3 & j & n & 5 & 4 & k & h \\
\hline
+24 & c & e & 6 & m & u & a & 7 & l \\
\hline
\end{array}
$$

इस तालिका का उपयोग करके किसी मान को _bech32_ अक्षर में बदलने के लिए, पहले कॉलम और पहली पंक्ति में उन मानों को खोजें, जिनका योग वांछित परिणाम देता है। फिर, संबंधित अक्षर प्राप्त करें। उदाहरण के लिए, दशमलव संख्या `19` को अक्षर `n` में बदला जाएगा, क्योंकि $19 = 16 + 3$।

हमारे सभी मूल्यों को मैप करके, हमें निम्नलिखित Address प्राप्त होता है:

```
qn7qnytxgsc3v5nxt9ff2y83g3pe84ff42stydj
```

अब बस इतना करना बाकी है कि HRP `bc` जोड़ें, जो दर्शाता है कि यह Address के लिए Bitcoin और Mainnet है, साथ ही विभाजक `1` जोड़ें, ताकि पूरा प्राप्त करने वाला Address मिल सके।

```
bc1qn7qnytxgsc3v5nxt9ff2y83g3pe84ff42stydj
```

_bech32_ वर्णमाला की विशेषता यह है कि इसमें सभी अल्फ़ान्यूमेरिक अक्षर शामिल होते हैं, लेकिन `1`, `b`, `i`, और `o` को छोड़कर। ऐसा इसलिए किया गया है ताकि इन अक्षरों के बीच दिखने में होने वाली गड़बड़ी से बचा जा सके, खासकर जब इन्हें इंसान द्वारा दर्ज या पढ़ा जा रहा हो।

संक्षेप में, यहाँ व्युत्पत्ति प्रक्रिया है:

![CYP201](assets/fr/065.webp)

यहाँ बताया गया है कि कैसे P2WPKH (SegWit v0) को एक जोड़ी चाबियों से Address प्राप्त करते हुए निकाला जाता है। अब चलिए P2TR (SegWit v1 / Taproot) पतों की ओर बढ़ते हैं और उनके निर्माण की प्रक्रिया को समझते हैं।

### आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।

Taproot पतों के लिए, निर्माण प्रक्रिया थोड़ी अलग होती है। चलिए, इसे एक साथ देखते हैं!

सार्वजनिक कुंजी संपीड़न के चरण से, ECDSA की तुलना में पहली भिन्नता दिखाई देती है: Bitcoin पर Schnorr के लिए उपयोग की जाने वाली सार्वजनिक कुंजियाँ केवल उनके अभिस्सा ($x$) द्वारा दर्शाई जाती हैं। इसलिए, कोई उपसर्ग नहीं होता है, और संपीड़ित कुंजी का माप ठीक 256 बिट्स होता है।

जैसा कि हमने पिछले अध्याय में देखा, एक P2TR स्क्रिप्ट बिटकॉइन को एक विशेष Schnorr सार्वजनिक कुंजी, जिसे $Q$ कहा जाता है, पर लॉक कर देती है। यह कुंजी $Q$ दो सार्वजनिक कुंजियों का संयोजन है: $P$, जो मुख्य आंतरिक सार्वजनिक कुंजी है, और $M$, जो _scriptPubKey_ की सूची के Merkle Root से प्राप्त सार्वजनिक कुंजी है। इस प्रकार की स्क्रिप्ट से लॉक किए गए बिटकॉइन को दो तरीकों से खर्च किया जा सकता है:


- आप सार्वजनिक कुंजी $P$ (_key path_) के लिए एक हस्ताक्षर प्रकाशित करके;
- Merkle Tree में शामिल स्क्रिप्ट्स में से एक को पूरा करके (_स्क्रिप्ट पथ_)।

असल में, ये दोनों कुंजियाँ वास्तव में "समेकित" नहीं होती हैं। कुंजी $P$ को कुंजी $M$ द्वारा थोड़ा बदल दिया जाता है। क्रिप्टोग्राफी में, एक सार्वजनिक कुंजी को "बदलना" का मतलब है इस कुंजी को एक अतिरिक्त मान जिसे "ट्वीक" कहते हैं, जोड़कर संशोधित करना। इस प्रक्रिया से संशोधित कुंजी मूल निजी कुंजी और ट्वीक के साथ संगत बनी रहती है। तकनीकी रूप से, एक ट्वीक एक स्केलर मान $t$ होता है जिसे प्रारंभिक सार्वजनिक कुंजी में जोड़ा जाता है। यदि $P$ मूल सार्वजनिक कुंजी है, तो बदली हुई कुंजी इस प्रकार बनती है:

$$
P' = P + tG
$$

यहाँ $G$ उस एलिप्टिक कर्व का जनरेटर है जिसका उपयोग किया जा रहा है। यह प्रक्रिया मूल कुंजी से एक नई सार्वजनिक कुंजी उत्पन्न करती है, जबकि इसके क्रिप्टोग्राफिक गुणों को बनाए रखते हुए इसे उपयोग में लाने की अनुमति देती है।

यदि आपको वैकल्पिक स्क्रिप्ट्स जोड़ने की आवश्यकता नहीं है (केवल _key path_ के माध्यम से खर्च करते हुए), तो आप generate एक Taproot Address को स्थापित कर सकते हैं जो आपके Wallet की गहराई 5 पर मौजूद सार्वजनिक कुंजी पर आधारित है। इस स्थिति में, _script path_ के लिए एक गैर-खर्च योग्य स्क्रिप्ट बनाना आवश्यक है, ताकि संरचना की आवश्यकताओं को पूरा किया जा सके। फिर $t$ ट्वीक की गणना एक टैग्ड Hash फ़ंक्शन, **`TapTweak`**, को आंतरिक सार्वजनिक कुंजी $P$ पर लागू करके की जाती है।

$$
t = \text{H}\_{\text{TapTweak}}(P)
$$

आपका प्रशिक्षण अक्टूबर 2023 तक के डेटा पर आधारित है।


- $\text{H}_{\text{TapTweak}}$** एक SHA256 Hash फंक्शन है जिसे `TapTweak` टैग के साथ टैग किया गया है। अगर आप टैग किए गए Hash फंक्शन के बारे में नहीं जानते हैं, तो मैं आपको अध्याय 3.3 देखने के लिए आमंत्रित करता हूँ।
- $P$ एक आंतरिक सार्वजनिक कुंजी है, जो अपने संकुचित 256-बिट प्रारूप में प्रस्तुत की गई है, जिसमें केवल $x$ निर्देशांक का उपयोग किया गया है।

Taproot सार्वजनिक कुंजी $Q$ को इस प्रकार से गणना की जाती है कि पहले ट्वीक $t$ को अण्डाकार वक्र जनरेटर $G$ से गुणा किया जाता है, और फिर इसे आंतरिक सार्वजनिक कुंजी $P$ में जोड़ा जाता है।

$$
Q = P + t \cdot G
$$

जब Taproot सार्वजनिक कुंजी $Q$ प्राप्त हो जाती है, तो हम संबंधित प्राप्त करने वाले Address को generate कर सकते हैं। अन्य प्रारूपों के विपरीत, Taproot पते सार्वजनिक कुंजी के Hash पर आधारित नहीं होते हैं। इसलिए, कुंजी $Q$ को सीधे Address में, बिना किसी प्रसंस्करण के, डाला जाता है।

शुरू करने के लिए, हम बिंदु $Q$ के $x$ निर्देशांक को निकालते हैं ताकि एक संकुचित सार्वजनिक कुंजी प्राप्त की जा सके। इस डेटा पर, एक चेकसम की गणना BCH कोड्स का उपयोग करके की जाती है, जैसे कि SegWit v0 पतों के साथ होता है। हालांकि, Taproot पतों के लिए उपयोग किया जाने वाला प्रोग्राम थोड़ा अलग है। वास्तव में, जब SegWit के साथ _bech32_ प्रारूप पेश किया गया, तो एक बग पाया गया: जब Address का अंतिम अक्षर `p` होता है, तो इस `p` के ठीक पहले `q` जोड़ने या हटाने से चेकसम अमान्य नहीं होता। हालांकि इस बग का SegWit v0 पर कोई प्रभाव नहीं पड़ता (आकार की सीमा के कारण), यह भविष्य में समस्या पैदा कर सकता है। इसलिए इस बग को Taproot पतों के लिए ठीक किया गया है, और नए ठीक किए गए प्रारूप को "_bech32m_" कहा जाता है।

Taproot Address को _bech32m_ फॉर्मेट में $x$ निर्देशांक को एनकोड करके उत्पन्न किया जाता है, जिसमें निम्नलिखित Elements शामिल है:


- एचआरपी (_ह्यूमन रीडेबल पार्ट_)**: `bc`, मुख्य Bitcoin नेटवर्क को दर्शाने के लिए;
- संस्करण**: `1` यह दर्शाने के लिए कि यह Taproot / SegWit का संस्करण 1 है।
- चेकसम**.

अंतिम Address का प्रारूप इस प्रकार होगा:

```
bc1p[Qx][checksum]
```

दूसरी ओर, अगर आप आंतरिक सार्वजनिक कुंजी (_script path_) के साथ-साथ वैकल्पिक स्क्रिप्ट्स जोड़ना चाहते हैं, तो प्राप्त करने वाले Address की गणना थोड़ी अलग होगी। आपको ट्वीक की गणना में वैकल्पिक स्क्रिप्ट्स के Hash को शामिल करना होगा। Taproot में, प्रत्येक वैकल्पिक स्क्रिप्ट, जो Merkle Tree के अंत में स्थित होती है, उसे "लीफ" कहा जाता है।

जब विभिन्न वैकल्पिक स्क्रिप्ट्स लिख ली जाती हैं, तो आपको उन्हें व्यक्तिगत रूप से टैग किए गए Hash फंक्शन `TapLeaf` के माध्यम से पास करना होता है, साथ में कुछ मेटाडेटा भी देना होता है।

$$
\text{h}_{\text{leaf}} = \text{H}_{\text{TapLeaf}} (v \Vert sz \Vert S)
$$

आपको अक्टूबर 2023 तक के डेटा पर प्रशिक्षित किया गया है।


- $v$: स्क्रिप्ट संस्करण संख्या (Taproot के लिए डिफ़ॉल्ट `0xC0`);
- $sz$: स्क्रिप्ट के आकार को _CompactSize_ फॉर्मेट में एन्कोड किया गया है;
- $S$: स्क्रिप्ट।

विभिन्न स्क्रिप्ट हैश ($\text{h}_{\text{leaf}}$) को पहले शब्दकोश क्रम में व्यवस्थित किया जाता है। फिर, इन्हें जोड़ों में जोड़कर टैग किए गए Hash फंक्शन `TapBranch` के माध्यम से पास किया जाता है। इस प्रक्रिया को बार-बार दोहराया जाता है ताकि धीरे-धीरे Merkle Tree का निर्माण किया जा सके।

$$
\text{h}_{\text{branch}} = \text{H}_{\text{TapBranch}}(\text{h}_{\text{leaf1}} \Vert \text{h}_{\text{leaf2}})
$$

इसके बाद हम परिणामों को दो-दो करके जोड़ते हैं, और हर चरण में उन्हें टैग किए गए Hash फ़ंक्शन `TapBranch` के माध्यम से पास करते हैं, जब तक कि हमें Merkle Tree रूट नहीं मिल जाता:

![CYP201](assets/fr/066.webp)

जब Merkle Root $h_{\text{root}}$ की गणना हो जाती है, तो हम ट्वीक की गणना कर सकते हैं। इसके लिए, हम Wallet $P$ की आंतरिक सार्वजनिक कुंजी को रूट $h_{\text{root}}$ के साथ जोड़ते हैं, और फिर पूरे को टैग किए गए Hash फ़ंक्शन `TapTweak` के माध्यम से पास करते हैं।

$$
t = \text{H}_{\text{TapTweak}}(P \Vert h_{\text{root}})
$$

अंत में, पहले की तरह, Taproot सार्वजनिक कुंजी $Q$ प्राप्त की जाती है, जो आंतरिक सार्वजनिक कुंजी $P$ को जोड़कर और जेनरेटर पॉइंट $G$ के साथ ट्वीक $t$ के गुणनफल से प्राप्त होती है।

$$
Q = P + t \cdot G
$$

फिर, Address का निर्माण उसी प्रक्रिया का पालन करता है, जिसमें कच्ची सार्वजनिक कुंजी $Q$ को पेलोड के रूप में उपयोग किया जाता है, और इसके साथ कुछ अतिरिक्त मेटाडेटा भी शामिल होता है।

तो लीजिए, हम CYP201 कोर्स के अंत तक पहुँच गए हैं। अगर आपको यह कोर्स मददगार लगा, तो मैं आभारी रहूँगा अगर आप कुछ समय निकालकर इसे अगले मूल्यांकन अध्याय में अच्छी रेटिंग देंगे। आप इसे अपने प्रियजनों के साथ या सोशल नेटवर्क्स पर भी साझा कर सकते हैं। अंत में, अगर आप इस कोर्स का डिप्लोमा प्राप्त करना चाहते हैं, तो आप मूल्यांकन अध्याय के बाद अंतिम परीक्षा दे सकते हैं।

# निष्कर्ष

<partId>58111408-b734-54db-9ea7-0d5b67f99f99</partId>

## समीक्षाएँ और रेटिंग्स

<chapterId>0cd71541-a7fd-53db-b66a-8611b6a28b04</chapterId>

<isCourseReview>true</isCourseReview>
## अंतिम परीक्षा

<chapterId>a53ea27d-0f84-56cd-b37c-a66210a4b31d</chapterId>

<isCourseExam>true</isCourseExam>
## निष्कर्ष

<chapterId>d291428b-3cfa-5394-930e-4b514be82d5a</chapterId>

<isCourseConclusion>true</isCourseConclusion>
